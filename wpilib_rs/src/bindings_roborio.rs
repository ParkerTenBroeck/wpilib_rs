/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type HAL_Handle = i32;
pub type HAL_PortHandle = HAL_Handle;
pub type HAL_AnalogInputHandle = HAL_Handle;
pub type HAL_AnalogOutputHandle = HAL_Handle;
pub type HAL_AnalogTriggerHandle = HAL_Handle;
pub type HAL_CompressorHandle = HAL_Handle;
pub type HAL_CounterHandle = HAL_Handle;
pub type HAL_DigitalHandle = HAL_Handle;
pub type HAL_DigitalPWMHandle = HAL_Handle;
pub type HAL_EncoderHandle = HAL_Handle;
pub type HAL_FPGAEncoderHandle = HAL_Handle;
pub type HAL_GyroHandle = HAL_Handle;
pub type HAL_InterruptHandle = HAL_Handle;
pub type HAL_NotifierHandle = HAL_Handle;
pub type HAL_RelayHandle = HAL_Handle;
pub type HAL_SolenoidHandle = HAL_Handle;
pub type HAL_SerialPortHandle = HAL_Handle;
pub type HAL_CANHandle = HAL_Handle;
pub type HAL_SimDeviceHandle = HAL_Handle;
pub type HAL_SimValueHandle = HAL_Handle;
pub type HAL_DMAHandle = HAL_Handle;
pub type HAL_DutyCycleHandle = HAL_Handle;
pub type HAL_AddressableLEDHandle = HAL_Handle;
pub type HAL_PDPHandle = HAL_CANHandle;
pub type HAL_PowerDistributionHandle = HAL_Handle;
pub type HAL_CTREPCMHandle = HAL_Handle;
pub type HAL_REVPDHHandle = HAL_Handle;
pub type HAL_REVPHHandle = HAL_Handle;
pub type HAL_Bool = i32;
#[doc = " A move-only C++ wrapper around a HAL handle.\n Does not ensure destruction."]
pub type hal_I2CPort = u32;
#[doc = " A move-only C++ wrapper around a HAL handle.\n Does not ensure destruction."]
pub type hal_SPIPort = u32;
#[doc = " C++ wrapper around a HAL simulator value handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hal_SimValue {
    pub m_handle: HAL_SimValueHandle,
}
#[test]
fn bindgen_test_layout_hal_SimValue() {
    const UNINIT: ::std::mem::MaybeUninit<hal_SimValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hal_SimValue>(),
        4usize,
        concat!("Size of: ", stringify!(hal_SimValue))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_SimValue>(),
        4usize,
        concat!("Alignment of ", stringify!(hal_SimValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_SimValue),
            "::",
            stringify!(m_handle)
        )
    );
}
#[doc = " C++ wrapper around a HAL simulator int value handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hal_SimInt {
    pub _base: hal_SimValue,
}
#[test]
fn bindgen_test_layout_hal_SimInt() {
    assert_eq!(
        ::std::mem::size_of::<hal_SimInt>(),
        4usize,
        concat!("Size of: ", stringify!(hal_SimInt))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_SimInt>(),
        4usize,
        concat!("Alignment of ", stringify!(hal_SimInt))
    );
}
#[doc = " C++ wrapper around a HAL simulator long value handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hal_SimLong {
    pub _base: hal_SimValue,
}
#[test]
fn bindgen_test_layout_hal_SimLong() {
    assert_eq!(
        ::std::mem::size_of::<hal_SimLong>(),
        4usize,
        concat!("Size of: ", stringify!(hal_SimLong))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_SimLong>(),
        4usize,
        concat!("Alignment of ", stringify!(hal_SimLong))
    );
}
#[doc = " C++ wrapper around a HAL simulator double value handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hal_SimDouble {
    pub _base: hal_SimValue,
}
#[test]
fn bindgen_test_layout_hal_SimDouble() {
    assert_eq!(
        ::std::mem::size_of::<hal_SimDouble>(),
        4usize,
        concat!("Size of: ", stringify!(hal_SimDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_SimDouble>(),
        4usize,
        concat!("Alignment of ", stringify!(hal_SimDouble))
    );
}
#[doc = " C++ wrapper around a HAL simulator enum value handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hal_SimEnum {
    pub _base: hal_SimValue,
}
#[test]
fn bindgen_test_layout_hal_SimEnum() {
    assert_eq!(
        ::std::mem::size_of::<hal_SimEnum>(),
        4usize,
        concat!("Size of: ", stringify!(hal_SimEnum))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_SimEnum>(),
        4usize,
        concat!("Alignment of ", stringify!(hal_SimEnum))
    );
}
#[doc = " C++ wrapper around a HAL simulator boolean value handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hal_SimBoolean {
    pub _base: hal_SimValue,
}
#[test]
fn bindgen_test_layout_hal_SimBoolean() {
    assert_eq!(
        ::std::mem::size_of::<hal_SimBoolean>(),
        4usize,
        concat!("Size of: ", stringify!(hal_SimBoolean))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_SimBoolean>(),
        4usize,
        concat!("Alignment of ", stringify!(hal_SimBoolean))
    );
}
#[doc = " A move-only C++ wrapper around a HAL simulator device handle."]
#[repr(C)]
#[derive(Debug)]
pub struct hal_SimDevice {
    pub m_handle: HAL_SimDeviceHandle,
}
pub const hal_SimDevice_Direction_kInput: hal_SimDevice_Direction = 0;
pub const hal_SimDevice_Direction_kOutput: hal_SimDevice_Direction = 1;
pub const hal_SimDevice_Direction_kBidir: hal_SimDevice_Direction = 2;
#[doc = " Direction of a simulated value (from the perspective of user code)."]
pub type hal_SimDevice_Direction = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_hal_SimDevice() {
    const UNINIT: ::std::mem::MaybeUninit<hal_SimDevice> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hal_SimDevice>(),
        4usize,
        concat!("Size of: ", stringify!(hal_SimDevice))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_SimDevice>(),
        4usize,
        concat!("Alignment of ", stringify!(hal_SimDevice))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hal_SimDevice),
            "::",
            stringify!(m_handle)
        )
    );
}
extern "C" {
    #[doc = " Creates a simulated device.\n\n The device name must be unique.  Returns null if the device name\n already exists.  This is a convenience method that appends index in\n brackets to the device name, e.g. passing index=1 results in \"device[1]\"\n for the device name.\n\n If not in simulation, results in an \"empty\" object that evaluates to false\n in a boolean context.\n\n @param name device name\n @param index device index number to append to name"]
    #[link_name = "\u{1}_ZN3hal9SimDeviceC1EPKci"]
    pub fn hal_SimDevice_SimDevice(
        this: *mut hal_SimDevice,
        name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Creates a simulated device.\n\n The device name must be unique.  Returns null if the device name\n already exists.  This is a convenience method that appends index and\n channel in brackets to the device name, e.g. passing index=1 and channel=2\n results in \"device[1,2]\" for the device name.\n\n If not in simulation, results in an \"empty\" object that evaluates to false\n in a boolean context.\n\n @param name device name\n @param index device index number to append to name\n @param channel device channel number to append to name"]
    #[link_name = "\u{1}_ZN3hal9SimDeviceC1EPKcii"]
    pub fn hal_SimDevice_SimDevice1(
        this: *mut hal_SimDevice,
        name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    );
}
impl hal_SimDevice {
    #[inline]
    pub unsafe fn new(name: *const ::std::os::raw::c_char, index: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        hal_SimDevice_SimDevice(__bindgen_tmp.as_mut_ptr(), name, index);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        name: *const ::std::os::raw::c_char,
        index: ::std::os::raw::c_int,
        channel: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        hal_SimDevice_SimDevice1(__bindgen_tmp.as_mut_ptr(), name, index, channel);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " A std::chrono compatible wrapper around the FPGA Timer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hal_fpga_clock {
    pub _address: u8,
}
pub type hal_fpga_clock_rep = rep;
pub type hal_fpga_clock_period = u8;
pub type hal_fpga_clock_duration = std_chrono_microseconds;
pub type hal_fpga_clock_time_point = u64;
pub const hal_fpga_clock_is_steady: bool = true;
extern "C" {
    #[link_name = "\u{1}_ZN3hal10fpga_clock8min_timeE"]
    pub static hal_fpga_clock_min_time: hal_fpga_clock_time_point;
}
#[test]
fn bindgen_test_layout_hal_fpga_clock() {
    assert_eq!(
        ::std::mem::size_of::<hal_fpga_clock>(),
        1usize,
        concat!("Size of: ", stringify!(hal_fpga_clock))
    );
    assert_eq!(
        ::std::mem::align_of::<hal_fpga_clock>(),
        1usize,
        concat!("Alignment of ", stringify!(hal_fpga_clock))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3hal10fpga_clock3nowEv"]
    pub fn hal_fpga_clock_now() -> hal_fpga_clock_time_point;
}
impl hal_fpga_clock {
    #[inline]
    pub unsafe fn now() -> hal_fpga_clock_time_point {
        hal_fpga_clock_now()
    }
}
pub const HAL_AccelerometerRange_HAL_AccelerometerRange_k2G: HAL_AccelerometerRange = 0;
pub const HAL_AccelerometerRange_HAL_AccelerometerRange_k4G: HAL_AccelerometerRange = 1;
pub const HAL_AccelerometerRange_HAL_AccelerometerRange_k8G: HAL_AccelerometerRange = 2;
#[doc = " The acceptable accelerometer ranges."]
pub type HAL_AccelerometerRange = i32;
extern "C" {
    #[doc = " Sets the accelerometer to active or standby mode.\n\n It must be in standby mode to change any configuration.\n\n @param active true to set to active, false for standby"]
    pub fn HAL_SetAccelerometerActive(active: HAL_Bool);
}
extern "C" {
    #[doc = " Sets the range of values that can be measured (either 2, 4, or 8 g-forces).\n\n The accelerometer should be in standby mode when this is called.\n\n @param range the accelerometer range"]
    pub fn HAL_SetAccelerometerRange(range: HAL_AccelerometerRange);
}
extern "C" {
    #[doc = " Gets the x-axis acceleration.\n\n This is a floating point value in units of 1 g-force.\n\n @return the X acceleration"]
    pub fn HAL_GetAccelerometerX() -> f64;
}
extern "C" {
    #[doc = " Gets the y-axis acceleration.\n\n This is a floating point value in units of 1 g-force.\n\n @return the Y acceleration"]
    pub fn HAL_GetAccelerometerY() -> f64;
}
extern "C" {
    #[doc = " Gets the z-axis acceleration.\n\n This is a floating point value in units of 1 g-force.\n\n @return the Z acceleration"]
    pub fn HAL_GetAccelerometerZ() -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_AddressableLEDData {
    pub b: u8,
    pub g: u8,
    pub r: u8,
    pub padding: u8,
}
#[test]
fn bindgen_test_layout_HAL_AddressableLEDData() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_AddressableLEDData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_AddressableLEDData>(),
        4usize,
        concat!("Size of: ", stringify!(HAL_AddressableLEDData))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_AddressableLEDData>(),
        1usize,
        concat!("Alignment of ", stringify!(HAL_AddressableLEDData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_AddressableLEDData),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_AddressableLEDData),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_AddressableLEDData),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_AddressableLEDData),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    pub fn HAL_InitializeAddressableLED(
        outputPort: HAL_DigitalHandle,
        status: *mut i32,
    ) -> HAL_AddressableLEDHandle;
}
extern "C" {
    pub fn HAL_FreeAddressableLED(handle: HAL_AddressableLEDHandle);
}
extern "C" {
    pub fn HAL_SetAddressableLEDOutputPort(
        handle: HAL_AddressableLEDHandle,
        outputPort: HAL_DigitalHandle,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetAddressableLEDLength(
        handle: HAL_AddressableLEDHandle,
        length: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_WriteAddressableLEDData(
        handle: HAL_AddressableLEDHandle,
        data: *const HAL_AddressableLEDData,
        length: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetAddressableLEDBitTiming(
        handle: HAL_AddressableLEDHandle,
        lowTime0NanoSeconds: i32,
        highTime0NanoSeconds: i32,
        lowTime1NanoSeconds: i32,
        highTime1NanoSeconds: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetAddressableLEDSyncTime(
        handle: HAL_AddressableLEDHandle,
        syncTimeMicroSeconds: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_StartAddressableLEDOutput(handle: HAL_AddressableLEDHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_StopAddressableLEDOutput(handle: HAL_AddressableLEDHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Is the channel attached to an accumulator.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success.\n @return The analog channel is attached to an accumulator."]
    pub fn HAL_IsAccumulatorChannel(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Initialize the accumulator.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_InitAccumulator(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Resets the accumulator to the initial value.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_ResetAccumulator(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Set the center value of the accumulator.\n\n The center value is subtracted from each A/D value before it is added to the\n accumulator. This is used for the center value of devices like gyros and\n accelerometers to make integration work and to take the device offset into\n account when integrating.\n\n This center value is based on the output of the oversampled and averaged\n source from channel 1. Because of this, any non-zero oversample bits will\n affect the size of the value for this field.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[in] center The center value of the accumulator.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetAccumulatorCenter(
        analogPortHandle: HAL_AnalogInputHandle,
        center: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Set the accumulator's deadband.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[in] deadband The deadband of the accumulator.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetAccumulatorDeadband(
        analogPortHandle: HAL_AnalogInputHandle,
        deadband: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Read the accumulated value.\n\n Read the value that has been accumulating on channel 1.\n The accumulator is attached after the oversample and average engine.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success.\n @return The 64-bit value accumulated since the last Reset()."]
    pub fn HAL_GetAccumulatorValue(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Read the number of accumulated values.\n\n Read the count of the accumulated values since the accumulator was last\n Reset().\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[out] status Error status variable. 0 on success.\n @return The number of times samples from the channel were accumulated."]
    pub fn HAL_GetAccumulatorCount(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Read the accumulated value and the number of accumulated values atomically.\n\n This function reads the value and count from the FPGA atomically.\n This can be used for averaging.\n\n @param[in] analogPortHandle Handle to the analog port.\n @param[in] value Pointer to the 64-bit accumulated output.\n @param[in] count Pointer to the number of accumulation cycles.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_GetAccumulatorOutput(
        analogPortHandle: HAL_AnalogInputHandle,
        value: *mut i64,
        count: *mut i64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Initializes an analog gyro.\n\n @param[in] handle handle to the analog port\n @param[in] allocationLocation the location where the allocation is occurring\n                                (can be null)\n @param[out] status the error code, or 0 for success\n @return the initialized gyro handle"]
    pub fn HAL_InitializeAnalogGyro(
        handle: HAL_AnalogInputHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_GyroHandle;
}
extern "C" {
    #[doc = " Sets up an analog gyro with the proper offsets and settings for the KOP\n analog gyro.\n\n @param[in] handle the gyro handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetupAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Frees an analog gyro.\n\n @param handle the gyro handle"]
    pub fn HAL_FreeAnalogGyro(handle: HAL_GyroHandle);
}
extern "C" {
    #[doc = " Sets the analog gyro parameters to the specified values.\n\n This is meant to be used if you want to reuse the values from a previous\n calibration.\n\n @param[in] handle                  the gyro handle\n @param[in] voltsPerDegreePerSecond the gyro volts scaling\n @param[in] offset                  the gyro offset\n @param[in] center                  the gyro center\n @param[out] status                  the error code, or 0 for success"]
    pub fn HAL_SetAnalogGyroParameters(
        handle: HAL_GyroHandle,
        voltsPerDegreePerSecond: f64,
        offset: f64,
        center: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the analog gyro volts per degrees per second scaling.\n\n @param[in] handle                  the gyro handle\n @param[in] voltsPerDegreePerSecond the gyro volts scaling\n @param[out] status                  the error code, or 0 for success"]
    pub fn HAL_SetAnalogGyroVoltsPerDegreePerSecond(
        handle: HAL_GyroHandle,
        voltsPerDegreePerSecond: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Resets the analog gyro value to 0.\n\n @param[in] handle the gyro handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_ResetAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Calibrates the analog gyro.\n\n This happens by calculating the average value of the gyro over 5 seconds, and\n setting that as the center. Note that this call blocks for 5 seconds to\n perform this.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_CalibrateAnalogGyro(handle: HAL_GyroHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the deadband of the analog gyro.\n\n @param[in] handle the gyro handle\n @param[in] volts  the voltage deadband\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetAnalogGyroDeadband(handle: HAL_GyroHandle, volts: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the gyro angle in degrees.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success.\n @return the gyro angle in degrees"]
    pub fn HAL_GetAnalogGyroAngle(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the gyro rate in degrees/second.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success.\n @return the gyro rate in degrees/second"]
    pub fn HAL_GetAnalogGyroRate(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the calibrated gyro offset.\n\n Can be used to not repeat a calibration but reconstruct the gyro object.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success.\n @return the gryo offset"]
    pub fn HAL_GetAnalogGyroOffset(handle: HAL_GyroHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the calibrated gyro center.\n\n Can be used to not repeat a calibration but reconstruct the gyro object.\n\n @param[in] handle the gyro handle\n @param[out] status Error status variable. 0 on success.\n @return the gyro center"]
    pub fn HAL_GetAnalogGyroCenter(handle: HAL_GyroHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Initializes the analog input port using the given port object.\n\n @param[in] portHandle Handle to the port to initialize.\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status the error code, or 0 for success\n @return the created analog input handle"]
    pub fn HAL_InitializeAnalogInputPort(
        portHandle: HAL_PortHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_AnalogInputHandle;
}
extern "C" {
    #[doc = " Frees an analog input port.\n\n @param analogPortHandle Handle to the analog port."]
    pub fn HAL_FreeAnalogInputPort(analogPortHandle: HAL_AnalogInputHandle);
}
extern "C" {
    #[doc = " Checks that the analog module number is valid.\n\n @param module The analog module number.\n @return Analog module is valid and present"]
    pub fn HAL_CheckAnalogModule(module: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Checks that the analog output channel number is valid.\n Verifies that the analog channel number is one of the legal channel numbers.\n Channel numbers are 0-based.\n\n @param channel The analog output channel number.\n @return Analog channel is valid"]
    pub fn HAL_CheckAnalogInputChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Indicates the analog input is used by a simulated device.\n\n @param handle the analog input handle\n @param device simulated device handle"]
    pub fn HAL_SetAnalogInputSimDevice(handle: HAL_AnalogInputHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Sets the sample rate.\n\n This is a global setting for the Athena and effects all channels.\n\n @param[in] samplesPerSecond The number of samples per channel per second.\n @param[out] status          the error code, or 0 for success"]
    pub fn HAL_SetAnalogSampleRate(samplesPerSecond: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the current sample rate.\n\n This assumes one entry in the scan list.\n This is a global setting for the Athena and effects all channels.\n\n @param[out] status the error code, or 0 for success\n @return Sample rate."]
    pub fn HAL_GetAnalogSampleRate(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the number of averaging bits.\n\n This sets the number of averaging bits. The actual number of averaged samples\n is 2**bits. Use averaging to improve the stability of your measurement at the\n expense of sampling rate. The averaging is done automatically in the FPGA.\n\n @param[in] analogPortHandle Handle to the analog port to configure.\n @param[in] bits Number of bits to average.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetAnalogAverageBits(
        analogPortHandle: HAL_AnalogInputHandle,
        bits: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the number of averaging bits.\n\n This gets the number of averaging bits from the FPGA. The actual number of\n averaged samples is 2**bits. The averaging is done automatically in the FPGA.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return Bits to average."]
    pub fn HAL_GetAnalogAverageBits(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the number of oversample bits.\n\n This sets the number of oversample bits. The actual number of oversampled\n values is 2**bits. Use oversampling to improve the resolution of your\n measurements at the expense of sampling rate. The oversampling is done\n automatically in the FPGA.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[in] bits Number of bits to oversample.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetAnalogOversampleBits(
        analogPortHandle: HAL_AnalogInputHandle,
        bits: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the number of oversample bits.\n\n This gets the number of oversample bits from the FPGA. The actual number of\n oversampled values is 2**bits. The oversampling is done automatically in the\n FPGA.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status          the error code, or 0 for success\n @return Bits to oversample."]
    pub fn HAL_GetAnalogOversampleBits(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets a sample straight from the channel on this module.\n\n The sample is a 12-bit value representing the 0V to 5V range of the A/D\n converter in the module. The units are in A/D converter codes.  Use\n GetVoltage() to get the analog value in calibrated units.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return A sample straight from the channel on this module."]
    pub fn HAL_GetAnalogValue(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets a sample from the output of the oversample and average engine for the\n channel.\n\n The sample is 12-bit + the value configured in SetOversampleBits().\n The value configured in SetAverageBits() will cause this value to be averaged\n 2**bits number of samples. This is not a sliding window.  The sample will not\n change until 2**(OversamplBits + AverageBits) samples have been acquired from\n the module on this channel. Use GetAverageVoltage() to get the analog value\n in calibrated units.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return A sample from the oversample and average engine for the channel."]
    pub fn HAL_GetAnalogAverageValue(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Converts a voltage to a raw value for a specified channel.\n\n This process depends on the calibration of each channel, so the channel must\n be specified.\n\n @todo This assumes raw values.  Oversampling not supported as is.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[in] voltage The voltage to convert.\n @param[out] status the error code, or 0 for success\n @return The raw value for the channel."]
    pub fn HAL_GetAnalogVoltsToValue(
        analogPortHandle: HAL_AnalogInputHandle,
        voltage: f64,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets a scaled sample straight from the channel on this module.\n\n The value is scaled to units of Volts using the calibrated scaling data from\n GetLSBWeight() and GetOffset().\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return A scaled sample straight from the channel on this module."]
    pub fn HAL_GetAnalogVoltage(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets a scaled sample from the output of the oversample and average engine for\n the channel.\n\n The value is scaled to units of Volts using the calibrated scaling data from\n GetLSBWeight() and GetOffset(). Using oversampling will cause this value to\n be higher resolution, but it will update more slowly. Using averaging will\n cause this value to be more stable, but it will update more slowly.\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return A scaled sample from the output of the oversample and average engine\n for the channel."]
    pub fn HAL_GetAnalogAverageVoltage(
        analogPortHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the factory scaling least significant bit weight constant.\n The least significant bit weight constant for the channel that was calibrated\n in manufacturing and stored in an eeprom in the module.\n\n Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status the error code, or 0 for success\n @return Least significant bit weight."]
    pub fn HAL_GetAnalogLSBWeight(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32)
        -> i32;
}
extern "C" {
    #[doc = " Gets the factory scaling offset constant.\n The offset constant for the channel that was calibrated in manufacturing and\n stored in an eeprom in the module.\n\n Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n\n @param[in] analogPortHandle Handle to the analog port to use.\n @param[out] status Error status variable. 0 on success.\n @return Offset constant."]
    pub fn HAL_GetAnalogOffset(analogPortHandle: HAL_AnalogInputHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = "  Get the analog voltage from a raw value.\n\n @param[in] analogPortHandle  Handle to the analog port the values were read\n                              from.\n @param[in] rawValue          The raw analog value\n @param[out] status           Error status variable. 0 on success.\n @return The voltage relating to the value"]
    pub fn HAL_GetAnalogValueToVolts(
        analogPortHandle: HAL_AnalogInputHandle,
        rawValue: i32,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Initializes the analog output port using the given port object.\n\n @param[in] portHandle handle to the port\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status Error status variable. 0 on success.\n @return the created analog output handle"]
    pub fn HAL_InitializeAnalogOutputPort(
        portHandle: HAL_PortHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_AnalogOutputHandle;
}
extern "C" {
    #[doc = " Frees an analog output port.\n\n @param analogOutputHandle the analog output handle"]
    pub fn HAL_FreeAnalogOutputPort(analogOutputHandle: HAL_AnalogOutputHandle);
}
extern "C" {
    #[doc = " Sets an analog output value.\n\n @param[in] analogOutputHandle the analog output handle\n @param[in] voltage            the voltage (0-5v) to output\n @param[out] status            Error status variable. 0 on success."]
    pub fn HAL_SetAnalogOutput(
        analogOutputHandle: HAL_AnalogOutputHandle,
        voltage: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the current analog output value.\n\n @param[in] analogOutputHandle the analog output handle\n @param[out] status            Error status variable. 0 on success.\n @return the current output voltage (0-5v)"]
    pub fn HAL_GetAnalogOutput(analogOutputHandle: HAL_AnalogOutputHandle, status: *mut i32)
        -> f64;
}
extern "C" {
    #[doc = " Checks that the analog output channel number is valid.\n\n Verifies that the analog channel number is one of the legal channel numbers.\n Channel numbers are 0-based.\n\n @return Analog channel is valid"]
    pub fn HAL_CheckAnalogOutputChannel(channel: i32) -> HAL_Bool;
}
pub const HAL_AnalogTriggerType_HAL_Trigger_kInWindow: HAL_AnalogTriggerType = 0;
pub const HAL_AnalogTriggerType_HAL_Trigger_kState: HAL_AnalogTriggerType = 1;
pub const HAL_AnalogTriggerType_HAL_Trigger_kRisingPulse: HAL_AnalogTriggerType = 2;
pub const HAL_AnalogTriggerType_HAL_Trigger_kFallingPulse: HAL_AnalogTriggerType = 3;
#[doc = " The type of analog trigger to trigger on."]
pub type HAL_AnalogTriggerType = i32;
extern "C" {
    #[doc = " Initializes an analog trigger.\n\n @param[in] portHandle the analog input to use for triggering\n @param[out] status     Error status variable. 0 on success.\n @return the created analog trigger handle"]
    pub fn HAL_InitializeAnalogTrigger(
        portHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> HAL_AnalogTriggerHandle;
}
extern "C" {
    #[doc = " Initializes an analog trigger with a Duty Cycle input\n\n @param[in] dutyCycleHandle the analog input to use for duty cycle\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_InitializeAnalogTriggerDutyCycle(
        dutyCycleHandle: HAL_DutyCycleHandle,
        status: *mut i32,
    ) -> HAL_AnalogTriggerHandle;
}
extern "C" {
    #[doc = " Frees an analog trigger.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_CleanAnalogTrigger(analogTriggerHandle: HAL_AnalogTriggerHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the raw ADC upper and lower limits of the analog trigger.\n\n HAL_SetAnalogTriggerLimitsVoltage or HAL_SetAnalogTriggerLimitsDutyCycle\n is likely better in most cases.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] lower               the lower ADC value\n @param[in] upper               the upper ADC value\n @param[out] status              Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerLimitsRaw(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: i32,
        upper: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the upper and lower limits of the analog trigger.\n\n The limits are given as floating point voltage values.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] lower               the lower voltage value\n @param[in] upper               the upper voltage value\n @param[out] status              Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerLimitsVoltage(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: f64,
        upper: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the upper and lower limits of the analog trigger.\n\n The limits are given as floating point duty cycle values.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] lower               the lower duty cycle value\n @param[in] upper               the upper duty cycle value\n @param[out] status              Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerLimitsDutyCycle(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        lower: f64,
        upper: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the analog trigger to use the averaged vs. raw values.\n\n If the value is true, then the averaged value is selected for the analog\n trigger, otherwise the immediate value is used.\n\n This is not allowed to be used if filtered mode is set.\n This is not allowed to be used with Duty Cycle based inputs.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] useAveragedValue    true to use averaged values, false for raw\n @param[out] status              Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerAveraged(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        useAveragedValue: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the analog trigger to use a filtered value.\n\n The analog trigger will operate with a 3 point average rejection filter. This\n is designed to help with 360 degree pot applications for the period where the\n pot crosses through zero.\n\n This is not allowed to be used if averaged mode is set.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] useFilteredValue    true to use filtered values, false for average\n                                or raw\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_SetAnalogTriggerFiltered(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        useFilteredValue: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Returns the InWindow output of the analog trigger.\n\n True if the analog input is between the upper and lower limits.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[out] status Error status variable. 0 on success.\n @return the InWindow output of the analog trigger"]
    pub fn HAL_GetAnalogTriggerInWindow(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns the TriggerState output of the analog trigger.\n\n True if above upper limit.\n False if below lower limit.\n If in Hysteresis, maintain previous state.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[out] status              Error status variable. 0 on success.\n @return the TriggerState output of the analog trigger"]
    pub fn HAL_GetAnalogTriggerTriggerState(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the state of the analog trigger output.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[in] type                the type of trigger to trigger on\n @param[out] status              Error status variable. 0 on success.\n @return the state of the analog trigger output"]
    pub fn HAL_GetAnalogTriggerOutput(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        type_: HAL_AnalogTriggerType,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Get the FPGA index for the AnlogTrigger.\n\n @param[in] analogTriggerHandle the trigger handle\n @param[out] status              Error status variable. 0 on success.\n @return the FPGA index"]
    pub fn HAL_GetAnalogTriggerFPGAIndex(
        analogTriggerHandle: HAL_AnalogTriggerHandle,
        status: *mut i32,
    ) -> i32;
}
#[doc = " Storage for CAN Stream Messages."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_CANStreamMessage {
    pub messageID: u32,
    pub timeStamp: u32,
    pub data: [u8; 8usize],
    pub dataSize: u8,
}
#[test]
fn bindgen_test_layout_HAL_CANStreamMessage() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_CANStreamMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_CANStreamMessage>(),
        20usize,
        concat!("Size of: ", stringify!(HAL_CANStreamMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_CANStreamMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_CANStreamMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).messageID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(messageID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_CANStreamMessage),
            "::",
            stringify!(dataSize)
        )
    );
}
extern "C" {
    #[doc = " Sends a CAN message.\n\n @param[in] messageID the CAN ID to send\n @param[in] data      the data to send (0-8 bytes)\n @param[in] dataSize  the size of the data to send (0-8 bytes)\n @param[in] periodMs  the period to repeat the packet at. Use\n                       HAL_CAN_SEND_PERIOD_NO_REPEAT to not repeat.\n @param[out] status    Error status variable. 0 on success."]
    pub fn HAL_CAN_SendMessage(
        messageID: u32,
        data: *const u8,
        dataSize: u8,
        periodMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Receives a CAN message.\n\n @param[out] messageID     store for the received message ID\n @param[in] messageIDMask the message ID mask to look for\n @param[out] data          data output (8 bytes)\n @param[out] dataSize      data length (0-8 bytes)\n @param[out] timeStamp     the packet received timestamp (based off of\n                           CLOCK_MONOTONIC)\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_CAN_ReceiveMessage(
        messageID: *mut u32,
        messageIDMask: u32,
        data: *mut u8,
        dataSize: *mut u8,
        timeStamp: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Opens a CAN stream.\n\n @param[out] sessionHandle output for the session handle\n @param[in] messageID     the message ID to read\n @param[in] messageIDMask the mssage ID mask\n @param[in] maxMessages   the maximum number of messages to stream\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_CAN_OpenStreamSession(
        sessionHandle: *mut u32,
        messageID: u32,
        messageIDMask: u32,
        maxMessages: u32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Closes a CAN stream.\n\n @param sessionHandle the session to close"]
    pub fn HAL_CAN_CloseStreamSession(sessionHandle: u32);
}
extern "C" {
    #[doc = " Reads a CAN stream message.\n\n @param[in] sessionHandle  the session handle\n @param[in] messages       array of messages\n @param[in] messagesToRead the max number of messages to read\n @param[out] messagesRead   the number of messages actually read\n @param[out] status         Error status variable. 0 on success."]
    pub fn HAL_CAN_ReadStreamSession(
        sessionHandle: u32,
        messages: *mut HAL_CANStreamMessage,
        messagesToRead: u32,
        messagesRead: *mut u32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets CAN status information.\n\n @param[out] percentBusUtilization the bus utilization\n @param[out] busOffCount           the number of bus off errors\n @param[out] txFullCount           the number of tx full errors\n @param[out] receiveErrorCount     the number of receive errors\n @param[out] transmitErrorCount    the number of transmit errors\n @param[out] status                Error status variable. 0 on success."]
    pub fn HAL_CAN_GetCANStatus(
        percentBusUtilization: *mut f32,
        busOffCount: *mut u32,
        txFullCount: *mut u32,
        receiveErrorCount: *mut u32,
        transmitErrorCount: *mut u32,
        status: *mut i32,
    );
}
pub const HAL_CANDeviceType_HAL_CAN_Dev_kBroadcast: HAL_CANDeviceType = 0;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kRobotController: HAL_CANDeviceType = 1;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kMotorController: HAL_CANDeviceType = 2;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kRelayController: HAL_CANDeviceType = 3;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kGyroSensor: HAL_CANDeviceType = 4;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kAccelerometer: HAL_CANDeviceType = 5;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kUltrasonicSensor: HAL_CANDeviceType = 6;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kGearToothSensor: HAL_CANDeviceType = 7;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kPowerDistribution: HAL_CANDeviceType = 8;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kPneumatics: HAL_CANDeviceType = 9;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kMiscellaneous: HAL_CANDeviceType = 10;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kIOBreakout: HAL_CANDeviceType = 11;
pub const HAL_CANDeviceType_HAL_CAN_Dev_kFirmwareUpdate: HAL_CANDeviceType = 31;
#[doc = " The CAN device type.\n\n Teams should use HAL_CAN_Dev_kMiscellaneous"]
pub type HAL_CANDeviceType = i32;
pub const HAL_CANManufacturer_HAL_CAN_Man_kBroadcast: HAL_CANManufacturer = 0;
pub const HAL_CANManufacturer_HAL_CAN_Man_kNI: HAL_CANManufacturer = 1;
pub const HAL_CANManufacturer_HAL_CAN_Man_kLM: HAL_CANManufacturer = 2;
pub const HAL_CANManufacturer_HAL_CAN_Man_kDEKA: HAL_CANManufacturer = 3;
pub const HAL_CANManufacturer_HAL_CAN_Man_kCTRE: HAL_CANManufacturer = 4;
pub const HAL_CANManufacturer_HAL_CAN_Man_kREV: HAL_CANManufacturer = 5;
pub const HAL_CANManufacturer_HAL_CAN_Man_kGrapple: HAL_CANManufacturer = 6;
pub const HAL_CANManufacturer_HAL_CAN_Man_kMS: HAL_CANManufacturer = 7;
pub const HAL_CANManufacturer_HAL_CAN_Man_kTeamUse: HAL_CANManufacturer = 8;
pub const HAL_CANManufacturer_HAL_CAN_Man_kKauaiLabs: HAL_CANManufacturer = 9;
pub const HAL_CANManufacturer_HAL_CAN_Man_kCopperforge: HAL_CANManufacturer = 10;
pub const HAL_CANManufacturer_HAL_CAN_Man_kPWF: HAL_CANManufacturer = 11;
pub const HAL_CANManufacturer_HAL_CAN_Man_kStudica: HAL_CANManufacturer = 12;
pub const HAL_CANManufacturer_HAL_CAN_Man_kTheThriftyBot: HAL_CANManufacturer = 13;
#[doc = " The CAN manufacturer ID.\n\n Teams should use HAL_CAN_Man_kTeamUse."]
pub type HAL_CANManufacturer = i32;
extern "C" {
    #[doc = " Initializes a CAN device.\n\n These follow the FIRST standard CAN layout.\n https://docs.wpilib.org/en/stable/docs/software/can-devices/can-addressing.html\n\n @param[in] manufacturer the can manufacturer\n @param[in] deviceId     the device ID (0-63)\n @param[in] deviceType   the device type\n @param[out] status      Error status variable. 0 on success.\n @return the created CAN handle"]
    pub fn HAL_InitializeCAN(
        manufacturer: HAL_CANManufacturer,
        deviceId: i32,
        deviceType: HAL_CANDeviceType,
        status: *mut i32,
    ) -> HAL_CANHandle;
}
extern "C" {
    #[doc = " Frees a CAN device\n\n @param handle the CAN handle"]
    pub fn HAL_CleanCAN(handle: HAL_CANHandle);
}
extern "C" {
    #[doc = " Writes a packet to the CAN device with a specific ID.\n\n This ID is 10 bits.\n\n @param[in] handle  the CAN handle\n @param[in] data    the data to write (0-8 bytes)\n @param[in] length  the length of data (0-8)\n @param[in] apiId   the ID to write (0-1023 bits)\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_WriteCANPacket(
        handle: HAL_CANHandle,
        data: *const u8,
        length: i32,
        apiId: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Writes a repeating packet to the CAN device with a specific ID.\n\n This ID is 10 bits.\n\n The RoboRIO will automatically repeat the packet at the specified interval\n\n @param[in] handle   the CAN handle\n @param[in] data     the data to write (0-8 bytes)\n @param[in] length   the length of data (0-8)\n @param[in] apiId    the ID to write (0-1023)\n @param[in] repeatMs the period to repeat in ms\n @param[out] status  Error status variable. 0 on success."]
    pub fn HAL_WriteCANPacketRepeating(
        handle: HAL_CANHandle,
        data: *const u8,
        length: i32,
        apiId: i32,
        repeatMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Writes an RTR frame of the specified length to the CAN device with the\n specific ID.\n\n By spec, the length must be equal to the length sent by the other device,\n otherwise behavior is unspecified.\n\n @param[in] handle   the CAN handle\n @param[in] length   the length of data to request (0-8)\n @param[in] apiId    the ID to write (0-1023)\n @param[out] status  Error status variable. 0 on success."]
    pub fn HAL_WriteCANRTRFrame(handle: HAL_CANHandle, length: i32, apiId: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Stops a repeating packet with a specific ID.\n\n This ID is 10 bits.\n\n @param[in] handle  the CAN handle\n @param[in] apiId   the ID to stop repeating (0-1023)\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_StopCANPacketRepeating(handle: HAL_CANHandle, apiId: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Reads a new CAN packet.\n\n This will only return properly once per packet received. Multiple calls\n without receiving another packet will return an error code.\n\n @param[in] handle             the CAN handle\n @param[in] apiId              the ID to read (0-1023)\n @param[out] data              the packet data (8 bytes)\n @param[out] length            the received length (0-8 bytes)\n @param[out] receivedTimestamp the packet received timestamp (based off of\n                               CLOCK_MONOTONIC)\n @param[out] status            Error status variable. 0 on success."]
    pub fn HAL_ReadCANPacketNew(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Reads a CAN packet. The will continuously return the last packet received,\n without accounting for packet age.\n\n @param[in] handle             the CAN handle\n @param[in] apiId              the ID to read (0-1023)\n @param[out] data              the packet data (8 bytes)\n @param[out] length            the received length (0-8 bytes)\n @param[out] receivedTimestamp the packet received timestamp (based off of\n                               CLOCK_MONOTONIC)\n @param[out] status            Error status variable. 0 on success."]
    pub fn HAL_ReadCANPacketLatest(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Reads a CAN packet. The will return the last packet received until the\n packet is older then the requested timeout. Then it will return an error\n code.\n\n @param[in] handle             the CAN handle\n @param[in] apiId              the ID to read (0-1023)\n @param[out] data              the packet data (8 bytes)\n @param[out] length            the received length (0-8 bytes)\n @param[out] receivedTimestamp the packet received timestamp (based off of\n                               CLOCK_MONOTONIC)\n @param[out] timeoutMs         the timeout time for the packet\n @param[out] status            Error status variable. 0 on success."]
    pub fn HAL_ReadCANPacketTimeout(
        handle: HAL_CANHandle,
        apiId: i32,
        data: *mut u8,
        length: *mut i32,
        receivedTimestamp: *mut u64,
        timeoutMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the number of FPGA system clock ticks per microsecond.\n\n @return the number of clock ticks per microsecond"]
    pub fn HAL_GetSystemClockTicksPerMicrosecond() -> i32;
}
pub const HAL_Counter_Mode_HAL_Counter_kTwoPulse: HAL_Counter_Mode = 0;
pub const HAL_Counter_Mode_HAL_Counter_kSemiperiod: HAL_Counter_Mode = 1;
pub const HAL_Counter_Mode_HAL_Counter_kPulseLength: HAL_Counter_Mode = 2;
pub const HAL_Counter_Mode_HAL_Counter_kExternalDirection: HAL_Counter_Mode = 3;
#[doc = " The counter mode."]
pub type HAL_Counter_Mode = i32;
extern "C" {
    #[doc = " Initializes a counter.\n\n @param[in] mode    the counter mode\n @param[in] index   the compressor index (output)\n @param[out] status Error status variable. 0 on success.\n @return the created handle"]
    pub fn HAL_InitializeCounter(
        mode: HAL_Counter_Mode,
        index: *mut i32,
        status: *mut i32,
    ) -> HAL_CounterHandle;
}
extern "C" {
    #[doc = " Frees a counter.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_FreeCounter(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the average sample size of a counter.\n\n @param[in] counterHandle  the counter handle\n @param[in] size           the size of samples to average\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetCounterAverageSize(counterHandle: HAL_CounterHandle, size: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the source object that causes the counter to count up.\n\n @param[in] counterHandle       the counter handle\n @param[in] digitalSourceHandle the digital source handle (either a\n                                HAL_AnalogTriggerHandle or a\n                                HAL_DigitalHandle)\n @param[in] analogTriggerType   the analog trigger type if the source is an\n                                analog trigger\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_SetCounterUpSource(
        counterHandle: HAL_CounterHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the up source to either detect rising edges or falling edges.\n\n Note that both are allowed to be set true at the same time without issues.\n\n @param[in] counterHandle  the counter handle\n @param[in] risingEdge     true to trigger on rising\n @param[in] fallingEdge    true to trigger on falling\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetCounterUpSourceEdge(
        counterHandle: HAL_CounterHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Disables the up counting source to the counter.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_ClearCounterUpSource(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the source object that causes the counter to count down.\n\n @param[in] counterHandle       the counter handle\n @param[in] digitalSourceHandle the digital source handle (either a\n                                HAL_AnalogTriggerHandle or a\n                                HAL_DigitalHandle)\n @param[in] analogTriggerType   the analog trigger type if the source is an\n                                analog trigger\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_SetCounterDownSource(
        counterHandle: HAL_CounterHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the down source to either detect rising edges or falling edges.\n Note that both are allowed to be set true at the same time without issues.\n\n @param[in] counterHandle  the counter handle\n @param[in] risingEdge     true to trigger on rising\n @param[in] fallingEdge    true to trigger on falling\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetCounterDownSourceEdge(
        counterHandle: HAL_CounterHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Disables the down counting source to the counter.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_ClearCounterDownSource(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets standard up / down counting mode on this counter.\n\n Up and down counts are sourced independently from two inputs.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterUpDownMode(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets directional counting mode on this counter.\n\n The direction is determined by the B input, with counting happening with the\n A input.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterExternalDirectionMode(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets Semi-period mode on this counter.\n\n The counter counts up based on the time the input is triggered. High or Low\n depends on the highSemiPeriod parameter.\n\n @param[in] counterHandle  the counter handle\n @param[in] highSemiPeriod true for counting when the input is high, false for\n                           low\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetCounterSemiPeriodMode(
        counterHandle: HAL_CounterHandle,
        highSemiPeriod: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the counter to count in up or down based on the length of the\n input pulse.\n\n This mode is most useful for direction sensitive gear tooth sensors.\n\n @param[in] counterHandle the counter handle\n @param[in] threshold     The pulse length beyond which the counter counts the\n                          opposite direction (seconds)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterPulseLengthMode(
        counterHandle: HAL_CounterHandle,
        threshold: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the Samples to Average which specifies the number of samples of the\n timer to average when calculating the period. Perform averaging to account\n for mechanical imperfections or as oversampling to increase resolution.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return SamplesToAverage The number of samples being averaged (from 1 to 127)"]
    pub fn HAL_GetCounterSamplesToAverage(
        counterHandle: HAL_CounterHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the Samples to Average which specifies the number of samples of the\n timer to average when calculating the period. Perform averaging to account\n for mechanical imperfections or as oversampling to increase resolution.\n\n @param[in] counterHandle    the counter handle\n @param[in] samplesToAverage The number of samples to average from 1 to 127\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetCounterSamplesToAverage(
        counterHandle: HAL_CounterHandle,
        samplesToAverage: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Resets the Counter to zero.\n\n Sets the counter value to zero. This does not effect the running state of the\n counter, just sets the current value to zero.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_ResetCounter(counterHandle: HAL_CounterHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Reads the current counter value.\n\n Reads the value at this instant. It may still be running, so it reflects the\n current value. Next time it is read, it might have a different value.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return the current counter value"]
    pub fn HAL_GetCounter(counterHandle: HAL_CounterHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetCounterPeriod(counterHandle: HAL_CounterHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the maximum period where the device is still considered \"moving\".\n\n Sets the maximum period where the device is considered moving. This value is\n used to determine the \"stopped\" state of the counter using the\n HAL_GetCounterStopped method.\n\n @param[in] counterHandle the counter handle\n @param[in] maxPeriod     the maximum period where the counted device is\n                          considered moving in seconds\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterMaxPeriod(
        counterHandle: HAL_CounterHandle,
        maxPeriod: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Selects whether you want to continue updating the event timer output when\n there are no samples captured.\n\n The output of the event timer has a buffer of periods that are averaged and\n posted to a register on the FPGA.  When the timer detects that the event\n source has stopped (based on the MaxPeriod) the buffer of samples to be\n averaged is emptied.\n\n If you enable the update when empty, you will be\n notified of the stopped source and the event time will report 0 samples.\n\n If you disable update when empty, the most recent average will remain on the\n output until a new sample is acquired.\n\n You will never see 0 samples output (except when there have been no events\n since an FPGA reset) and you will likely not see the stopped bit become true\n (since it is updated at the end of an average and there are no samples to\n average).\n\n @param[in] counterHandle the counter handle\n @param[in] enabled       true to enable counter updating with no samples\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetCounterUpdateWhenEmpty(
        counterHandle: HAL_CounterHandle,
        enabled: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Determines if the clock is stopped.\n\n Determine if the clocked input is stopped based on the MaxPeriod value set\n using the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the\n device (and counter) are assumed to be stopped and it returns true.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return true if the most recent counter period exceeds the MaxPeriod value\n         set by SetMaxPeriod"]
    pub fn HAL_GetCounterStopped(counterHandle: HAL_CounterHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the last direction the counter value changed.\n\n @param[in] counterHandle the counter handle\n @param[out] status       Error status variable. 0 on success.\n @return the last direction the counter value changed"]
    pub fn HAL_GetCounterDirection(counterHandle: HAL_CounterHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the Counter to return reversed sensing on the direction.\n\n This allows counters to change the direction they are counting in the case of\n 1X and 2X quadrature encoding only. Any other counter mode isn't supported.\n\n @param[in] counterHandle    the counter handle\n @param[in] reverseDirection true if the value counted should be negated.\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetCounterReverseDirection(
        counterHandle: HAL_CounterHandle,
        reverseDirection: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_InitializeCTREPCM(
        module: i32,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_CTREPCMHandle;
}
extern "C" {
    pub fn HAL_FreeCTREPCM(handle: HAL_CTREPCMHandle);
}
extern "C" {
    pub fn HAL_CheckCTREPCMSolenoidChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressor(handle: HAL_CTREPCMHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetCTREPCMClosedLoopControl(
        handle: HAL_CTREPCMHandle,
        enabled: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetCTREPCMClosedLoopControl(handle: HAL_CTREPCMHandle, status: *mut i32)
        -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMPressureSwitch(handle: HAL_CTREPCMHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorCurrent(handle: HAL_CTREPCMHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorCurrentTooHighFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorCurrentTooHighStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorShortedStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorShortedFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorNotConnectedStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMCompressorNotConnectedFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMSolenoids(handle: HAL_CTREPCMHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_SetCTREPCMSolenoids(
        handle: HAL_CTREPCMHandle,
        mask: i32,
        values: i32,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetCTREPCMSolenoidDisabledList(handle: HAL_CTREPCMHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_GetCTREPCMSolenoidVoltageStickyFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetCTREPCMSolenoidVoltageFault(
        handle: HAL_CTREPCMHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_ClearAllCTREPCMStickyFaults(handle: HAL_CTREPCMHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_FireCTREPCMOneShot(handle: HAL_CTREPCMHandle, index: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetCTREPCMOneShotDuration(
        handle: HAL_CTREPCMHandle,
        index: i32,
        durMs: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Creates a new instance of a digital port.\n\n @param[in] portHandle         the port handle to create from\n @param[in] input              true for input, false for output\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status            Error status variable. 0 on success.\n @return the created digital handle"]
    pub fn HAL_InitializeDIOPort(
        portHandle: HAL_PortHandle,
        input: HAL_Bool,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_DigitalHandle;
}
extern "C" {
    #[doc = " Checks if a DIO channel is valid.\n\n @param channel the channel number to check\n @return true if the channel is correct, otherwise false"]
    pub fn HAL_CheckDIOChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Frees a DIO port.\n\n @param dioPortHandle the DIO channel handle"]
    pub fn HAL_FreeDIOPort(dioPortHandle: HAL_DigitalHandle);
}
extern "C" {
    #[doc = " Indicates the DIO channel is used by a simulated device.\n\n @param handle the DIO channel handle\n @param device simulated device handle"]
    pub fn HAL_SetDIOSimDevice(handle: HAL_DigitalHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Allocates a DO PWM Generator.\n\n @param[out] status Error status variable. 0 on success.\n @return the allocated digital PWM handle"]
    pub fn HAL_AllocateDigitalPWM(status: *mut i32) -> HAL_DigitalPWMHandle;
}
extern "C" {
    #[doc = " Frees the resource associated with a DO PWM generator.\n\n @param[in] pwmGenerator the digital PWM handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_FreeDigitalPWM(pwmGenerator: HAL_DigitalPWMHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Changes the frequency of the DO PWM generator.\n\n The valid range is from 0.6 Hz to 19 kHz.\n\n  The frequency resolution is logarithmic.\n\n @param[in] rate the frequency to output all digital output PWM signals\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetDigitalPWMRate(rate: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Configures the duty-cycle of the PWM generator.\n\n @param[in] pwmGenerator the digital PWM handle\n @param[in] dutyCycle    the percent duty cycle to output [0..1]\n @param[out] status      Error status variable. 0 on success."]
    pub fn HAL_SetDigitalPWMDutyCycle(
        pwmGenerator: HAL_DigitalPWMHandle,
        dutyCycle: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures the digital PWM to be a PPS signal with specified duty cycle.\n\n @param[in] pwmGenerator the digital PWM handle\n @param[in] dutyCycle    the percent duty cycle to output [0..1]\n @param[out] status      Error status variable. 0 on success."]
    pub fn HAL_SetDigitalPWMPPS(
        pwmGenerator: HAL_DigitalPWMHandle,
        dutyCycle: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Configures which DO channel the PWM signal is output on.\n\n @param[in] pwmGenerator the digital PWM handle\n @param[in] channel      the channel to output on\n @param[out] status      Error status variable. 0 on success."]
    pub fn HAL_SetDigitalPWMOutputChannel(
        pwmGenerator: HAL_DigitalPWMHandle,
        channel: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Writes a digital value to a DIO channel.\n\n @param[in] dioPortHandle the digital port handle\n @param[in] value         the state to set the digital channel (if it is\n                          configured as an output)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetDIO(dioPortHandle: HAL_DigitalHandle, value: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the direction of a DIO channel.\n\n @param[in] dioPortHandle the digital port handle\n @param[in] input         true to set input, false for output\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetDIODirection(dioPortHandle: HAL_DigitalHandle, input: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Reads a digital value from a DIO channel.\n\n @param[in] dioPortHandle the digital port handle\n @param[out] status       Error status variable. 0 on success.\n @return the state of the specified channel"]
    pub fn HAL_GetDIO(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Reads the direction of a DIO channel.\n\n @param[in] dioPortHandle the digital port handle\n @param[out] status       Error status variable. 0 on success.\n @return true for input, false for output"]
    pub fn HAL_GetDIODirection(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Generates a single digital pulse.\n\n Write a pulse to the specified digital output channel. There can only be a\n single pulse going at any time.\n\n @param[in] dioPortHandle the digital port handle\n @param[in] pulseLengthSeconds   the active length of the pulse (in seconds)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_Pulse(dioPortHandle: HAL_DigitalHandle, pulseLengthSeconds: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Generates a single digital pulse on multiple channels.\n\n Write a pulse to the channels enabled by the mask. There can only be a\n single pulse going at any time.\n\n @param[in] channelMask the channel mask\n @param[in] pulseLengthSeconds   the active length of the pulse (in seconds)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_PulseMultiple(channelMask: u32, pulseLengthSeconds: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Checks a DIO line to see if it is currently generating a pulse.\n\n @param[in] dioPortHandle the digital port handle\n @param[out] status Error status variable. 0 on success.\n @return true if a pulse is in progress, otherwise false"]
    pub fn HAL_IsPulsing(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Checks if any DIO line is currently generating a pulse.\n\n @param[out] status Error status variable. 0 on success.\n @return true if a pulse on some line is in progress"]
    pub fn HAL_IsAnyPulsing(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Writes the filter index from the FPGA.\n\n Set the filter index used to filter out short pulses.\n\n @param[in] dioPortHandle the digital port handle\n @param[in] filterIndex   the filter index (Must be in the range 0 - 3, where\n                          0 means \"none\" and 1 - 3 means filter # filterIndex\n                          - 1)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetFilterSelect(
        dioPortHandle: HAL_DigitalHandle,
        filterIndex: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Reads the filter index from the FPGA.\n\n Gets the filter index used to filter out short pulses.\n\n @param[in] dioPortHandle the digital port handle\n @param[out] status       Error status variable. 0 on success.\n @return filterIndex  the filter index (Must be in the range 0 - 3, where 0\n                      means \"none\" and 1 - 3 means filter # filterIndex - 1)"]
    pub fn HAL_GetFilterSelect(dioPortHandle: HAL_DigitalHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Sets the filter period for the specified filter index.\n\n Sets the filter period in FPGA cycles.  Even though there are 2 different\n filter index domains (MXP vs HDR), ignore that distinction for now since it\n compilicates the interface.  That can be changed later.\n\n @param[in] filterIndex the filter index, 0 - 2\n @param[in] value       the number of cycles that the signal must not\n                        transition to be counted as a transition.\n @param[out] status     Error status variable. 0 on success."]
    pub fn HAL_SetFilterPeriod(filterIndex: i32, value: i64, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the filter period for the specified filter index.\n\n Gets the filter period in FPGA cycles.  Even though there are 2 different\n filter index domains (MXP vs HDR), ignore that distinction for now since it\n compilicates the interface.  Set status to NiFpga_Status_SoftwareFault if the\n filter values miss-match.\n\n @param[in] filterIndex the filter index, 0 - 2\n @param[out] status     Error status variable. 0 on success."]
    pub fn HAL_GetFilterPeriod(filterIndex: i32, status: *mut i32) -> i64;
}
pub const HAL_DMAReadStatus_HAL_DMA_OK: HAL_DMAReadStatus = 1;
pub const HAL_DMAReadStatus_HAL_DMA_TIMEOUT: HAL_DMAReadStatus = 2;
pub const HAL_DMAReadStatus_HAL_DMA_ERROR: HAL_DMAReadStatus = 3;
#[doc = " The DMA Read Status."]
pub type HAL_DMAReadStatus = i32;
#[doc = " Buffer for containing all DMA data for a specific sample."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_DMASample {
    pub readBuffer: [u32; 74usize],
    pub channelOffsets: [i32; 22usize],
    pub timeStamp: u64,
    pub captureSize: u32,
    pub triggerChannels: u8,
}
#[test]
fn bindgen_test_layout_HAL_DMASample() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_DMASample> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_DMASample>(),
        400usize,
        concat!("Size of: ", stringify!(HAL_DMASample))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_DMASample>(),
        8usize,
        concat!("Alignment of ", stringify!(HAL_DMASample))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_DMASample),
            "::",
            stringify!(readBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channelOffsets) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_DMASample),
            "::",
            stringify!(channelOffsets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeStamp) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_DMASample),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).captureSize) as usize - ptr as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_DMASample),
            "::",
            stringify!(captureSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).triggerChannels) as usize - ptr as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_DMASample),
            "::",
            stringify!(triggerChannels)
        )
    );
}
extern "C" {
    #[doc = " Initializes an object for peforming DMA transfers.\n\n @param[out] status Error status variable. 0 on success.\n @return the created dma handle"]
    pub fn HAL_InitializeDMA(status: *mut i32) -> HAL_DMAHandle;
}
extern "C" {
    #[doc = " Frees a DMA object.\n\n @param handle the dma handle"]
    pub fn HAL_FreeDMA(handle: HAL_DMAHandle);
}
extern "C" {
    #[doc = " Pauses or unpauses a DMA transfer.\n\n This can only be called while DMA is running.\n\n @param[in] handle  the dma handle\n @param[in] pause   true to pause transfers, false to resume.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetDMAPause(handle: HAL_DMAHandle, pause: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Sets DMA transfers to occur at a specific timed interval.\n\n This will remove any external triggers. Only timed or external is supported.\n\n Only 1 timed period is supported.\n\n This can only be called if DMA is not started.\n\n @param[in] handle        the dma handle\n @param[in] periodSeconds the period to trigger in seconds\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetDMATimedTrigger(handle: HAL_DMAHandle, periodSeconds: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets DMA transfers to occur at a specific timed interval in FPGA cycles.\n\n This will remove any external triggers. Only timed or external is supported.\n\n Only 1 timed period is supported\n\n The FPGA currently runs at 40 MHz, but this can change.\n HAL_GetSystemClockTicksPerMicrosecond can be used to get a computable value\n for this.\n\n This can only be called if DMA is not started.\n\n @param[in] handle the dma handle\n @param[in] cycles the period to trigger in FPGA cycles\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetDMATimedTriggerCycles(handle: HAL_DMAHandle, cycles: u32, status: *mut i32);
}
extern "C" {
    #[doc = " Adds position data for an encoder to be collected by DMA.\n\n This can only be called if DMA is not started.\n\n @param[in] handle the dma handle\n @param[in] encoderHandle the encoder to add\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_AddDMAEncoder(
        handle: HAL_DMAHandle,
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Adds timer data for an encoder to be collected by DMA.\n\n This can only be called if DMA is not started.\n\n @param[in] handle the dma handle\n @param[in] encoderHandle the encoder to add\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_AddDMAEncoderPeriod(
        handle: HAL_DMAHandle,
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Adds position data for an counter to be collected by DMA.\n\n This can only be called if DMA is not started.\n\n @param[in] handle the dma handle\n @param[in] counterHandle the counter to add\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_AddDMACounter(
        handle: HAL_DMAHandle,
        counterHandle: HAL_CounterHandle,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Adds timer data for an counter to be collected by DMA.\n\n @param[in] handle the dma handle\n @param[in] counterHandle the counter to add\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_AddDMACounterPeriod(
        handle: HAL_DMAHandle,
        counterHandle: HAL_CounterHandle,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Adds a digital source to be collected by DMA.\n\n This can only be called if DMA is not started.\n\n @param[in] handle the dma handle\n @param[in] digitalSourceHandle the digital source to add\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_AddDMADigitalSource(
        handle: HAL_DMAHandle,
        digitalSourceHandle: HAL_Handle,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Adds an analog input to be collected by DMA.\n\n This can only be called if DMA is not started.\n\n @param[in] handle the dma handle\n @param[in] aInHandle the analog input to add\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_AddDMAAnalogInput(
        handle: HAL_DMAHandle,
        aInHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Adds averaged data of an analog input to be collected by DMA.\n\n This can only be called if DMA is not started.\n\n @param[in] handle the dma handle\n @param[in] aInHandle the analog input to add\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_AddDMAAveragedAnalogInput(
        handle: HAL_DMAHandle,
        aInHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Adds acuumulator data of an analog input to be collected by DMA.\n\n This can only be called if DMA is not started.\n\n @param[in] handle the dma handle\n @param[in] aInHandle the analog input to add\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_AddDMAAnalogAccumulator(
        handle: HAL_DMAHandle,
        aInHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Adds a duty cycle input to be collected by DMA.\n\n This can only be called if DMA is not started.\n\n @param[in] handle the dma handle\n @param[in] dutyCycleHandle the duty cycle input to add\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_AddDMADutyCycle(
        handle: HAL_DMAHandle,
        dutyCycleHandle: HAL_DutyCycleHandle,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets DMA transfers to occur on an external trigger.\n\n This will remove any timed trigger set. Only timed or external is supported.\n\n Up to 8 external triggers are currently supported.\n\n This can only be called if DMA is not started.\n\n @param[in] handle              the dma handle\n @param[in] digitalSourceHandle the digital source handle (either a\n                                HAL_AnalogTriggerHandle or a\n                                HAL_DigitalHandle)\n @param[in] analogTriggerType   the analog trigger type if the source is an\n                                analog trigger\n @param[in] rising              true to trigger on rising edge\n @param[in] falling             true to trigger on falling edge\n @param[out] status             Error status variable. 0 on success.\n @return the index of the trigger"]
    pub fn HAL_SetDMAExternalTrigger(
        handle: HAL_DMAHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        rising: HAL_Bool,
        falling: HAL_Bool,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Clear all sensors from the DMA collection list.\n\n This can only be called if DMA is not started.\n\n @param[in] handle the dma handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_ClearDMASensors(handle: HAL_DMAHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Clear all external triggers from the DMA trigger list.\n\n This can only be called if DMA is not started.\n\n @param[in] handle the dma handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_ClearDMAExternalTriggers(handle: HAL_DMAHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Starts DMA Collection.\n\n @param[in] handle the dma handle\n @param[in] queueDepth the number of objects to be able to queue\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_StartDMA(handle: HAL_DMAHandle, queueDepth: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Stops DMA Collection.\n\n @param[in] handle the dma handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_StopDMA(handle: HAL_DMAHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the direct pointer to the DMA object.\n\n This is only to be used if absolute maximum performance is required. This\n will only be valid until the handle is freed.\n\n @param handle the dma handle"]
    pub fn HAL_GetDMADirectPointer(handle: HAL_DMAHandle) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Reads a DMA sample using a direct DMA pointer.\n\n See HAL_ReadDMA for full documentation.\n\n @param[in] dmaPointer     direct DMA pointer\n @param[in] dmaSample      the sample object to place data into\n @param[in] timeoutSeconds the time to wait for data to be queued before\n                           timing out\n @param[in] remainingOut   the number of samples remaining in the queue\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_ReadDMADirect(
        dmaPointer: *mut ::std::os::raw::c_void,
        dmaSample: *mut HAL_DMASample,
        timeoutSeconds: f64,
        remainingOut: *mut i32,
        status: *mut i32,
    ) -> HAL_DMAReadStatus;
}
extern "C" {
    #[doc = " Reads a DMA sample from the queue.\n\n\n @param[in] handle         the dma handle\n @param[in] dmaSample      the sample object to place data into\n @param[in] timeoutSeconds the time to wait for data to be queued before\n                           timing out\n @param[in] remainingOut   the number of samples remaining in the queue\n @param[out] status        Error status variable. 0 on success.\n @return the succes result of the sample read"]
    pub fn HAL_ReadDMA(
        handle: HAL_DMAHandle,
        dmaSample: *mut HAL_DMASample,
        timeoutSeconds: f64,
        remainingOut: *mut i32,
        status: *mut i32,
    ) -> HAL_DMAReadStatus;
}
extern "C" {
    #[doc = " Returns the timestamp of the sample.\n This is in the same time domain as HAL_GetFPGATime().\n\n @param[in] dmaSample the sample to read from\n @param[out] status Error status variable. 0 on success.\n @return timestamp in microseconds since FPGA Initialization"]
    pub fn HAL_GetDMASampleTime(dmaSample: *const HAL_DMASample, status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Returns the raw distance data for an encoder from the sample.\n\n This can be scaled with DistancePerPulse and DecodingScaleFactor to match the\n result of GetDistance()\n\n @param[in] dmaSample the sample to read from\n @param[in] encoderHandle the encoder handle\n @param[out] status Error status variable. 0 on success.\n @return raw encoder ticks"]
    pub fn HAL_GetDMASampleEncoderRaw(
        dmaSample: *const HAL_DMASample,
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the distance data for an counter from the sample.\n\n @param[in] dmaSample the sample to read from\n @param[in] counterHandle the counter handle\n @param[out] status Error status variable. 0 on success.\n @return counter ticks"]
    pub fn HAL_GetDMASampleCounter(
        dmaSample: *const HAL_DMASample,
        counterHandle: HAL_CounterHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the raw period data for an encoder from the sample.\n\n This can be scaled with DistancePerPulse and DecodingScaleFactor to match the\n result of GetRate()\n\n @param[in] dmaSample the sample to read from\n @param[in] encoderHandle the encoder handle\n @param[out] status Error status variable. 0 on success.\n @return raw encoder period"]
    pub fn HAL_GetDMASampleEncoderPeriodRaw(
        dmaSample: *const HAL_DMASample,
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the period data for an counter from the sample.\n\n @param[in] dmaSample the sample to read from\n @param[in] counterHandle the counter handle\n @param[out] status Error status variable. 0 on success.\n @return counter period"]
    pub fn HAL_GetDMASampleCounterPeriod(
        dmaSample: *const HAL_DMASample,
        counterHandle: HAL_CounterHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the state of a digital source from the sample.\n\n @param[in] dmaSample the sample to read from\n @param[in] dSourceHandle the digital source handle\n @param[out] status Error status variable. 0 on success.\n @return digital source state"]
    pub fn HAL_GetDMASampleDigitalSource(
        dmaSample: *const HAL_DMASample,
        dSourceHandle: HAL_Handle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Returns the raw analog data for an analog input from the sample.\n\n This can be scaled with HAL_GetAnalogValueToVolts to match GetVoltage().\n\n @param[in] dmaSample the sample to read from\n @param[in] aInHandle the analog input handle\n @param[out] status Error status variable. 0 on success.\n @return raw analog data"]
    pub fn HAL_GetDMASampleAnalogInputRaw(
        dmaSample: *const HAL_DMASample,
        aInHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the raw averaged analog data for an analog input from the sample.\n\n This can be scaled with HAL_GetAnalogValueToVolts to match\n GetAveragedVoltage().\n\n @param[in] dmaSample the sample to read from\n @param[in] aInHandle the analog input handle\n @param[out] status Error status variable. 0 on success.\n @return raw averaged analog data"]
    pub fn HAL_GetDMASampleAveragedAnalogInputRaw(
        dmaSample: *const HAL_DMASample,
        aInHandle: HAL_AnalogInputHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the analog accumulator data for an analog input from the sample.\n\n @param[in] dmaSample the sample to read from\n @param[in] aInHandle the analog input handle\n @param[in] count the accumulator count\n @param[in] value the accumulator value\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_GetDMASampleAnalogAccumulator(
        dmaSample: *const HAL_DMASample,
        aInHandle: HAL_AnalogInputHandle,
        count: *mut i64,
        value: *mut i64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Returns the raw duty cycle input ratio data from the sample.\n\n Use HAL_GetDutyCycleOutputScaleFactor to scale this to a percentage.\n\n @param[in] dmaSample the sample to read from\n @param[in] dutyCycleHandle the duty cycle handle\n @param[out] status Error status variable. 0 on success.\n @return raw duty cycle input data"]
    pub fn HAL_GetDMASampleDutyCycleOutputRaw(
        dmaSample: *const HAL_DMASample,
        dutyCycleHandle: HAL_DutyCycleHandle,
        status: *mut i32,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string {
    pub _address: u8,
}
pub type std_basic_string__Char_alloc_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string__Alloc_traits_impl {
    pub _address: u8,
}
pub type std_basic_string__Alloc_traits_impl__Base = u8;
pub type std_basic_string__Alloc_traits = u8;
pub type std_basic_string_traits_type = u8;
pub type std_basic_string_value_type = u8;
pub type std_basic_string_allocator_type = u8;
pub type std_basic_string_size_type = u8;
pub type std_basic_string_difference_type = u8;
pub type std_basic_string_reference = u8;
pub type std_basic_string_const_reference = u8;
pub type std_basic_string_pointer = u8;
pub type std_basic_string_const_pointer = u8;
pub type std_basic_string_iterator = u8;
pub type std_basic_string_const_iterator = u8;
pub type std_basic_string_const_reverse_iterator = u8;
pub type std_basic_string_reverse_iterator = u8;
pub type std_basic_string___const_iterator = u8;
pub type std_basic_string___sv_type = u8;
pub type std_basic_string__If_sv = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string___sv_wrapper {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string__Alloc_hider {
    pub _address: u8,
}
pub const std_basic_string__S_local_capacity: std_basic_string__bindgen_ty_1 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union std_basic_string__bindgen_ty_2 {
    pub _bindgen_opaque_blob: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_initializer_list {
    pub _address: u8,
}
pub type std_initializer_list_value_type = u8;
pub type std_initializer_list_reference = u8;
pub type std_initializer_list_const_reference = u8;
pub type std_initializer_list_size_type = u32;
pub type std_initializer_list_iterator = u8;
pub type std_initializer_list_const_iterator = u8;
pub type std_false_type = u8;
extern "C" {
    #[link_name = "\u{1}_ZNSt45__do_is_implicitly_default_constructible_impl6__testEz"]
    pub fn std___do_is_implicitly_default_constructible_impl___test() -> std_false_type;
}
pub type std_conditional_type = u8;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__Prime_rehash_policy {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
pub type std___detail__Prime_rehash_policy___has_load_factor = u8;
pub type std___detail__Prime_rehash_policy__State = u32;
#[test]
fn bindgen_test_layout_std___detail__Prime_rehash_policy() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__Prime_rehash_policy>(),
        8usize,
        concat!("Size of: ", stringify!(std___detail__Prime_rehash_policy))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__Prime_rehash_policy>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(std___detail__Prime_rehash_policy)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt8__detail20_Prime_rehash_policy11_M_next_bktEj"]
    pub fn std___detail__Prime_rehash_policy__M_next_bkt(
        this: *const std___detail__Prime_rehash_policy,
        __n: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt8__detail20_Prime_rehash_policy14_M_need_rehashEjjj"]
    pub fn std___detail__Prime_rehash_policy__M_need_rehash(
        this: *const std___detail__Prime_rehash_policy,
        __n_bkt: usize,
        __n_elt: usize,
        __n_ins: usize,
    ) -> [u32; 2usize];
}
impl std___detail__Prime_rehash_policy {
    #[inline]
    pub unsafe fn _M_next_bkt(&self, __n: usize) -> usize {
        std___detail__Prime_rehash_policy__M_next_bkt(self, __n)
    }
    #[inline]
    pub unsafe fn _M_need_rehash(
        &self,
        __n_bkt: usize,
        __n_elt: usize,
        __n_ins: usize,
    ) -> [u32; 2usize] {
        std___detail__Prime_rehash_policy__M_need_rehash(self, __n_bkt, __n_elt, __n_ins)
    }
}
pub const std___detail__Prime_rehash_policy__S_growth_factor: usize = 2;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std___detail__List_node_base {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std___detail__List_node_base() {
    assert_eq!(
        ::std::mem::size_of::<std___detail__List_node_base>(),
        8usize,
        concat!("Size of: ", stringify!(std___detail__List_node_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___detail__List_node_base>(),
        4usize,
        concat!("Alignment of ", stringify!(std___detail__List_node_base))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base4swapERS0_S1_"]
    pub fn std___detail__List_node_base_swap(
        __x: *mut std___detail__List_node_base,
        __y: *mut std___detail__List_node_base,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base11_M_transferEPS0_S1_"]
    pub fn std___detail__List_node_base__M_transfer(
        this: *mut std___detail__List_node_base,
        __first: *mut std___detail__List_node_base,
        __last: *mut std___detail__List_node_base,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base10_M_reverseEv"]
    pub fn std___detail__List_node_base__M_reverse(this: *mut std___detail__List_node_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base7_M_hookEPS0_"]
    pub fn std___detail__List_node_base__M_hook(
        this: *mut std___detail__List_node_base,
        __position: *mut std___detail__List_node_base,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8__detail15_List_node_base9_M_unhookEv"]
    pub fn std___detail__List_node_base__M_unhook(this: *mut std___detail__List_node_base);
}
impl std___detail__List_node_base {
    #[inline]
    pub unsafe fn swap(
        __x: *mut std___detail__List_node_base,
        __y: *mut std___detail__List_node_base,
    ) {
        std___detail__List_node_base_swap(__x, __y)
    }
    #[inline]
    pub unsafe fn _M_transfer(
        &mut self,
        __first: *mut std___detail__List_node_base,
        __last: *mut std___detail__List_node_base,
    ) {
        std___detail__List_node_base__M_transfer(self, __first, __last)
    }
    #[inline]
    pub unsafe fn _M_reverse(&mut self) {
        std___detail__List_node_base__M_reverse(self)
    }
    #[inline]
    pub unsafe fn _M_hook(&mut self, __position: *mut std___detail__List_node_base) {
        std___detail__List_node_base__M_hook(self, __position)
    }
    #[inline]
    pub unsafe fn _M_unhook(&mut self) {
        std___detail__List_node_base__M_unhook(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6ranges12__cust_imove9iter_moveEv"]
    pub fn std_ranges___cust_imove_iter_move();
}
extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_bad_exceptionv"]
    pub fn std___throw_bad_exception() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt17__throw_bad_allocv"]
    pub fn std___throw_bad_alloc() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt28__throw_bad_array_new_lengthv"]
    pub fn std___throw_bad_array_new_length() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt16__throw_bad_castv"]
    pub fn std___throw_bad_cast() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt18__throw_bad_typeidv"]
    pub fn std___throw_bad_typeid() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_logic_errorPKc"]
    pub fn std___throw_logic_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_domain_errorPKc"]
    pub fn std___throw_domain_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_invalid_argumentPKc"]
    pub fn std___throw_invalid_argument(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_length_errorPKc"]
    pub fn std___throw_length_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_out_of_rangePKc"]
    pub fn std___throw_out_of_range(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt24__throw_out_of_range_fmtPKcz"]
    pub fn std___throw_out_of_range_fmt(arg1: *const ::std::os::raw::c_char, ...) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt21__throw_runtime_errorPKc"]
    pub fn std___throw_runtime_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_range_errorPKc"]
    pub fn std___throw_range_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt22__throw_overflow_errorPKc"]
    pub fn std___throw_overflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt23__throw_underflow_errorPKc"]
    pub fn std___throw_underflow_error(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKc"]
    pub fn std___throw_ios_failure(arg1: *const ::std::os::raw::c_char) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19__throw_ios_failurePKci"]
    pub fn std___throw_ios_failure1(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_system_errori"]
    pub fn std___throw_system_error(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20__throw_future_errori"]
    pub fn std___throw_future_error(arg1: ::std::os::raw::c_int) -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt25__throw_bad_function_callv"]
    pub fn std___throw_bad_function_call() -> !;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pair {
    pub _address: u8,
}
pub type std_pair_first_type = u8;
pub type std_pair_second_type = u8;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_forward_iterator_tag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_forward_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_forward_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_forward_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_forward_iterator_tag))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_bidirectional_iterator_tag {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_bidirectional_iterator_tag() {
    assert_eq!(
        ::std::mem::size_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Size of: ", stringify!(std_bidirectional_iterator_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bidirectional_iterator_tag>(),
        1usize,
        concat!("Alignment of ", stringify!(std_bidirectional_iterator_tag))
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_exception {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_exception>(),
        4usize,
        concat!("Size of: ", stringify!(std_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_exception>(),
        4usize,
        concat!("Alignment of ", stringify!(std_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9exceptionD1Ev"]
    pub fn std_exception_exception_destructor(this: *mut std_exception);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
    pub fn std_exception_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_bad_alloc {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std_bad_alloc() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_alloc>(),
        4usize,
        concat!("Size of: ", stringify!(std_bad_alloc))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_alloc>(),
        4usize,
        concat!("Alignment of ", stringify!(std_bad_alloc))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9bad_allocD1Ev"]
    pub fn std_bad_alloc_bad_alloc_destructor(this: *mut std_bad_alloc);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9bad_alloc4whatEv"]
    pub fn std_bad_alloc_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_bad_array_new_length {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std_bad_array_new_length() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_array_new_length>(),
        4usize,
        concat!("Size of: ", stringify!(std_bad_array_new_length))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_array_new_length>(),
        4usize,
        concat!("Alignment of ", stringify!(std_bad_array_new_length))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt20bad_array_new_lengthD1Ev"]
    pub fn std_bad_array_new_length_bad_array_new_length_destructor(
        this: *mut std_bad_array_new_length,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt20bad_array_new_length4whatEv"]
    pub fn std_bad_array_new_length_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type std_new_handler = u32;
extern "C" {
    #[link_name = "\u{1}_ZSt15set_new_handlerPFvvE"]
    pub fn std_set_new_handler(arg1: std_new_handler) -> std_new_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt15get_new_handlerv"]
    pub fn std_get_new_handler() -> std_new_handler;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator {
    pub _address: u8,
}
pub type std_reverse_iterator___traits_type = u8;
pub type std_reverse_iterator_iterator_type = u8;
pub type std_reverse_iterator_pointer = u8;
pub type std_reverse_iterator_iterator_concept = u8;
pub type std_reverse_iterator_iterator_category = u8;
pub type std_reverse_iterator_value_type = u8;
pub type std_reverse_iterator_difference_type = u8;
pub type std_reverse_iterator_reference = u8;
pub type std_array_value_type = u8;
pub type std_array_pointer = u8;
pub type std_array_const_pointer = u8;
pub type std_array_reference = u8;
pub type std_array_const_reference = u8;
pub type std_array_iterator = u8;
pub type std_array_const_iterator = u8;
pub type std_array_size_type = u32;
pub type std_array_difference_type = u32;
pub type std_array_reverse_iterator = u8;
pub type std_array_const_reverse_iterator = u8;
pub type std_array__AT_Type = u8;
pub type std_span___is_compatible_array = u8;
pub type std_span___is_compatible_ref = u8;
pub type std_span_element_type = u8;
pub type std_span_value_type = u8;
pub type std_span_size_type = u32;
pub type std_span_difference_type = u32;
pub type std_span_pointer = u8;
pub type std_span_const_pointer = u8;
pub type std_span_reference = u8;
pub type std_span_const_reference = u8;
pub type std_span_iterator = u8;
pub type std_span_reverse_iterator = u8;
pub type std_string = [u32; 6usize];
pub type std_streamsize = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_value_type = u8;
pub type std_allocator_size_type = u32;
pub type std_allocator_difference_type = u32;
pub type std_allocator_propagate_on_container_move_assignment = u8;
pub type std_allocator_is_always_equal = u8;
pub type std___c_locale = u32;
pub type std_istream = [u32; 36usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_greater {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_less {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZSt11_Hash_bytesPKvjj"]
    pub fn std__Hash_bytes(
        __ptr: *const ::std::os::raw::c_void,
        __len: usize,
        __seed: usize,
    ) -> usize;
}
extern "C" {
    #[link_name = "\u{1}_ZSt15_Fnv_hash_bytesPKvjj"]
    pub fn std__Fnv_hash_bytes(
        __ptr: *const ::std::os::raw::c_void,
        __len: usize,
        __seed: usize,
    ) -> usize;
}
pub type std_string_view = [u32; 2usize];
extern "C" {
    #[link_name = "\u{1}_ZSt7getlineIcSt11char_traitsIcESaIcEERSt13basic_istreamIT_T0_ES7_RNSt7__cxx1112basic_stringIS4_S5_T1_EES4_"]
    pub fn std_getline(
        __in: *mut [u32; 36usize],
        __str: *mut [u32; 6usize],
        __delim: ::std::os::raw::c_char,
    ) -> *mut [u32; 36usize];
}
extern "C" {
    #[link_name = "\u{1}_ZSt7getlineIwSt11char_traitsIwESaIwEERSt13basic_istreamIT_T0_ES7_RNSt7__cxx1112basic_stringIS4_S5_T1_EES4_"]
    pub fn std_getline1(
        __in: *mut [u32; 37usize],
        __str: *mut [u32; 6usize],
        __delim: u32,
    ) -> *mut [u32; 37usize];
}
extern "C" {
    #[link_name = "\u{1}num"]
    pub static std_ratio_num: ::std::os::raw::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}den"]
    pub static std_ratio_den: ::std::os::raw::c_longlong;
}
pub type std_ratio_multiply = u8;
pub type std_ratio_add = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_duration {
    pub _address: u8,
}
pub type std_chrono_duration___is_float = u8;
pub type std_chrono_duration___divide = u8;
pub type std_chrono_duration___is_harmonic = u8;
pub type std_chrono_duration_rep = u8;
pub type std_chrono_duration_period = u8;
pub type std_chrono_nanoseconds = u64;
pub type std_chrono_microseconds = u64;
pub type std_chrono_milliseconds = u64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_chrono_time_point {
    pub _address: u8,
}
pub type std_chrono_time_point_clock = u8;
pub type std_chrono_time_point_duration = u8;
pub type std_chrono_time_point_rep = u8;
pub type std_chrono_time_point_period = u8;
pub type std_chrono_system_clock_time_point = u64;
extern "C" {
    #[link_name = "\u{1}_ZNSt6chrono3_V212system_clock3nowEv"]
    pub fn std_chrono_system_clock_now() -> std_chrono_system_clock_time_point;
}
pub type std_chrono_steady_clock_time_point = u64;
extern "C" {
    #[link_name = "\u{1}_ZNSt6chrono3_V212steady_clock3nowEv"]
    pub fn std_chrono_steady_clock_now() -> std_chrono_steady_clock_time_point;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_bad_exception {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std_bad_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_exception>(),
        4usize,
        concat!("Size of: ", stringify!(std_bad_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_exception>(),
        4usize,
        concat!("Alignment of ", stringify!(std_bad_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13bad_exceptionD1Ev"]
    pub fn std_bad_exception_bad_exception_destructor(this: *mut std_bad_exception);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt13bad_exception4whatEv"]
    pub fn std_bad_exception_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
pub type std_terminate_handler = u32;
extern "C" {
    #[link_name = "\u{1}_ZSt13set_terminatePFvvE"]
    pub fn std_set_terminate(arg1: std_terminate_handler) -> std_terminate_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt13get_terminatev"]
    pub fn std_get_terminate() -> std_terminate_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt9terminatev"]
    pub fn std_terminate() -> !;
}
pub type std_unexpected_handler = u32;
extern "C" {
    #[link_name = "\u{1}_ZSt14set_unexpectedPFvvE"]
    pub fn std_set_unexpected(arg1: std_unexpected_handler) -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt14get_unexpectedv"]
    pub fn std_get_unexpected() -> std_unexpected_handler;
}
extern "C" {
    #[link_name = "\u{1}_ZSt10unexpectedv"]
    pub fn std_unexpected() -> !;
}
extern "C" {
    #[link_name = "\u{1}_ZSt18uncaught_exceptionv"]
    pub fn std_uncaught_exception() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZSt19uncaught_exceptionsv"]
    pub fn std_uncaught_exceptions() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_type_info {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_type_info() {
    assert_eq!(
        ::std::mem::size_of::<std_type_info>(),
        8usize,
        concat!("Size of: ", stringify!(std_type_info))
    );
    assert_eq!(
        ::std::mem::align_of::<std_type_info>(),
        4usize,
        concat!("Alignment of ", stringify!(std_type_info))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt9type_infoD1Ev"]
    pub fn std_type_info_type_info_destructor(this: *mut std_type_info);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info14__is_pointer_pEv"]
    pub fn std_type_info___is_pointer_p(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info15__is_function_pEv"]
    pub fn std_type_info___is_function_p(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info10__do_catchEPKS_PPvj"]
    pub fn std_type_info___do_catch(
        this: *mut ::std::os::raw::c_void,
        __thr_type: *const std_type_info,
        __thr_obj: *mut *mut ::std::os::raw::c_void,
        __outer: ::std::os::raw::c_uint,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt9type_info11__do_upcastEPKN10__cxxabiv117__class_type_infoEPPv"]
    pub fn std_type_info___do_upcast(
        this: *mut ::std::os::raw::c_void,
        __target: *const __cxxabiv1___class_type_info,
        __obj_ptr: *mut *mut ::std::os::raw::c_void,
    ) -> bool;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_bad_cast {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std_bad_cast() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_cast>(),
        4usize,
        concat!("Size of: ", stringify!(std_bad_cast))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_cast>(),
        4usize,
        concat!("Alignment of ", stringify!(std_bad_cast))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8bad_castD1Ev"]
    pub fn std_bad_cast_bad_cast_destructor(this: *mut std_bad_cast);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt8bad_cast4whatEv"]
    pub fn std_bad_cast_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_bad_typeid {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std_bad_typeid() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_typeid>(),
        4usize,
        concat!("Size of: ", stringify!(std_bad_typeid))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_typeid>(),
        4usize,
        concat!("Alignment of ", stringify!(std_bad_typeid))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10bad_typeidD1Ev"]
    pub fn std_bad_typeid_bad_typeid_destructor(this: *mut std_bad_typeid);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt10bad_typeid4whatEv"]
    pub fn std_bad_typeid_what(this: *mut ::std::os::raw::c_void) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std___exception_ptr_exception_ptr {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std___exception_ptr_exception_ptr() {
    assert_eq!(
        ::std::mem::size_of::<std___exception_ptr_exception_ptr>(),
        4usize,
        concat!("Size of: ", stringify!(std___exception_ptr_exception_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<std___exception_ptr_exception_ptr>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(std___exception_ptr_exception_ptr)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt15__exception_ptr13exception_ptr20__cxa_exception_typeEv"]
    pub fn std___exception_ptr_exception_ptr___cxa_exception_type(
        this: *const std___exception_ptr_exception_ptr,
    ) -> *const std_type_info;
}
impl std___exception_ptr_exception_ptr {
    #[inline]
    pub unsafe fn __cxa_exception_type(&self) -> *const std_type_info {
        std___exception_ptr_exception_ptr___cxa_exception_type(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZSt17current_exceptionv"]
    pub fn std_current_exception() -> std___exception_ptr_exception_ptr;
}
extern "C" {
    #[link_name = "\u{1}_ZSt17rethrow_exceptionNSt15__exception_ptr13exception_ptrE"]
    pub fn std_rethrow_exception(arg1: std___exception_ptr_exception_ptr) -> !;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_nested_exception {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_nested_exception() {
    assert_eq!(
        ::std::mem::size_of::<std_nested_exception>(),
        8usize,
        concat!("Size of: ", stringify!(std_nested_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<std_nested_exception>(),
        4usize,
        concat!("Alignment of ", stringify!(std_nested_exception))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16nested_exceptionD1Ev"]
    pub fn std_nested_exception_nested_exception_destructor(this: *mut std_nested_exception);
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_locale {
    pub _bindgen_opaque_blob: u32,
}
pub type std_locale_category = u32;
pub const std_locale__S_categories_size: std_locale__bindgen_ty_1 = 12;
pub type std_locale__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_std_locale() {
    assert_eq!(
        ::std::mem::size_of::<std_locale>(),
        4usize,
        concat!("Size of: ", stringify!(std_locale))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale>(),
        4usize,
        concat!("Alignment of ", stringify!(std_locale))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt6locale4nameB5cxx11Ev"]
    pub fn std_locale_name(this: *const std_locale) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale6globalERKS_"]
    pub fn std_locale_global(__loc: *const std_locale) -> std_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale7classicEv"]
    pub fn std_locale_classic() -> *const std_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1Ev"]
    pub fn std_locale_locale(this: *mut std_locale);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1ERKS_"]
    pub fn std_locale_locale1(this: *mut std_locale, __other: *const std_locale);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1EPKc"]
    pub fn std_locale_locale2(this: *mut std_locale, __s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1ERKS_PKci"]
    pub fn std_locale_locale3(
        this: *mut std_locale,
        __base: *const std_locale,
        __s: *const ::std::os::raw::c_char,
        __cat: std_locale_category,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeC1ERKS_S1_i"]
    pub fn std_locale_locale4(
        this: *mut std_locale,
        __base: *const std_locale,
        __add: *const std_locale,
        __cat: std_locale_category,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6localeD1Ev"]
    pub fn std_locale_locale_destructor(this: *mut std_locale);
}
impl std_locale {
    #[inline]
    pub unsafe fn name(&self) -> std_string {
        std_locale_name(self)
    }
    #[inline]
    pub unsafe fn global(__loc: *const std_locale) -> std_locale {
        std_locale_global(__loc)
    }
    #[inline]
    pub unsafe fn classic() -> *const std_locale {
        std_locale_classic()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(__other: *const std_locale) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale1(__bindgen_tmp.as_mut_ptr(), __other);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(__s: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale2(__bindgen_tmp.as_mut_ptr(), __s);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        __base: *const std_locale,
        __s: *const ::std::os::raw::c_char,
        __cat: std_locale_category,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale3(__bindgen_tmp.as_mut_ptr(), __base, __s, __cat);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(
        __base: *const std_locale,
        __add: *const std_locale,
        __cat: std_locale_category,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_locale_locale4(__bindgen_tmp.as_mut_ptr(), __base, __add, __cat);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_locale_locale_destructor(self)
    }
}
pub const std_locale_none: std_locale_category = 0;
pub const std_locale_ctype: std_locale_category = 1;
pub const std_locale_numeric: std_locale_category = 2;
pub const std_locale_collate: std_locale_category = 4;
pub const std_locale_time: std_locale_category = 8;
pub const std_locale_monetary: std_locale_category = 16;
pub const std_locale_messages: std_locale_category = 32;
pub const std_locale_all: std_locale_category = 63;
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale10_S_classicE"]
    pub static mut std_locale__S_classic: *mut std_locale__Impl;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale9_S_globalE"]
    pub static mut std_locale__S_global: *mut std_locale__Impl;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale13_S_categoriesE"]
    pub static std_locale__S_categories: *const *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale7_S_onceE"]
    pub static mut std_locale__S_once: __gthread_once_t;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale17_S_twinned_facetsE"]
    pub static std_locale__S_twinned_facets: [*const std_locale_id; 0usize];
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_locale_facet {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_locale_facet___shim {
    _unused: [u8; 0],
}
#[test]
fn bindgen_test_layout_std_locale_facet() {
    assert_eq!(
        ::std::mem::size_of::<std_locale_facet>(),
        8usize,
        concat!("Size of: ", stringify!(std_locale_facet))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale_facet>(),
        4usize,
        concat!("Alignment of ", stringify!(std_locale_facet))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet18_S_create_c_localeERP15__locale_structPKcS2_"]
    pub fn std_locale_facet__S_create_c_locale(
        __cloc: *mut std___c_locale,
        __s: *const ::std::os::raw::c_char,
        __old: std___c_locale,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet17_S_clone_c_localeERP15__locale_struct"]
    pub fn std_locale_facet__S_clone_c_locale(__cloc: *mut std___c_locale) -> std___c_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet19_S_destroy_c_localeERP15__locale_struct"]
    pub fn std_locale_facet__S_destroy_c_locale(__cloc: *mut std___c_locale);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet20_S_lc_ctype_c_localeEP15__locale_structPKc"]
    pub fn std_locale_facet__S_lc_ctype_c_locale(
        __cloc: std___c_locale,
        __s: *const ::std::os::raw::c_char,
    ) -> std___c_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet15_S_get_c_localeEv"]
    pub fn std_locale_facet__S_get_c_locale() -> std___c_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet13_S_get_c_nameEv"]
    pub fn std_locale_facet__S_get_c_name() -> *const ::std::os::raw::c_char;
}
impl std_locale_facet {
    #[inline]
    pub unsafe fn _S_create_c_locale(
        __cloc: *mut std___c_locale,
        __s: *const ::std::os::raw::c_char,
        __old: std___c_locale,
    ) {
        std_locale_facet__S_create_c_locale(__cloc, __s, __old)
    }
    #[inline]
    pub unsafe fn _S_clone_c_locale(__cloc: *mut std___c_locale) -> std___c_locale {
        std_locale_facet__S_clone_c_locale(__cloc)
    }
    #[inline]
    pub unsafe fn _S_destroy_c_locale(__cloc: *mut std___c_locale) {
        std_locale_facet__S_destroy_c_locale(__cloc)
    }
    #[inline]
    pub unsafe fn _S_lc_ctype_c_locale(
        __cloc: std___c_locale,
        __s: *const ::std::os::raw::c_char,
    ) -> std___c_locale {
        std_locale_facet__S_lc_ctype_c_locale(__cloc, __s)
    }
    #[inline]
    pub unsafe fn _S_get_c_locale() -> std___c_locale {
        std_locale_facet__S_get_c_locale()
    }
    #[inline]
    pub unsafe fn _S_get_c_name() -> *const ::std::os::raw::c_char {
        std_locale_facet__S_get_c_name()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet11_S_c_localeE"]
    pub static mut std_locale_facet__S_c_locale: std___c_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet9_S_c_nameE"]
    pub static std_locale_facet__S_c_name: [::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facet7_S_onceE"]
    pub static mut std_locale_facet__S_once: __gthread_once_t;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5facetD1Ev"]
    pub fn std_locale_facet_facet_destructor(this: *mut std_locale_facet);
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_locale_id {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std_locale_id() {
    assert_eq!(
        ::std::mem::size_of::<std_locale_id>(),
        4usize,
        concat!("Size of: ", stringify!(std_locale_id))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale_id>(),
        4usize,
        concat!("Alignment of ", stringify!(std_locale_id))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt6locale2id5_M_idEv"]
    pub fn std_locale_id__M_id(this: *const std_locale_id) -> usize;
}
impl std_locale_id {
    #[inline]
    pub unsafe fn _M_id(&self) -> usize {
        std_locale_id__M_id(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale2id11_S_refcountE"]
    pub static mut std_locale_id__S_refcount: _Atomic_word;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_locale__Impl {
    pub _bindgen_opaque_blob: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_std_locale__Impl() {
    assert_eq!(
        ::std::mem::size_of::<std_locale__Impl>(),
        20usize,
        concat!("Size of: ", stringify!(std_locale__Impl))
    );
    assert_eq!(
        ::std::mem::align_of::<std_locale__Impl>(),
        4usize,
        concat!("Alignment of ", stringify!(std_locale__Impl))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl11_S_id_ctypeE"]
    pub static std_locale__Impl__S_id_ctype: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl13_S_id_numericE"]
    pub static std_locale__Impl__S_id_numeric: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl13_S_id_collateE"]
    pub static std_locale__Impl__S_id_collate: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl10_S_id_timeE"]
    pub static std_locale__Impl__S_id_time: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl14_S_id_monetaryE"]
    pub static std_locale__Impl__S_id_monetary: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl14_S_id_messagesE"]
    pub static std_locale__Impl__S_id_messages: [*const std_locale_id; 0usize];
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6locale5_Impl19_S_facet_categoriesE"]
    pub static std_locale__Impl__S_facet_categories: [*const *const std_locale_id; 0usize];
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std___cow_string {
    pub _bindgen_opaque_blob: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Copy, Clone)]
pub union std___cow_string__bindgen_ty_1 {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std___cow_string__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<std___cow_string__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(std___cow_string__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<std___cow_string__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(std___cow_string__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout_std___cow_string() {
    assert_eq!(
        ::std::mem::size_of::<std___cow_string>(),
        4usize,
        concat!("Size of: ", stringify!(std___cow_string))
    );
    assert_eq!(
        ::std::mem::align_of::<std___cow_string>(),
        4usize,
        concat!("Alignment of ", stringify!(std___cow_string))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1Ev"]
    pub fn std___cow_string___cow_string(this: *mut std___cow_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std___cow_string___cow_string1(this: *mut std___cow_string, arg1: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1EPKcj"]
    pub fn std___cow_string___cow_string2(
        this: *mut std___cow_string,
        arg1: *const ::std::os::raw::c_char,
        arg2: usize,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1ERKS_"]
    pub fn std___cow_string___cow_string3(
        this: *mut std___cow_string,
        arg1: *const std___cow_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringC1EOS_"]
    pub fn std___cow_string___cow_string4(this: *mut std___cow_string, arg1: *mut std___cow_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12__cow_stringD1Ev"]
    pub fn std___cow_string___cow_string_destructor(this: *mut std___cow_string);
}
impl std___cow_string {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const ::std::os::raw::c_char, arg2: usize) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string2(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std___cow_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(arg1: *mut std___cow_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std___cow_string___cow_string4(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std___cow_string___cow_string_destructor(self)
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_logic_error {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_logic_error() {
    assert_eq!(
        ::std::mem::size_of::<std_logic_error>(),
        8usize,
        concat!("Size of: ", stringify!(std_logic_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_logic_error>(),
        4usize,
        concat!("Alignment of ", stringify!(std_logic_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_logic_error_logic_error(this: *mut std_logic_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1EPKc"]
    pub fn std_logic_error_logic_error1(
        this: *mut std_logic_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1EOS_"]
    pub fn std_logic_error_logic_error2(this: *mut std_logic_error, arg1: *mut std_logic_error);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorC1ERKS_"]
    pub fn std_logic_error_logic_error3(this: *mut std_logic_error, arg1: *const std_logic_error);
}
impl std_logic_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut std_logic_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std_logic_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_logic_error_logic_error3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11logic_errorD1Ev"]
    pub fn std_logic_error_logic_error_destructor(this: *mut std_logic_error);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt11logic_error4whatEv"]
    pub fn std_logic_error_what(this: *mut ::std::os::raw::c_void)
        -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_domain_error {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_domain_error() {
    assert_eq!(
        ::std::mem::size_of::<std_domain_error>(),
        8usize,
        concat!("Size of: ", stringify!(std_domain_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_domain_error>(),
        4usize,
        concat!("Alignment of ", stringify!(std_domain_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_domain_error_domain_error(this: *mut std_domain_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorC1EPKc"]
    pub fn std_domain_error_domain_error1(
        this: *mut std_domain_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_domain_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_domain_error_domain_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_domain_error_domain_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12domain_errorD1Ev"]
    pub fn std_domain_error_domain_error_destructor(this: *mut std_domain_error);
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_invalid_argument {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_invalid_argument() {
    assert_eq!(
        ::std::mem::size_of::<std_invalid_argument>(),
        8usize,
        concat!("Size of: ", stringify!(std_invalid_argument))
    );
    assert_eq!(
        ::std::mem::align_of::<std_invalid_argument>(),
        4usize,
        concat!("Alignment of ", stringify!(std_invalid_argument))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_invalid_argument_invalid_argument(
        this: *mut std_invalid_argument,
        __arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentC1EPKc"]
    pub fn std_invalid_argument_invalid_argument1(
        this: *mut std_invalid_argument,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_invalid_argument {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_invalid_argument_invalid_argument(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_invalid_argument_invalid_argument1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16invalid_argumentD1Ev"]
    pub fn std_invalid_argument_invalid_argument_destructor(this: *mut std_invalid_argument);
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_length_error {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_length_error() {
    assert_eq!(
        ::std::mem::size_of::<std_length_error>(),
        8usize,
        concat!("Size of: ", stringify!(std_length_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_length_error>(),
        4usize,
        concat!("Alignment of ", stringify!(std_length_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_length_error_length_error(this: *mut std_length_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorC1EPKc"]
    pub fn std_length_error_length_error1(
        this: *mut std_length_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_length_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_length_error_length_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_length_error_length_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12length_errorD1Ev"]
    pub fn std_length_error_length_error_destructor(this: *mut std_length_error);
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_out_of_range {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_out_of_range() {
    assert_eq!(
        ::std::mem::size_of::<std_out_of_range>(),
        8usize,
        concat!("Size of: ", stringify!(std_out_of_range))
    );
    assert_eq!(
        ::std::mem::align_of::<std_out_of_range>(),
        4usize,
        concat!("Alignment of ", stringify!(std_out_of_range))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_out_of_range_out_of_range(this: *mut std_out_of_range, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeC1EPKc"]
    pub fn std_out_of_range_out_of_range1(
        this: *mut std_out_of_range,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_out_of_range {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_out_of_range_out_of_range(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_out_of_range_out_of_range1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12out_of_rangeD1Ev"]
    pub fn std_out_of_range_out_of_range_destructor(this: *mut std_out_of_range);
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_runtime_error {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_runtime_error() {
    assert_eq!(
        ::std::mem::size_of::<std_runtime_error>(),
        8usize,
        concat!("Size of: ", stringify!(std_runtime_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_runtime_error>(),
        4usize,
        concat!("Alignment of ", stringify!(std_runtime_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_runtime_error_runtime_error(this: *mut std_runtime_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1EPKc"]
    pub fn std_runtime_error_runtime_error1(
        this: *mut std_runtime_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1EOS_"]
    pub fn std_runtime_error_runtime_error2(
        this: *mut std_runtime_error,
        arg1: *mut std_runtime_error,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorC1ERKS_"]
    pub fn std_runtime_error_runtime_error3(
        this: *mut std_runtime_error,
        arg1: *const std_runtime_error,
    );
}
impl std_runtime_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *mut std_runtime_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error2(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(arg1: *const std_runtime_error) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_runtime_error_runtime_error3(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt13runtime_errorD1Ev"]
    pub fn std_runtime_error_runtime_error_destructor(this: *mut std_runtime_error);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt13runtime_error4whatEv"]
    pub fn std_runtime_error_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_range_error {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_range_error() {
    assert_eq!(
        ::std::mem::size_of::<std_range_error>(),
        8usize,
        concat!("Size of: ", stringify!(std_range_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_range_error>(),
        4usize,
        concat!("Alignment of ", stringify!(std_range_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_range_error_range_error(this: *mut std_range_error, __arg: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorC1EPKc"]
    pub fn std_range_error_range_error1(
        this: *mut std_range_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_range_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_range_error_range_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_range_error_range_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt11range_errorD1Ev"]
    pub fn std_range_error_range_error_destructor(this: *mut std_range_error);
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_overflow_error {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_overflow_error() {
    assert_eq!(
        ::std::mem::size_of::<std_overflow_error>(),
        8usize,
        concat!("Size of: ", stringify!(std_overflow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_overflow_error>(),
        4usize,
        concat!("Alignment of ", stringify!(std_overflow_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_overflow_error_overflow_error(
        this: *mut std_overflow_error,
        __arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorC1EPKc"]
    pub fn std_overflow_error_overflow_error1(
        this: *mut std_overflow_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_overflow_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_overflow_error_overflow_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_overflow_error_overflow_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt14overflow_errorD1Ev"]
    pub fn std_overflow_error_overflow_error_destructor(this: *mut std_overflow_error);
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_underflow_error {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_underflow_error() {
    assert_eq!(
        ::std::mem::size_of::<std_underflow_error>(),
        8usize,
        concat!("Size of: ", stringify!(std_underflow_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_underflow_error>(),
        4usize,
        concat!("Alignment of ", stringify!(std_underflow_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_underflow_error_underflow_error(
        this: *mut std_underflow_error,
        __arg: *const std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorC1EPKc"]
    pub fn std_underflow_error_underflow_error1(
        this: *mut std_underflow_error,
        arg1: *const ::std::os::raw::c_char,
    );
}
impl std_underflow_error {
    #[inline]
    pub unsafe fn new(__arg: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_underflow_error_underflow_error(__bindgen_tmp.as_mut_ptr(), __arg);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_underflow_error_underflow_error1(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt15underflow_errorD1Ev"]
    pub fn std_underflow_error_underflow_error_destructor(this: *mut std_underflow_error);
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_error_category {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std_error_category() {
    assert_eq!(
        ::std::mem::size_of::<std_error_category>(),
        4usize,
        concat!("Size of: ", stringify!(std_error_category))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_category>(),
        4usize,
        concat!("Alignment of ", stringify!(std_error_category))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3_V214error_categoryD1Ev"]
    pub fn std_error_category_error_category_destructor(this: *mut std_error_category);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category23default_error_conditionEi"]
    pub fn std_error_category_default_error_condition(
        this: *mut ::std::os::raw::c_void,
        __i: ::std::os::raw::c_int,
    ) -> std_error_condition;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentEiRKSt15error_condition"]
    pub fn std_error_category_equivalent(
        this: *mut ::std::os::raw::c_void,
        __i: ::std::os::raw::c_int,
        __cond: *const std_error_condition,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentERKSt10error_codei"]
    pub fn std_error_category_equivalent1(
        this: *mut ::std::os::raw::c_void,
        __code: *const std_error_code,
        __i: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3_V216generic_categoryEv"]
    pub fn std_generic_category() -> *const std_error_category;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3_V215system_categoryEv"]
    pub fn std_system_category() -> *const std_error_category;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_error_code {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_error_code() {
    assert_eq!(
        ::std::mem::size_of::<std_error_code>(),
        8usize,
        concat!("Size of: ", stringify!(std_error_code))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_code>(),
        4usize,
        concat!("Alignment of ", stringify!(std_error_code))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt10error_code23default_error_conditionEv"]
    pub fn std_error_code_default_error_condition(
        this: *const std_error_code,
    ) -> std_error_condition;
}
impl std_error_code {
    #[inline]
    pub unsafe fn default_error_condition(&self) -> std_error_condition {
        std_error_code_default_error_condition(self)
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_error_condition {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_error_condition() {
    assert_eq!(
        ::std::mem::size_of::<std_error_condition>(),
        8usize,
        concat!("Size of: ", stringify!(std_error_condition))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_condition>(),
        4usize,
        concat!("Alignment of ", stringify!(std_error_condition))
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_system_error {
    pub _bindgen_opaque_blob: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_std_system_error() {
    assert_eq!(
        ::std::mem::size_of::<std_system_error>(),
        16usize,
        concat!("Size of: ", stringify!(std_system_error))
    );
    assert_eq!(
        ::std::mem::align_of::<std_system_error>(),
        4usize,
        concat!("Alignment of ", stringify!(std_system_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12system_errorD1Ev"]
    pub fn std_system_error_system_error_destructor(this: *mut std_system_error);
}
extern "C" {
    #[link_name = "\u{1}_ZSt17iostream_categoryv"]
    pub fn std_iostream_category() -> *const std_error_category;
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base {
    pub _bindgen_opaque_blob: [u32; 28usize],
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base_failure {
    pub _bindgen_opaque_blob: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_std_ios_base_failure() {
    assert_eq!(
        ::std::mem::size_of::<std_ios_base_failure>(),
        16usize,
        concat!("Size of: ", stringify!(std_ios_base_failure))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base_failure>(),
        4usize,
        concat!("Alignment of ", stringify!(std_ios_base_failure))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std_ios_base_failure_failure(this: *mut std_ios_base_failure, __str: *const std_string);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt10error_code"]
    pub fn std_ios_base_failure_failure1(
        this: *mut std_ios_base_failure,
        arg1: *const std_string,
        arg2: *const std_error_code,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1EPKcRKSt10error_code"]
    pub fn std_ios_base_failure_failure2(
        this: *mut std_ios_base_failure,
        arg1: *const ::std::os::raw::c_char,
        arg2: *const std_error_code,
    );
}
impl std_ios_base_failure {
    #[inline]
    pub unsafe fn new(__str: *const std_string) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure(__bindgen_tmp.as_mut_ptr(), __str);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(arg1: *const std_string, arg2: *const std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure1(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(arg1: *const ::std::os::raw::c_char, arg2: *const std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_failure_failure2(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
}
pub type std_ios_base_fmtflags = u32;
pub type std_ios_base_iostate = u32;
pub type std_ios_base_openmode = u32;
pub type std_ios_base_seekdir = u32;
pub const std_ios_base_event_erase_event: std_ios_base_event = 0;
pub const std_ios_base_event_imbue_event: std_ios_base_event = 1;
pub const std_ios_base_event_copyfmt_event: std_ios_base_event = 2;
pub type std_ios_base_event = ::std::os::raw::c_uint;
pub type std_ios_base_event_callback = u32;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base__Callback_list {
    pub _bindgen_opaque_blob: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_std_ios_base__Callback_list() {
    assert_eq!(
        ::std::mem::size_of::<std_ios_base__Callback_list>(),
        16usize,
        concat!("Size of: ", stringify!(std_ios_base__Callback_list))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base__Callback_list>(),
        4usize,
        concat!("Alignment of ", stringify!(std_ios_base__Callback_list))
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base__Words {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_std_ios_base__Words() {
    assert_eq!(
        ::std::mem::size_of::<std_ios_base__Words>(),
        8usize,
        concat!("Size of: ", stringify!(std_ios_base__Words))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base__Words>(),
        4usize,
        concat!("Alignment of ", stringify!(std_ios_base__Words))
    );
}
pub const std_ios_base__S_local_word_size: std_ios_base__bindgen_ty_1 = 8;
pub type std_ios_base__bindgen_ty_1 = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_ios_base_Init {
    pub _bindgen_opaque_blob: u8,
}
#[test]
fn bindgen_test_layout_std_ios_base_Init() {
    assert_eq!(
        ::std::mem::size_of::<std_ios_base_Init>(),
        1usize,
        concat!("Size of: ", stringify!(std_ios_base_Init))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base_Init>(),
        1usize,
        concat!("Alignment of ", stringify!(std_ios_base_Init))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4InitC1Ev"]
    pub fn std_ios_base_Init_Init(this: *mut std_ios_base_Init);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4InitD1Ev"]
    pub fn std_ios_base_Init_Init_destructor(this: *mut std_ios_base_Init);
}
impl std_ios_base_Init {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_Init_Init(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_ios_base_Init_Init_destructor(self)
    }
}
#[test]
fn bindgen_test_layout_std_ios_base() {
    assert_eq!(
        ::std::mem::size_of::<std_ios_base>(),
        112usize,
        concat!("Size of: ", stringify!(std_ios_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std_ios_base>(),
        4usize,
        concat!("Alignment of ", stringify!(std_ios_base))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base17register_callbackEPFvNS_5eventERS_iEi"]
    pub fn std_ios_base_register_callback(
        this: *mut std_ios_base,
        __fn: std_ios_base_event_callback,
        __index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base17_M_call_callbacksENS_5eventE"]
    pub fn std_ios_base__M_call_callbacks(this: *mut std_ios_base, __ev: std_ios_base_event);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base20_M_dispose_callbacksEv"]
    pub fn std_ios_base__M_dispose_callbacks(this: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base13_M_grow_wordsEib"]
    pub fn std_ios_base__M_grow_words(
        this: *mut std_ios_base,
        __index: ::std::os::raw::c_int,
        __iword: bool,
    ) -> *mut std_ios_base__Words;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7_M_initEv"]
    pub fn std_ios_base__M_init(this: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base15sync_with_stdioEb"]
    pub fn std_ios_base_sync_with_stdio(__sync: bool) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5imbueERKSt6locale"]
    pub fn std_ios_base_imbue(this: *mut std_ios_base, __loc: *const std_locale) -> std_locale;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6xallocEv"]
    pub fn std_ios_base_xalloc() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7_M_moveERS_"]
    pub fn std_ios_base__M_move(this: *mut std_ios_base, arg1: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7_M_swapERS_"]
    pub fn std_ios_base__M_swap(this: *mut std_ios_base, __rhs: *mut std_ios_base);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_baseC1Ev"]
    pub fn std_ios_base_ios_base(this: *mut std_ios_base);
}
impl std_ios_base {
    #[inline]
    pub unsafe fn register_callback(
        &mut self,
        __fn: std_ios_base_event_callback,
        __index: ::std::os::raw::c_int,
    ) {
        std_ios_base_register_callback(self, __fn, __index)
    }
    #[inline]
    pub unsafe fn _M_call_callbacks(&mut self, __ev: std_ios_base_event) {
        std_ios_base__M_call_callbacks(self, __ev)
    }
    #[inline]
    pub unsafe fn _M_dispose_callbacks(&mut self) {
        std_ios_base__M_dispose_callbacks(self)
    }
    #[inline]
    pub unsafe fn _M_grow_words(
        &mut self,
        __index: ::std::os::raw::c_int,
        __iword: bool,
    ) -> *mut std_ios_base__Words {
        std_ios_base__M_grow_words(self, __index, __iword)
    }
    #[inline]
    pub unsafe fn _M_init(&mut self) {
        std_ios_base__M_init(self)
    }
    #[inline]
    pub unsafe fn sync_with_stdio(__sync: bool) -> bool {
        std_ios_base_sync_with_stdio(__sync)
    }
    #[inline]
    pub unsafe fn imbue(&mut self, __loc: *const std_locale) -> std_locale {
        std_ios_base_imbue(self, __loc)
    }
    #[inline]
    pub unsafe fn xalloc() -> ::std::os::raw::c_int {
        std_ios_base_xalloc()
    }
    #[inline]
    pub unsafe fn _M_move(&mut self, arg1: *mut std_ios_base) {
        std_ios_base__M_move(self, arg1)
    }
    #[inline]
    pub unsafe fn _M_swap(&mut self, __rhs: *mut std_ios_base) {
        std_ios_base__M_swap(self, __rhs)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_ios_base_ios_base(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11D1Ev"]
    pub fn std_ios_base_failure_failure_destructor(this: *mut std_ios_base_failure);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt8ios_base7failureB5cxx114whatEv"]
    pub fn std_ios_base_failure_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9boolalphaE"]
    pub static std_ios_base_boolalpha: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3decE"]
    pub static std_ios_base_dec: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5fixedE"]
    pub static std_ios_base_fixed: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3hexE"]
    pub static std_ios_base_hex: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base8internalE"]
    pub static std_ios_base_internal: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4leftE"]
    pub static std_ios_base_left: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3octE"]
    pub static std_ios_base_oct: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5rightE"]
    pub static std_ios_base_right: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base10scientificE"]
    pub static std_ios_base_scientific: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base8showbaseE"]
    pub static std_ios_base_showbase: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9showpointE"]
    pub static std_ios_base_showpoint: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7showposE"]
    pub static std_ios_base_showpos: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6skipwsE"]
    pub static std_ios_base_skipws: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7unitbufE"]
    pub static std_ios_base_unitbuf: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9uppercaseE"]
    pub static std_ios_base_uppercase: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base11adjustfieldE"]
    pub static std_ios_base_adjustfield: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base9basefieldE"]
    pub static std_ios_base_basefield: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base10floatfieldE"]
    pub static std_ios_base_floatfield: std_ios_base_fmtflags;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6badbitE"]
    pub static std_ios_base_badbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6eofbitE"]
    pub static std_ios_base_eofbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7failbitE"]
    pub static std_ios_base_failbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base7goodbitE"]
    pub static std_ios_base_goodbit: std_ios_base_iostate;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3appE"]
    pub static std_ios_base_app: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3ateE"]
    pub static std_ios_base_ate: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base6binaryE"]
    pub static std_ios_base_binary: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base2inE"]
    pub static std_ios_base_in: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3outE"]
    pub static std_ios_base_out: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base5truncE"]
    pub static std_ios_base_trunc: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base11__noreplaceE"]
    pub static std_ios_base___noreplace: std_ios_base_openmode;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3begE"]
    pub static std_ios_base_beg: std_ios_base_seekdir;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3curE"]
    pub static std_ios_base_cur: std_ios_base_seekdir;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base3endE"]
    pub static std_ios_base_end: std_ios_base_seekdir;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4Init11_S_refcountE"]
    pub static mut std_ios_base_Init__S_refcount: _Atomic_word;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_base4Init20_S_synced_with_stdioE"]
    pub static mut std_ios_base_Init__S_synced_with_stdio: bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt8ios_baseD1Ev"]
    pub fn std_ios_base_ios_base_destructor(this: *mut std_ios_base);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_streambuf {}
pub type std_basic_streambuf_char_type = u8;
pub type std_basic_streambuf_traits_type = u8;
pub type std_basic_streambuf_int_type = u8;
pub type std_basic_streambuf_pos_type = u8;
pub type std_basic_streambuf_off_type = u8;
pub type std_basic_streambuf___streambuf_type = u8;
extern "C" {
    #[link_name = "\u{1}_ZSt21__copy_streambufs_eofIcSt11char_traitsIcEEiPSt15basic_streambufIT_T0_ES6_Rb"]
    pub fn std___copy_streambufs_eof(
        __sbin: *mut [u32; 8usize],
        __sbout: *mut [u32; 8usize],
        __ineof: *mut bool,
    ) -> std_streamsize;
}
extern "C" {
    #[link_name = "\u{1}_ZSt21__copy_streambufs_eofIwSt11char_traitsIwEEiPSt15basic_streambufIT_T0_ES6_Rb"]
    pub fn std___copy_streambufs_eof1(
        __sbin: *mut [u32; 8usize],
        __sbout: *mut [u32; 8usize],
        __ineof: *mut bool,
    ) -> std_streamsize;
}
extern "C" {
    #[link_name = "\u{1}_ZSt14__convert_to_vIfEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct"]
    pub fn std___convert_to_v(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut f32,
        arg3: *mut std_ios_base_iostate,
        arg4: *const std___c_locale,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt14__convert_to_vIdEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct"]
    pub fn std___convert_to_v1(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut f64,
        arg3: *mut std_ios_base_iostate,
        arg4: *const std___c_locale,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt14__convert_to_vIeEvPKcRT_RSt12_Ios_IostateRKP15__locale_struct"]
    pub fn std___convert_to_v2(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut f64,
        arg3: *mut std_ios_base_iostate,
        arg4: *const std___c_locale,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10__num_base15_S_format_floatERKSt8ios_basePcc"]
    pub fn std___num_base__S_format_float(
        __io: *const std_ios_base,
        __fptr: *mut ::std::os::raw::c_char,
        __mod: ::std::os::raw::c_char,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt17__verify_groupingPKcjRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn std___verify_grouping(
        __grouping: *const ::std::os::raw::c_char,
        __grouping_size: usize,
        __grouping_tmp: *const std_string,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostream {}
pub type std_basic_ostream_char_type = u8;
pub type std_basic_ostream_int_type = u8;
pub type std_basic_ostream_pos_type = u8;
pub type std_basic_ostream_off_type = u8;
pub type std_basic_ostream_traits_type = u8;
pub type std_basic_ostream___streambuf_type = u8;
pub type std_basic_ostream___ios_type = u8;
pub type std_basic_ostream___ostream_type = u8;
pub type std_basic_ostream___num_put_type = u8;
pub type std_basic_ostream___ctype_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_ostream_sentry {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream {}
pub type std_basic_istream_char_type = u8;
pub type std_basic_istream_int_type = u8;
pub type std_basic_istream_pos_type = u8;
pub type std_basic_istream_off_type = u8;
pub type std_basic_istream_traits_type = u8;
pub type std_basic_istream___streambuf_type = u8;
pub type std_basic_istream___ios_type = u8;
pub type std_basic_istream___istream_type = u8;
pub type std_basic_istream___num_get_type = u8;
pub type std_basic_istream___ctype_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_istream_sentry {
    pub _address: u8,
}
pub type std_basic_istream_sentry_traits_type = u8;
pub type std_basic_istream_sentry___streambuf_type = u8;
pub type std_basic_istream_sentry___istream_type = u8;
pub type std_basic_istream_sentry___ctype_type = u8;
pub type std_basic_istream_sentry___int_type = u8;
extern "C" {
    #[link_name = "\u{1}_ZSt17__istream_extractRSiPci"]
    pub fn std___istream_extract(
        arg1: *mut std_istream,
        arg2: *mut ::std::os::raw::c_char,
        arg3: std_streamsize,
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std___time_get_state {
    pub _bindgen_opaque_blob: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_std___time_get_state() {
    assert_eq!(
        ::std::mem::size_of::<std___time_get_state>(),
        12usize,
        concat!("Size of: ", stringify!(std___time_get_state))
    );
    assert_eq!(
        ::std::mem::align_of::<std___time_get_state>(),
        4usize,
        concat!("Alignment of ", stringify!(std___time_get_state))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt16__time_get_state17_M_finalize_stateEP2tm"]
    pub fn std___time_get_state__M_finalize_state(this: *mut std___time_get_state, __tm: *mut tm);
}
impl std___time_get_state {
    #[inline]
    pub unsafe fn _M_finalize_state(&mut self, __tm: *mut tm) {
        std___time_get_state__M_finalize_state(self, __tm)
    }
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std_money_base_pattern {
    pub _bindgen_opaque_blob: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_std_money_base_pattern() {
    assert_eq!(
        ::std::mem::size_of::<std_money_base_pattern>(),
        4usize,
        concat!("Size of: ", stringify!(std_money_base_pattern))
    );
    assert_eq!(
        ::std::mem::align_of::<std_money_base_pattern>(),
        1usize,
        concat!("Alignment of ", stringify!(std_money_base_pattern))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10money_base20_S_construct_patternEccc"]
    pub fn std_money_base__S_construct_pattern(
        __precedes: ::std::os::raw::c_char,
        __space: ::std::os::raw::c_char,
        __posn: ::std::os::raw::c_char,
    ) -> std_money_base_pattern;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_default_delete {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_ptr {
    pub _address: u8,
}
pub type std_unique_ptr__DeleterConstraint = u8;
pub type std_unique_ptr_pointer = u8;
pub type std_unique_ptr_element_type = u8;
pub type std_unique_ptr_deleter_type = u8;
pub type std_unique_ptr___safe_conversion_up = u8;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_bad_weak_ptr {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std_bad_weak_ptr() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_weak_ptr>(),
        4usize,
        concat!("Size of: ", stringify!(std_bad_weak_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_weak_ptr>(),
        4usize,
        concat!("Alignment of ", stringify!(std_bad_weak_ptr))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt12bad_weak_ptr4whatEv"]
    pub fn std_bad_weak_ptr_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZNSt12bad_weak_ptrD1Ev"]
    pub fn std_bad_weak_ptr_bad_weak_ptr_destructor(this: *mut std_bad_weak_ptr);
}
extern "C" {
    #[link_name = "\u{1}_M_add_ref_lock_nothrow"]
    pub fn std__Sp_counted_base__M_add_ref_lock_nothrow(this: *mut u8) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_M_release"]
    pub fn std__Sp_counted_base__M_release(this: *mut u8);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_shared_ptr {
    pub _address: u8,
}
pub type std_shared_ptr__Constructible = u8;
pub type std_shared_ptr__Assignable = u8;
pub type std_shared_ptr_element_type = u8;
pub type std_shared_ptr_weak_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_weak_ptr {
    pub _address: u8,
}
pub type std_weak_ptr__Constructible = u8;
pub type std_weak_ptr__Assignable = u8;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_mutex {
    pub _bindgen_opaque_blob: [u32; 6usize],
}
pub type std_mutex_native_handle_type = u32;
#[test]
fn bindgen_test_layout_std_mutex() {
    assert_eq!(
        ::std::mem::size_of::<std_mutex>(),
        24usize,
        concat!("Size of: ", stringify!(std_mutex))
    );
    assert_eq!(
        ::std::mem::align_of::<std_mutex>(),
        4usize,
        concat!("Alignment of ", stringify!(std_mutex))
    );
}
#[repr(C)]
#[repr(align(1))]
#[derive(Debug, Copy, Clone)]
pub struct std__Sp_locker {
    pub _bindgen_opaque_blob: [u8; 2usize],
}
#[test]
fn bindgen_test_layout_std__Sp_locker() {
    assert_eq!(
        ::std::mem::size_of::<std__Sp_locker>(),
        2usize,
        concat!("Size of: ", stringify!(std__Sp_locker))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Sp_locker>(),
        1usize,
        concat!("Alignment of ", stringify!(std__Sp_locker))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerC1EPKv"]
    pub fn std__Sp_locker__Sp_locker(
        this: *mut std__Sp_locker,
        arg1: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerC1EPKvS1_"]
    pub fn std__Sp_locker__Sp_locker1(
        this: *mut std__Sp_locker,
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt10_Sp_lockerD1Ev"]
    pub fn std__Sp_locker__Sp_locker_destructor(this: *mut std__Sp_locker);
}
impl std__Sp_locker {
    #[inline]
    pub unsafe fn new(arg1: *const ::std::os::raw::c_void) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std__Sp_locker__Sp_locker(__bindgen_tmp.as_mut_ptr(), arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std__Sp_locker__Sp_locker1(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std__Sp_locker__Sp_locker_destructor(self)
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_bad_function_call {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std_bad_function_call() {
    assert_eq!(
        ::std::mem::size_of::<std_bad_function_call>(),
        4usize,
        concat!("Size of: ", stringify!(std_bad_function_call))
    );
    assert_eq!(
        ::std::mem::align_of::<std_bad_function_call>(),
        4usize,
        concat!("Alignment of ", stringify!(std_bad_function_call))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt17bad_function_callD1Ev"]
    pub fn std_bad_function_call_bad_function_call_destructor(this: *mut std_bad_function_call);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt17bad_function_call4whatEv"]
    pub fn std_bad_function_call_what(
        this: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_function {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector {
    pub _address: u8,
}
pub type std_vector__Base = u8;
pub type std_vector__Tp_alloc_type = u8;
pub type std_vector__Alloc_traits = u8;
pub type std_vector_value_type = u8;
pub type std_vector_pointer = u8;
pub type std_vector_const_pointer = u8;
pub type std_vector_reference = u8;
pub type std_vector_const_reference = u8;
pub type std_vector_iterator = u8;
pub type std_vector_const_iterator = u8;
pub type std_vector_const_reverse_iterator = u8;
pub type std_vector_reverse_iterator = u8;
pub type std_vector_size_type = u32;
pub type std_vector_difference_type = u32;
pub type std_vector_allocator_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_vector__Temporary_value {
    pub _address: u8,
}
#[repr(C)]
#[repr(align(1))]
#[derive(Copy, Clone)]
pub union std_vector__Temporary_value__Storage {
    pub _bindgen_opaque_blob: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_atomic {
    pub _address: u8,
}
pub type std_atomic_value_type = u8;
pub type std_atomic_bool = u8;
pub type std_atomic_int = u32;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_thread {
    pub _bindgen_opaque_blob: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_thread__State {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std_thread__State() {
    assert_eq!(
        ::std::mem::size_of::<std_thread__State>(),
        4usize,
        concat!("Size of: ", stringify!(std_thread__State))
    );
    assert_eq!(
        ::std::mem::align_of::<std_thread__State>(),
        4usize,
        concat!("Alignment of ", stringify!(std_thread__State))
    );
}
pub type std_thread__State_ptr = u32;
pub type std_thread_native_handle_type = u32;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std_thread_id {
    pub _bindgen_opaque_blob: u32,
}
#[test]
fn bindgen_test_layout_std_thread_id() {
    assert_eq!(
        ::std::mem::size_of::<std_thread_id>(),
        4usize,
        concat!("Size of: ", stringify!(std_thread_id))
    );
    assert_eq!(
        ::std::mem::align_of::<std_thread_id>(),
        4usize,
        concat!("Alignment of ", stringify!(std_thread_id))
    );
}
pub type std_thread___not_same = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_thread__State_impl {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_thread__Invoker {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_thread__Invoker___result {
    pub _address: u8,
}
pub type std_thread__Call_wrapper = u8;
#[test]
fn bindgen_test_layout_std_thread() {
    assert_eq!(
        ::std::mem::size_of::<std_thread>(),
        4usize,
        concat!("Size of: ", stringify!(std_thread))
    );
    assert_eq!(
        ::std::mem::align_of::<std_thread>(),
        4usize,
        concat!("Alignment of ", stringify!(std_thread))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6thread4joinEv"]
    pub fn std_thread_join(this: *mut std_thread);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6thread6detachEv"]
    pub fn std_thread_detach(this: *mut std_thread);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6thread20hardware_concurrencyEv"]
    pub fn std_thread_hardware_concurrency() -> ::std::os::raw::c_uint;
}
impl std_thread {
    #[inline]
    pub unsafe fn join(&mut self) {
        std_thread_join(self)
    }
    #[inline]
    pub unsafe fn detach(&mut self) {
        std_thread_detach(self)
    }
    #[inline]
    pub unsafe fn hardware_concurrency() -> ::std::os::raw::c_uint {
        std_thread_hardware_concurrency()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNSt6thread6_StateD1Ev"]
    pub fn std_thread__State__State_destructor(this: *mut std_thread__State);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_unique_lock {
    pub _address: u8,
}
pub type std_unique_lock_mutex_type = u8;
extern "C" {
    #[link_name = "\u{1}__once_proxy"]
    pub fn std___once_proxy();
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct std_condition_variable {
    pub _bindgen_opaque_blob: [u64; 6usize],
}
pub type std_condition_variable_steady_clock = u8;
pub type std_condition_variable_system_clock = u8;
pub type std_condition_variable___clock_t = u8;
pub type std_condition_variable_native_handle_type = u32;
#[test]
fn bindgen_test_layout_std_condition_variable() {
    assert_eq!(
        ::std::mem::size_of::<std_condition_variable>(),
        48usize,
        concat!("Size of: ", stringify!(std_condition_variable))
    );
    assert_eq!(
        ::std::mem::align_of::<std_condition_variable>(),
        8usize,
        concat!("Alignment of ", stringify!(std_condition_variable))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt18condition_variable10notify_oneEv"]
    pub fn std_condition_variable_notify_one(this: *mut std_condition_variable);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt18condition_variable10notify_allEv"]
    pub fn std_condition_variable_notify_all(this: *mut std_condition_variable);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt18condition_variable4waitERSt11unique_lockISt5mutexE"]
    pub fn std_condition_variable_wait(
        this: *mut std_condition_variable,
        __lock: *mut [u32; 2usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt18condition_variableC1Ev"]
    pub fn std_condition_variable_condition_variable(this: *mut std_condition_variable);
}
extern "C" {
    #[link_name = "\u{1}_ZNSt18condition_variableD1Ev"]
    pub fn std_condition_variable_condition_variable_destructor(this: *mut std_condition_variable);
}
impl std_condition_variable {
    #[inline]
    pub unsafe fn notify_one(&mut self) {
        std_condition_variable_notify_one(self)
    }
    #[inline]
    pub unsafe fn notify_all(&mut self) {
        std_condition_variable_notify_all(self)
    }
    #[inline]
    pub unsafe fn wait(&mut self, __lock: *mut [u32; 2usize]) {
        std_condition_variable_wait(self, __lock)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        std_condition_variable_condition_variable(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        std_condition_variable_condition_variable_destructor(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZSt25notify_all_at_thread_exitRSt18condition_variableSt11unique_lockISt5mutexE"]
    pub fn std_notify_all_at_thread_exit(arg1: *mut std_condition_variable, arg2: [u32; 2usize]);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_optional {
    pub _address: u8,
}
pub type std_optional__Base = u8;
pub type std_optional___not_self = u8;
pub type std_optional___not_tag = u8;
pub type std_optional__Requires = u8;
pub type std_optional_value_type = u8;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct std__Rb_tree_node_base {
    pub _bindgen_opaque_blob: [u32; 4usize],
}
pub type std__Rb_tree_node_base__Base_ptr = u32;
pub type std__Rb_tree_node_base__Const_Base_ptr = u32;
#[test]
fn bindgen_test_layout_std__Rb_tree_node_base() {
    assert_eq!(
        ::std::mem::size_of::<std__Rb_tree_node_base>(),
        16usize,
        concat!("Size of: ", stringify!(std__Rb_tree_node_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std__Rb_tree_node_base>(),
        4usize,
        concat!("Alignment of ", stringify!(std__Rb_tree_node_base))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt18_Rb_tree_incrementPSt18_Rb_tree_node_base"]
    pub fn std__Rb_tree_increment(__x: *mut std__Rb_tree_node_base) -> *mut std__Rb_tree_node_base;
}
extern "C" {
    #[link_name = "\u{1}_ZSt18_Rb_tree_incrementPKSt18_Rb_tree_node_base"]
    pub fn std__Rb_tree_increment1(
        __x: *const std__Rb_tree_node_base,
    ) -> *const std__Rb_tree_node_base;
}
extern "C" {
    #[link_name = "\u{1}_ZSt18_Rb_tree_decrementPSt18_Rb_tree_node_base"]
    pub fn std__Rb_tree_decrement(__x: *mut std__Rb_tree_node_base) -> *mut std__Rb_tree_node_base;
}
extern "C" {
    #[link_name = "\u{1}_ZSt18_Rb_tree_decrementPKSt18_Rb_tree_node_base"]
    pub fn std__Rb_tree_decrement1(
        __x: *const std__Rb_tree_node_base,
    ) -> *const std__Rb_tree_node_base;
}
extern "C" {
    #[link_name = "\u{1}_ZSt29_Rb_tree_insert_and_rebalancebPSt18_Rb_tree_node_baseS0_RS_"]
    pub fn std__Rb_tree_insert_and_rebalance(
        __insert_left: bool,
        __x: *mut std__Rb_tree_node_base,
        __p: *mut std__Rb_tree_node_base,
        __header: *mut std__Rb_tree_node_base,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZSt28_Rb_tree_rebalance_for_erasePSt18_Rb_tree_node_baseRS_"]
    pub fn std__Rb_tree_rebalance_for_erase(
        __z: *mut std__Rb_tree_node_base,
        __header: *mut std__Rb_tree_node_base,
    ) -> *mut std__Rb_tree_node_base;
}
extern "C" {
    #[link_name = "\u{1}_ZSt20_Rb_tree_black_countPKSt18_Rb_tree_node_baseS1_"]
    pub fn std__Rb_tree_black_count(
        __node: *const std__Rb_tree_node_base,
        __root: *const std__Rb_tree_node_base,
    ) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_variant {
    pub _address: u8,
}
pub type std_variant__Base = u8;
pub type std_variant__Default_ctor_enabler = u8;
pub type std_variant___to_type = u8;
pub type std_variant___accepted_type = u8;
pub type std_variant__Traits = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_variant___is_in_place_tag {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_set {
    pub _address: u8,
}
pub type std_set_key_type = u8;
pub type std_set_value_type = u8;
pub type std_set_key_compare = u8;
pub type std_set_value_compare = u8;
pub type std_set_allocator_type = u8;
pub type std_set__Key_alloc_type = u8;
pub type std_set__Rep_type = u8;
pub type std_set__Alloc_traits = u8;
pub type std_set_pointer = u8;
pub type std_set_const_pointer = u8;
pub type std_set_reference = u8;
pub type std_set_const_reference = u8;
pub type std_set_iterator = u8;
pub type std_set_const_iterator = u8;
pub type std_set_reverse_iterator = u8;
pub type std_set_const_reverse_iterator = u8;
pub type std_set_size_type = u8;
pub type std_set_difference_type = u8;
pub type std_set_node_type = u8;
pub type std_set_insert_return_type = u8;
#[doc = " Generic handle for all WPI handle-based interfaces.\n\n Handle data layout:\n - Bits 0-23:  Type-specific\n - Bits 24-30: Type\n - Bit 31:     Error"]
pub type WPI_Handle = ::std::os::raw::c_uint;
#[doc = " An event handle."]
pub type WPI_EventHandle = WPI_Handle;
#[repr(C)]
pub struct wpi_Sendable__bindgen_vtable {
    pub wpi_Sendable_InitSendable:
        unsafe extern "C" fn(this: *mut wpi_Sendable, builder: *mut wpi_SendableBuilder),
}
#[doc = " Interface for Sendable objects."]
#[repr(C)]
#[derive(Debug)]
pub struct wpi_Sendable {
    pub vtable_: *const wpi_Sendable__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_wpi_Sendable() {
    assert_eq!(
        ::std::mem::size_of::<wpi_Sendable>(),
        4usize,
        concat!("Size of: ", stringify!(wpi_Sendable))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_Sendable>(),
        4usize,
        concat!("Alignment of ", stringify!(wpi_Sendable))
    );
}
#[doc = " A helper class for use with objects that add themselves to SendableRegistry.\n It takes care of properly calling Move() and Remove() on move and\n destruction.  No action is taken if the object is copied.\n Use public inheritance with CRTP when using this class.\n @tparam CRTP derived class"]
#[repr(C)]
#[derive(Debug)]
pub struct wpi_SendableHelper {
    pub _address: u8,
}
pub type wpi_mutex = std_mutex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_log_DataLog {
    _unused: [u8; 0],
}
#[doc = " StringMapEntryBase - Shared base class of StringMapEntry instances."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_StringMapEntryBase {
    pub keyLength: usize,
}
#[test]
fn bindgen_test_layout_wpi_StringMapEntryBase() {
    const UNINIT: ::std::mem::MaybeUninit<wpi_StringMapEntryBase> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wpi_StringMapEntryBase>(),
        4usize,
        concat!("Size of: ", stringify!(wpi_StringMapEntryBase))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_StringMapEntryBase>(),
        4usize,
        concat!("Alignment of ", stringify!(wpi_StringMapEntryBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_StringMapEntryBase),
            "::",
            stringify!(keyLength)
        )
    );
}
#[doc = " StringMapEntryStorage - Holds the value in a StringMapEntry.\n\n Factored out into a separate base class to make it easier to specialize.\n This is primarily intended to support StringSet, which doesn't need a value\n stored at all."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_StringMapEntryStorage<ValueTy> {
    pub _base: wpi_StringMapEntryBase,
    pub second: ValueTy,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ValueTy>>,
}
#[doc = " StringMapEntry - This is used to represent one value that is inserted into\n a StringMap.  It contains the Value itself and the key: the string length\n and data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_StringMapEntry<ValueTy> {
    pub _base: wpi_StringMapEntryStorage<ValueTy>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ValueTy>>,
}
#[doc = " CRTP base class which implements the entire standard iterator facade\n in terms of a minimal subset of the interface.\n\n Use this when it is reasonable to implement most of the iterator\n functionality in terms of a core subset. If you need special behavior or\n there are performance implications for this, you may want to override the\n relevant members instead.\n\n Note, one abstraction that this does *not* provide is implementing\n subtraction in terms of addition by negating the difference. Negation isn't\n always information preserving, and I can see very reasonable iterator\n designs where this doesn't work well. It doesn't really force much added\n boilerplate anyways.\n\n Another abstraction that this doesn't provide is implementing increment in\n terms of addition of one. These aren't equivalent for all iterator\n categories, and respecting that adds a lot of complexity for little gain.\n\n Iterators are expected to have const rules analogous to pointers, with a\n single, const-qualified operator*() that returns ReferenceT. This matches\n the second and third pointers in the following example:\n \\code\n   int Value;\n   { int *I = &Value; }             // ReferenceT 'int&'\n   { int *const I = &Value; }       // ReferenceT 'int&'; const\n   { const int *I = &Value; }       // ReferenceT 'const int&'\n   { const int *const I = &Value; } // ReferenceT 'const int&'; const\n \\endcode\n If an iterator facade returns a handle to its own state, then T (and\n PointerT and ReferenceT) should usually be const-qualified. Otherwise, if\n clients are expected to modify the handle itself, the field can be declared\n mutable or use const_cast.\n\n Classes wishing to use `iterator_facade_base` should implement the following\n methods:\n\n Forward Iterators:\n   (All of the following methods)\n   - DerivedT &operator=(const DerivedT &R);\n   - bool operator==(const DerivedT &R) const;\n   - T &operator*() const;\n   - DerivedT &operator++();\n\n Bidirectional Iterators:\n   (All methods of forward iterators, plus the following)\n   - DerivedT &operator--();\n\n Random-access Iterators:\n   (All methods of bidirectional iterators excluding the following)\n   - DerivedT &operator++();\n   - DerivedT &operator--();\n   (and plus the following)\n   - bool operator<(const DerivedT &RHS) const;\n   - DifferenceTypeT operator-(const DerivedT &R) const;\n   - DerivedT &operator+=(DifferenceTypeT N);\n   - DerivedT &operator-=(DifferenceTypeT N);\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_iterator_facade_base {
    pub _address: u8,
}
pub type wpi_iterator_facade_base_iterator_category<IteratorCategoryT> = IteratorCategoryT;
pub type wpi_iterator_facade_base_value_type<T> = T;
pub type wpi_iterator_facade_base_difference_type<DifferenceTypeT> = DifferenceTypeT;
pub type wpi_iterator_facade_base_pointer<PointerT> = PointerT;
pub type wpi_iterator_facade_base_reference<ReferenceT> = ReferenceT;
pub const wpi_iterator_facade_base_IsRandomAccess: wpi_iterator_facade_base__bindgen_ty_1 = 0;
pub const wpi_iterator_facade_base_IsBidirectional: wpi_iterator_facade_base__bindgen_ty_1 = 0;
pub type wpi_iterator_facade_base__bindgen_ty_1 = i32;
#[doc = " A proxy object for computing a reference via indirecting a copy of an\n iterator. This is used in APIs which need to produce a reference via\n indirection but for which the iterator object might be a temporary. The\n proxy preserves the iterator internally and exposes the indirected\n reference via a conversion operator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_iterator_facade_base_ReferenceProxy<DerivedT> {
    pub I: DerivedT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<DerivedT>>,
}
#[doc = " A proxy object for computing a pointer via indirecting a copy of a\n reference. This is used in APIs which need to produce a pointer but for\n which the reference might be a temporary. The proxy preserves the\n reference internally and exposes the pointer via a arrow operator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_iterator_facade_base_PointerProxy<ReferenceT> {
    pub R: ReferenceT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ReferenceT>>,
}
#[doc = " CRTP base class providing obvious overloads for the core \\c\n Allocate() methods of LLVM-style allocators.\n\n This base class both documents the full public interface exposed by all\n LLVM-style allocators, and redirects all of the overloads to a single core\n set of methods which the derived class must define."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_AllocatorBase {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_MallocAllocator {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_wpi_MallocAllocator() {
    assert_eq!(
        ::std::mem::size_of::<wpi_MallocAllocator>(),
        1usize,
        concat!("Size of: ", stringify!(wpi_MallocAllocator))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_MallocAllocator>(),
        1usize,
        concat!("Alignment of ", stringify!(wpi_MallocAllocator))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_const_pointer_or_const_ref {
    pub _address: u8,
}
pub type wpi_const_pointer_or_const_ref_type<T> = *const T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_detail_DenseMapPair {
    pub _address: u8,
}
#[doc = "@brief general exception of the @ref json class\n\nThis class is an extension of `std::exception` objects with a member @a id for\nexception ids. It is used as the base class for all exceptions thrown by the\n@ref json class. This class can hence be used as \"wildcard\" to catch\nexceptions.\n\nSubclasses:\n- @ref parse_error for exceptions indicating a parse error\n- @ref invalid_iterator for exceptions indicating errors with iterators\n- @ref type_error for exceptions indicating executing a member function with\na wrong type\n- @ref out_of_range for exceptions indicating access out of the defined range\n- @ref other_error for exceptions indicating other library errors\n\n@internal\n@note To have nothrow-copy-constructible exceptions, we internally use\n`std::runtime_error` which can cope with arbitrary-length error messages.\nIntermediate strings are built with static functions and then passed to\nthe actual constructor.\n@endinternal\n\n@liveexample{The following code shows how arbitrary library exceptions can be\ncaught.,exception}\n\n@since version 3.0.0"]
#[repr(C)]
#[derive(Debug)]
pub struct wpi_detail_exception {
    pub _base: std_exception,
    #[doc = " the id of the exception"]
    pub id: ::std::os::raw::c_int,
    #[doc = " an exception object as storage for error messages"]
    pub m: std_runtime_error,
}
#[test]
fn bindgen_test_layout_wpi_detail_exception() {
    const UNINIT: ::std::mem::MaybeUninit<wpi_detail_exception> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wpi_detail_exception>(),
        16usize,
        concat!("Size of: ", stringify!(wpi_detail_exception))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_detail_exception>(),
        4usize,
        concat!("Alignment of ", stringify!(wpi_detail_exception))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_detail_exception),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_detail_exception),
            "::",
            stringify!(m)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi6detail9exceptionC1EiSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_detail_exception_exception(
        this: *mut wpi_detail_exception,
        id_: ::std::os::raw::c_int,
        what_arg: std_string_view,
    );
}
impl wpi_detail_exception {
    #[inline]
    pub unsafe fn new(id_: ::std::os::raw::c_int, what_arg: std_string_view) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        wpi_detail_exception_exception(__bindgen_tmp.as_mut_ptr(), id_, what_arg);
        __bindgen_tmp.assume_init()
    }
}
#[doc = "@brief exception indicating a parse error\n\nThis exception is thrown by the library when a parse error occurs. Parse errors\ncan occur during the deserialization of JSON text, CBOR, MessagePack, as well\nas when using JSON Patch.\n\nMember @a byte holds the byte index of the last read character in the input\nfile.\n\nExceptions have ids 1xx.\n\nname / id                      | example message | description\n------------------------------ | --------------- | -------------------------\njson.exception.parse_error.101 | parse error at 2: unexpected end of input; expected string literal | This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member @a byte indicates the error position.\njson.exception.parse_error.102 | parse error at 14: missing or wrong low surrogate | JSON uses the `\\uxxxx` format to describe Unicode characters. Code points above above 0xFFFF are split into two `\\uxxxx` entries (\"surrogate pairs\"). This error indicates that the surrogate pair is incomplete or contains an invalid code point.\njson.exception.parse_error.103 | parse error: code points above 0x10FFFF are invalid | Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid.\njson.exception.parse_error.104 | parse error: JSON patch must be an array of objects | [RFC 6902](https://tools.ietf.org/html/rfc6902) requires a JSON Patch document to be a JSON document that represents an array of objects.\njson.exception.parse_error.105 | parse error: operation must have string member 'op' | An operation of a JSON Patch document must contain exactly one \"op\" member, whose value indicates the operation to perform. Its value must be one of \"add\", \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are errors.\njson.exception.parse_error.106 | parse error: array index '01' must not begin with '0' | An array index in a JSON Pointer ([RFC 6901](https://tools.ietf.org/html/rfc6901)) may be `0` or any number without a leading `0`.\njson.exception.parse_error.107 | parse error: JSON pointer must be empty or begin with '/' - was: 'foo' | A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a `/` character.\njson.exception.parse_error.108 | parse error: escape character '~' must be followed with '0' or '1' | In a JSON Pointer, only `~0` and `~1` are valid escape sequences.\njson.exception.parse_error.109 | parse error: array index 'one' is not a number | A JSON Pointer array index must be a number.\njson.exception.parse_error.110 | parse error at 1: cannot read 2 bytes from vector | When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read.\njson.exception.parse_error.112 | parse error at 1: error reading CBOR; last byte: 0xF8 | Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read.\njson.exception.parse_error.113 | parse error at 2: expected a CBOR string; last byte: 0x98 | While parsing a map key, a value that is not a string has been read.\n\n@note For an input with n bytes, 1 is the index of the first character and n+1\nis the index of the terminating null byte or the end of file. This also\nholds true when reading a byte vector (CBOR or MessagePack).\n\n@liveexample{The following code shows how a `parse_error` exception can be\ncaught.,parse_error}\n\n@sa @ref exception for the base class of the library exceptions\n@sa @ref invalid_iterator for exceptions indicating errors with iterators\n@sa @ref type_error for exceptions indicating executing a member function with\na wrong type\n@sa @ref out_of_range for exceptions indicating access out of the defined range\n@sa @ref other_error for exceptions indicating other library errors\n\n@since version 3.0.0"]
#[repr(C)]
#[derive(Debug)]
pub struct wpi_detail_parse_error {
    pub _base: wpi_detail_exception,
    #[doc = "@brief byte index of the parse error\n\nThe byte index of the last read character in the input file.\n\n@note For an input with n bytes, 1 is the index of the first character and\nn+1 is the index of the terminating null byte or the end of file.\nThis also holds true when reading a byte vector (CBOR or MessagePack)."]
    pub byte: usize,
}
#[test]
fn bindgen_test_layout_wpi_detail_parse_error() {
    const UNINIT: ::std::mem::MaybeUninit<wpi_detail_parse_error> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wpi_detail_parse_error>(),
        20usize,
        concat!("Size of: ", stringify!(wpi_detail_parse_error))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_detail_parse_error>(),
        4usize,
        concat!("Alignment of ", stringify!(wpi_detail_parse_error))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).byte) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_detail_parse_error),
            "::",
            stringify!(byte)
        )
    );
}
extern "C" {
    #[doc = "@brief create a parse error exception\n@param[in] id_       the id of the exception\n@param[in] byte_     the byte index where the error occurred (or 0 if the\nposition cannot be determined)\n@param[in] what_arg  the explanatory string\n@return parse_error object"]
    #[link_name = "\u{1}_ZN3wpi6detail11parse_error6createEijSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_detail_parse_error_create(
        id_: ::std::os::raw::c_int,
        byte_: usize,
        what_arg: std_string_view,
    ) -> wpi_detail_parse_error;
}
impl wpi_detail_parse_error {
    #[inline]
    pub unsafe fn create(
        id_: ::std::os::raw::c_int,
        byte_: usize,
        what_arg: std_string_view,
    ) -> wpi_detail_parse_error {
        wpi_detail_parse_error_create(id_, byte_, what_arg)
    }
}
#[doc = "@brief exception indicating errors with iterators\n\nThis exception is thrown if iterators passed to a library function do not match\nthe expected semantics.\n\nExceptions have ids 2xx.\n\nname / id                           | example message | description\n----------------------------------- | --------------- | -------------------------\njson.exception.invalid_iterator.201 | iterators are not compatible | The iterators passed to constructor @ref json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.\njson.exception.invalid_iterator.202 | iterator does not fit current value | In an erase or insert function, the passed iterator @a pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion.\njson.exception.invalid_iterator.203 | iterators do not fit current value | Either iterator passed to function @ref erase(IteratorType first, IteratorType last) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from.\njson.exception.invalid_iterator.204 | iterators out of range | When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly (@ref begin(), @ref end()), because this is the only way the single stored value is expressed. All other ranges are invalid.\njson.exception.invalid_iterator.205 | iterator out of range | When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the @ref begin() iterator, because it is the only way to address the stored value. All other iterators are invalid.\njson.exception.invalid_iterator.206 | cannot construct with iterators from null | The iterators passed to constructor @ref json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range.\njson.exception.invalid_iterator.207 | cannot use key() for non-object iterators | The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key.\njson.exception.invalid_iterator.208 | cannot use operator[] for object iterators | The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.\njson.exception.invalid_iterator.209 | cannot use offsets with object iterators | The offset operators (+, -, +=, -=) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.\njson.exception.invalid_iterator.210 | iterators do not fit | The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.\njson.exception.invalid_iterator.211 | passed iterators may not belong to container | The iterator range passed to the insert function must not be a subrange of the container to insert to.\njson.exception.invalid_iterator.212 | cannot compare iterators of different containers | When two iterators are compared, they must belong to the same container.\njson.exception.invalid_iterator.213 | cannot compare order of object iterators | The order of object iterators cannot be compared, because JSON objects are unordered.\njson.exception.invalid_iterator.214 | cannot get value | Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to @ref begin().\n\n@liveexample{The following code shows how an `invalid_iterator` exception can be\ncaught.,invalid_iterator}\n\n@sa @ref exception for the base class of the library exceptions\n@sa @ref parse_error for exceptions indicating a parse error\n@sa @ref type_error for exceptions indicating executing a member function with\na wrong type\n@sa @ref out_of_range for exceptions indicating access out of the defined range\n@sa @ref other_error for exceptions indicating other library errors\n\n@since version 3.0.0"]
#[repr(C)]
#[derive(Debug)]
pub struct wpi_detail_invalid_iterator {
    pub _base: wpi_detail_exception,
}
#[test]
fn bindgen_test_layout_wpi_detail_invalid_iterator() {
    assert_eq!(
        ::std::mem::size_of::<wpi_detail_invalid_iterator>(),
        16usize,
        concat!("Size of: ", stringify!(wpi_detail_invalid_iterator))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_detail_invalid_iterator>(),
        4usize,
        concat!("Alignment of ", stringify!(wpi_detail_invalid_iterator))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi6detail16invalid_iterator6createEiSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_detail_invalid_iterator_create(
        id_: ::std::os::raw::c_int,
        what_arg: std_string_view,
    ) -> wpi_detail_invalid_iterator;
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi6detail16invalid_iterator6createEiSt17basic_string_viewIcSt11char_traitsIcEES5_"]
    pub fn wpi_detail_invalid_iterator_create1(
        id_: ::std::os::raw::c_int,
        what_arg: std_string_view,
        type_info: std_string_view,
    ) -> wpi_detail_invalid_iterator;
}
impl wpi_detail_invalid_iterator {
    #[inline]
    pub unsafe fn create(
        id_: ::std::os::raw::c_int,
        what_arg: std_string_view,
    ) -> wpi_detail_invalid_iterator {
        wpi_detail_invalid_iterator_create(id_, what_arg)
    }
    #[inline]
    pub unsafe fn create1(
        id_: ::std::os::raw::c_int,
        what_arg: std_string_view,
        type_info: std_string_view,
    ) -> wpi_detail_invalid_iterator {
        wpi_detail_invalid_iterator_create1(id_, what_arg, type_info)
    }
}
#[doc = "@brief exception indicating executing a member function with a wrong type\n\nThis exception is thrown in case of a type error; that is, a library function is\nexecuted on a JSON value whose type does not match the expected semantics.\n\nExceptions have ids 3xx.\n\nname / id                     | example message | description\n----------------------------- | --------------- | -------------------------\njson.exception.type_error.301 | cannot create object from initializer list | To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead.\njson.exception.type_error.302 | type must be object, but is array | During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types.\njson.exception.type_error.303 | incompatible ReferenceType for get_ref, actual type is object | To retrieve a reference to a value stored in a @ref json object with @ref get_ref, the type of the reference must match the value type. For instance, for a JSON array, the @a ReferenceType must be @ref array_t&.\njson.exception.type_error.304 | cannot use at() with string | The @ref at() member functions can only be executed for certain JSON types.\njson.exception.type_error.305 | cannot use operator[] with string | The @ref operator[] member functions can only be executed for certain JSON types.\njson.exception.type_error.306 | cannot use value() with string | The @ref value() member functions can only be executed for certain JSON types.\njson.exception.type_error.307 | cannot use erase() with string | The @ref erase() member functions can only be executed for certain JSON types.\njson.exception.type_error.308 | cannot use push_back() with string | The @ref push_back() and @ref operator+= member functions can only be executed for certain JSON types.\njson.exception.type_error.309 | cannot use insert() with | The @ref insert() member functions can only be executed for certain JSON types.\njson.exception.type_error.310 | cannot use swap() with number | The @ref swap() member functions can only be executed for certain JSON types.\njson.exception.type_error.311 | cannot use emplace_back() with string | The @ref emplace_back() member function can only be executed for certain JSON types.\njson.exception.type_error.312 | cannot use update() with string | The @ref update() member functions can only be executed for certain JSON types.\njson.exception.type_error.313 | invalid value to unflatten | The @ref unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined.\njson.exception.type_error.314 | only objects can be unflattened | The @ref unflatten function only works for an object whose keys are JSON Pointers.\njson.exception.type_error.315 | values in object must be primitive | The @ref unflatten function only works for an object whose keys are JSON Pointers and whose values are primitive.\njson.exception.type_error.316 | invalid UTF-8 byte at index 10: 0x7E | The @ref dump function only works with UTF-8 encoded strings; that is, if you assign a `std::string` to a JSON value, make sure it is UTF-8 encoded. |\n\n@liveexample{The following code shows how a `type_error` exception can be\ncaught.,type_error}\n\n@sa @ref exception for the base class of the library exceptions\n@sa @ref parse_error for exceptions indicating a parse error\n@sa @ref invalid_iterator for exceptions indicating errors with iterators\n@sa @ref out_of_range for exceptions indicating access out of the defined range\n@sa @ref other_error for exceptions indicating other library errors\n\n@since version 3.0.0"]
#[repr(C)]
#[derive(Debug)]
pub struct wpi_detail_type_error {
    pub _base: wpi_detail_exception,
}
#[test]
fn bindgen_test_layout_wpi_detail_type_error() {
    assert_eq!(
        ::std::mem::size_of::<wpi_detail_type_error>(),
        16usize,
        concat!("Size of: ", stringify!(wpi_detail_type_error))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_detail_type_error>(),
        4usize,
        concat!("Alignment of ", stringify!(wpi_detail_type_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi6detail10type_error6createEiSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_detail_type_error_create(
        id_: ::std::os::raw::c_int,
        what_arg: std_string_view,
    ) -> wpi_detail_type_error;
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi6detail10type_error6createEiSt17basic_string_viewIcSt11char_traitsIcEES5_"]
    pub fn wpi_detail_type_error_create1(
        id_: ::std::os::raw::c_int,
        what_arg: std_string_view,
        type_info: std_string_view,
    ) -> wpi_detail_type_error;
}
impl wpi_detail_type_error {
    #[inline]
    pub unsafe fn create(
        id_: ::std::os::raw::c_int,
        what_arg: std_string_view,
    ) -> wpi_detail_type_error {
        wpi_detail_type_error_create(id_, what_arg)
    }
    #[inline]
    pub unsafe fn create1(
        id_: ::std::os::raw::c_int,
        what_arg: std_string_view,
        type_info: std_string_view,
    ) -> wpi_detail_type_error {
        wpi_detail_type_error_create1(id_, what_arg, type_info)
    }
}
#[doc = "@brief exception indicating access out of the defined range\n\nThis exception is thrown in case a library function is called on an input\nparameter that exceeds the expected range, for instance in case of array\nindices or nonexisting object keys.\n\nExceptions have ids 4xx.\n\nname / id                       | example message | description\n------------------------------- | --------------- | -------------------------\njson.exception.out_of_range.401 | array index 3 is out of range | The provided array index @a i is larger than @a size-1.\njson.exception.out_of_range.402 | array index '-' (3) is out of range | The special array index `-` in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.\njson.exception.out_of_range.403 | key 'foo' not found | The provided key was not found in the JSON object.\njson.exception.out_of_range.404 | unresolved reference token 'foo' | A reference token in a JSON Pointer could not be resolved.\njson.exception.out_of_range.405 | JSON pointer has no parent | The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value.\njson.exception.out_of_range.406 | number overflow parsing '10E1000' | A parsed number could not be stored as without changing it to NaN or INF.\njson.exception.out_of_range.407 | number overflow serializing '9223372036854775808' | UBJSON only supports integers numbers up to 9223372036854775807. |\njson.exception.out_of_range.408 | excessive array size: 8658170730974374167 | The size (following `#`) of an UBJSON array or object exceeds the maximal capacity. |\n\n@liveexample{The following code shows how an `out_of_range` exception can be\ncaught.,out_of_range}\n\n@sa @ref exception for the base class of the library exceptions\n@sa @ref parse_error for exceptions indicating a parse error\n@sa @ref invalid_iterator for exceptions indicating errors with iterators\n@sa @ref type_error for exceptions indicating executing a member function with\na wrong type\n@sa @ref other_error for exceptions indicating other library errors\n\n@since version 3.0.0"]
#[repr(C)]
#[derive(Debug)]
pub struct wpi_detail_out_of_range {
    pub _base: wpi_detail_exception,
}
#[test]
fn bindgen_test_layout_wpi_detail_out_of_range() {
    assert_eq!(
        ::std::mem::size_of::<wpi_detail_out_of_range>(),
        16usize,
        concat!("Size of: ", stringify!(wpi_detail_out_of_range))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_detail_out_of_range>(),
        4usize,
        concat!("Alignment of ", stringify!(wpi_detail_out_of_range))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi6detail12out_of_range6createEiSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_detail_out_of_range_create(
        id_: ::std::os::raw::c_int,
        what_arg: std_string_view,
    ) -> wpi_detail_out_of_range;
}
impl wpi_detail_out_of_range {
    #[inline]
    pub unsafe fn create(
        id_: ::std::os::raw::c_int,
        what_arg: std_string_view,
    ) -> wpi_detail_out_of_range {
        wpi_detail_out_of_range_create(id_, what_arg)
    }
}
#[doc = "@brief exception indicating other library errors\n\nThis exception is thrown in case of errors that cannot be classified with the\nother exception types.\n\nExceptions have ids 5xx.\n\nname / id                      | example message | description\n------------------------------ | --------------- | -------------------------\njson.exception.other_error.501 | unsuccessful: {\"op\":\"test\",\"path\":\"/baz\", \"value\":\"bar\"} | A JSON Patch operation 'test' failed. The unsuccessful operation is also printed.\n\n@sa @ref exception for the base class of the library exceptions\n@sa @ref parse_error for exceptions indicating a parse error\n@sa @ref invalid_iterator for exceptions indicating errors with iterators\n@sa @ref type_error for exceptions indicating executing a member function with\na wrong type\n@sa @ref out_of_range for exceptions indicating access out of the defined range\n\n@liveexample{The following code shows how an `other_error` exception can be\ncaught.,other_error}\n\n@since version 3.0.0"]
#[repr(C)]
#[derive(Debug)]
pub struct wpi_detail_other_error {
    pub _base: wpi_detail_exception,
}
#[test]
fn bindgen_test_layout_wpi_detail_other_error() {
    assert_eq!(
        ::std::mem::size_of::<wpi_detail_other_error>(),
        16usize,
        concat!("Size of: ", stringify!(wpi_detail_other_error))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_detail_other_error>(),
        4usize,
        concat!("Alignment of ", stringify!(wpi_detail_other_error))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi6detail11other_error6createEiSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_detail_other_error_create(
        id_: ::std::os::raw::c_int,
        what_arg: std_string_view,
    ) -> wpi_detail_other_error;
}
impl wpi_detail_other_error {
    #[inline]
    pub unsafe fn create(
        id_: ::std::os::raw::c_int,
        what_arg: std_string_view,
    ) -> wpi_detail_other_error {
        wpi_detail_other_error_create(id_, what_arg)
    }
}
#[doc = "< null value"]
pub const wpi_detail_value_t_null: wpi_detail_value_t = 0;
#[doc = "< object (unordered set of name/value pairs)"]
pub const wpi_detail_value_t_object: wpi_detail_value_t = 1;
#[doc = "< array (ordered collection of values)"]
pub const wpi_detail_value_t_array: wpi_detail_value_t = 2;
#[doc = "< string value"]
pub const wpi_detail_value_t_string: wpi_detail_value_t = 3;
#[doc = "< boolean value"]
pub const wpi_detail_value_t_boolean: wpi_detail_value_t = 4;
#[doc = "< number value (signed integer)"]
pub const wpi_detail_value_t_number_integer: wpi_detail_value_t = 5;
#[doc = "< number value (unsigned integer)"]
pub const wpi_detail_value_t_number_unsigned: wpi_detail_value_t = 6;
#[doc = "< number value (floating-point)"]
pub const wpi_detail_value_t_number_float: wpi_detail_value_t = 7;
#[doc = "< discarded by the the parser callback function"]
pub const wpi_detail_value_t_discarded: wpi_detail_value_t = 8;
#[doc = "@brief the JSON type enumeration\n\nThis enumeration collects the different JSON types. It is internally used to\ndistinguish the stored values, and the functions @ref json::is_null(),\n@ref json::is_object(), @ref json::is_array(),\n@ref json::is_string(), @ref json::is_boolean(),\n@ref json::is_number() (with @ref json::is_number_integer(),\n@ref json::is_number_unsigned(), and @ref json::is_number_float()),\n@ref json::is_discarded(), @ref json::is_primitive(), and\n@ref json::is_structured() rely on it.\n\n@note There are three enumeration entries (number_integer, number_unsigned, and\nnumber_float), because the library distinguishes these three types for numbers:\nuint64_t is used for unsigned integers,\nint64_t is used for signed integers, and\ndouble is used for floating-point numbers or to\napproximate integers which do not fit in the limits of their respective type.\n\n@sa @ref json::json(const value_t value_type) -- create a JSON\nvalue with the default value for a given type\n\n@since version 1.0.0"]
pub type wpi_detail_value_t = ::std::os::raw::c_uchar;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_detail_primitive_iterator_t {
    #[doc = " iterator as signed integer type"]
    pub m_it: wpi_detail_primitive_iterator_t_difference_type,
}
pub type wpi_detail_primitive_iterator_t_difference_type = isize;
pub const wpi_detail_primitive_iterator_t_begin_value:
    wpi_detail_primitive_iterator_t_difference_type = 0;
pub const wpi_detail_primitive_iterator_t_end_value:
    wpi_detail_primitive_iterator_t_difference_type = 1;
#[test]
fn bindgen_test_layout_wpi_detail_primitive_iterator_t() {
    const UNINIT: ::std::mem::MaybeUninit<wpi_detail_primitive_iterator_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wpi_detail_primitive_iterator_t>(),
        4usize,
        concat!("Size of: ", stringify!(wpi_detail_primitive_iterator_t))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_detail_primitive_iterator_t>(),
        4usize,
        concat!("Alignment of ", stringify!(wpi_detail_primitive_iterator_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_it) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_detail_primitive_iterator_t),
            "::",
            stringify!(m_it)
        )
    );
}
#[doc = "@brief an iterator value\n\n@note This structure could easily be a union, but MSVC currently does not allow\nunions members with complex constructors, see https://github.com/nlohmann/json/pull/105."]
#[repr(C)]
pub struct wpi_detail_internal_iterator {
    #[doc = " iterator for JSON objects"]
    pub object_iterator: [u8; 0usize],
    #[doc = " iterator for JSON arrays"]
    pub array_iterator: [u8; 0usize],
    #[doc = " generic iterator for all other types"]
    pub primitive_iterator: wpi_detail_primitive_iterator_t,
}
#[doc = "@brief a template for a bidirectional iterator for the @ref json class\n\nThis class implements a both iterators (iterator and const_iterator) for the\n@ref json class.\n\n@note An iterator is called *initialized* when a pointer to a JSON value has\nbeen set (e.g., by a constructor or a copy assignment). If the iterator is\ndefault-constructed, it is *uninitialized* and most methods are undefined.\nThe library uses assertions to detect calls on uninitialized iterators.**\n\n@requirement The class satisfies the following concept requirements:\n-\n[BidirectionalIterator](http://en.cppreference.com/w/cpp/concept/BidirectionalIterator):\nThe iterator that can be moved can be moved in both directions (i.e.\nincremented and decremented).\n\n@since version 1.0.0, simplified in version 2.0.9, change to bidirectional\niterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)"]
#[repr(C)]
pub struct wpi_detail_iter_impl {
    #[doc = " associated JSON instance"]
    pub m_object: wpi_detail_iter_impl_pointer,
    #[doc = " the actual iterator of the associated instance"]
    pub m_it: wpi_detail_internal_iterator,
}
pub type wpi_detail_iter_impl_object_t = [u8; 0usize];
pub type wpi_detail_iter_impl_array_t = [u8; 0usize];
#[doc = " The std::iterator class template (used as a base class to provide typedefs) is deprecated in C++17.\n The C++ Standard has never required user-defined iterators to derive from std::iterator.\n A user-defined iterator should provide publicly accessible typedefs named\n iterator_category, value_type, difference_type, pointer, and reference.\n Note that value_type is required to be non-const, even for constant iterators."]
pub type wpi_detail_iter_impl_iterator_category = std_bidirectional_iterator_tag;
#[doc = " the type of the values when the iterator is dereferenced"]
pub type wpi_detail_iter_impl_value_type = [u8; 0usize];
#[doc = " a type to represent differences between iterators"]
pub type wpi_detail_iter_impl_difference_type = [u8; 0usize];
#[doc = " defines a pointer to the type iterated over (value_type)"]
pub type wpi_detail_iter_impl_pointer = [u8; 0usize];
#[doc = " defines a reference to the type iterated over (value_type)"]
pub type wpi_detail_iter_impl_reference = [u8; 0usize];
#[doc = " proxy class for the items() function"]
#[repr(C)]
pub struct wpi_detail_iteration_proxy {
    #[doc = " the container to iterate"]
    pub container: [u8; 0usize],
}
#[doc = " helper class for iteration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_detail_iteration_proxy_iteration_proxy_internal<IteratorType> {
    #[doc = " the iterator"]
    pub anchor: IteratorType,
    #[doc = " an index for arrays (used to create key names)"]
    pub array_index: usize,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<IteratorType>>,
}
#[doc = "@brief a template for a reverse iterator class\n\n@tparam Base the base iterator type to reverse. Valid types are @ref\niterator (to create @ref reverse_iterator) and @ref const_iterator (to\ncreate @ref const_reverse_iterator).\n\n@requirement The class satisfies the following concept requirements:\n-\n[BidirectionalIterator](http://en.cppreference.com/w/cpp/concept/BidirectionalIterator):\nThe iterator that can be moved can be moved in both directions (i.e.\nincremented and decremented).\n- [OutputIterator](http://en.cppreference.com/w/cpp/concept/OutputIterator):\nIt is possible to write to the pointed-to element (only if @a Base is\n@ref iterator).\n\n@since version 1.0.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_detail_json_reverse_iterator {
    pub _address: u8,
}
pub type wpi_detail_json_reverse_iterator_difference_type = isize;
#[doc = " shortcut to the reverse iterator adapter"]
pub type wpi_detail_json_reverse_iterator_base_iterator = u8;
#[doc = " the reference type for the pointed-to element"]
pub type wpi_detail_json_reverse_iterator_reference = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_detail_json_ref<BasicJsonType> {
    pub owned_value: wpi_detail_json_ref_value_type<BasicJsonType>,
    pub value_ref: *mut wpi_detail_json_ref_value_type<BasicJsonType>,
    pub is_rvalue: bool,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BasicJsonType>>,
}
pub type wpi_detail_json_ref_value_type<BasicJsonType> = BasicJsonType;
pub type wpi_SmallVectorTemplateBase_ValueParamT<T> = *const T;
#[doc = " This class consists of common code factored out of the SmallVector class to\n reduce code duplication based on the SmallVector 'N' template parameter."]
#[repr(C)]
#[derive(Debug)]
pub struct wpi_SmallVectorImpl {
    pub _address: u8,
}
#[doc = " SmallVectorTemplateBase<TriviallyCopyable = false> - This is where we put\n method implementations that are designed to work with non-trivial T's.\n\n We approximate is_trivially_copyable with trivial move/copy construction and\n trivial destruction. While the standard doesn't specify that you're allowed\n copy these types with memcpy, there is no way for the type to observe this.\n This catches the important case of std::pair<POD, POD>, which is not\n trivially assignable."]
pub type wpi_SmallVectorImpl_SuperClass = u8;
pub type wpi_SmallVectorImpl_iterator = wpi_SmallVectorImpl_SuperClass;
pub type wpi_SmallVectorImpl_const_iterator = wpi_SmallVectorImpl_SuperClass;
pub type wpi_SmallVectorImpl_reference = wpi_SmallVectorImpl_SuperClass;
pub type wpi_SmallVectorImpl_size_type = wpi_SmallVectorImpl_SuperClass;
pub type wpi_SmallVectorImpl_ValueParamT = wpi_SmallVectorImpl_SuperClass;
#[doc = " StringMapImpl - This is the base class of StringMap that is shared among\n all of its instantiations."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_StringMapImpl {
    pub TheTable: *mut *mut wpi_StringMapEntryBase,
    pub NumBuckets: ::std::os::raw::c_uint,
    pub NumItems: ::std::os::raw::c_uint,
    pub NumTombstones: ::std::os::raw::c_uint,
    pub ItemSize: ::std::os::raw::c_uint,
}
pub const wpi_StringMapImpl_TombstoneIntVal: usize = 4294967292;
#[test]
fn bindgen_test_layout_wpi_StringMapImpl() {
    const UNINIT: ::std::mem::MaybeUninit<wpi_StringMapImpl> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wpi_StringMapImpl>(),
        20usize,
        concat!("Size of: ", stringify!(wpi_StringMapImpl))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_StringMapImpl>(),
        4usize,
        concat!("Alignment of ", stringify!(wpi_StringMapImpl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TheTable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_StringMapImpl),
            "::",
            stringify!(TheTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumBuckets) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_StringMapImpl),
            "::",
            stringify!(NumBuckets)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumItems) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_StringMapImpl),
            "::",
            stringify!(NumItems)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NumTombstones) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_StringMapImpl),
            "::",
            stringify!(NumTombstones)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ItemSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_StringMapImpl),
            "::",
            stringify!(ItemSize)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi13StringMapImpl11RehashTableEj"]
    pub fn wpi_StringMapImpl_RehashTable(
        this: *mut wpi_StringMapImpl,
        BucketNo: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " LookupBucketFor - Look up the bucket that the specified string should end\n up in.  If it already exists as a key in the map, the Item pointer for the\n specified bucket will be non-null.  Otherwise, it will be null.  In either\n case, the FullHashValue field of the bucket will be set to the hash value\n of the string."]
    #[link_name = "\u{1}_ZN3wpi13StringMapImpl15LookupBucketForESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_StringMapImpl_LookupBucketFor(
        this: *mut wpi_StringMapImpl,
        Key: std_string_view,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " FindKey - Look up the bucket that contains the specified key. If it exists\n in the map, return the bucket number of the key.  Otherwise return -1.\n This does not modify the map."]
    #[link_name = "\u{1}_ZNK3wpi13StringMapImpl7FindKeyESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_StringMapImpl_FindKey(
        this: *const wpi_StringMapImpl,
        Key: std_string_view,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " RemoveKey - Remove the specified StringMapEntry from the table, but do not\n delete it.  This aborts if the value isn't in the table."]
    #[link_name = "\u{1}_ZN3wpi13StringMapImpl9RemoveKeyEPNS_18StringMapEntryBaseE"]
    pub fn wpi_StringMapImpl_RemoveKey(
        this: *mut wpi_StringMapImpl,
        V: *mut wpi_StringMapEntryBase,
    );
}
extern "C" {
    #[doc = " RemoveKey - Remove the StringMapEntry for the specified key from the\n table, returning it.  If the key is not in the table, this returns null."]
    #[link_name = "\u{1}_ZN3wpi13StringMapImpl9RemoveKeyESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_StringMapImpl_RemoveKey1(
        this: *mut wpi_StringMapImpl,
        Key: std_string_view,
    ) -> *mut wpi_StringMapEntryBase;
}
extern "C" {
    #[doc = " Allocate the table with the specified number of buckets and otherwise\n setup the map as empty."]
    #[link_name = "\u{1}_ZN3wpi13StringMapImpl4initEj"]
    pub fn wpi_StringMapImpl_init(this: *mut wpi_StringMapImpl, Size: ::std::os::raw::c_uint);
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi13StringMapImplC1Ejj"]
    pub fn wpi_StringMapImpl_StringMapImpl(
        this: *mut wpi_StringMapImpl,
        InitSize: ::std::os::raw::c_uint,
        ItemSize: ::std::os::raw::c_uint,
    );
}
impl wpi_StringMapImpl {
    #[inline]
    pub unsafe fn RehashTable(
        &mut self,
        BucketNo: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        wpi_StringMapImpl_RehashTable(self, BucketNo)
    }
    #[inline]
    pub unsafe fn LookupBucketFor(&mut self, Key: std_string_view) -> ::std::os::raw::c_uint {
        wpi_StringMapImpl_LookupBucketFor(self, Key)
    }
    #[inline]
    pub unsafe fn FindKey(&self, Key: std_string_view) -> ::std::os::raw::c_int {
        wpi_StringMapImpl_FindKey(self, Key)
    }
    #[inline]
    pub unsafe fn RemoveKey(&mut self, V: *mut wpi_StringMapEntryBase) {
        wpi_StringMapImpl_RemoveKey(self, V)
    }
    #[inline]
    pub unsafe fn RemoveKey1(&mut self, Key: std_string_view) -> *mut wpi_StringMapEntryBase {
        wpi_StringMapImpl_RemoveKey1(self, Key)
    }
    #[inline]
    pub unsafe fn init(&mut self, Size: ::std::os::raw::c_uint) {
        wpi_StringMapImpl_init(self, Size)
    }
    #[inline]
    pub unsafe fn new(InitSize: ::std::os::raw::c_uint, ItemSize: ::std::os::raw::c_uint) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        wpi_StringMapImpl_StringMapImpl(__bindgen_tmp.as_mut_ptr(), InitSize, ItemSize);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " StringMap - This is an unconventional map that is specialized for handling\n keys that are \"strings\", which are basically ranges of bytes. This does some\n funky memory allocation and hashing things to make it extremely efficient,\n storing the string data *after* the value in the map."]
#[repr(C)]
#[derive(Debug)]
pub struct wpi_StringMap<AllocatorTy> {
    pub _base: wpi_StringMapImpl,
    pub Allocator: AllocatorTy,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<AllocatorTy>>,
}
#[doc = " StringMapEntry - This is used to represent one value that is inserted into\n a StringMap.  It contains the Value itself and the key: the string length\n and data."]
pub type wpi_StringMap_MapEntryTy<ValueTy> = wpi_StringMapEntry<ValueTy>;
pub type wpi_StringMap_key_type = *const ::std::os::raw::c_char;
pub type wpi_StringMap_mapped_type<ValueTy> = ValueTy;
#[doc = " StringMapEntry - This is used to represent one value that is inserted into\n a StringMap.  It contains the Value itself and the key: the string length\n and data."]
pub type wpi_StringMap_value_type<ValueTy> = wpi_StringMapEntry<ValueTy>;
pub type wpi_StringMap_size_type = usize;
pub type wpi_StringMap_const_iterator = wpi_StringMapConstIterator;
pub type wpi_StringMap_iterator = wpi_StringMapIterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_StringMapIterBase {
    pub Ptr: *mut *mut wpi_StringMapEntryBase,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_StringMapConstIterator {
    pub _base: wpi_StringMapIterBase,
}
pub type wpi_StringMapConstIterator_base = wpi_StringMapIterBase;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_StringMapIterator {
    pub _base: wpi_StringMapIterBase,
}
pub type wpi_StringMapIterator_base = wpi_StringMapIterBase;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_raw_ostream {
    _unused: [u8; 0],
}
#[doc = " An information struct used to provide DenseMap with the various necessary\n components for a given value type `T`. `Enable` is an optional additional\n parameter that is used to support SFINAE (generally using std::enable_if_t)\n in derived DenseMapInfo specializations; in non-SFINAE use cases this should\n just be `void`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_DenseMapInfo {
    pub _address: u8,
}
#[doc = " A base class for data structure classes wishing to make iterators\n (\"handles\") pointing into themselves fail-fast.  When building without\n asserts, this class is empty and does nothing.\n\n DebugEpochBase does not by itself track handles pointing into itself.  The\n expectation is that routines touching the handles will poll on\n isHandleInSync at appropriate points to assert that the handle they're using\n is still valid.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct wpi_DebugEpochBase {
    pub Epoch: u64,
}
#[doc = " A base class for iterator classes (\"handles\") that wish to poll for\n iterator invalidating modifications in the underlying data structure.\n When LLVM is built without asserts, this class is empty and does nothing.\n\n HandleBase does not track the parent data structure by itself.  It expects\n the routines modifying the data structure to call incrementEpoch when they\n make an iterator-invalidating modification.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_DebugEpochBase_HandleBase {
    pub EpochAddress: *const u64,
    pub EpochAtCreation: u64,
}
#[test]
fn bindgen_test_layout_wpi_DebugEpochBase_HandleBase() {
    const UNINIT: ::std::mem::MaybeUninit<wpi_DebugEpochBase_HandleBase> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wpi_DebugEpochBase_HandleBase>(),
        16usize,
        concat!("Size of: ", stringify!(wpi_DebugEpochBase_HandleBase))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_DebugEpochBase_HandleBase>(),
        8usize,
        concat!("Alignment of ", stringify!(wpi_DebugEpochBase_HandleBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EpochAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_DebugEpochBase_HandleBase),
            "::",
            stringify!(EpochAddress)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EpochAtCreation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_DebugEpochBase_HandleBase),
            "::",
            stringify!(EpochAtCreation)
        )
    );
}
#[test]
fn bindgen_test_layout_wpi_DebugEpochBase() {
    const UNINIT: ::std::mem::MaybeUninit<wpi_DebugEpochBase> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wpi_DebugEpochBase>(),
        8usize,
        concat!("Size of: ", stringify!(wpi_DebugEpochBase))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_DebugEpochBase>(),
        8usize,
        concat!("Alignment of ", stringify!(wpi_DebugEpochBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Epoch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_DebugEpochBase),
            "::",
            stringify!(Epoch)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct wpi_DenseMapBase {
    pub _base: wpi_DebugEpochBase,
}
pub type wpi_DenseMapBase_const_arg_type_t = wpi_const_pointer_or_const_ref;
pub type wpi_DenseMapBase_size_type = ::std::os::raw::c_uint;
pub type wpi_DenseMapBase_key_type<KeyT> = KeyT;
pub type wpi_DenseMapBase_mapped_type<ValueT> = ValueT;
pub type wpi_DenseMapBase_value_type<BucketT> = BucketT;
pub type wpi_DenseMapBase_iterator = u8;
pub type wpi_DenseMapBase_const_iterator = u8;
#[repr(C)]
#[derive(Debug)]
pub struct wpi_DenseMap<BucketT> {
    pub _base: wpi_DenseMapBase,
    pub Buckets: *mut BucketT,
    pub NumEntries: ::std::os::raw::c_uint,
    pub NumTombstones: ::std::os::raw::c_uint,
    pub NumBuckets: ::std::os::raw::c_uint,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<BucketT>>,
}
pub type wpi_DenseMap_BaseT = wpi_DenseMapBase;
pub type wpi_DenseMapIterator_difference_type = isize;
pub type wpi_DenseMapIterator_value_type = u8;
pub type wpi_DenseMapIterator_pointer = *mut wpi_DenseMapIterator_value_type;
pub type wpi_DenseMapIterator_reference = *mut wpi_DenseMapIterator_value_type;
pub type wpi_DenseMapIterator_iterator_category = std_forward_iterator_tag;
#[doc = " This class is the same as std::priority_queue with two changes:\n\n 1. Adds a remove() function for removing all elements from the priority queue\n    that match the given value.\n 2. Replaces \"void pop()\" with \"T pop()\" so the element can be moved from the\n    queue directly instead of copied from top()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_priority_queue<Sequence, Compare> {
    pub c: Sequence,
    pub comp: Compare,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Sequence>>,
    pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Compare>>,
}
pub type wpi_priority_queue_value_type = [u8; 0usize];
pub type wpi_priority_queue_reference = [u8; 0usize];
pub type wpi_priority_queue_const_reference = [u8; 0usize];
pub type wpi_priority_queue_size_type = [u8; 0usize];
pub type wpi_priority_queue_container_type<Sequence> = Sequence;
pub type wpi_priority_queue_value_compare<Compare> = Compare;
#[doc = " unique_function is a type-erasing functor similar to std::function.\n\n It can hold move-only function objects, like lambdas capturing unique_ptrs.\n Accordingly, it is movable but not copyable.\n\n It supports const-qualification:\n - unique_function<int() const> has a const operator().\n   It can only hold functions which themselves have a const operator().\n - unique_function<int()> has a non-const operator().\n   It can hold functions with a non-const operator(), like mutable lambdas."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_unique_function {
    pub _address: u8,
}
#[repr(C)]
pub struct wpi_SendableBuilder__bindgen_vtable {
    pub wpi_SendableBuilder_SetSmartDashboardType:
        unsafe extern "C" fn(this: *mut wpi_SendableBuilder, type_: std_string_view),
    pub wpi_SendableBuilder_SetActuator:
        unsafe extern "C" fn(this: *mut wpi_SendableBuilder, value: bool),
    pub wpi_SendableBuilder_SetSafeState:
        unsafe extern "C" fn(this: *mut wpi_SendableBuilder, func: [u32; 4usize]),
    pub wpi_SendableBuilder_AddBooleanProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddIntegerProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddFloatProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddDoubleProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddStringProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddBooleanArrayProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddIntegerArrayProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddFloatArrayProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddDoubleArrayProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddStringArrayProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddRawProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        typeString: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddSmallStringProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddSmallBooleanArrayProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddSmallIntegerArrayProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddSmallFloatArrayProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddSmallDoubleArrayProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddSmallStringArrayProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_AddSmallRawProperty: unsafe extern "C" fn(
        this: *mut wpi_SendableBuilder,
        key: std_string_view,
        typeString: std_string_view,
        getter: u8,
        setter: u8,
    ),
    pub wpi_SendableBuilder_GetBackendKind:
        unsafe extern "C" fn(this: *const wpi_SendableBuilder) -> wpi_SendableBuilder_BackendKind,
    pub wpi_SendableBuilder_IsPublished:
        unsafe extern "C" fn(this: *const wpi_SendableBuilder) -> bool,
    pub wpi_SendableBuilder_Update: unsafe extern "C" fn(this: *mut wpi_SendableBuilder),
    pub wpi_SendableBuilder_ClearProperties: unsafe extern "C" fn(this: *mut wpi_SendableBuilder),
}
#[repr(C)]
#[derive(Debug)]
pub struct wpi_SendableBuilder {
    pub vtable_: *const wpi_SendableBuilder__bindgen_vtable,
}
pub const wpi_SendableBuilder_BackendKind_kUnknown: wpi_SendableBuilder_BackendKind = 0;
pub const wpi_SendableBuilder_BackendKind_kNetworkTables: wpi_SendableBuilder_BackendKind = 1;
#[doc = " The backend kinds used for the sendable builder."]
pub type wpi_SendableBuilder_BackendKind = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_wpi_SendableBuilder() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableBuilder>(),
        4usize,
        concat!("Size of: ", stringify!(wpi_SendableBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableBuilder>(),
        4usize,
        concat!("Alignment of ", stringify!(wpi_SendableBuilder))
    );
}
pub type wpi_SmallSetIterator_SetIterTy = u8;
pub type wpi_SmallSetIterator_VecIterTy = u8;
#[doc = " SmallSetIterator - This class implements a const_iterator for SmallSet by\n delegating to the underlying SmallVector or Set iterators."]
pub type wpi_SmallSetIterator_SelfTy = u8;
#[doc = " Iterators to the parts of the SmallSet containing the data. They are set\n depending on isSmall."]
#[repr(C)]
#[repr(align(1))]
pub struct wpi_SmallSetIterator__bindgen_ty_1 {
    pub SetIter: __BindgenUnionField<wpi_SmallSetIterator_SetIterTy>,
    pub VecIter: __BindgenUnionField<wpi_SmallSetIterator_VecIterTy>,
    pub bindgen_union_field: [u8; 0usize],
}
pub type wpi_SmallSet_VIterator = u8;
pub type wpi_SmallSet_mutable_iterator = u8;
pub type wpi_SmallSet_size_type = usize;
#[doc = " SmallSetIterator - This class implements a const_iterator for SmallSet by\n delegating to the underlying SmallVector or Set iterators."]
pub type wpi_SmallSet_const_iterator = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_raw_istream {
    _unused: [u8; 0],
}
#[doc = "@brief default JSONSerializer template argument\n\nThis serializer ignores the template arguments and uses ADL\n([argument-dependent lookup](http://en.cppreference.com/w/cpp/language/adl))\nfor serialization."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_adl_serializer {
    pub _address: u8,
}
#[doc = "@brief a class to store JSON values\n\n@requirement The class satisfies the following concept requirements:\n- Basic\n- [DefaultConstructible](http://en.cppreference.com/w/cpp/concept/DefaultConstructible):\nJSON values can be default constructed. The result will be a JSON null\nvalue.\n- [MoveConstructible](http://en.cppreference.com/w/cpp/concept/MoveConstructible):\nA JSON value can be constructed from an rvalue argument.\n- [CopyConstructible](http://en.cppreference.com/w/cpp/concept/CopyConstructible):\nA JSON value can be copy-constructed from an lvalue expression.\n- [MoveAssignable](http://en.cppreference.com/w/cpp/concept/MoveAssignable):\nA JSON value van be assigned from an rvalue argument.\n- [CopyAssignable](http://en.cppreference.com/w/cpp/concept/CopyAssignable):\nA JSON value can be copy-assigned from an lvalue expression.\n- [Destructible](http://en.cppreference.com/w/cpp/concept/Destructible):\nJSON values can be destructed.\n- Layout\n- [StandardLayoutType](http://en.cppreference.com/w/cpp/concept/StandardLayoutType):\nJSON values have\n[standard layout](http://en.cppreference.com/w/cpp/language/data_members#Standard_layout):\nAll non-static data members are private and standard layout types, the\nclass has no virtual functions or (virtual) base classes.\n- Library-wide\n- [EqualityComparable](http://en.cppreference.com/w/cpp/concept/EqualityComparable):\nJSON values can be compared with `==`, see @ref\noperator==(const_reference,const_reference).\n- [LessThanComparable](http://en.cppreference.com/w/cpp/concept/LessThanComparable):\nJSON values can be compared with `<`, see @ref\noperator<(const_reference,const_reference).\n- [Swappable](http://en.cppreference.com/w/cpp/concept/Swappable):\nAny JSON lvalue or rvalue of can be swapped with any lvalue or rvalue of\nother compatible types, using unqualified function call @ref swap().\n- [NullablePointer](http://en.cppreference.com/w/cpp/concept/NullablePointer):\nJSON values can be compared against `std::nullptr_t` objects which are used\nto model the `null` value.\n- Container\n- [Container](http://en.cppreference.com/w/cpp/concept/Container):\nJSON values can be used like STL containers and provide iterator access.\n- [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer);\nJSON values can be used like STL containers and provide reverse iterator\naccess.\n\n@invariant The member variables @a m_value and @a m_type have the following\nrelationship:\n- If `m_type == value_t::object`, then `m_value.object != nullptr`.\n- If `m_type == value_t::array`, then `m_value.array != nullptr`.\n- If `m_type == value_t::string`, then `m_value.string != nullptr`.\nThe invariants are checked by member function assert_invariant().\n\n@internal\n@note ObjectType trick from http://stackoverflow.com/a/9860911\n@endinternal\n\n@see [RFC 7159: The JavaScript Object Notation (JSON) Data Interchange\nFormat](http://rfc7159.net/rfc7159)\n\n@since version 1.0.0\n\n@nosubgrouping"]
#[repr(C)]
pub struct wpi_json {
    #[doc = " the type of the current element"]
    pub m_type: wpi_json_value_t,
    #[doc = " the value of the current element"]
    pub m_value: wpi_json_json_value,
}
pub type wpi_json_primitive_iterator_t = wpi_detail_primitive_iterator_t;
pub type wpi_json_internal_iterator = wpi_detail_internal_iterator;
pub type wpi_json_iter_impl = wpi_detail_iter_impl;
pub type wpi_json_iteration_proxy = wpi_detail_iteration_proxy;
pub type wpi_json_json_reverse_iterator = wpi_detail_json_reverse_iterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_json_binary_reader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_json_binary_writer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_json_lexer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_json_parser {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wpi_json_serializer {
    _unused: [u8; 0],
}
#[doc = "@brief the JSON type enumeration\n\nThis enumeration collects the different JSON types. It is internally used to\ndistinguish the stored values, and the functions @ref json::is_null(),\n@ref json::is_object(), @ref json::is_array(),\n@ref json::is_string(), @ref json::is_boolean(),\n@ref json::is_number() (with @ref json::is_number_integer(),\n@ref json::is_number_unsigned(), and @ref json::is_number_float()),\n@ref json::is_discarded(), @ref json::is_primitive(), and\n@ref json::is_structured() rely on it.\n\n@note There are three enumeration entries (number_integer, number_unsigned, and\nnumber_float), because the library distinguishes these three types for numbers:\nuint64_t is used for unsigned integers,\nint64_t is used for signed integers, and\ndouble is used for floating-point numbers or to\napproximate integers which do not fit in the limits of their respective type.\n\n@sa @ref json::json(const value_t value_type) -- create a JSON\nvalue with the default value for a given type\n\n@since version 1.0.0"]
pub use self::wpi_detail_value_t as wpi_json_value_t;
#[doc = "@brief JSON Pointer\n\nA JSON pointer defines a string syntax for identifying a specific value\nwithin a JSON document. It can be used with functions `at` and\n`operator[]`. Furthermore, JSON pointers are the base for JSON patches.\n\n@sa [RFC 6901](https://tools.ietf.org/html/rfc6901)\n\n@since version 2.0.0"]
pub type wpi_json_json_pointer = [u32; 3usize];
pub type wpi_json_json_serializer = wpi_adl_serializer;
#[doc = " helper type for initializer lists of json values"]
pub type wpi_json_initializer_list_t = [u32; 2usize];
#[doc = "@brief general exception of the @ref json class\n\nThis class is an extension of `std::exception` objects with a member @a id for\nexception ids. It is used as the base class for all exceptions thrown by the\n@ref json class. This class can hence be used as \"wildcard\" to catch\nexceptions.\n\nSubclasses:\n- @ref parse_error for exceptions indicating a parse error\n- @ref invalid_iterator for exceptions indicating errors with iterators\n- @ref type_error for exceptions indicating executing a member function with\na wrong type\n- @ref out_of_range for exceptions indicating access out of the defined range\n- @ref other_error for exceptions indicating other library errors\n\n@internal\n@note To have nothrow-copy-constructible exceptions, we internally use\n`std::runtime_error` which can cope with arbitrary-length error messages.\nIntermediate strings are built with static functions and then passed to\nthe actual constructor.\n@endinternal\n\n@liveexample{The following code shows how arbitrary library exceptions can be\ncaught.,exception}\n\n@since version 3.0.0"]
pub type wpi_json_exception = wpi_detail_exception;
#[doc = "@brief exception indicating a parse error\n\nThis exception is thrown by the library when a parse error occurs. Parse errors\ncan occur during the deserialization of JSON text, CBOR, MessagePack, as well\nas when using JSON Patch.\n\nMember @a byte holds the byte index of the last read character in the input\nfile.\n\nExceptions have ids 1xx.\n\nname / id                      | example message | description\n------------------------------ | --------------- | -------------------------\njson.exception.parse_error.101 | parse error at 2: unexpected end of input; expected string literal | This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member @a byte indicates the error position.\njson.exception.parse_error.102 | parse error at 14: missing or wrong low surrogate | JSON uses the `\\uxxxx` format to describe Unicode characters. Code points above above 0xFFFF are split into two `\\uxxxx` entries (\"surrogate pairs\"). This error indicates that the surrogate pair is incomplete or contains an invalid code point.\njson.exception.parse_error.103 | parse error: code points above 0x10FFFF are invalid | Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid.\njson.exception.parse_error.104 | parse error: JSON patch must be an array of objects | [RFC 6902](https://tools.ietf.org/html/rfc6902) requires a JSON Patch document to be a JSON document that represents an array of objects.\njson.exception.parse_error.105 | parse error: operation must have string member 'op' | An operation of a JSON Patch document must contain exactly one \"op\" member, whose value indicates the operation to perform. Its value must be one of \"add\", \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are errors.\njson.exception.parse_error.106 | parse error: array index '01' must not begin with '0' | An array index in a JSON Pointer ([RFC 6901](https://tools.ietf.org/html/rfc6901)) may be `0` or any number without a leading `0`.\njson.exception.parse_error.107 | parse error: JSON pointer must be empty or begin with '/' - was: 'foo' | A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a `/` character.\njson.exception.parse_error.108 | parse error: escape character '~' must be followed with '0' or '1' | In a JSON Pointer, only `~0` and `~1` are valid escape sequences.\njson.exception.parse_error.109 | parse error: array index 'one' is not a number | A JSON Pointer array index must be a number.\njson.exception.parse_error.110 | parse error at 1: cannot read 2 bytes from vector | When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read.\njson.exception.parse_error.112 | parse error at 1: error reading CBOR; last byte: 0xF8 | Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read.\njson.exception.parse_error.113 | parse error at 2: expected a CBOR string; last byte: 0x98 | While parsing a map key, a value that is not a string has been read.\n\n@note For an input with n bytes, 1 is the index of the first character and n+1\nis the index of the terminating null byte or the end of file. This also\nholds true when reading a byte vector (CBOR or MessagePack).\n\n@liveexample{The following code shows how a `parse_error` exception can be\ncaught.,parse_error}\n\n@sa @ref exception for the base class of the library exceptions\n@sa @ref invalid_iterator for exceptions indicating errors with iterators\n@sa @ref type_error for exceptions indicating executing a member function with\na wrong type\n@sa @ref out_of_range for exceptions indicating access out of the defined range\n@sa @ref other_error for exceptions indicating other library errors\n\n@since version 3.0.0"]
pub type wpi_json_parse_error = wpi_detail_parse_error;
#[doc = "@brief exception indicating errors with iterators\n\nThis exception is thrown if iterators passed to a library function do not match\nthe expected semantics.\n\nExceptions have ids 2xx.\n\nname / id                           | example message | description\n----------------------------------- | --------------- | -------------------------\njson.exception.invalid_iterator.201 | iterators are not compatible | The iterators passed to constructor @ref json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.\njson.exception.invalid_iterator.202 | iterator does not fit current value | In an erase or insert function, the passed iterator @a pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion.\njson.exception.invalid_iterator.203 | iterators do not fit current value | Either iterator passed to function @ref erase(IteratorType first, IteratorType last) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from.\njson.exception.invalid_iterator.204 | iterators out of range | When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly (@ref begin(), @ref end()), because this is the only way the single stored value is expressed. All other ranges are invalid.\njson.exception.invalid_iterator.205 | iterator out of range | When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the @ref begin() iterator, because it is the only way to address the stored value. All other iterators are invalid.\njson.exception.invalid_iterator.206 | cannot construct with iterators from null | The iterators passed to constructor @ref json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range.\njson.exception.invalid_iterator.207 | cannot use key() for non-object iterators | The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key.\njson.exception.invalid_iterator.208 | cannot use operator[] for object iterators | The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.\njson.exception.invalid_iterator.209 | cannot use offsets with object iterators | The offset operators (+, -, +=, -=) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered.\njson.exception.invalid_iterator.210 | iterators do not fit | The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range (@a first, @a last) is invalid.\njson.exception.invalid_iterator.211 | passed iterators may not belong to container | The iterator range passed to the insert function must not be a subrange of the container to insert to.\njson.exception.invalid_iterator.212 | cannot compare iterators of different containers | When two iterators are compared, they must belong to the same container.\njson.exception.invalid_iterator.213 | cannot compare order of object iterators | The order of object iterators cannot be compared, because JSON objects are unordered.\njson.exception.invalid_iterator.214 | cannot get value | Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to @ref begin().\n\n@liveexample{The following code shows how an `invalid_iterator` exception can be\ncaught.,invalid_iterator}\n\n@sa @ref exception for the base class of the library exceptions\n@sa @ref parse_error for exceptions indicating a parse error\n@sa @ref type_error for exceptions indicating executing a member function with\na wrong type\n@sa @ref out_of_range for exceptions indicating access out of the defined range\n@sa @ref other_error for exceptions indicating other library errors\n\n@since version 3.0.0"]
pub type wpi_json_invalid_iterator = wpi_detail_invalid_iterator;
#[doc = "@brief exception indicating executing a member function with a wrong type\n\nThis exception is thrown in case of a type error; that is, a library function is\nexecuted on a JSON value whose type does not match the expected semantics.\n\nExceptions have ids 3xx.\n\nname / id                     | example message | description\n----------------------------- | --------------- | -------------------------\njson.exception.type_error.301 | cannot create object from initializer list | To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead.\njson.exception.type_error.302 | type must be object, but is array | During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types.\njson.exception.type_error.303 | incompatible ReferenceType for get_ref, actual type is object | To retrieve a reference to a value stored in a @ref json object with @ref get_ref, the type of the reference must match the value type. For instance, for a JSON array, the @a ReferenceType must be @ref array_t&.\njson.exception.type_error.304 | cannot use at() with string | The @ref at() member functions can only be executed for certain JSON types.\njson.exception.type_error.305 | cannot use operator[] with string | The @ref operator[] member functions can only be executed for certain JSON types.\njson.exception.type_error.306 | cannot use value() with string | The @ref value() member functions can only be executed for certain JSON types.\njson.exception.type_error.307 | cannot use erase() with string | The @ref erase() member functions can only be executed for certain JSON types.\njson.exception.type_error.308 | cannot use push_back() with string | The @ref push_back() and @ref operator+= member functions can only be executed for certain JSON types.\njson.exception.type_error.309 | cannot use insert() with | The @ref insert() member functions can only be executed for certain JSON types.\njson.exception.type_error.310 | cannot use swap() with number | The @ref swap() member functions can only be executed for certain JSON types.\njson.exception.type_error.311 | cannot use emplace_back() with string | The @ref emplace_back() member function can only be executed for certain JSON types.\njson.exception.type_error.312 | cannot use update() with string | The @ref update() member functions can only be executed for certain JSON types.\njson.exception.type_error.313 | invalid value to unflatten | The @ref unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined.\njson.exception.type_error.314 | only objects can be unflattened | The @ref unflatten function only works for an object whose keys are JSON Pointers.\njson.exception.type_error.315 | values in object must be primitive | The @ref unflatten function only works for an object whose keys are JSON Pointers and whose values are primitive.\njson.exception.type_error.316 | invalid UTF-8 byte at index 10: 0x7E | The @ref dump function only works with UTF-8 encoded strings; that is, if you assign a `std::string` to a JSON value, make sure it is UTF-8 encoded. |\n\n@liveexample{The following code shows how a `type_error` exception can be\ncaught.,type_error}\n\n@sa @ref exception for the base class of the library exceptions\n@sa @ref parse_error for exceptions indicating a parse error\n@sa @ref invalid_iterator for exceptions indicating errors with iterators\n@sa @ref out_of_range for exceptions indicating access out of the defined range\n@sa @ref other_error for exceptions indicating other library errors\n\n@since version 3.0.0"]
pub type wpi_json_type_error = wpi_detail_type_error;
#[doc = "@brief exception indicating access out of the defined range\n\nThis exception is thrown in case a library function is called on an input\nparameter that exceeds the expected range, for instance in case of array\nindices or nonexisting object keys.\n\nExceptions have ids 4xx.\n\nname / id                       | example message | description\n------------------------------- | --------------- | -------------------------\njson.exception.out_of_range.401 | array index 3 is out of range | The provided array index @a i is larger than @a size-1.\njson.exception.out_of_range.402 | array index '-' (3) is out of range | The special array index `-` in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it.\njson.exception.out_of_range.403 | key 'foo' not found | The provided key was not found in the JSON object.\njson.exception.out_of_range.404 | unresolved reference token 'foo' | A reference token in a JSON Pointer could not be resolved.\njson.exception.out_of_range.405 | JSON pointer has no parent | The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value.\njson.exception.out_of_range.406 | number overflow parsing '10E1000' | A parsed number could not be stored as without changing it to NaN or INF.\njson.exception.out_of_range.407 | number overflow serializing '9223372036854775808' | UBJSON only supports integers numbers up to 9223372036854775807. |\njson.exception.out_of_range.408 | excessive array size: 8658170730974374167 | The size (following `#`) of an UBJSON array or object exceeds the maximal capacity. |\n\n@liveexample{The following code shows how an `out_of_range` exception can be\ncaught.,out_of_range}\n\n@sa @ref exception for the base class of the library exceptions\n@sa @ref parse_error for exceptions indicating a parse error\n@sa @ref invalid_iterator for exceptions indicating errors with iterators\n@sa @ref type_error for exceptions indicating executing a member function with\na wrong type\n@sa @ref other_error for exceptions indicating other library errors\n\n@since version 3.0.0"]
pub type wpi_json_out_of_range = wpi_detail_out_of_range;
#[doc = "@brief exception indicating other library errors\n\nThis exception is thrown in case of errors that cannot be classified with the\nother exception types.\n\nExceptions have ids 5xx.\n\nname / id                      | example message | description\n------------------------------ | --------------- | -------------------------\njson.exception.other_error.501 | unsuccessful: {\"op\":\"test\",\"path\":\"/baz\", \"value\":\"bar\"} | A JSON Patch operation 'test' failed. The unsuccessful operation is also printed.\n\n@sa @ref exception for the base class of the library exceptions\n@sa @ref parse_error for exceptions indicating a parse error\n@sa @ref invalid_iterator for exceptions indicating errors with iterators\n@sa @ref type_error for exceptions indicating executing a member function with\na wrong type\n@sa @ref out_of_range for exceptions indicating access out of the defined range\n\n@liveexample{The following code shows how an `other_error` exception can be\ncaught.,other_error}\n\n@since version 3.0.0"]
pub type wpi_json_other_error = wpi_detail_other_error;
#[doc = " the type of an element reference"]
pub type wpi_json_reference = *mut value_type;
#[doc = " the type of an element const reference"]
pub type wpi_json_const_reference = *const value_type;
#[doc = " a type to represent differences between iterators"]
pub type wpi_json_difference_type = isize;
#[doc = " a type to represent container sizes"]
pub type wpi_json_size_type = usize;
#[doc = " the allocator type"]
pub type wpi_json_allocator_type = u8;
#[doc = " the type of an element pointer"]
pub type wpi_json_pointer = u32;
#[doc = " the type of an element const pointer"]
pub type wpi_json_const_pointer = *const wpi_json;
#[doc = "@brief a template for a bidirectional iterator for the @ref json class\n\nThis class implements a both iterators (iterator and const_iterator) for the\n@ref json class.\n\n@note An iterator is called *initialized* when a pointer to a JSON value has\nbeen set (e.g., by a constructor or a copy assignment). If the iterator is\ndefault-constructed, it is *uninitialized* and most methods are undefined.\nThe library uses assertions to detect calls on uninitialized iterators.**\n\n@requirement The class satisfies the following concept requirements:\n-\n[BidirectionalIterator](http://en.cppreference.com/w/cpp/concept/BidirectionalIterator):\nThe iterator that can be moved can be moved in both directions (i.e.\nincremented and decremented).\n\n@since version 1.0.0, simplified in version 2.0.9, change to bidirectional\niterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)"]
pub type wpi_json_iterator = wpi_detail_iter_impl;
#[doc = "@brief a template for a bidirectional iterator for the @ref json class\n\nThis class implements a both iterators (iterator and const_iterator) for the\n@ref json class.\n\n@note An iterator is called *initialized* when a pointer to a JSON value has\nbeen set (e.g., by a constructor or a copy assignment). If the iterator is\ndefault-constructed, it is *uninitialized* and most methods are undefined.\nThe library uses assertions to detect calls on uninitialized iterators.**\n\n@requirement The class satisfies the following concept requirements:\n-\n[BidirectionalIterator](http://en.cppreference.com/w/cpp/concept/BidirectionalIterator):\nThe iterator that can be moved can be moved in both directions (i.e.\nincremented and decremented).\n\n@since version 1.0.0, simplified in version 2.0.9, change to bidirectional\niterators in version 3.0.0 (see https://github.com/nlohmann/json/issues/593)"]
pub type wpi_json_const_iterator = wpi_detail_iter_impl;
#[doc = "@brief a template for a reverse iterator class\n\n@tparam Base the base iterator type to reverse. Valid types are @ref\niterator (to create @ref reverse_iterator) and @ref const_iterator (to\ncreate @ref const_reverse_iterator).\n\n@requirement The class satisfies the following concept requirements:\n-\n[BidirectionalIterator](http://en.cppreference.com/w/cpp/concept/BidirectionalIterator):\nThe iterator that can be moved can be moved in both directions (i.e.\nincremented and decremented).\n- [OutputIterator](http://en.cppreference.com/w/cpp/concept/OutputIterator):\nIt is possible to write to the pointed-to element (only if @a Base is\n@ref iterator).\n\n@since version 1.0.0"]
pub type wpi_json_reverse_iterator = wpi_detail_json_reverse_iterator;
#[doc = "@brief a template for a reverse iterator class\n\n@tparam Base the base iterator type to reverse. Valid types are @ref\niterator (to create @ref reverse_iterator) and @ref const_iterator (to\ncreate @ref const_reverse_iterator).\n\n@requirement The class satisfies the following concept requirements:\n-\n[BidirectionalIterator](http://en.cppreference.com/w/cpp/concept/BidirectionalIterator):\nThe iterator that can be moved can be moved in both directions (i.e.\nincremented and decremented).\n- [OutputIterator](http://en.cppreference.com/w/cpp/concept/OutputIterator):\nIt is possible to write to the pointed-to element (only if @a Base is\n@ref iterator).\n\n@since version 1.0.0"]
pub type wpi_json_const_reverse_iterator = wpi_detail_json_reverse_iterator;
#[doc = " @name JSON value data types\n The data types to store a JSON value. These types are derived from\n the template arguments passed to class @ref json.\n @{"]
pub type wpi_json_object_comparator_t = u8;
#[doc = " StringMap - This is an unconventional map that is specialized for handling\n keys that are \"strings\", which are basically ranges of bytes. This does some\n funky memory allocation and hashing things to make it extremely efficient,\n storing the string data *after* the value in the map."]
pub type wpi_json_object_t = wpi_StringMap<wpi_MallocAllocator>;
#[doc = "@brief a type for an array\n\n[RFC 7159](http://rfc7159.net/rfc7159) describes JSON arrays as follows:\n> An array is an ordered sequence of zero or more values.\n\n#### Limits\n\n[RFC 7159](http://rfc7159.net/rfc7159) specifies:\n> An implementation may set limits on the maximum depth of nesting.\n\nIn this class, the array's limit of nesting is not explicitly constrained.\nHowever, a maximum depth of nesting may be introduced by the compiler or\nruntime environment. A theoretical limit can be queried by calling the\n@ref max_size function of a JSON array.\n\n#### Storage\n\nArrays are stored as pointers in a @ref json type. That is, for any\naccess to array values, a pointer of type `array_t*` must be dereferenced.\n\n@sa @ref object_t -- type for an object value\n\n@since version 1.0.0"]
pub type wpi_json_array_t = [u32; 3usize];
#[doc = "@brief a JSON value\n\nThe actual storage for a JSON value of the @ref json class. This\nunion combines the different storage types for the JSON value types\ndefined in @ref value_t.\n\nJSON type | value_t type    | used type\n--------- | --------------- | ------------------------\nobject    | object          | pointer to @ref object_t\narray     | array           | pointer to @ref array_t\nstring    | string          | pointer to std::string\nboolean   | boolean         | bool\nnumber    | number_integer  | int64_t\nnumber    | number_unsigned | uint64_t\nnumber    | number_float    | double\nnull      | null            | *no value is stored*\n\n@note Variable-length types (objects, arrays, and strings) are stored as\npointers. The size of the union should not exceed 64 bits if the default\nvalue types are used.\n\n@since version 1.0.0"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union wpi_json_json_value {
    #[doc = " object (stored with pointer to save storage)"]
    pub object: *mut wpi_json_object_t,
    #[doc = " array (stored with pointer to save storage)"]
    pub array: *mut wpi_json_array_t,
    #[doc = " string (stored with pointer to save storage)"]
    pub string: *mut std_string,
    #[doc = " boolean"]
    pub boolean: bool,
    #[doc = " number (integer)"]
    pub number_integer: i64,
    #[doc = " number (unsigned integer)"]
    pub number_unsigned: u64,
    #[doc = " number (floating-point)"]
    pub number_float: f64,
}
#[test]
fn bindgen_test_layout_wpi_json_json_value() {
    const UNINIT: ::std::mem::MaybeUninit<wpi_json_json_value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wpi_json_json_value>(),
        8usize,
        concat!("Size of: ", stringify!(wpi_json_json_value))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_json_json_value>(),
        8usize,
        concat!("Alignment of ", stringify!(wpi_json_json_value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).object) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_json_json_value),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).array) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_json_json_value),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_json_json_value),
            "::",
            stringify!(string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_json_json_value),
            "::",
            stringify!(boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).number_integer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_json_json_value),
            "::",
            stringify!(number_integer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).number_unsigned) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_json_json_value),
            "::",
            stringify!(number_unsigned)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).number_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_json_json_value),
            "::",
            stringify!(number_float)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json10json_value7destroyENS_6detail7value_tE"]
    pub fn wpi_json_json_value_destroy(this: *mut wpi_json_json_value, t: wpi_json_value_t);
}
extern "C" {
    #[doc = " constructor for empty values of a given type"]
    #[link_name = "\u{1}_ZN3wpi4json10json_valueC1ENS_6detail7value_tE"]
    pub fn wpi_json_json_value_json_value(this: *mut wpi_json_json_value, t: wpi_json_value_t);
}
impl wpi_json_json_value {
    #[inline]
    pub unsafe fn destroy(&mut self, t: wpi_json_value_t) {
        wpi_json_json_value_destroy(self, t)
    }
    #[inline]
    pub unsafe fn new(t: wpi_json_value_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        wpi_json_json_value_json_value(__bindgen_tmp.as_mut_ptr(), t);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " the parser read `{` and started to process a JSON object"]
pub const wpi_json_parse_event_t_object_start: wpi_json_parse_event_t = 0;
#[doc = " the parser read `}` and finished processing a JSON object"]
pub const wpi_json_parse_event_t_object_end: wpi_json_parse_event_t = 1;
#[doc = " the parser read `[` and started to process a JSON array"]
pub const wpi_json_parse_event_t_array_start: wpi_json_parse_event_t = 2;
#[doc = " the parser read `]` and finished processing a JSON array"]
pub const wpi_json_parse_event_t_array_end: wpi_json_parse_event_t = 3;
#[doc = " the parser read a key of a value in an object"]
pub const wpi_json_parse_event_t_key: wpi_json_parse_event_t = 4;
#[doc = " the parser finished reading a JSON value"]
pub const wpi_json_parse_event_t_value: wpi_json_parse_event_t = 5;
#[doc = "@brief parser event types\n\nThe parser callback distinguishes the following events:\n- `object_start`: the parser read `{` and started to process a JSON object\n- `key`: the parser read a key of a value in an object\n- `object_end`: the parser read `}` and finished processing a JSON object\n- `array_start`: the parser read `[` and started to process a JSON array\n- `array_end`: the parser read `]` and finished processing a JSON array\n- `value`: the parser finished reading a JSON value\n\n@image html callback_events.png \"Example when certain parse events are triggered\"\n\n@sa @ref parser_callback_t for more information and examples"]
pub type wpi_json_parse_event_t = u8;
#[doc = "@brief per-element parser callback type\n\nWith a parser callback function, the result of parsing a JSON text can be\ninfluenced. When passed to @ref parse, it is called on certain events\n(passed as @ref parse_event_t via parameter @a event) with a set recursion\ndepth @a depth and context JSON value @a parsed. The return value of the\ncallback function is a boolean indicating whether the element that emitted\nthe callback shall be kept or not.\n\nWe distinguish six scenarios (determined by the event type) in which the\ncallback function can be called. The following table describes the values\nof the parameters @a depth, @a event, and @a parsed.\n\nparameter @a event | description | parameter @a depth | parameter @a parsed\n------------------ | ----------- | ------------------ | -------------------\nparse_event_t::object_start | the parser read `{` and started to process a JSON object | depth of the parent of the JSON object | a JSON value with type discarded\nparse_event_t::key | the parser read a key of a value in an object | depth of the currently parsed JSON object | a JSON string containing the key\nparse_event_t::object_end | the parser read `}` and finished processing a JSON object | depth of the parent of the JSON object | the parsed JSON object\nparse_event_t::array_start | the parser read `[` and started to process a JSON array | depth of the parent of the JSON array | a JSON value with type discarded\nparse_event_t::array_end | the parser read `]` and finished processing a JSON array | depth of the parent of the JSON array | the parsed JSON array\nparse_event_t::value | the parser finished reading a JSON value | depth of the value | the parsed JSON value\n\n@image html callback_events.png \"Example when certain parse events are triggered\"\n\nDiscarding a value (i.e., returning `false`) has different effects\ndepending on the context in which function was called:\n\n- Discarded values in structured types are skipped. That is, the parser\nwill behave as if the discarded value was never read.\n- In case a value outside a structured type is skipped, it is replaced\nwith `null`. This case happens if the top-level element is skipped.\n\n@param[in] depth  the depth of the recursion during parsing\n\n@param[in] event  an event of type parse_event_t indicating the context in\nthe callback function has been called\n\n@param[in,out] parsed  the current intermediate parse result; note that\nwriting to this value has no effect for parse_event_t::key events\n\n@return Whether the JSON value which called the function during parsing\nshould be kept (`true`) or not (`false`). In the latter case, it is either\nskipped completely or replaced by an empty discarded object.\n\n@sa @ref parse for examples\n\n@since version 1.0.0"]
pub type wpi_json_parser_callback_t = [u32; 4usize];
#[test]
fn bindgen_test_layout_wpi_json() {
    const UNINIT: ::std::mem::MaybeUninit<wpi_json> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wpi_json>(),
        16usize,
        concat!("Size of: ", stringify!(wpi_json))
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_json>(),
        8usize,
        concat!("Alignment of ", stringify!(wpi_json))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_json),
            "::",
            stringify!(m_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(wpi_json),
            "::",
            stringify!(m_value)
        )
    );
}
extern "C" {
    #[doc = "@brief returns version information on the library\n\nThis function returns a JSON object with information about the library,\nincluding the version number and information on the platform and compiler.\n\n@return JSON object holding version information\nkey         | description\n----------- | ---------------\n`compiler`  | Information on the used compiler. It is an object with the following keys: `c++` (the used C++ standard), `family` (the compiler family; possible values are `clang`, `icc`, `gcc`, `ilecpp`, `msvc`, `pgcpp`, `sunpro`, and `unknown`), and `version` (the compiler version).\n`copyright` | The copyright line for the library as string.\n`name`      | The name of the library as string.\n`platform`  | The used platform as string. Possible values are `win32`, `linux`, `apple`, `unix`, and `unknown`.\n`url`       | The URL of the project as string.\n`version`   | The version of the library. It is an object with the following keys: `major`, `minor`, and `patch` as defined by [Semantic Versioning](http://semver.org), and `string` (the version string).\n\n@liveexample{The following code shows an example output of the `meta()`\nfunction.,meta}\n\n@exceptionsafety Strong guarantee: if an exception is thrown, there are no\nchanges to any JSON value.\n\n@complexity Constant.\n\n@since 2.1.0"]
    #[link_name = "\u{1}_ZN3wpi4json4metaEv"]
    pub fn wpi_json_meta() -> wpi_json;
}
extern "C" {
    #[doc = "@brief serialization\n\nSerialization function for JSON values. The function tries to mimic\nPython's `json.dumps()` function, and currently supports its @a indent\nand @a ensure_ascii parameters.\n\n@param[in] indent If indent is nonnegative, then array elements and object\nmembers will be pretty-printed with that indent level. An indent level of\n`0` will only insert newlines. `-1` (the default) selects the most compact\nrepresentation.\n@param[in] indent_char The character to use for indentation if @a indent is\ngreater than `0`. The default is ` ` (space).\n@param[in] ensure_ascii If @a ensure_ascii is true, all non-ASCII characters\nin the output are escaped with `\\uXXXX` sequences, and the result consists\nof ASCII characters only.\n\n@return string containing the serialization of the JSON value\n\n@throw type_error.316 if a string stored inside the JSON value is not\nUTF-8 encoded\n\n@complexity Linear.\n\n@exceptionsafety Strong guarantee: if an exception is thrown, there are no\nchanges in the JSON value.\n\n@liveexample{The following example shows the effect of different @a indent\\,\n@a indent_char\\, and @a ensure_ascii parameters to the result of the\nserialization.,dump}\n\n@see https://docs.python.org/2/library/json.html#json.dump\n\n@since version 1.0.0; indentation character @a indent_char, option\n@a ensure_ascii and exceptions added in version 3.0.0"]
    #[link_name = "\u{1}_ZNK3wpi4json4dumpB5cxx11Eicb"]
    pub fn wpi_json_dump(
        this: *const wpi_json,
        indent: ::std::os::raw::c_int,
        indent_char: ::std::os::raw::c_char,
        ensure_ascii: bool,
    ) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3wpi4json4dumpERNS_11raw_ostreamEicb"]
    pub fn wpi_json_dump1(
        this: *const wpi_json,
        os: *mut wpi_raw_ostream,
        indent: ::std::os::raw::c_int,
        indent_char: ::std::os::raw::c_char,
        ensure_ascii: bool,
    );
}
extern "C" {
    #[doc = "@brief access specified array element with bounds checking\n\nReturns a reference to the element at specified location @a idx, with\nbounds checking.\n\n@param[in] idx  index of the element to access\n\n@return reference to the element at index @a idx\n\n@throw type_error.304 if the JSON value is not an array; in this case,\ncalling `at` with an index makes no sense. See example below.\n@throw out_of_range.401 if the index @a idx is out of range of the array;\nthat is, `idx >= size()`. See example below.\n\n@exceptionsafety Strong guarantee: if an exception is thrown, there are no\nchanges in the JSON value.\n\n@complexity Constant.\n\n@since version 1.0.0\n\n@liveexample{The example below shows how array elements can be read and\nwritten using `at()`. It also demonstrates the different exceptions that\ncan be thrown.,at__size_type}"]
    #[link_name = "\u{1}_ZN3wpi4json2atEj"]
    pub fn wpi_json_at(this: *mut wpi_json, idx: wpi_json_size_type) -> wpi_json_reference;
}
extern "C" {
    #[doc = "@brief access specified array element with bounds checking\n\nReturns a const reference to the element at specified location @a idx,\nwith bounds checking.\n\n@param[in] idx  index of the element to access\n\n@return const reference to the element at index @a idx\n\n@throw type_error.304 if the JSON value is not an array; in this case,\ncalling `at` with an index makes no sense. See example below.\n@throw out_of_range.401 if the index @a idx is out of range of the array;\nthat is, `idx >= size()`. See example below.\n\n@exceptionsafety Strong guarantee: if an exception is thrown, there are no\nchanges in the JSON value.\n\n@complexity Constant.\n\n@since version 1.0.0\n\n@liveexample{The example below shows how array elements can be read using\n`at()`. It also demonstrates the different exceptions that can be thrown.,\nat__size_type_const}"]
    #[link_name = "\u{1}_ZNK3wpi4json2atEj"]
    pub fn wpi_json_at1(this: *const wpi_json, idx: wpi_json_size_type)
        -> wpi_json_const_reference;
}
extern "C" {
    #[doc = "@brief access specified object element with bounds checking\n\nReturns a reference to the element at with specified key @a key, with\nbounds checking.\n\n@param[in] key  key of the element to access\n\n@return reference to the element at key @a key\n\n@throw type_error.304 if the JSON value is not an object; in this case,\ncalling `at` with a key makes no sense. See example below.\n@throw out_of_range.403 if the key @a key is is not stored in the object;\nthat is, `find(key) == end()`. See example below.\n\n@exceptionsafety Strong guarantee: if an exception is thrown, there are no\nchanges in the JSON value.\n\n@complexity Logarithmic in the size of the container.\n\n@sa @ref operator[](const typename object_t::key_type&) for unchecked\naccess by reference\n@sa @ref value() for access by value with a default value\n\n@since version 1.0.0\n\n@liveexample{The example below shows how object elements can be read and\nwritten using `at()`. It also demonstrates the different exceptions that\ncan be thrown.,at__object_t_key_type}"]
    #[link_name = "\u{1}_ZN3wpi4json2atESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_json_at2(this: *mut wpi_json, key: std_string_view) -> wpi_json_reference;
}
extern "C" {
    #[doc = "@brief access specified object element with bounds checking\n\nReturns a const reference to the element at with specified key @a key,\nwith bounds checking.\n\n@param[in] key  key of the element to access\n\n@return const reference to the element at key @a key\n\n@throw type_error.304 if the JSON value is not an object; in this case,\ncalling `at` with a key makes no sense. See example below.\n@throw out_of_range.403 if the key @a key is is not stored in the object;\nthat is, `find(key) == end()`. See example below.\n\n@exceptionsafety Strong guarantee: if an exception is thrown, there are no\nchanges in the JSON value.\n\n@complexity Logarithmic in the size of the container.\n\n@sa @ref operator[](const typename object_t::key_type&) for unchecked\naccess by reference\n@sa @ref value() for access by value with a default value\n\n@since version 1.0.0\n\n@liveexample{The example below shows how object elements can be read using\n`at()`. It also demonstrates the different exceptions that can be thrown.,\nat__object_t_key_type_const}"]
    #[link_name = "\u{1}_ZNK3wpi4json2atESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_json_at3(this: *const wpi_json, key: std_string_view) -> wpi_json_const_reference;
}
extern "C" {
    #[doc = "@brief remove element from a JSON object given a key\n\nRemoves elements from a JSON object with the key value @a key.\n\n@param[in] key value of the elements to remove\n\n@return Number of elements removed. If @a ObjectType is the default\n`std::map` type, the return value will always be `0` (@a key was not\nfound) or `1` (@a key was found).\n\n@post References and iterators to the erased elements are invalidated.\nOther references and iterators are not affected.\n\n@throw type_error.307 when called on a type other than JSON object;\nexample: `\"cannot use erase() with null\"`\n\n@complexity `log(size()) + count(key)`\n\n@liveexample{The example shows the effect of `erase()`.,erase__key_type}\n\n@sa @ref erase(IteratorType) -- removes the element at a given position\n@sa @ref erase(IteratorType, IteratorType) -- removes the elements in\nthe given range\n@sa @ref erase(const size_type) -- removes the element from an array at\nthe given index\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json5eraseESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_json_erase(this: *mut wpi_json, key: std_string_view) -> wpi_json_size_type;
}
extern "C" {
    #[doc = "@brief remove element from a JSON array given an index\n\nRemoves element from a JSON array at the index @a idx.\n\n@param[in] idx index of the element to remove\n\n@throw type_error.307 when called on a type other than JSON object;\nexample: `\"cannot use erase() with null\"`\n@throw out_of_range.401 when `idx >= size()`; example: `\"array index 17\nis out of range\"`\n\n@complexity Linear in distance between @a idx and the end of the container.\n\n@liveexample{The example shows the effect of `erase()`.,erase__size_type}\n\n@sa @ref erase(IteratorType) -- removes the element at a given position\n@sa @ref erase(IteratorType, IteratorType) -- removes the elements in\nthe given range\n@sa @ref erase(const typename object_t::key_type&) -- removes the element\nfrom an object at the given key\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json5eraseEj"]
    pub fn wpi_json_erase1(this: *mut wpi_json, idx: wpi_json_size_type);
}
extern "C" {
    #[doc = "@brief find an element in a JSON object\n\nFinds an element in a JSON object with key equivalent to @a key. If the\nelement is not found or the JSON value is not an object, end() is\nreturned.\n\n@note This method always returns @ref end() when executed on a JSON type\nthat is not an object.\n\n@param[in] key key value of the element to search for.\n\n@return Iterator to an element with key equivalent to @a key. If no such\nelement is found or the JSON value is not an object, past-the-end (see\n@ref end()) iterator is returned.\n\n@complexity Logarithmic in the size of the JSON object.\n\n@liveexample{The example shows how `find()` is used.,find__key_type}\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json4findESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_json_find(this: *mut wpi_json, key: std_string_view) -> wpi_json_iterator;
}
extern "C" {
    #[doc = "@brief find an element in a JSON object\n@copydoc find(KeyT&&)"]
    #[link_name = "\u{1}_ZNK3wpi4json4findESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_json_find1(this: *const wpi_json, key: std_string_view) -> wpi_json_const_iterator;
}
extern "C" {
    #[doc = "@brief returns the number of occurrences of a key in a JSON object\n\nReturns the number of elements with key @a key. If ObjectType is the\ndefault `std::map` type, the return value will always be `0` (@a key was\nnot found) or `1` (@a key was found).\n\n@note This method always returns `0` when executed on a JSON type that is\nnot an object.\n\n@param[in] key key value of the element to count\n\n@return Number of elements with key @a key. If the JSON value is not an\nobject, the return value will be `0`.\n\n@complexity Logarithmic in the size of the JSON object.\n\n@liveexample{The example shows how `count()` is used.,count}\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZNK3wpi4json5countESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_json_count(this: *const wpi_json, key: std_string_view) -> wpi_json_size_type;
}
extern "C" {
    #[doc = "@brief checks whether the container is empty.\n\nChecks if a JSON value has no elements (i.e. whether its @ref size is `0`).\n\n@return The return value depends on the different types and is\ndefined as follows:\nValue type  | return value\n----------- | -------------\nnull        | `true`\nboolean     | `false`\nstring      | `false`\nnumber      | `false`\nobject      | result of function `object_t::empty()`\narray       | result of function `array_t::empty()`\n\n@liveexample{The following code uses `empty()` to check if a JSON\nobject contains any elements.,empty}\n\n@complexity Constant, as long as @ref array_t and @ref object_t satisfy\nthe Container concept; that is, their `empty()` functions have constant\ncomplexity.\n\n@iterators No changes.\n\n@exceptionsafety No-throw guarantee: this function never throws exceptions.\n\n@note This function does not return whether a string stored as JSON value\nis empty - it returns whether the JSON container itself is empty which is\nfalse in the case of a string.\n\n@requirement This function helps `json` satisfying the\n[Container](http://en.cppreference.com/w/cpp/concept/Container)\nrequirements:\n- The complexity is constant.\n- Has the semantics of `begin() == end()`.\n\n@sa @ref size() -- returns the number of elements\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZNK3wpi4json5emptyEv"]
    pub fn wpi_json_empty(this: *const wpi_json) -> bool;
}
extern "C" {
    #[doc = "@brief returns the number of elements\n\nReturns the number of elements in a JSON value.\n\n@return The return value depends on the different types and is\ndefined as follows:\nValue type  | return value\n----------- | -------------\nnull        | `0`\nboolean     | `1`\nstring      | `1`\nnumber      | `1`\nobject      | result of function object_t::size()\narray       | result of function array_t::size()\n\n@liveexample{The following code calls `size()` on the different value\ntypes.,size}\n\n@complexity Constant, as long as @ref array_t and @ref object_t satisfy\nthe Container concept; that is, their size() functions have constant\ncomplexity.\n\n@iterators No changes.\n\n@exceptionsafety No-throw guarantee: this function never throws exceptions.\n\n@note This function does not return the length of a string stored as JSON\nvalue - it returns the number of elements in the JSON value which is 1 in\nthe case of a string.\n\n@requirement This function helps `json` satisfying the\n[Container](http://en.cppreference.com/w/cpp/concept/Container)\nrequirements:\n- The complexity is constant.\n- Has the semantics of `std::distance(begin(), end())`.\n\n@sa @ref empty() -- checks whether the container is empty\n@sa @ref max_size() -- returns the maximal number of elements\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZNK3wpi4json4sizeEv"]
    pub fn wpi_json_size(this: *const wpi_json) -> wpi_json_size_type;
}
extern "C" {
    #[doc = "@brief returns the maximum possible number of elements\n\nReturns the maximum number of elements a JSON value is able to hold due to\nsystem or library implementation limitations, i.e. `std::distance(begin(),\nend())` for the JSON value.\n\n@return The return value depends on the different types and is\ndefined as follows:\nValue type  | return value\n----------- | -------------\nnull        | `0` (same as `size()`)\nboolean     | `1` (same as `size()`)\nstring      | `1` (same as `size()`)\nnumber      | `1` (same as `size()`)\nobject      | result of function `object_t::max_size()`\narray       | result of function `array_t::max_size()`\n\n@liveexample{The following code calls `max_size()` on the different value\ntypes. Note the output is implementation specific.,max_size}\n\n@complexity Constant, as long as @ref array_t and @ref object_t satisfy\nthe Container concept; that is, their `max_size()` functions have constant\ncomplexity.\n\n@iterators No changes.\n\n@exceptionsafety No-throw guarantee: this function never throws exceptions.\n\n@requirement This function helps `json` satisfying the\n[Container](http://en.cppreference.com/w/cpp/concept/Container)\nrequirements:\n- The complexity is constant.\n- Has the semantics of returning `b.size()` where `b` is the largest\npossible JSON value.\n\n@sa @ref size() -- returns the number of elements\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZNK3wpi4json8max_sizeEv"]
    pub fn wpi_json_max_size(this: *const wpi_json) -> wpi_json_size_type;
}
extern "C" {
    #[doc = "@brief clears the contents\n\nClears the content of a JSON value and resets it to the default value as\nif @ref json(value_t) would have been called with the current value\ntype from @ref type():\n\nValue type  | initial value\n----------- | -------------\nnull        | `null`\nboolean     | `false`\nstring      | `\"\"`\nnumber      | `0`\nobject      | `{}`\narray       | `[]`\n\n@post Has the same effect as calling\n@code {.cpp}\nthis = json(type());\n@endcode\n\n@liveexample{The example below shows the effect of `clear()` to different\nJSON types.,clear}\n\n@complexity Linear in the size of the JSON value.\n\n@iterators All iterators, pointers and references related to this container\nare invalidated.\n\n@exceptionsafety No-throw guarantee: this function never throws exceptions.\n\n@sa @ref json(value_t) -- constructor that creates an object with the\nsame value than calling `clear()`\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json5clearEv"]
    pub fn wpi_json_clear(this: *mut wpi_json);
}
extern "C" {
    #[doc = "@brief add an object to an array\n\nAppends the given element @a val to the end of the JSON value. If the\nfunction is called on a JSON null value, an empty array is created before\nappending @a val.\n\n@param[in] val the value to add to the JSON array\n\n@throw type_error.308 when called on a type other than JSON array or\nnull; example: `\"cannot use push_back() with number\"`\n\n@complexity Amortized constant.\n\n@liveexample{The example shows how `push_back()` and `+=` can be used to\nadd elements to a JSON array. Note how the `null` value was silently\nconverted to a JSON array.,push_back}\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json9push_backEOS0_"]
    pub fn wpi_json_push_back(this: *mut wpi_json, val: *mut wpi_json);
}
extern "C" {
    #[doc = "@brief add an object to an array\n@copydoc push_back(json&&)"]
    #[link_name = "\u{1}_ZN3wpi4json9push_backERKS0_"]
    pub fn wpi_json_push_back1(this: *mut wpi_json, val: *const wpi_json);
}
extern "C" {
    #[doc = "@brief add an object to an object\n\nThis function allows to use `push_back` with an initializer list. In case\n\n1. the current value is an object,\n2. the initializer list @a init contains only two elements, and\n3. the first element of @a init is a string,\n\n@a init is converted into an object element and added using\n@ref push_back(const typename object_t::value_type&). Otherwise, @a init\nis converted to a JSON value and added using @ref push_back(json&&).\n\n@param[in] init  an initializer list\n\n@complexity Linear in the size of the initializer list @a init.\n\n@note This function is required to resolve an ambiguous overload error,\nbecause pairs like `{\"key\", \"value\"}` can be both interpreted as\n`object_t::value_type` or `std::initializer_list<json>`, see\nhttps://github.com/nlohmann/json/issues/235 for more information.\n\n@liveexample{The example shows how initializer lists are treated as\nobjects when possible.,push_back__initializer_list}"]
    #[link_name = "\u{1}_ZN3wpi4json9push_backESt16initializer_listINS_6detail8json_refIS0_EEE"]
    pub fn wpi_json_push_back2(this: *mut wpi_json, init: wpi_json_initializer_list_t);
}
extern "C" {
    #[doc = "@brief inserts element\n\nInserts element @a val before iterator @a pos.\n\n@param[in] pos iterator before which the content will be inserted; may be\nthe end() iterator\n@param[in] val element to insert\n@return iterator pointing to the inserted @a val.\n\n@throw type_error.309 if called on JSON values other than arrays;\nexample: `\"cannot use insert() with string\"`\n@throw invalid_iterator.202 if @a pos is not an iterator of *this;\nexample: `\"iterator does not fit current value\"`\n\n@complexity Constant plus linear in the distance between @a pos and end of\nthe container.\n\n@liveexample{The example shows how `insert()` is used.,insert}\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json6insertENS_6detail9iter_implIKS0_EERS3_"]
    pub fn wpi_json_insert(
        this: *mut wpi_json,
        pos: wpi_json_const_iterator,
        val: *const wpi_json,
    ) -> wpi_json_iterator;
}
extern "C" {
    #[doc = "@brief inserts elements\n\nInserts @a cnt copies of @a val before iterator @a pos.\n\n@param[in] pos iterator before which the content will be inserted; may be\nthe end() iterator\n@param[in] cnt number of copies of @a val to insert\n@param[in] val element to insert\n@return iterator pointing to the first element inserted, or @a pos if\n`cnt==0`\n\n@throw type_error.309 if called on JSON values other than arrays; example:\n`\"cannot use insert() with string\"`\n@throw invalid_iterator.202 if @a pos is not an iterator of *this;\nexample: `\"iterator does not fit current value\"`\n\n@complexity Linear in @a cnt plus linear in the distance between @a pos\nand end of the container.\n\n@liveexample{The example shows how `insert()` is used.,insert__count}\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json6insertENS_6detail9iter_implIKS0_EEjRS3_"]
    pub fn wpi_json_insert1(
        this: *mut wpi_json,
        pos: wpi_json_const_iterator,
        cnt: wpi_json_size_type,
        val: *const wpi_json,
    ) -> wpi_json_iterator;
}
extern "C" {
    #[doc = "@brief inserts elements\n\nInserts elements from range `[first, last)` before iterator @a pos.\n\n@param[in] pos iterator before which the content will be inserted; may be\nthe end() iterator\n@param[in] first begin of the range of elements to insert\n@param[in] last end of the range of elements to insert\n\n@throw type_error.309 if called on JSON values other than arrays; example:\n`\"cannot use insert() with string\"`\n@throw invalid_iterator.202 if @a pos is not an iterator of *this;\nexample: `\"iterator does not fit current value\"`\n@throw invalid_iterator.210 if @a first and @a last do not belong to the\nsame JSON value; example: `\"iterators do not fit\"`\n@throw invalid_iterator.211 if @a first or @a last are iterators into\ncontainer for which insert is called; example: `\"passed iterators may not\nbelong to container\"`\n\n@return iterator pointing to the first element inserted, or @a pos if\n`first==last`\n\n@complexity Linear in `std::distance(first, last)` plus linear in the\ndistance between @a pos and end of the container.\n\n@liveexample{The example shows how `insert()` is used.,insert__range}\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json6insertENS_6detail9iter_implIKS0_EES4_S4_"]
    pub fn wpi_json_insert2(
        this: *mut wpi_json,
        pos: wpi_json_const_iterator,
        first: wpi_json_const_iterator,
        last: wpi_json_const_iterator,
    ) -> wpi_json_iterator;
}
extern "C" {
    #[doc = "@brief inserts elements\n\nInserts elements from initializer list @a ilist before iterator @a pos.\n\n@param[in] pos iterator before which the content will be inserted; may be\nthe end() iterator\n@param[in] ilist initializer list to insert the values from\n\n@throw type_error.309 if called on JSON values other than arrays; example:\n`\"cannot use insert() with string\"`\n@throw invalid_iterator.202 if @a pos is not an iterator of *this;\nexample: `\"iterator does not fit current value\"`\n\n@return iterator pointing to the first element inserted, or @a pos if\n`ilist` is empty\n\n@complexity Linear in `ilist.size()` plus linear in the distance between\n@a pos and end of the container.\n\n@liveexample{The example shows how `insert()` is used.,insert__ilist}\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json6insertENS_6detail9iter_implIKS0_EESt16initializer_listINS1_8json_refIS0_EEE"]
    pub fn wpi_json_insert3(
        this: *mut wpi_json,
        pos: wpi_json_const_iterator,
        ilist: wpi_json_initializer_list_t,
    ) -> wpi_json_iterator;
}
extern "C" {
    #[doc = "@brief inserts elements\n\nInserts elements from range `[first, last)`.\n\n@param[in] first begin of the range of elements to insert\n@param[in] last end of the range of elements to insert\n\n@throw type_error.309 if called on JSON values other than objects; example:\n`\"cannot use insert() with string\"`\n@throw invalid_iterator.202 if iterator @a first or @a last does does not\npoint to an object; example: `\"iterators first and last must point to\nobjects\"`\n@throw invalid_iterator.210 if @a first and @a last do not belong to the\nsame JSON value; example: `\"iterators do not fit\"`\n\n@complexity Logarithmic: `O(N*log(size() + N))`, where `N` is the number\nof elements to insert.\n\n@liveexample{The example shows how `insert()` is used.,insert__range_object}\n\n@since version 3.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json6insertENS_6detail9iter_implIKS0_EES4_"]
    pub fn wpi_json_insert4(
        this: *mut wpi_json,
        first: wpi_json_const_iterator,
        last: wpi_json_const_iterator,
    );
}
extern "C" {
    #[doc = "@brief updates a JSON object from another object, overwriting existing keys\n\nInserts all values from JSON object @a j and overwrites existing keys.\n\n@param[in] j  JSON object to read values from\n\n@throw type_error.312 if called on JSON values other than objects; example:\n`\"cannot use update() with string\"`\n\n@complexity O(N*log(size() + N)), where N is the number of elements to\ninsert.\n\n@liveexample{The example shows how `update()` is used.,update}\n\n@sa https://docs.python.org/3.6/library/stdtypes.html#dict.update\n\n@since version 3.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json6updateERKS0_"]
    pub fn wpi_json_update(this: *mut wpi_json, j: wpi_json_const_reference);
}
extern "C" {
    #[doc = "@brief updates a JSON object from another object, overwriting existing keys\n\nInserts all values from from range `[first, last)` and overwrites existing\nkeys.\n\n@param[in] first begin of the range of elements to insert\n@param[in] last end of the range of elements to insert\n\n@throw type_error.312 if called on JSON values other than objects; example:\n`\"cannot use update() with string\"`\n@throw invalid_iterator.202 if iterator @a first or @a last does does not\npoint to an object; example: `\"iterators first and last must point to\nobjects\"`\n@throw invalid_iterator.210 if @a first and @a last do not belong to the\nsame JSON value; example: `\"iterators do not fit\"`\n\n@complexity O(N*log(size() + N)), where N is the number of elements to\ninsert.\n\n@liveexample{The example shows how `update()` is used__range.,update}\n\n@sa https://docs.python.org/3.6/library/stdtypes.html#dict.update\n\n@since version 3.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json6updateENS_6detail9iter_implIKS0_EES4_"]
    pub fn wpi_json_update1(
        this: *mut wpi_json,
        first: wpi_json_const_iterator,
        last: wpi_json_const_iterator,
    );
}
extern "C" {
    #[doc = "@brief deserialize from a compatible input\n\nThis function reads from a compatible input. Examples are:\n- an array of 1-byte values\n- strings with character/literal type with size of 1 byte\n- input streams\n- container with contiguous storage of 1-byte values. Compatible container\ntypes include `std::vector`, `std::string`, `std::array`,\nand `std::initializer_list`. Furthermore, C-style\narrays can be used with `std::begin()`/`std::end()`. User-defined\ncontainers can be used as long as they implement random-access iterators\nand a contiguous storage.\n\n@pre Each element of the container has a size of 1 byte. Violating this\nprecondition yields undefined behavior. **This precondition is enforced\nwith a static assertion.**\n\n@pre The container storage is contiguous. Violating this precondition\nyields undefined behavior. **This precondition is enforced with an\nassertion.**\n@pre Each element of the container has a size of 1 byte. Violating this\nprecondition yields undefined behavior. **This precondition is enforced\nwith a static assertion.**\n\n@warning There is no way to enforce all preconditions at compile-time. If\nthe function is called with a noncompliant container and with\nassertions switched off, the behavior is undefined and will most\nlikely yield segmentation violation.\n\n@param[in] i  input to read from\n@param[in] cb  a parser callback function of type @ref parser_callback_t\nwhich is used to control the deserialization by filtering unwanted values\n(optional)\n\n@return result of the deserialization\n\n@throw parse_error.101 if a parse error occurs; example: `\"\"unexpected end\nof input; expected string literal\"\"`\n@throw parse_error.102 if to_unicode fails or surrogate error\n@throw parse_error.103 if to_unicode fails\n\n@complexity Linear in the length of the input. The parser is a predictive\nLL(1) parser. The complexity can be higher if the parser callback function\n@a cb has a super-linear complexity.\n\n@note A UTF-8 byte order mark is silently ignored.\n\n@liveexample{The example below demonstrates the `parse()` function reading\nfrom an array.,parse__array__parser_callback_t}\n\n@liveexample{The example below demonstrates the `parse()` function with\nand without callback function.,parse__string__parser_callback_t}\n\n@liveexample{The example below demonstrates the `parse()` function with\nand without callback function.,parse__istream__parser_callback_t}\n\n@liveexample{The example below demonstrates the `parse()` function reading\nfrom a contiguous container.,parse__contiguouscontainer__parser_callback_t}\n\n@since version 2.0.3 (contiguous containers)"]
    #[link_name = "\u{1}_ZN3wpi4json5parseESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFbiNS0_13parse_event_tERS0_EEb"]
    pub fn wpi_json_parse(
        s: std_string_view,
        cb: wpi_json_parser_callback_t,
        allow_exceptions: bool,
    ) -> wpi_json;
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json5parseESt4spanIKhLj4294967295EESt8functionIFbiNS0_13parse_event_tERS0_EEb"]
    pub fn wpi_json_parse1(
        arr: [u32; 2usize],
        cb: wpi_json_parser_callback_t,
        allow_exceptions: bool,
    ) -> wpi_json;
}
extern "C" {
    #[doc = "@copydoc json parse(raw_istream&, const parser_callback_t)"]
    #[link_name = "\u{1}_ZN3wpi4json5parseERNS_11raw_istreamESt8functionIFbiNS0_13parse_event_tERS0_EEb"]
    pub fn wpi_json_parse2(
        i: *mut wpi_raw_istream,
        cb: wpi_json_parser_callback_t,
        allow_exceptions: bool,
    ) -> wpi_json;
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json6acceptESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn wpi_json_accept(s: std_string_view) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json6acceptESt4spanIKhLj4294967295EE"]
    pub fn wpi_json_accept1(arr: [u32; 2usize]) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json6acceptERNS_11raw_istreamE"]
    pub fn wpi_json_accept2(i: *mut wpi_raw_istream) -> bool;
}
extern "C" {
    #[doc = "@brief return the type as string\n\nReturns the type name as string to be used in error messages - usually to\nindicate that a function was called on a wrong JSON type.\n\n@return a string representation of a the @a m_type member:\nValue type  | return value\n----------- | -------------\nnull        | `\"null\"`\nboolean     | `\"boolean\"`\nstring      | `\"string\"`\nnumber      | `\"number\"` (for all number types)\nobject      | `\"object\"`\narray       | `\"array\"`\ndiscarded   | `\"discarded\"`\n\n@exceptionsafety No-throw guarantee: this function never throws exceptions.\n\n@complexity Constant.\n\n@liveexample{The following code exemplifies `type_name()` for all JSON\ntypes.,type_name}\n\n@sa @ref type() -- return the type of the JSON value\n@sa @ref operator value_t() -- return the type of the JSON value (implicit)\n\n@since version 1.0.0, public since 2.1.0, `const char*` and `noexcept`\nsince 3.0.0"]
    #[link_name = "\u{1}_ZNK3wpi4json9type_nameEv"]
    pub fn wpi_json_type_name(this: *const wpi_json) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = "@brief create a CBOR serialization of a given JSON value\n\nSerializes a given JSON value @a j to a byte vector using the CBOR (Concise\nBinary Object Representation) serialization format. CBOR is a binary\nserialization format which aims to be more compact than JSON itself, yet\nmore efficient to parse.\n\nThe library uses the following mapping from JSON values types to\nCBOR types according to the CBOR specification (RFC 7049):\n\nJSON value type | value/range                                | CBOR type                          | first byte\n--------------- | ------------------------------------------ | ---------------------------------- | ---------------\nnull            | `null`                                     | Null                               | 0xF6\nboolean         | `true`                                     | True                               | 0xF5\nboolean         | `false`                                    | False                              | 0xF4\nnumber_integer  | -9223372036854775808..-2147483649          | Negative integer (8 bytes follow)  | 0x3B\nnumber_integer  | -2147483648..-32769                        | Negative integer (4 bytes follow)  | 0x3A\nnumber_integer  | -32768..-129                               | Negative integer (2 bytes follow)  | 0x39\nnumber_integer  | -128..-25                                  | Negative integer (1 byte follow)   | 0x38\nnumber_integer  | -24..-1                                    | Negative integer                   | 0x20..0x37\nnumber_integer  | 0..23                                      | Integer                            | 0x00..0x17\nnumber_integer  | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18\nnumber_integer  | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19\nnumber_integer  | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A\nnumber_integer  | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B\nnumber_unsigned | 0..23                                      | Integer                            | 0x00..0x17\nnumber_unsigned | 24..255                                    | Unsigned integer (1 byte follow)   | 0x18\nnumber_unsigned | 256..65535                                 | Unsigned integer (2 bytes follow)  | 0x19\nnumber_unsigned | 65536..4294967295                          | Unsigned integer (4 bytes follow)  | 0x1A\nnumber_unsigned | 4294967296..18446744073709551615           | Unsigned integer (8 bytes follow)  | 0x1B\nnumber_float    | *any value*                                | Double-Precision Float             | 0xFB\nstring          | *length*: 0..23                            | UTF-8 string                       | 0x60..0x77\nstring          | *length*: 23..255                          | UTF-8 string (1 byte follow)       | 0x78\nstring          | *length*: 256..65535                       | UTF-8 string (2 bytes follow)      | 0x79\nstring          | *length*: 65536..4294967295                | UTF-8 string (4 bytes follow)      | 0x7A\nstring          | *length*: 4294967296..18446744073709551615 | UTF-8 string (8 bytes follow)      | 0x7B\narray           | *size*: 0..23                              | array                              | 0x80..0x97\narray           | *size*: 23..255                            | array (1 byte follow)              | 0x98\narray           | *size*: 256..65535                         | array (2 bytes follow)             | 0x99\narray           | *size*: 65536..4294967295                  | array (4 bytes follow)             | 0x9A\narray           | *size*: 4294967296..18446744073709551615   | array (8 bytes follow)             | 0x9B\nobject          | *size*: 0..23                              | map                                | 0xA0..0xB7\nobject          | *size*: 23..255                            | map (1 byte follow)                | 0xB8\nobject          | *size*: 256..65535                         | map (2 bytes follow)               | 0xB9\nobject          | *size*: 65536..4294967295                  | map (4 bytes follow)               | 0xBA\nobject          | *size*: 4294967296..18446744073709551615   | map (8 bytes follow)               | 0xBB\n\n@note The mapping is **complete** in the sense that any JSON value type\ncan be converted to a CBOR value.\n\n@note If NaN or Infinity are stored inside a JSON number, they are\nserialized properly. This behavior differs from the @ref dump()\nfunction which serializes NaN or Infinity to `null`.\n\n@note The following CBOR types are not used in the conversion:\n- byte strings (0x40..0x5F)\n- UTF-8 strings terminated by \"break\" (0x7F)\n- arrays terminated by \"break\" (0x9F)\n- maps terminated by \"break\" (0xBF)\n- date/time (0xC0..0xC1)\n- bignum (0xC2..0xC3)\n- decimal fraction (0xC4)\n- bigfloat (0xC5)\n- tagged items (0xC6..0xD4, 0xD8..0xDB)\n- expected conversions (0xD5..0xD7)\n- simple values (0xE0..0xF3, 0xF8)\n- undefined (0xF7)\n- half and single-precision floats (0xF9-0xFA)\n- break (0xFF)\n\n@param[in] j  JSON value to serialize\n@return MessagePack serialization as byte vector\n\n@complexity Linear in the size of the JSON value @a j.\n\n@liveexample{The example shows the serialization of a JSON value to a byte\nvector in CBOR format.,to_cbor}\n\n@sa http://cbor.io\n@sa @ref from_cbor(raw_istream&, const bool strict) for the\nanalogous deserialization\n@sa @ref to_msgpack(const json&) for the related MessagePack format\n@sa @ref to_ubjson(const json&, const bool, const bool) for the\nrelated UBJSON format\n\n@since version 2.0.9"]
    #[link_name = "\u{1}_ZN3wpi4json7to_cborERKS0_"]
    pub fn wpi_json_to_cbor(j: *const wpi_json) -> [u32; 3usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json7to_cborERKS0_RSt6vectorIhSaIhEE"]
    pub fn wpi_json_to_cbor1(j: *const wpi_json, buf: *mut [u32; 3usize]) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json7to_cborERKS0_RNS_15SmallVectorImplIhEE"]
    pub fn wpi_json_to_cbor2(j: *const wpi_json, buf: *mut wpi_SmallVectorImpl) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json7to_cborERNS_11raw_ostreamERKS0_"]
    pub fn wpi_json_to_cbor3(os: *mut wpi_raw_ostream, j: *const wpi_json);
}
extern "C" {
    #[doc = "@brief create a MessagePack serialization of a given JSON value\n\nSerializes a given JSON value @a j to a byte vector using the MessagePack\nserialization format. MessagePack is a binary serialization format which\naims to be more compact than JSON itself, yet more efficient to parse.\n\nThe library uses the following mapping from JSON values types to\nMessagePack types according to the MessagePack specification:\n\nJSON value type | value/range                       | MessagePack type | first byte\n--------------- | --------------------------------- | ---------------- | ----------\nnull            | `null`                            | nil              | 0xC0\nboolean         | `true`                            | true             | 0xC3\nboolean         | `false`                           | false            | 0xC2\nnumber_integer  | -9223372036854775808..-2147483649 | int64            | 0xD3\nnumber_integer  | -2147483648..-32769               | int32            | 0xD2\nnumber_integer  | -32768..-129                      | int16            | 0xD1\nnumber_integer  | -128..-33                         | int8             | 0xD0\nnumber_integer  | -32..-1                           | negative fixint  | 0xE0..0xFF\nnumber_integer  | 0..127                            | positive fixint  | 0x00..0x7F\nnumber_integer  | 128..255                          | uint 8           | 0xCC\nnumber_integer  | 256..65535                        | uint 16          | 0xCD\nnumber_integer  | 65536..4294967295                 | uint 32          | 0xCE\nnumber_integer  | 4294967296..18446744073709551615  | uint 64          | 0xCF\nnumber_unsigned | 0..127                            | positive fixint  | 0x00..0x7F\nnumber_unsigned | 128..255                          | uint 8           | 0xCC\nnumber_unsigned | 256..65535                        | uint 16          | 0xCD\nnumber_unsigned | 65536..4294967295                 | uint 32          | 0xCE\nnumber_unsigned | 4294967296..18446744073709551615  | uint 64          | 0xCF\nnumber_float    | *any value*                       | float 64         | 0xCB\nstring          | *length*: 0..31                   | fixstr           | 0xA0..0xBF\nstring          | *length*: 32..255                 | str 8            | 0xD9\nstring          | *length*: 256..65535              | str 16           | 0xDA\nstring          | *length*: 65536..4294967295       | str 32           | 0xDB\narray           | *size*: 0..15                     | fixarray         | 0x90..0x9F\narray           | *size*: 16..65535                 | array 16         | 0xDC\narray           | *size*: 65536..4294967295         | array 32         | 0xDD\nobject          | *size*: 0..15                     | fix map          | 0x80..0x8F\nobject          | *size*: 16..65535                 | map 16           | 0xDE\nobject          | *size*: 65536..4294967295         | map 32           | 0xDF\n\n@note The mapping is **complete** in the sense that any JSON value type\ncan be converted to a MessagePack value.\n\n@note The following values can **not** be converted to a MessagePack value:\n- strings with more than 4294967295 bytes\n- arrays with more than 4294967295 elements\n- objects with more than 4294967295 elements\n\n@note The following MessagePack types are not used in the conversion:\n- bin 8 - bin 32 (0xC4..0xC6)\n- ext 8 - ext 32 (0xC7..0xC9)\n- float 32 (0xCA)\n- fixext 1 - fixext 16 (0xD4..0xD8)\n\n@note Any MessagePack output created @ref to_msgpack can be successfully\nparsed by @ref from_msgpack.\n\n@note If NaN or Infinity are stored inside a JSON number, they are\nserialized properly. This behavior differs from the @ref dump()\nfunction which serializes NaN or Infinity to `null`.\n\n@param[in] j  JSON value to serialize\n@return MessagePack serialization as byte vector\n\n@complexity Linear in the size of the JSON value @a j.\n\n@liveexample{The example shows the serialization of a JSON value to a byte\nvector in MessagePack format.,to_msgpack}\n\n@sa http://msgpack.org\n@sa @ref from_msgpack(const std::vector<uint8_t>&, const size_t) for the\nanalogous deserialization\n@sa @ref to_cbor(const json& for the related CBOR format\n@sa @ref to_ubjson(const json&, const bool, const bool) for the\nrelated UBJSON format\n\n@since version 2.0.9"]
    #[link_name = "\u{1}_ZN3wpi4json10to_msgpackERKS0_"]
    pub fn wpi_json_to_msgpack(j: *const wpi_json) -> [u32; 3usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json10to_msgpackERKS0_RSt6vectorIhSaIhEE"]
    pub fn wpi_json_to_msgpack1(j: *const wpi_json, buf: *mut [u32; 3usize]) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json10to_msgpackERKS0_RNS_15SmallVectorImplIhEE"]
    pub fn wpi_json_to_msgpack2(j: *const wpi_json, buf: *mut wpi_SmallVectorImpl)
        -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json10to_msgpackERNS_11raw_ostreamERKS0_"]
    pub fn wpi_json_to_msgpack3(os: *mut wpi_raw_ostream, j: *const wpi_json);
}
extern "C" {
    #[doc = "@brief create a UBJSON serialization of a given JSON value\n\nSerializes a given JSON value @a j to a byte vector using the UBJSON\n(Universal Binary JSON) serialization format. UBJSON aims to be more compact\nthan JSON itself, yet more efficient to parse.\n\nThe library uses the following mapping from JSON values types to\nUBJSON types according to the UBJSON specification:\n\nJSON value type | value/range                       | UBJSON type | marker\n--------------- | --------------------------------- | ----------- | ------\nnull            | `null`                            | null        | `Z`\nboolean         | `true`                            | true        | `T`\nboolean         | `false`                           | false       | `F`\nnumber_integer  | -9223372036854775808..-2147483649 | int64       | `L`\nnumber_integer  | -2147483648..-32769               | int32       | `l`\nnumber_integer  | -32768..-129                      | int16       | `I`\nnumber_integer  | -128..127                         | int8        | `i`\nnumber_integer  | 128..255                          | uint8       | `U`\nnumber_integer  | 256..32767                        | int16       | `I`\nnumber_integer  | 32768..2147483647                 | int32       | `l`\nnumber_integer  | 2147483648..9223372036854775807   | int64       | `L`\nnumber_unsigned | 0..127                            | int8        | `i`\nnumber_unsigned | 128..255                          | uint8       | `U`\nnumber_unsigned | 256..32767                        | int16       | `I`\nnumber_unsigned | 32768..2147483647                 | int32       | `l`\nnumber_unsigned | 2147483648..9223372036854775807   | int64       | `L`\nnumber_float    | *any value*                       | float64     | `D`\nstring          | *with shortest length indicator*  | string      | `S`\narray           | *see notes on optimized format*   | array       | `[`\nobject          | *see notes on optimized format*   | map         | `{`\n\n@note The mapping is **complete** in the sense that any JSON value type\ncan be converted to a UBJSON value.\n\n@note The following values can **not** be converted to a UBJSON value:\n- strings with more than 9223372036854775807 bytes (theoretical)\n- unsigned integer numbers above 9223372036854775807\n\n@note The following markers are not used in the conversion:\n- `Z`: no-op values are not created.\n- `C`: single-byte strings are serialized with `S` markers.\n\n@note Any UBJSON output created @ref to_ubjson can be successfully parsed\nby @ref from_ubjson.\n\n@note If NaN or Infinity are stored inside a JSON number, they are\nserialized properly. This behavior differs from the @ref dump()\nfunction which serializes NaN or Infinity to `null`.\n\n@note The optimized formats for containers are supported: Parameter\n@a use_size adds size information to the beginning of a container and\nremoves the closing marker. Parameter @a use_type further checks\nwhether all elements of a container have the same type and adds the\ntype marker to the beginning of the container. The @a use_type\nparameter must only be used together with @a use_size = true. Note\nthat @a use_size = true alone may result in larger representations -\nthe benefit of this parameter is that the receiving side is\nimmediately informed on the number of elements of the container.\n\n@param[in] j  JSON value to serialize\n@param[in] use_size  whether to add size annotations to container types\n@param[in] use_type  whether to add type annotations to container types\n(must be combined with @a use_size = true)\n@return UBJSON serialization as byte vector\n\n@complexity Linear in the size of the JSON value @a j.\n\n@liveexample{The example shows the serialization of a JSON value to a byte\nvector in UBJSON format.,to_ubjson}\n\n@sa http://ubjson.org\n@sa @ref from_ubjson(raw_istream&, const bool strict) for the\nanalogous deserialization\n@sa @ref to_cbor(const json& for the related CBOR format\n@sa @ref to_msgpack(const json&) for the related MessagePack format\n\n@since version 3.1.0"]
    #[link_name = "\u{1}_ZN3wpi4json9to_ubjsonERKS0_bb"]
    pub fn wpi_json_to_ubjson(j: *const wpi_json, use_size: bool, use_type: bool) -> [u32; 3usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json9to_ubjsonERKS0_RSt6vectorIhSaIhEEbb"]
    pub fn wpi_json_to_ubjson1(
        j: *const wpi_json,
        buf: *mut [u32; 3usize],
        use_size: bool,
        use_type: bool,
    ) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json9to_ubjsonERKS0_RNS_15SmallVectorImplIhEEbb"]
    pub fn wpi_json_to_ubjson2(
        j: *const wpi_json,
        buf: *mut wpi_SmallVectorImpl,
        use_size: bool,
        use_type: bool,
    ) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json9to_ubjsonERNS_11raw_ostreamERKS0_bb"]
    pub fn wpi_json_to_ubjson3(
        os: *mut wpi_raw_ostream,
        j: *const wpi_json,
        use_size: bool,
        use_type: bool,
    );
}
extern "C" {
    #[doc = "@brief create a JSON value from an input in CBOR format\n\nDeserializes a given input @a i to a JSON value using the CBOR (Concise\nBinary Object Representation) serialization format.\n\nThe library maps CBOR types to JSON value types as follows:\n\nCBOR type              | JSON value type | first byte\n---------------------- | --------------- | ----------\nInteger                | number_unsigned | 0x00..0x17\nUnsigned integer       | number_unsigned | 0x18\nUnsigned integer       | number_unsigned | 0x19\nUnsigned integer       | number_unsigned | 0x1A\nUnsigned integer       | number_unsigned | 0x1B\nNegative integer       | number_integer  | 0x20..0x37\nNegative integer       | number_integer  | 0x38\nNegative integer       | number_integer  | 0x39\nNegative integer       | number_integer  | 0x3A\nNegative integer       | number_integer  | 0x3B\nNegative integer       | number_integer  | 0x40..0x57\nUTF-8 string           | string          | 0x60..0x77\nUTF-8 string           | string          | 0x78\nUTF-8 string           | string          | 0x79\nUTF-8 string           | string          | 0x7A\nUTF-8 string           | string          | 0x7B\nUTF-8 string           | string          | 0x7F\narray                  | array           | 0x80..0x97\narray                  | array           | 0x98\narray                  | array           | 0x99\narray                  | array           | 0x9A\narray                  | array           | 0x9B\narray                  | array           | 0x9F\nmap                    | object          | 0xA0..0xB7\nmap                    | object          | 0xB8\nmap                    | object          | 0xB9\nmap                    | object          | 0xBA\nmap                    | object          | 0xBB\nmap                    | object          | 0xBF\nFalse                  | `false`         | 0xF4\nTrue                   | `true`          | 0xF5\nNill                   | `null`          | 0xF6\nHalf-Precision Float   | number_float    | 0xF9\nSingle-Precision Float | number_float    | 0xFA\nDouble-Precision Float | number_float    | 0xFB\n\n@warning The mapping is **incomplete** in the sense that not all CBOR\ntypes can be converted to a JSON value. The following CBOR types\nare not supported and will yield parse errors (parse_error.112):\n- byte strings (0x40..0x5F)\n- date/time (0xC0..0xC1)\n- bignum (0xC2..0xC3)\n- decimal fraction (0xC4)\n- bigfloat (0xC5)\n- tagged items (0xC6..0xD4, 0xD8..0xDB)\n- expected conversions (0xD5..0xD7)\n- simple values (0xE0..0xF3, 0xF8)\n- undefined (0xF7)\n\n@warning CBOR allows map keys of any type, whereas JSON only allows\nstrings as keys in object values. Therefore, CBOR maps with keys\nother than UTF-8 strings are rejected (parse_error.113).\n\n@note Any CBOR output created @ref to_cbor can be successfully parsed by\n@ref from_cbor.\n\n@param[in] i  an input in CBOR format convertible to an input adapter\n@param[in] strict  whether to expect the input to be consumed until EOF\n(true by default)\n@return deserialized JSON value\n\n@throw parse_error.110 if the given input ends prematurely or the end of\nfile was not reached when @a strict was set to true\n@throw parse_error.112 if unsupported features from CBOR were\nused in the given input @a v or if the input is not valid CBOR\n@throw parse_error.113 if a string was expected as map key, but not found\n\n@complexity Linear in the size of the input @a i.\n\n@liveexample{The example shows the deserialization of a byte vector in CBOR\nformat to a JSON value.,from_cbor}\n\n@sa http://cbor.io\n@sa @ref to_cbor(const json&) for the analogous serialization\n@sa @ref from_msgpack(raw_istream&, const bool) for the\nrelated MessagePack format\n@sa @ref from_ubjson(raw_istream&, const bool) for the related\nUBJSON format\n\n@since version 2.0.9; parameter @a start_index since 2.1.1; changed to\nconsume input adapters, removed start_index parameter, and added\n@a strict parameter since 3.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json9from_cborERNS_11raw_istreamEb"]
    pub fn wpi_json_from_cbor(is: *mut wpi_raw_istream, strict: bool) -> wpi_json;
}
extern "C" {
    #[doc = "@copydoc from_cbor(raw_istream&, const bool)"]
    #[link_name = "\u{1}_ZN3wpi4json9from_cborESt4spanIKhLj4294967295EEb"]
    pub fn wpi_json_from_cbor1(arr: [u32; 2usize], strict: bool) -> wpi_json;
}
extern "C" {
    #[doc = "@brief create a JSON value from an input in MessagePack format\n\nDeserializes a given input @a i to a JSON value using the MessagePack\nserialization format.\n\nThe library maps MessagePack types to JSON value types as follows:\n\nMessagePack type | JSON value type | first byte\n---------------- | --------------- | ----------\npositive fixint  | number_unsigned | 0x00..0x7F\nfixmap           | object          | 0x80..0x8F\nfixarray         | array           | 0x90..0x9F\nfixstr           | string          | 0xA0..0xBF\nnil              | `null`          | 0xC0\nfalse            | `false`         | 0xC2\ntrue             | `true`          | 0xC3\nfloat 32         | number_float    | 0xCA\nfloat 64         | number_float    | 0xCB\nuint 8           | number_unsigned | 0xCC\nuint 16          | number_unsigned | 0xCD\nuint 32          | number_unsigned | 0xCE\nuint 64          | number_unsigned | 0xCF\nint 8            | number_integer  | 0xD0\nint 16           | number_integer  | 0xD1\nint 32           | number_integer  | 0xD2\nint 64           | number_integer  | 0xD3\nstr 8            | string          | 0xD9\nstr 16           | string          | 0xDA\nstr 32           | string          | 0xDB\narray 16         | array           | 0xDC\narray 32         | array           | 0xDD\nmap 16           | object          | 0xDE\nmap 32           | object          | 0xDF\nnegative fixint  | number_integer  | 0xE0-0xFF\n\n@warning The mapping is **incomplete** in the sense that not all\nMessagePack types can be converted to a JSON value. The following\nMessagePack types are not supported and will yield parse errors:\n- bin 8 - bin 32 (0xC4..0xC6)\n- ext 8 - ext 32 (0xC7..0xC9)\n- fixext 1 - fixext 16 (0xD4..0xD8)\n\n@note Any MessagePack output created @ref to_msgpack can be successfully\nparsed by @ref from_msgpack.\n\n@param[in] i  an input in MessagePack format convertible to an input\nadapter\n@param[in] strict  whether to expect the input to be consumed until EOF\n(true by default)\n\n@throw parse_error.110 if the given input ends prematurely or the end of\nfile was not reached when @a strict was set to true\n@throw parse_error.112 if unsupported features from MessagePack were\nused in the given input @a i or if the input is not valid MessagePack\n@throw parse_error.113 if a string was expected as map key, but not found\n\n@complexity Linear in the size of the input @a i.\n\n@liveexample{The example shows the deserialization of a byte vector in\nMessagePack format to a JSON value.,from_msgpack}\n\n@sa http://msgpack.org\n@sa @ref to_msgpack(const json&) for the analogous serialization\n@sa @ref from_cbor(raw_istream&, const bool) for the related CBOR\nformat\n@sa @ref from_ubjson(raw_istream&, const bool) for the related\nUBJSON format\n\n@since version 2.0.9; parameter @a start_index since 2.1.1; changed to\nconsume input adapters, removed start_index parameter, and added\n@a strict parameter since 3.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json12from_msgpackERNS_11raw_istreamEb"]
    pub fn wpi_json_from_msgpack(is: *mut wpi_raw_istream, strict: bool) -> wpi_json;
}
extern "C" {
    #[doc = "@copydoc from_msgpack(raw_istream&, const bool)"]
    #[link_name = "\u{1}_ZN3wpi4json12from_msgpackESt4spanIKhLj4294967295EEb"]
    pub fn wpi_json_from_msgpack1(arr: [u32; 2usize], strict: bool) -> wpi_json;
}
extern "C" {
    #[doc = "@brief create a JSON value from an input in UBJSON format\n\nDeserializes a given input @a i to a JSON value using the UBJSON (Universal\nBinary JSON) serialization format.\n\nThe library maps UBJSON types to JSON value types as follows:\n\nUBJSON type | JSON value type                         | marker\n----------- | --------------------------------------- | ------\nno-op       | *no value, next value is read*          | `N`\nnull        | `null`                                  | `Z`\nfalse       | `false`                                 | `F`\ntrue        | `true`                                  | `T`\nfloat32     | number_float                            | `d`\nfloat64     | number_float                            | `D`\nuint8       | number_unsigned                         | `U`\nint8        | number_integer                          | `i`\nint16       | number_integer                          | `I`\nint32       | number_integer                          | `l`\nint64       | number_integer                          | `L`\nstring      | string                                  | `S`\nchar        | string                                  | `C`\narray       | array (optimized values are supported)  | `[`\nobject      | object (optimized values are supported) | `{`\n\n@note The mapping is **complete** in the sense that any UBJSON value can\nbe converted to a JSON value.\n\n@param[in] i  an input in UBJSON format convertible to an input adapter\n@param[in] strict  whether to expect the input to be consumed until EOF\n(true by default)\n\n@throw parse_error.110 if the given input ends prematurely or the end of\nfile was not reached when @a strict was set to true\n@throw parse_error.112 if a parse error occurs\n@throw parse_error.113 if a string could not be parsed successfully\n\n@complexity Linear in the size of the input @a i.\n\n@liveexample{The example shows the deserialization of a byte vector in\nUBJSON format to a JSON value.,from_ubjson}\n\n@sa http://ubjson.org\n@sa @ref to_ubjson(const json&, const bool, const bool) for the\nanalogous serialization\n@sa @ref from_cbor(raw_istream&, const bool) for the related CBOR\nformat\n@sa @ref from_msgpack(raw_istream&, const bool) for the related\nMessagePack format\n\n@since version 3.1.0"]
    #[link_name = "\u{1}_ZN3wpi4json11from_ubjsonERNS_11raw_istreamEb"]
    pub fn wpi_json_from_ubjson(is: *mut wpi_raw_istream, strict: bool) -> wpi_json;
}
extern "C" {
    #[link_name = "\u{1}_ZN3wpi4json11from_ubjsonESt4spanIKhLj4294967295EEb"]
    pub fn wpi_json_from_ubjson1(arr: [u32; 2usize], strict: bool) -> wpi_json;
}
extern "C" {
    #[doc = "@brief applies a JSON patch\n\n[JSON Patch](http://jsonpatch.com) defines a JSON document structure for\nexpressing a sequence of operations to apply to a JSON) document. With\nthis function, a JSON Patch is applied to the current JSON value by\nexecuting all operations from the patch.\n\n@param[in] json_patch  JSON patch document\n@return patched document\n\n@note The application of a patch is atomic: Either all operations succeed\nand the patched document is returned or an exception is thrown. In\nany case, the original value is not changed: the patch is applied\nto a copy of the value.\n\n@throw parse_error.104 if the JSON patch does not consist of an array of\nobjects\n\n@throw parse_error.105 if the JSON patch is malformed (e.g., mandatory\nattributes are missing); example: `\"operation add must have member path\"`\n\n@throw out_of_range.401 if an array index is out of range.\n\n@throw out_of_range.403 if a JSON pointer inside the patch could not be\nresolved successfully in the current JSON value; example: `\"key baz not\nfound\"`\n\n@throw out_of_range.405 if JSON pointer has no parent (\"add\", \"remove\",\n\"move\")\n\n@throw other_error.501 if \"test\" operation was unsuccessful\n\n@complexity Linear in the size of the JSON value and the length of the\nJSON patch. As usually only a fraction of the JSON value is affected by\nthe patch, the complexity can usually be neglected.\n\n@liveexample{The following code shows how a JSON patch is applied to a\nvalue.,patch}\n\n@sa @ref diff -- create a JSON patch by comparing two JSON values\n\n@sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)\n@sa [RFC 6901 (JSON Pointer)](https://tools.ietf.org/html/rfc6901)\n\n@since version 2.0.0"]
    #[link_name = "\u{1}_ZNK3wpi4json5patchERKS0_"]
    pub fn wpi_json_patch(this: *const wpi_json, json_patch: *const wpi_json) -> wpi_json;
}
extern "C" {
    #[doc = "@brief creates a diff as a JSON patch\n\nCreates a [JSON Patch](http://jsonpatch.com) so that value @a source can\nbe changed into the value @a target by calling @ref patch function.\n\n@invariant For two JSON values @a source and @a target, the following code\nyields always `true`:\n@code {.cpp}\nsource.patch(diff(source, target)) == target;\n@endcode\n\n@note Currently, only `remove`, `add`, and `replace` operations are\ngenerated.\n\n@param[in] source  JSON value to compare from\n@param[in] target  JSON value to compare against\n@param[in] path    helper value to create JSON pointers\n\n@return a JSON patch to convert the @a source to @a target\n\n@complexity Linear in the lengths of @a source and @a target.\n\n@liveexample{The following code shows how a JSON patch is created as a\ndiff for two JSON values.,diff}\n\n@sa @ref patch -- apply a JSON patch\n@sa @ref merge_patch -- apply a JSON Merge Patch\n\n@sa [RFC 6902 (JSON Patch)](https://tools.ietf.org/html/rfc6902)\n\n@since version 2.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json4diffERKS0_S2_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn wpi_json_diff(
        source: *const wpi_json,
        target: *const wpi_json,
        path: *const std_string,
    ) -> wpi_json;
}
extern "C" {
    #[doc = "@brief applies a JSON Merge Patch\n\nThe merge patch format is primarily intended for use with the HTTP PATCH\nmethod as a means of describing a set of modifications to a target\nresource's content. This function applies a merge patch to the current\nJSON value.\n\nThe function implements the following algorithm from Section 2 of\n[RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396):\n\n```\ndefine MergePatch(Target, Patch):\nif Patch is an Object:\nif Target is not an Object:\nTarget = {} // Ignore the contents and set it to an empty Object\nfor each Name/Value pair in Patch:\nif Value is null:\nif Name exists in Target:\nremove the Name/Value pair from Target\nelse:\nTarget[Name] = MergePatch(Target[Name], Value)\nreturn Target\nelse:\nreturn Patch\n```\n\nThereby, `Target` is the current object; that is, the patch is applied to\nthe current value.\n\n@param[in] patch  the patch to apply\n\n@complexity Linear in the lengths of @a patch.\n\n@liveexample{The following code shows how a JSON Merge Patch is applied to\na JSON document.,merge_patch}\n\n@sa @ref patch -- apply a JSON patch\n@sa [RFC 7396 (JSON Merge Patch)](https://tools.ietf.org/html/rfc7396)\n\n@since version 3.0.0"]
    #[link_name = "\u{1}_ZN3wpi4json11merge_patchERKS0_"]
    pub fn wpi_json_merge_patch(this: *mut wpi_json, patch: *const wpi_json);
}
extern "C" {
    #[doc = "@brief create a container (array or object) from an initializer list\n\nCreates a JSON value of type array or object from the passed initializer\nlist @a init. In case @a type_deduction is `true` (default), the type of\nthe JSON value to be created is deducted from the initializer list @a init\naccording to the following rules:\n\n1. If the list is empty, an empty JSON object value `{}` is created.\n2. If the list consists of pairs whose first element is a string, a JSON\nobject value is created where the first elements of the pairs are\ntreated as keys and the second elements are as values.\n3. In all other cases, an array is created.\n\nThe rules aim to create the best fit between a C++ initializer list and\nJSON values. The rationale is as follows:\n\n1. The empty initializer list is written as `{}` which is exactly an empty\nJSON object.\n2. C++ has no way of describing mapped types other than to list a list of\npairs. As JSON requires that keys must be of type string, rule 2 is the\nweakest constraint one can pose on initializer lists to interpret them\nas an object.\n3. In all other cases, the initializer list could not be interpreted as\nJSON object type, so interpreting it as JSON array type is safe.\n\nWith the rules described above, the following JSON values cannot be\nexpressed by an initializer list:\n\n- the empty array (`[]`): use @ref array(initializer_list_t)\nwith an empty initializer list in this case\n- arrays whose elements satisfy rule 2: use @ref\narray(initializer_list_t) with the same initializer list\nin this case\n\n@note When used without parentheses around an empty initializer list, @ref\njson() is called instead of this function, yielding the JSON null\nvalue.\n\n@param[in] init  initializer list with JSON values\n\n@param[in] type_deduction internal parameter; when set to `true`, the type\nof the JSON value is deducted from the initializer list @a init; when set\nto `false`, the type provided via @a manual_type is forced. This mode is\nused by the functions @ref array(initializer_list_t) and\n@ref object(initializer_list_t).\n\n@param[in] manual_type internal parameter; when @a type_deduction is set\nto `false`, the created JSON value will use the provided type (only @ref\nvalue_t::array and @ref value_t::object are valid); when @a type_deduction\nis set to `true`, this parameter has no effect\n\n@throw type_error.301 if @a type_deduction is `false`, @a manual_type is\n`value_t::object`, but @a init contains an element which is not a pair\nwhose first element is a string. In this case, the constructor could not\ncreate an object. If @a type_deduction would have be `true`, an array\nwould have been created. See @ref object(initializer_list_t)\nfor an example.\n\n@complexity Linear in the size of the initializer list @a init.\n\n@exceptionsafety Strong guarantee: if an exception is thrown, there are no\nchanges to any JSON value.\n\n@liveexample{The example below shows how JSON values are created from\ninitializer lists.,json__list_init_t}\n\n@sa @ref array(initializer_list_t) -- create a JSON array\nvalue from an initializer list\n@sa @ref object(initializer_list_t) -- create a JSON object\nvalue from an initializer list\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZN3wpi4jsonC1ESt16initializer_listINS_6detail8json_refIS0_EEEbNS2_7value_tE"]
    pub fn wpi_json_json(
        this: *mut wpi_json,
        init: wpi_json_initializer_list_t,
        type_deduction: bool,
        manual_type: wpi_json_value_t,
    );
}
extern "C" {
    #[doc = "@brief construct an array with count copies of given value\n\nConstructs a JSON array value by creating @a cnt copies of a passed value.\nIn case @a cnt is `0`, an empty array is created.\n\n@param[in] cnt  the number of JSON copies of @a val to create\n@param[in] val  the JSON value to copy\n\n@post `std::distance(begin(),end()) == cnt` holds.\n\n@complexity Linear in @a cnt.\n\n@exceptionsafety Strong guarantee: if an exception is thrown, there are no\nchanges to any JSON value.\n\n@liveexample{The following code shows examples for the @ref\njson(size_type\\, const json&)\nconstructor.,json__size_type_json}\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZN3wpi4jsonC1EjRKS0_"]
    pub fn wpi_json_json1(this: *mut wpi_json, cnt: wpi_json_size_type, val: *const wpi_json);
}
extern "C" {
    #[doc = "@brief copy constructor\n\nCreates a copy of a given JSON value.\n\n@param[in] other  the JSON value to copy\n\n@post `*this == other`\n\n@complexity Linear in the size of @a other.\n\n@exceptionsafety Strong guarantee: if an exception is thrown, there are no\nchanges to any JSON value.\n\n@requirement This function helps `json` satisfying the\n[Container](http://en.cppreference.com/w/cpp/concept/Container)\nrequirements:\n- The complexity is linear.\n- As postcondition, it holds: `other == json(other)`.\n\n@liveexample{The following code shows an example for the copy\nconstructor.,json__json}\n\n@since version 1.0.0"]
    #[link_name = "\u{1}_ZN3wpi4jsonC1ERKS0_"]
    pub fn wpi_json_json2(this: *mut wpi_json, other: *const wpi_json);
}
impl wpi_json {
    #[inline]
    pub unsafe fn meta() -> wpi_json {
        wpi_json_meta()
    }
    #[inline]
    pub unsafe fn dump(
        &self,
        indent: ::std::os::raw::c_int,
        indent_char: ::std::os::raw::c_char,
        ensure_ascii: bool,
    ) -> std_string {
        wpi_json_dump(self, indent, indent_char, ensure_ascii)
    }
    #[inline]
    pub unsafe fn dump1(
        &self,
        os: *mut wpi_raw_ostream,
        indent: ::std::os::raw::c_int,
        indent_char: ::std::os::raw::c_char,
        ensure_ascii: bool,
    ) {
        wpi_json_dump1(self, os, indent, indent_char, ensure_ascii)
    }
    #[inline]
    pub unsafe fn at(&mut self, idx: wpi_json_size_type) -> wpi_json_reference {
        wpi_json_at(self, idx)
    }
    #[inline]
    pub unsafe fn at1(&self, idx: wpi_json_size_type) -> wpi_json_const_reference {
        wpi_json_at1(self, idx)
    }
    #[inline]
    pub unsafe fn at2(&mut self, key: std_string_view) -> wpi_json_reference {
        wpi_json_at2(self, key)
    }
    #[inline]
    pub unsafe fn at3(&self, key: std_string_view) -> wpi_json_const_reference {
        wpi_json_at3(self, key)
    }
    #[inline]
    pub unsafe fn erase(&mut self, key: std_string_view) -> wpi_json_size_type {
        wpi_json_erase(self, key)
    }
    #[inline]
    pub unsafe fn erase1(&mut self, idx: wpi_json_size_type) {
        wpi_json_erase1(self, idx)
    }
    #[inline]
    pub unsafe fn find(&mut self, key: std_string_view) -> wpi_json_iterator {
        wpi_json_find(self, key)
    }
    #[inline]
    pub unsafe fn find1(&self, key: std_string_view) -> wpi_json_const_iterator {
        wpi_json_find1(self, key)
    }
    #[inline]
    pub unsafe fn count(&self, key: std_string_view) -> wpi_json_size_type {
        wpi_json_count(self, key)
    }
    #[inline]
    pub unsafe fn empty(&self) -> bool {
        wpi_json_empty(self)
    }
    #[inline]
    pub unsafe fn size(&self) -> wpi_json_size_type {
        wpi_json_size(self)
    }
    #[inline]
    pub unsafe fn max_size(&self) -> wpi_json_size_type {
        wpi_json_max_size(self)
    }
    #[inline]
    pub unsafe fn clear(&mut self) {
        wpi_json_clear(self)
    }
    #[inline]
    pub unsafe fn push_back(&mut self, val: *mut wpi_json) {
        wpi_json_push_back(self, val)
    }
    #[inline]
    pub unsafe fn push_back1(&mut self, val: *const wpi_json) {
        wpi_json_push_back1(self, val)
    }
    #[inline]
    pub unsafe fn push_back2(&mut self, init: wpi_json_initializer_list_t) {
        wpi_json_push_back2(self, init)
    }
    #[inline]
    pub unsafe fn insert(
        &mut self,
        pos: wpi_json_const_iterator,
        val: *const wpi_json,
    ) -> wpi_json_iterator {
        wpi_json_insert(self, pos, val)
    }
    #[inline]
    pub unsafe fn insert1(
        &mut self,
        pos: wpi_json_const_iterator,
        cnt: wpi_json_size_type,
        val: *const wpi_json,
    ) -> wpi_json_iterator {
        wpi_json_insert1(self, pos, cnt, val)
    }
    #[inline]
    pub unsafe fn insert2(
        &mut self,
        pos: wpi_json_const_iterator,
        first: wpi_json_const_iterator,
        last: wpi_json_const_iterator,
    ) -> wpi_json_iterator {
        wpi_json_insert2(self, pos, first, last)
    }
    #[inline]
    pub unsafe fn insert3(
        &mut self,
        pos: wpi_json_const_iterator,
        ilist: wpi_json_initializer_list_t,
    ) -> wpi_json_iterator {
        wpi_json_insert3(self, pos, ilist)
    }
    #[inline]
    pub unsafe fn insert4(
        &mut self,
        first: wpi_json_const_iterator,
        last: wpi_json_const_iterator,
    ) {
        wpi_json_insert4(self, first, last)
    }
    #[inline]
    pub unsafe fn update(&mut self, j: wpi_json_const_reference) {
        wpi_json_update(self, j)
    }
    #[inline]
    pub unsafe fn update1(
        &mut self,
        first: wpi_json_const_iterator,
        last: wpi_json_const_iterator,
    ) {
        wpi_json_update1(self, first, last)
    }
    #[inline]
    pub unsafe fn parse(
        s: std_string_view,
        cb: wpi_json_parser_callback_t,
        allow_exceptions: bool,
    ) -> wpi_json {
        wpi_json_parse(s, cb, allow_exceptions)
    }
    #[inline]
    pub unsafe fn parse1(
        arr: [u32; 2usize],
        cb: wpi_json_parser_callback_t,
        allow_exceptions: bool,
    ) -> wpi_json {
        wpi_json_parse1(arr, cb, allow_exceptions)
    }
    #[inline]
    pub unsafe fn parse2(
        i: *mut wpi_raw_istream,
        cb: wpi_json_parser_callback_t,
        allow_exceptions: bool,
    ) -> wpi_json {
        wpi_json_parse2(i, cb, allow_exceptions)
    }
    #[inline]
    pub unsafe fn accept(s: std_string_view) -> bool {
        wpi_json_accept(s)
    }
    #[inline]
    pub unsafe fn accept1(arr: [u32; 2usize]) -> bool {
        wpi_json_accept1(arr)
    }
    #[inline]
    pub unsafe fn accept2(i: *mut wpi_raw_istream) -> bool {
        wpi_json_accept2(i)
    }
    #[inline]
    pub unsafe fn type_name(&self) -> *const ::std::os::raw::c_char {
        wpi_json_type_name(self)
    }
    #[inline]
    pub unsafe fn to_cbor(j: *const wpi_json) -> [u32; 3usize] {
        wpi_json_to_cbor(j)
    }
    #[inline]
    pub unsafe fn to_cbor1(j: *const wpi_json, buf: *mut [u32; 3usize]) -> [u32; 2usize] {
        wpi_json_to_cbor1(j, buf)
    }
    #[inline]
    pub unsafe fn to_cbor2(j: *const wpi_json, buf: *mut wpi_SmallVectorImpl) -> [u32; 2usize] {
        wpi_json_to_cbor2(j, buf)
    }
    #[inline]
    pub unsafe fn to_cbor3(os: *mut wpi_raw_ostream, j: *const wpi_json) {
        wpi_json_to_cbor3(os, j)
    }
    #[inline]
    pub unsafe fn to_msgpack(j: *const wpi_json) -> [u32; 3usize] {
        wpi_json_to_msgpack(j)
    }
    #[inline]
    pub unsafe fn to_msgpack1(j: *const wpi_json, buf: *mut [u32; 3usize]) -> [u32; 2usize] {
        wpi_json_to_msgpack1(j, buf)
    }
    #[inline]
    pub unsafe fn to_msgpack2(j: *const wpi_json, buf: *mut wpi_SmallVectorImpl) -> [u32; 2usize] {
        wpi_json_to_msgpack2(j, buf)
    }
    #[inline]
    pub unsafe fn to_msgpack3(os: *mut wpi_raw_ostream, j: *const wpi_json) {
        wpi_json_to_msgpack3(os, j)
    }
    #[inline]
    pub unsafe fn to_ubjson(j: *const wpi_json, use_size: bool, use_type: bool) -> [u32; 3usize] {
        wpi_json_to_ubjson(j, use_size, use_type)
    }
    #[inline]
    pub unsafe fn to_ubjson1(
        j: *const wpi_json,
        buf: *mut [u32; 3usize],
        use_size: bool,
        use_type: bool,
    ) -> [u32; 2usize] {
        wpi_json_to_ubjson1(j, buf, use_size, use_type)
    }
    #[inline]
    pub unsafe fn to_ubjson2(
        j: *const wpi_json,
        buf: *mut wpi_SmallVectorImpl,
        use_size: bool,
        use_type: bool,
    ) -> [u32; 2usize] {
        wpi_json_to_ubjson2(j, buf, use_size, use_type)
    }
    #[inline]
    pub unsafe fn to_ubjson3(
        os: *mut wpi_raw_ostream,
        j: *const wpi_json,
        use_size: bool,
        use_type: bool,
    ) {
        wpi_json_to_ubjson3(os, j, use_size, use_type)
    }
    #[inline]
    pub unsafe fn from_cbor(is: *mut wpi_raw_istream, strict: bool) -> wpi_json {
        wpi_json_from_cbor(is, strict)
    }
    #[inline]
    pub unsafe fn from_cbor1(arr: [u32; 2usize], strict: bool) -> wpi_json {
        wpi_json_from_cbor1(arr, strict)
    }
    #[inline]
    pub unsafe fn from_msgpack(is: *mut wpi_raw_istream, strict: bool) -> wpi_json {
        wpi_json_from_msgpack(is, strict)
    }
    #[inline]
    pub unsafe fn from_msgpack1(arr: [u32; 2usize], strict: bool) -> wpi_json {
        wpi_json_from_msgpack1(arr, strict)
    }
    #[inline]
    pub unsafe fn from_ubjson(is: *mut wpi_raw_istream, strict: bool) -> wpi_json {
        wpi_json_from_ubjson(is, strict)
    }
    #[inline]
    pub unsafe fn from_ubjson1(arr: [u32; 2usize], strict: bool) -> wpi_json {
        wpi_json_from_ubjson1(arr, strict)
    }
    #[inline]
    pub unsafe fn patch(&self, json_patch: *const wpi_json) -> wpi_json {
        wpi_json_patch(self, json_patch)
    }
    #[inline]
    pub unsafe fn diff(
        source: *const wpi_json,
        target: *const wpi_json,
        path: *const std_string,
    ) -> wpi_json {
        wpi_json_diff(source, target, path)
    }
    #[inline]
    pub unsafe fn merge_patch(&mut self, patch: *const wpi_json) {
        wpi_json_merge_patch(self, patch)
    }
    #[inline]
    pub unsafe fn new(
        init: wpi_json_initializer_list_t,
        type_deduction: bool,
        manual_type: wpi_json_value_t,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        wpi_json_json(
            __bindgen_tmp.as_mut_ptr(),
            init,
            type_deduction,
            manual_type,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(cnt: wpi_json_size_type, val: *const wpi_json) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        wpi_json_json1(__bindgen_tmp.as_mut_ptr(), cnt, val);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(other: *const wpi_json) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        wpi_json_json2(__bindgen_tmp.as_mut_ptr(), other);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HAL_ControlWord {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_HAL_ControlWord() {
    assert_eq!(
        ::std::mem::size_of::<HAL_ControlWord>(),
        4usize,
        concat!("Size of: ", stringify!(HAL_ControlWord))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_ControlWord>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_ControlWord))
    );
}
impl HAL_ControlWord {
    #[inline]
    pub fn enabled(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_enabled(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn autonomous(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_autonomous(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn test(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_test(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn eStop(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_eStop(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fmsAttached(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fmsAttached(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dsAttached(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_dsAttached(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn control_reserved(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_control_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        enabled: u32,
        autonomous: u32,
        test: u32,
        eStop: u32,
        fmsAttached: u32,
        dsAttached: u32,
        control_reserved: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let enabled: u32 = unsafe { ::std::mem::transmute(enabled) };
            enabled as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let autonomous: u32 = unsafe { ::std::mem::transmute(autonomous) };
            autonomous as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let test: u32 = unsafe { ::std::mem::transmute(test) };
            test as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let eStop: u32 = unsafe { ::std::mem::transmute(eStop) };
            eStop as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let fmsAttached: u32 = unsafe { ::std::mem::transmute(fmsAttached) };
            fmsAttached as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let dsAttached: u32 = unsafe { ::std::mem::transmute(dsAttached) };
            dsAttached as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let control_reserved: u32 = unsafe { ::std::mem::transmute(control_reserved) };
            control_reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed1: HAL_AllianceStationID = 0;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed2: HAL_AllianceStationID = 1;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kRed3: HAL_AllianceStationID = 2;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue1: HAL_AllianceStationID = 3;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue2: HAL_AllianceStationID = 4;
pub const HAL_AllianceStationID_HAL_AllianceStationID_kBlue3: HAL_AllianceStationID = 5;
pub type HAL_AllianceStationID = i32;
pub const HAL_MatchType_HAL_kMatchType_none: HAL_MatchType = 0;
pub const HAL_MatchType_HAL_kMatchType_practice: HAL_MatchType = 1;
pub const HAL_MatchType_HAL_kMatchType_qualification: HAL_MatchType = 2;
pub const HAL_MatchType_HAL_kMatchType_elimination: HAL_MatchType = 3;
pub type HAL_MatchType = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_JoystickAxes {
    pub count: i16,
    pub axes: [f32; 12usize],
    pub raw: [u8; 12usize],
}
#[test]
fn bindgen_test_layout_HAL_JoystickAxes() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickAxes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickAxes>(),
        64usize,
        concat!("Size of: ", stringify!(HAL_JoystickAxes))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickAxes>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_JoystickAxes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(axes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickAxes),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_JoystickPOVs {
    pub count: i16,
    pub povs: [i16; 12usize],
}
#[test]
fn bindgen_test_layout_HAL_JoystickPOVs() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickPOVs> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickPOVs>(),
        26usize,
        concat!("Size of: ", stringify!(HAL_JoystickPOVs))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickPOVs>(),
        2usize,
        concat!("Alignment of ", stringify!(HAL_JoystickPOVs))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickPOVs),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).povs) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickPOVs),
            "::",
            stringify!(povs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_JoystickButtons {
    pub buttons: u32,
    pub count: u8,
}
#[test]
fn bindgen_test_layout_HAL_JoystickButtons() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickButtons> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickButtons>(),
        8usize,
        concat!("Size of: ", stringify!(HAL_JoystickButtons))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickButtons>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_JoystickButtons))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buttons) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickButtons),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickButtons),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_JoystickDescriptor {
    pub isXbox: u8,
    pub type_: u8,
    pub name: [::std::os::raw::c_char; 256usize],
    pub axisCount: u8,
    pub axisTypes: [u8; 12usize],
    pub buttonCount: u8,
    pub povCount: u8,
}
#[test]
fn bindgen_test_layout_HAL_JoystickDescriptor() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_JoystickDescriptor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_JoystickDescriptor>(),
        273usize,
        concat!("Size of: ", stringify!(HAL_JoystickDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_JoystickDescriptor>(),
        1usize,
        concat!("Alignment of ", stringify!(HAL_JoystickDescriptor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isXbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(isXbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axisCount) as usize - ptr as usize },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(axisCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).axisTypes) as usize - ptr as usize },
        259usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(axisTypes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buttonCount) as usize - ptr as usize },
        271usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(buttonCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).povCount) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_JoystickDescriptor),
            "::",
            stringify!(povCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_MatchInfo {
    pub eventName: [::std::os::raw::c_char; 64usize],
    pub matchType: HAL_MatchType,
    pub matchNumber: u16,
    pub replayNumber: u8,
    pub gameSpecificMessage: [u8; 64usize],
    pub gameSpecificMessageSize: u16,
}
#[test]
fn bindgen_test_layout_HAL_MatchInfo() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_MatchInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_MatchInfo>(),
        140usize,
        concat!("Size of: ", stringify!(HAL_MatchInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_MatchInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_MatchInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eventName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(eventName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matchType) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(matchType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matchNumber) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(matchNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replayNumber) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(replayNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gameSpecificMessage) as usize - ptr as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(gameSpecificMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gameSpecificMessageSize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_MatchInfo),
            "::",
            stringify!(gameSpecificMessageSize)
        )
    );
}
extern "C" {
    #[doc = " Sends an error to the driver station.\n\n @param isError   true for error, false for warning\n @param errorCode the error code\n @param isLVCode  true for a LV error code, false for a standard error code\n @param details   the details of the error\n @param location  the file location of the errror\n @param callStack the callstack of the error\n @param printMsg  true to print the error message to stdout as well as to the\n DS"]
    pub fn HAL_SendError(
        isError: HAL_Bool,
        errorCode: i32,
        isLVCode: HAL_Bool,
        details: *const ::std::os::raw::c_char,
        location: *const ::std::os::raw::c_char,
        callStack: *const ::std::os::raw::c_char,
        printMsg: HAL_Bool,
    ) -> i32;
}
extern "C" {
    #[doc = " Set the print function used by HAL_SendError\n\n @param func Function called by HAL_SendError when stderr is printed"]
    pub fn HAL_SetPrintErrorImpl(
        func: ::std::option::Option<
            unsafe extern "C" fn(line: *const ::std::os::raw::c_char, size: usize),
        >,
    );
}
extern "C" {
    #[doc = " Sends a line to the driver station console.\n\n @param line the line to send (null terminated)"]
    pub fn HAL_SendConsoleLine(line: *const ::std::os::raw::c_char) -> i32;
}
extern "C" {
    #[doc = " Gets the current control word of the driver station.\n\n The control work contains the robot state.\n\n @param controlWord the control word (out)\n @return the error code, or 0 for success"]
    pub fn HAL_GetControlWord(controlWord: *mut HAL_ControlWord) -> i32;
}
extern "C" {
    #[doc = " Gets the current alliance station ID.\n\n @param[out] status the error code, or 0 for success\n @return the alliance station ID"]
    pub fn HAL_GetAllianceStation(status: *mut i32) -> HAL_AllianceStationID;
}
extern "C" {
    #[doc = " Gets the axes of a specific joystick.\n\n @param joystickNum the joystick number\n @param axes        the axes values (output)\n @return the error code, or 0 for success"]
    pub fn HAL_GetJoystickAxes(joystickNum: i32, axes: *mut HAL_JoystickAxes) -> i32;
}
extern "C" {
    #[doc = " Gets the POVs of a specific joystick.\n\n @param joystickNum the joystick number\n @param povs        the POV values (output)\n @return the error code, or 0 for success"]
    pub fn HAL_GetJoystickPOVs(joystickNum: i32, povs: *mut HAL_JoystickPOVs) -> i32;
}
extern "C" {
    #[doc = " Gets the buttons of a specific joystick.\n\n @param joystickNum the joystick number\n @param buttons     the button values (output)\n @return the error code, or 0 for success"]
    pub fn HAL_GetJoystickButtons(joystickNum: i32, buttons: *mut HAL_JoystickButtons) -> i32;
}
extern "C" {
    pub fn HAL_GetAllJoystickData(
        axes: *mut HAL_JoystickAxes,
        povs: *mut HAL_JoystickPOVs,
        buttons: *mut HAL_JoystickButtons,
    );
}
extern "C" {
    #[doc = " Retrieves the Joystick Descriptor for particular slot.\n\n @param joystickNum the joystick number\n @param[out] desc   descriptor (data transfer object) to fill in. desc is\n                    filled in regardless of success. In other words, if\n                    descriptor is not available, desc is filled in with\n                    default values matching the init-values in Java and C++\n                    Driver Station for when caller requests a too-large\n                    joystick index.\n @return error code reported from Network Comm back-end.  Zero is good,\n         nonzero is bad."]
    pub fn HAL_GetJoystickDescriptor(joystickNum: i32, desc: *mut HAL_JoystickDescriptor) -> i32;
}
extern "C" {
    #[doc = " Gets is a specific joystick is considered to be an XBox controller.\n\n @param joystickNum the joystick number\n @return true if xbox, false otherwise"]
    pub fn HAL_GetJoystickIsXbox(joystickNum: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the type of joystick connected.\n\n This is device specific, and different depending on what system input type\n the joystick uses.\n\n @param joystickNum the joystick number\n @return the enumerated joystick type"]
    pub fn HAL_GetJoystickType(joystickNum: i32) -> i32;
}
extern "C" {
    #[doc = " Gets the name of a joystick.\n\n The returned array must be freed with HAL_FreeJoystickName.\n\n Will be null terminated.\n\n @param joystickNum the joystick number\n @return the joystick name"]
    pub fn HAL_GetJoystickName(joystickNum: i32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Frees a joystick name received with HAL_GetJoystickName\n\n @param name the name storage"]
    pub fn HAL_FreeJoystickName(name: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Gets the type of a specific joystick axis.\n\n This is device specific, and different depending on what system input type\n the joystick uses.\n\n @param joystickNum the joystick number\n @param axis        the axis number\n @return the enumerated axis type"]
    pub fn HAL_GetJoystickAxisType(joystickNum: i32, axis: i32) -> i32;
}
extern "C" {
    #[doc = " Set joystick outputs.\n\n @param joystickNum the joystick number\n @param outputs     bitmask of outputs, 1 for on 0 for off\n @param leftRumble  the left rumble value (0-FFFF)\n @param rightRumble the right rumble value (0-FFFF)\n @return the error code, or 0 for success"]
    pub fn HAL_SetJoystickOutputs(
        joystickNum: i32,
        outputs: i64,
        leftRumble: i32,
        rightRumble: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Returns the approximate match time.\n\n The FMS does not send an official match time to the robots, but does send\n an approximate match time. The value will count down the time remaining in\n the current period (auto or teleop).\n\n Warning: This is not an official time (so it cannot be used to dispute ref\n calls or guarantee that a function will trigger before the match ends).\n\n The Practice Match function of the DS approximates the behavior seen on\n the field.\n\n @param[out] status the error code, or 0 for success\n @return time remaining in current match period (auto or teleop)"]
    pub fn HAL_GetMatchTime(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets if outputs are enabled by the control system."]
    pub fn HAL_GetOutputsEnabled() -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets info about a specific match.\n\n @param[in] info the match info (output)\n @return the error code, or 0 for success"]
    pub fn HAL_GetMatchInfo(info: *mut HAL_MatchInfo) -> i32;
}
extern "C" {
    pub fn HAL_RefreshDSData();
}
extern "C" {
    pub fn HAL_ProvideNewDataEventHandle(handle: WPI_EventHandle);
}
extern "C" {
    pub fn HAL_RemoveNewDataEventHandle(handle: WPI_EventHandle);
}
extern "C" {
    #[doc = " Sets the program starting flag in the DS.\n\n This is what changes the DS to showing robot code ready."]
    pub fn HAL_ObserveUserProgramStarting();
}
extern "C" {
    #[doc = " Sets the disabled flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
    pub fn HAL_ObserveUserProgramDisabled();
}
extern "C" {
    #[doc = " Sets the autonomous enabled flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
    pub fn HAL_ObserveUserProgramAutonomous();
}
extern "C" {
    #[doc = " Sets the teleoperated enabled flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
    pub fn HAL_ObserveUserProgramTeleop();
}
extern "C" {
    #[doc = " Sets the test mode flag in the DS.\n\n This is used for the DS to ensure the robot is properly responding to its\n state request. Ensure this gets called about every 50ms, or the robot will be\n disabled by the DS."]
    pub fn HAL_ObserveUserProgramTest();
}
extern "C" {
    #[doc = " Initialize a DutyCycle input.\n\n @param[in] digitalSourceHandle the digital source to use (either a\n                                 HAL_DigitalHandle or a\n                                 HAL_AnalogTriggerHandle)\n @param[in] triggerType the analog trigger type of the source if it is\n                         an analog trigger\n @param[out] status Error status variable. 0 on success.\n @return thre created duty cycle handle"]
    pub fn HAL_InitializeDutyCycle(
        digitalSourceHandle: HAL_Handle,
        triggerType: HAL_AnalogTriggerType,
        status: *mut i32,
    ) -> HAL_DutyCycleHandle;
}
extern "C" {
    #[doc = " Free a DutyCycle.\n\n @param dutyCycleHandle the duty cycle handle"]
    pub fn HAL_FreeDutyCycle(dutyCycleHandle: HAL_DutyCycleHandle);
}
extern "C" {
    #[doc = " Indicates the duty cycle is used by a simulated device.\n\n @param handle the duty cycle handle\n @param device simulated device handle"]
    pub fn HAL_SetDutyCycleSimDevice(handle: HAL_DutyCycleHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Get the frequency of the duty cycle signal.\n\n @param[in] dutyCycleHandle the duty cycle handle\n @param[out] status Error status variable. 0 on success.\n @return frequency in Hertz"]
    pub fn HAL_GetDutyCycleFrequency(dutyCycleHandle: HAL_DutyCycleHandle, status: *mut i32)
        -> i32;
}
extern "C" {
    #[doc = " Get the output ratio of the duty cycle signal.\n\n <p> 0 means always low, 1 means always high.\n\n @param[in] dutyCycleHandle the duty cycle handle\n @param[out] status Error status variable. 0 on success.\n @return output ratio between 0 and 1"]
    pub fn HAL_GetDutyCycleOutput(dutyCycleHandle: HAL_DutyCycleHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Get the raw high time of the duty cycle signal.\n\n @param[in] dutyCycleHandle the duty cycle handle\n @param[out] status Error status variable. 0 on success.\n @return high time of last pulse in nanoseconds"]
    pub fn HAL_GetDutyCycleHighTime(dutyCycleHandle: HAL_DutyCycleHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Get the scale factor of the output.\n\n <p> An output equal to this value is always high, and then linearly scales\n down to 0. Divide a raw result by this in order to get the\n percentage between 0 and 1. Used by DMA.\n\n @param[in] dutyCycleHandle the duty cycle handle\n @param[out] status Error status variable. 0 on success.\n @return the output scale factor"]
    pub fn HAL_GetDutyCycleOutputScaleFactor(
        dutyCycleHandle: HAL_DutyCycleHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Get the FPGA index for the DutyCycle.\n\n @param[in] dutyCycleHandle the duty cycle handle\n @param[out] status Error status variable. 0 on success.\n @return the FPGA index"]
    pub fn HAL_GetDutyCycleFPGAIndex(dutyCycleHandle: HAL_DutyCycleHandle, status: *mut i32)
        -> i32;
}
pub const HAL_EncoderIndexingType_HAL_kResetWhileHigh: HAL_EncoderIndexingType = 0;
pub const HAL_EncoderIndexingType_HAL_kResetWhileLow: HAL_EncoderIndexingType = 1;
pub const HAL_EncoderIndexingType_HAL_kResetOnFallingEdge: HAL_EncoderIndexingType = 2;
pub const HAL_EncoderIndexingType_HAL_kResetOnRisingEdge: HAL_EncoderIndexingType = 3;
#[doc = " The type of index pulse for the encoder."]
pub type HAL_EncoderIndexingType = i32;
pub const HAL_EncoderEncodingType_HAL_Encoder_k1X: HAL_EncoderEncodingType = 0;
pub const HAL_EncoderEncodingType_HAL_Encoder_k2X: HAL_EncoderEncodingType = 1;
pub const HAL_EncoderEncodingType_HAL_Encoder_k4X: HAL_EncoderEncodingType = 2;
#[doc = " The encoding scaling of the encoder."]
pub type HAL_EncoderEncodingType = i32;
extern "C" {
    #[doc = " Initializes an encoder.\n\n @param[in] digitalSourceHandleA the A source (either a HAL_DigitalHandle or a\n                                 HAL_AnalogTriggerHandle)\n @param[in] analogTriggerTypeA   the analog trigger type of the A source if it\n                                 is an analog trigger\n @param[in] digitalSourceHandleB the B source (either a HAL_DigitalHandle or a\n                                 HAL_AnalogTriggerHandle)\n @param[in] analogTriggerTypeB   the analog trigger type of the B source if it\n                                 is an analog trigger\n @param[in] reverseDirection     true to reverse the counting direction from\n                                 standard, otherwise false\n @param[in] encodingType         the encoding type\n @param[out] status              Error status variable. 0 on success.\n @return the created encoder handle"]
    pub fn HAL_InitializeEncoder(
        digitalSourceHandleA: HAL_Handle,
        analogTriggerTypeA: HAL_AnalogTriggerType,
        digitalSourceHandleB: HAL_Handle,
        analogTriggerTypeB: HAL_AnalogTriggerType,
        reverseDirection: HAL_Bool,
        encodingType: HAL_EncoderEncodingType,
        status: *mut i32,
    ) -> HAL_EncoderHandle;
}
extern "C" {
    #[doc = " Frees an encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_FreeEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Indicates the encoder is used by a simulated device.\n\n @param handle the encoder handle\n @param device simulated device handle"]
    pub fn HAL_SetEncoderSimDevice(handle: HAL_EncoderHandle, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Gets the current counts of the encoder after encoding type scaling.\n\n This is scaled by the value passed duing initialization to encodingType.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status Error status variable. 0 on success.\n @return the current scaled count"]
    pub fn HAL_GetEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the raw counts of the encoder.\n\n This is not scaled by any values.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status Error status variable. 0 on success.\n @return the raw encoder count"]
    pub fn HAL_GetEncoderRaw(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the encoder scale value.\n\n This is set by the value passed during initialization to encodingType.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the encoder scale value"]
    pub fn HAL_GetEncoderEncodingScale(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Reads the current encoder value.\n\n Read the value at this instant. It may still be running, so it reflects the\n current value. Next time it is read, it might have a different value.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_ResetEncoder(encoderHandle: HAL_EncoderHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetEncoderPeriod(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the maximum period where the device is still considered \"moving\".\n\n Sets the maximum period where the device is considered moving. This value is\n used to determine the \"stopped\" state of the encoder using the\n HAL_GetEncoderStopped method.\n\n @param[in] encoderHandle the encoder handle\n @param[in] maxPeriod     the maximum period where the counted device is\n                          considered moving in seconds\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetEncoderMaxPeriod(
        encoderHandle: HAL_EncoderHandle,
        maxPeriod: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Determines if the clock is stopped.\n\n Determines if the clocked input is stopped based on the MaxPeriod value set\n using the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the\n device (and encoder) are assumed to be stopped and it returns true.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return true if the most recent encoder period exceeds the MaxPeriod value\n         set by SetMaxPeriod"]
    pub fn HAL_GetEncoderStopped(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the last direction the encoder value changed.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the last direction the encoder value changed"]
    pub fn HAL_GetEncoderDirection(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the current distance traveled by the encoder.\n\n This is the encoder count scaled by the distance per pulse set for the\n encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the encoder distance (units are determined by the units\n                      passed to HAL_SetEncoderDistancePerPulse)"]
    pub fn HAL_GetEncoderDistance(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the current rate of the encoder.\n\n This is the encoder period scaled by the distance per pulse set for the\n encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the encoder rate (units are determined by the units passed to\n         HAL_SetEncoderDistancePerPulse, time value is seconds)"]
    pub fn HAL_GetEncoderRate(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Sets the minimum rate to be considered moving by the encoder.\n\n Units need to match what is set by HAL_SetEncoderDistancePerPulse, with time\n as seconds.\n\n @param[in] encoderHandle the encoder handle\n @param[in] minRate       the minimum rate to be considered moving (units are\n                          determined by the units passed to\n                          HAL_SetEncoderDistancePerPulse, time value is\n                          seconds)\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetEncoderMinRate(encoderHandle: HAL_EncoderHandle, minRate: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the distance traveled per encoder pulse. This is used as a scaling\n factor for the rate and distance calls.\n\n @param[in] encoderHandle    the encoder handle\n @param[in] distancePerPulse the distance traveled per encoder pulse (units\n                             user defined)\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetEncoderDistancePerPulse(
        encoderHandle: HAL_EncoderHandle,
        distancePerPulse: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets if to reverse the direction of the encoder.\n\n Note that this is not a toggle. It is an absolute set.\n\n @param[in] encoderHandle    the encoder handle\n @param[in] reverseDirection true to reverse the direction, false to not.\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetEncoderReverseDirection(
        encoderHandle: HAL_EncoderHandle,
        reverseDirection: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the number of encoder samples to average when calculating encoder rate.\n\n @param[in] encoderHandle    the encoder handle\n @param[in] samplesToAverage the number of samples to average\n @param[out] status          Error status variable. 0 on success."]
    pub fn HAL_SetEncoderSamplesToAverage(
        encoderHandle: HAL_EncoderHandle,
        samplesToAverage: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the current samples to average value.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the current samples to average value"]
    pub fn HAL_GetEncoderSamplesToAverage(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Sets the source for an index pulse on the encoder.\n\n The index pulse can be used to cause an encoder to reset based on an external\n input.\n\n @param[in] encoderHandle       the encoder handle\n @param[in] digitalSourceHandle the index source handle (either a\n                                HAL_AnalogTriggerHandle or a\n                                HAL_DigitalHandle)\n @param[in] analogTriggerType   the analog trigger type if the source is an\n                                analog trigger\n @param[in] type                the index triggering type\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_SetEncoderIndexSource(
        encoderHandle: HAL_EncoderHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        type_: HAL_EncoderIndexingType,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the FPGA index of the encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the FPGA index of the encoder"]
    pub fn HAL_GetEncoderFPGAIndex(encoderHandle: HAL_EncoderHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the decoding scale factor of the encoder.\n\n This is used to perform the scaling from raw to type scaled values.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the scale value for the encoder"]
    pub fn HAL_GetEncoderDecodingScaleFactor(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the user set distance per pulse of the encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the set distance per pulse"]
    pub fn HAL_GetEncoderDistancePerPulse(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the encoding type of the encoder.\n\n @param[in] encoderHandle the encoder handle\n @param[out] status       Error status variable. 0 on success.\n @return the encoding type"]
    pub fn HAL_GetEncoderEncodingType(
        encoderHandle: HAL_EncoderHandle,
        status: *mut i32,
    ) -> HAL_EncoderEncodingType;
}
#[doc = " @defgroup hal_extensions Simulator Extensions\n @ingroup hal_capi\n HAL Simulator Extensions.  These are libraries that provide additional\n simulator functionality.\n\n An extension must expose the HALSIM_InitExtension entry point which is\n invoked after the library is loaded.\n\n The entry point is expected to return < 0 for errors that should stop\n the HAL completely, 0 for success, and > 0 for a non fatal error.\n @{"]
pub type halsim_extension_init_func_t =
    ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    #[doc = " Loads a single extension from a direct path.\n\n Expected to be called internally, not by users.\n\n @param library the library path\n @return the succes state of the initialization"]
    pub fn HAL_LoadOneExtension(library: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Loads any extra halsim libraries provided in the HALSIM_EXTENSIONS\n environment variable.\n\n @return the succes state of the initialization"]
    pub fn HAL_LoadExtensions() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Registers an extension such that other extensions can discover it.\n\n The passed data pointer is retained and the extension must keep this\n pointer valid.\n\n @param name extension name (may embed version number)\n @param data data pointer"]
    pub fn HAL_RegisterExtension(
        name: *const ::std::os::raw::c_char,
        data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Registers an extension registration listener function. The function will\n be called immediately with any currently registered extensions, and will\n be called later when any additional extensions are registered.\n\n @param param parameter data to pass to callback function\n @param func callback function to be called for each registered extension;\n             parameters are the parameter data, extension name, and extension\n             data pointer passed to HAL_RegisterExtension()"]
    pub fn HAL_RegisterExtensionListener(
        param: *mut ::std::os::raw::c_void,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                name: *const ::std::os::raw::c_char,
                data: *mut ::std::os::raw::c_void,
            ),
        >,
    );
}
extern "C" {
    #[doc = " Enables or disables the message saying no HAL extensions were found.\n\n Some apps don't care, and the message create clutter. For general team code,\n we want it.\n\n This must be called before HAL_Initialize is called.\n\n This defaults to true.\n\n @param showMessage true to show message, false to not."]
    pub fn HAL_SetShowExtensionsNotFoundMessages(showMessage: HAL_Bool);
}
extern "C" {
    #[doc = " Registers a function to be called from HAL_Shutdown(). This is intended\n for use only by simulation extensions.\n\n @param param parameter data to pass to callback function\n @param func callback function"]
    pub fn HAL_OnShutdown(
        param: *mut ::std::os::raw::c_void,
        func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    #[doc = " Reports a hardware usage to the HAL.\n\n @param resource       the used resource\n @param instanceNumber the instance of the resource\n @param context        a user specified context index\n @param feature        a user specified feature string\n @return               the index of the added value in NetComm"]
    pub fn HAL_Report(
        resource: i32,
        instanceNumber: i32,
        context: i32,
        feature: *const ::std::os::raw::c_char,
    ) -> i64;
}
pub const HALUsageReporting_tResourceType_kResourceType_Controller:
    HALUsageReporting_tResourceType = 0;
pub const HALUsageReporting_tResourceType_kResourceType_Module: HALUsageReporting_tResourceType = 1;
pub const HALUsageReporting_tResourceType_kResourceType_Language: HALUsageReporting_tResourceType =
    2;
pub const HALUsageReporting_tResourceType_kResourceType_CANPlugin: HALUsageReporting_tResourceType =
    3;
pub const HALUsageReporting_tResourceType_kResourceType_Accelerometer:
    HALUsageReporting_tResourceType = 4;
pub const HALUsageReporting_tResourceType_kResourceType_ADXL345: HALUsageReporting_tResourceType =
    5;
pub const HALUsageReporting_tResourceType_kResourceType_AnalogChannel:
    HALUsageReporting_tResourceType = 6;
pub const HALUsageReporting_tResourceType_kResourceType_AnalogTrigger:
    HALUsageReporting_tResourceType = 7;
pub const HALUsageReporting_tResourceType_kResourceType_AnalogTriggerOutput:
    HALUsageReporting_tResourceType = 8;
pub const HALUsageReporting_tResourceType_kResourceType_CANJaguar: HALUsageReporting_tResourceType =
    9;
pub const HALUsageReporting_tResourceType_kResourceType_Compressor:
    HALUsageReporting_tResourceType = 10;
pub const HALUsageReporting_tResourceType_kResourceType_Counter: HALUsageReporting_tResourceType =
    11;
pub const HALUsageReporting_tResourceType_kResourceType_Dashboard: HALUsageReporting_tResourceType =
    12;
pub const HALUsageReporting_tResourceType_kResourceType_DigitalInput:
    HALUsageReporting_tResourceType = 13;
pub const HALUsageReporting_tResourceType_kResourceType_DigitalOutput:
    HALUsageReporting_tResourceType = 14;
pub const HALUsageReporting_tResourceType_kResourceType_DriverStationCIO:
    HALUsageReporting_tResourceType = 15;
pub const HALUsageReporting_tResourceType_kResourceType_DriverStationEIO:
    HALUsageReporting_tResourceType = 16;
pub const HALUsageReporting_tResourceType_kResourceType_DriverStationLCD:
    HALUsageReporting_tResourceType = 17;
pub const HALUsageReporting_tResourceType_kResourceType_Encoder: HALUsageReporting_tResourceType =
    18;
pub const HALUsageReporting_tResourceType_kResourceType_GearTooth: HALUsageReporting_tResourceType =
    19;
pub const HALUsageReporting_tResourceType_kResourceType_Gyro: HALUsageReporting_tResourceType = 20;
pub const HALUsageReporting_tResourceType_kResourceType_I2C: HALUsageReporting_tResourceType = 21;
pub const HALUsageReporting_tResourceType_kResourceType_Framework: HALUsageReporting_tResourceType =
    22;
pub const HALUsageReporting_tResourceType_kResourceType_Jaguar: HALUsageReporting_tResourceType =
    23;
pub const HALUsageReporting_tResourceType_kResourceType_Joystick: HALUsageReporting_tResourceType =
    24;
pub const HALUsageReporting_tResourceType_kResourceType_Kinect: HALUsageReporting_tResourceType =
    25;
pub const HALUsageReporting_tResourceType_kResourceType_KinectStick:
    HALUsageReporting_tResourceType = 26;
pub const HALUsageReporting_tResourceType_kResourceType_PIDController:
    HALUsageReporting_tResourceType = 27;
pub const HALUsageReporting_tResourceType_kResourceType_Preferences:
    HALUsageReporting_tResourceType = 28;
pub const HALUsageReporting_tResourceType_kResourceType_PWM: HALUsageReporting_tResourceType = 29;
pub const HALUsageReporting_tResourceType_kResourceType_Relay: HALUsageReporting_tResourceType = 30;
pub const HALUsageReporting_tResourceType_kResourceType_RobotDrive:
    HALUsageReporting_tResourceType = 31;
pub const HALUsageReporting_tResourceType_kResourceType_SerialPort:
    HALUsageReporting_tResourceType = 32;
pub const HALUsageReporting_tResourceType_kResourceType_Servo: HALUsageReporting_tResourceType = 33;
pub const HALUsageReporting_tResourceType_kResourceType_Solenoid: HALUsageReporting_tResourceType =
    34;
pub const HALUsageReporting_tResourceType_kResourceType_SPI: HALUsageReporting_tResourceType = 35;
pub const HALUsageReporting_tResourceType_kResourceType_Task: HALUsageReporting_tResourceType = 36;
pub const HALUsageReporting_tResourceType_kResourceType_Ultrasonic:
    HALUsageReporting_tResourceType = 37;
pub const HALUsageReporting_tResourceType_kResourceType_Victor: HALUsageReporting_tResourceType =
    38;
pub const HALUsageReporting_tResourceType_kResourceType_Button: HALUsageReporting_tResourceType =
    39;
pub const HALUsageReporting_tResourceType_kResourceType_Command: HALUsageReporting_tResourceType =
    40;
pub const HALUsageReporting_tResourceType_kResourceType_AxisCamera:
    HALUsageReporting_tResourceType = 41;
pub const HALUsageReporting_tResourceType_kResourceType_PCVideoServer:
    HALUsageReporting_tResourceType = 42;
pub const HALUsageReporting_tResourceType_kResourceType_SmartDashboard:
    HALUsageReporting_tResourceType = 43;
pub const HALUsageReporting_tResourceType_kResourceType_Talon: HALUsageReporting_tResourceType = 44;
pub const HALUsageReporting_tResourceType_kResourceType_HiTechnicColorSensor:
    HALUsageReporting_tResourceType = 45;
pub const HALUsageReporting_tResourceType_kResourceType_HiTechnicAccel:
    HALUsageReporting_tResourceType = 46;
pub const HALUsageReporting_tResourceType_kResourceType_HiTechnicCompass:
    HALUsageReporting_tResourceType = 47;
pub const HALUsageReporting_tResourceType_kResourceType_SRF08: HALUsageReporting_tResourceType = 48;
pub const HALUsageReporting_tResourceType_kResourceType_AnalogOutput:
    HALUsageReporting_tResourceType = 49;
pub const HALUsageReporting_tResourceType_kResourceType_VictorSP: HALUsageReporting_tResourceType =
    50;
pub const HALUsageReporting_tResourceType_kResourceType_PWMTalonSRX:
    HALUsageReporting_tResourceType = 51;
pub const HALUsageReporting_tResourceType_kResourceType_CANTalonSRX:
    HALUsageReporting_tResourceType = 52;
pub const HALUsageReporting_tResourceType_kResourceType_ADXL362: HALUsageReporting_tResourceType =
    53;
pub const HALUsageReporting_tResourceType_kResourceType_ADXRS450: HALUsageReporting_tResourceType =
    54;
pub const HALUsageReporting_tResourceType_kResourceType_RevSPARK: HALUsageReporting_tResourceType =
    55;
pub const HALUsageReporting_tResourceType_kResourceType_MindsensorsSD540:
    HALUsageReporting_tResourceType = 56;
pub const HALUsageReporting_tResourceType_kResourceType_DigitalGlitchFilter:
    HALUsageReporting_tResourceType = 57;
pub const HALUsageReporting_tResourceType_kResourceType_ADIS16448: HALUsageReporting_tResourceType =
    58;
pub const HALUsageReporting_tResourceType_kResourceType_PDP: HALUsageReporting_tResourceType = 59;
pub const HALUsageReporting_tResourceType_kResourceType_PCM: HALUsageReporting_tResourceType = 60;
pub const HALUsageReporting_tResourceType_kResourceType_PigeonIMU: HALUsageReporting_tResourceType =
    61;
pub const HALUsageReporting_tResourceType_kResourceType_NidecBrushless:
    HALUsageReporting_tResourceType = 62;
pub const HALUsageReporting_tResourceType_kResourceType_CANifier: HALUsageReporting_tResourceType =
    63;
pub const HALUsageReporting_tResourceType_kResourceType_TalonFX: HALUsageReporting_tResourceType =
    64;
pub const HALUsageReporting_tResourceType_kResourceType_CTRE_future1:
    HALUsageReporting_tResourceType = 65;
pub const HALUsageReporting_tResourceType_kResourceType_CTRE_future2:
    HALUsageReporting_tResourceType = 66;
pub const HALUsageReporting_tResourceType_kResourceType_CTRE_future3:
    HALUsageReporting_tResourceType = 67;
pub const HALUsageReporting_tResourceType_kResourceType_CTRE_future4:
    HALUsageReporting_tResourceType = 68;
pub const HALUsageReporting_tResourceType_kResourceType_CTRE_future5:
    HALUsageReporting_tResourceType = 69;
pub const HALUsageReporting_tResourceType_kResourceType_CTRE_future6:
    HALUsageReporting_tResourceType = 70;
pub const HALUsageReporting_tResourceType_kResourceType_LinearFilter:
    HALUsageReporting_tResourceType = 71;
pub const HALUsageReporting_tResourceType_kResourceType_XboxController:
    HALUsageReporting_tResourceType = 72;
pub const HALUsageReporting_tResourceType_kResourceType_UsbCamera: HALUsageReporting_tResourceType =
    73;
pub const HALUsageReporting_tResourceType_kResourceType_NavX: HALUsageReporting_tResourceType = 74;
pub const HALUsageReporting_tResourceType_kResourceType_Pixy: HALUsageReporting_tResourceType = 75;
pub const HALUsageReporting_tResourceType_kResourceType_Pixy2: HALUsageReporting_tResourceType = 76;
pub const HALUsageReporting_tResourceType_kResourceType_ScanseSweep:
    HALUsageReporting_tResourceType = 77;
pub const HALUsageReporting_tResourceType_kResourceType_Shuffleboard:
    HALUsageReporting_tResourceType = 78;
pub const HALUsageReporting_tResourceType_kResourceType_CAN: HALUsageReporting_tResourceType = 79;
pub const HALUsageReporting_tResourceType_kResourceType_DigilentDMC60:
    HALUsageReporting_tResourceType = 80;
pub const HALUsageReporting_tResourceType_kResourceType_PWMVictorSPX:
    HALUsageReporting_tResourceType = 81;
pub const HALUsageReporting_tResourceType_kResourceType_RevSparkMaxPWM:
    HALUsageReporting_tResourceType = 82;
pub const HALUsageReporting_tResourceType_kResourceType_RevSparkMaxCAN:
    HALUsageReporting_tResourceType = 83;
pub const HALUsageReporting_tResourceType_kResourceType_ADIS16470: HALUsageReporting_tResourceType =
    84;
pub const HALUsageReporting_tResourceType_kResourceType_PIDController2:
    HALUsageReporting_tResourceType = 85;
pub const HALUsageReporting_tResourceType_kResourceType_ProfiledPIDController:
    HALUsageReporting_tResourceType = 86;
pub const HALUsageReporting_tResourceType_kResourceType_Kinematics:
    HALUsageReporting_tResourceType = 87;
pub const HALUsageReporting_tResourceType_kResourceType_Odometry: HALUsageReporting_tResourceType =
    88;
pub const HALUsageReporting_tResourceType_kResourceType_Units: HALUsageReporting_tResourceType = 89;
pub const HALUsageReporting_tResourceType_kResourceType_TrapezoidProfile:
    HALUsageReporting_tResourceType = 90;
pub const HALUsageReporting_tResourceType_kResourceType_DutyCycle: HALUsageReporting_tResourceType =
    91;
pub const HALUsageReporting_tResourceType_kResourceType_AddressableLEDs:
    HALUsageReporting_tResourceType = 92;
pub const HALUsageReporting_tResourceType_kResourceType_FusionVenom:
    HALUsageReporting_tResourceType = 93;
pub const HALUsageReporting_tResourceType_kResourceType_PS4Controller:
    HALUsageReporting_tResourceType = 94;
pub type HALUsageReporting_tResourceType = i32;
pub const HALUsageReporting_tInstances_kLanguage_LabVIEW: HALUsageReporting_tInstances = 1;
pub const HALUsageReporting_tInstances_kLanguage_CPlusPlus: HALUsageReporting_tInstances = 2;
pub const HALUsageReporting_tInstances_kLanguage_Java: HALUsageReporting_tInstances = 3;
pub const HALUsageReporting_tInstances_kLanguage_Python: HALUsageReporting_tInstances = 4;
pub const HALUsageReporting_tInstances_kLanguage_DotNet: HALUsageReporting_tInstances = 5;
pub const HALUsageReporting_tInstances_kLanguage_Kotlin: HALUsageReporting_tInstances = 6;
pub const HALUsageReporting_tInstances_kCANPlugin_BlackJagBridge: HALUsageReporting_tInstances = 1;
pub const HALUsageReporting_tInstances_kCANPlugin_2CAN: HALUsageReporting_tInstances = 2;
pub const HALUsageReporting_tInstances_kFramework_Iterative: HALUsageReporting_tInstances = 1;
pub const HALUsageReporting_tInstances_kFramework_Simple: HALUsageReporting_tInstances = 2;
pub const HALUsageReporting_tInstances_kFramework_CommandControl: HALUsageReporting_tInstances = 3;
pub const HALUsageReporting_tInstances_kFramework_Timed: HALUsageReporting_tInstances = 4;
pub const HALUsageReporting_tInstances_kFramework_ROS: HALUsageReporting_tInstances = 5;
pub const HALUsageReporting_tInstances_kFramework_RobotBuilder: HALUsageReporting_tInstances = 6;
pub const HALUsageReporting_tInstances_kRobotDrive_ArcadeStandard: HALUsageReporting_tInstances = 1;
pub const HALUsageReporting_tInstances_kRobotDrive_ArcadeButtonSpin: HALUsageReporting_tInstances =
    2;
pub const HALUsageReporting_tInstances_kRobotDrive_ArcadeRatioCurve: HALUsageReporting_tInstances =
    3;
pub const HALUsageReporting_tInstances_kRobotDrive_Tank: HALUsageReporting_tInstances = 4;
pub const HALUsageReporting_tInstances_kRobotDrive_MecanumPolar: HALUsageReporting_tInstances = 5;
pub const HALUsageReporting_tInstances_kRobotDrive_MecanumCartesian: HALUsageReporting_tInstances =
    6;
pub const HALUsageReporting_tInstances_kRobotDrive2_DifferentialArcade:
    HALUsageReporting_tInstances = 7;
pub const HALUsageReporting_tInstances_kRobotDrive2_DifferentialTank: HALUsageReporting_tInstances =
    8;
pub const HALUsageReporting_tInstances_kRobotDrive2_DifferentialCurvature:
    HALUsageReporting_tInstances = 9;
pub const HALUsageReporting_tInstances_kRobotDrive2_MecanumCartesian: HALUsageReporting_tInstances =
    10;
pub const HALUsageReporting_tInstances_kRobotDrive2_MecanumPolar: HALUsageReporting_tInstances = 11;
pub const HALUsageReporting_tInstances_kRobotDrive2_KilloughCartesian:
    HALUsageReporting_tInstances = 12;
pub const HALUsageReporting_tInstances_kRobotDrive2_KilloughPolar: HALUsageReporting_tInstances =
    13;
pub const HALUsageReporting_tInstances_kDriverStationCIO_Analog: HALUsageReporting_tInstances = 1;
pub const HALUsageReporting_tInstances_kDriverStationCIO_DigitalIn: HALUsageReporting_tInstances =
    2;
pub const HALUsageReporting_tInstances_kDriverStationCIO_DigitalOut: HALUsageReporting_tInstances =
    3;
pub const HALUsageReporting_tInstances_kDriverStationEIO_Acceleration:
    HALUsageReporting_tInstances = 1;
pub const HALUsageReporting_tInstances_kDriverStationEIO_AnalogIn: HALUsageReporting_tInstances = 2;
pub const HALUsageReporting_tInstances_kDriverStationEIO_AnalogOut: HALUsageReporting_tInstances =
    3;
pub const HALUsageReporting_tInstances_kDriverStationEIO_Button: HALUsageReporting_tInstances = 4;
pub const HALUsageReporting_tInstances_kDriverStationEIO_LED: HALUsageReporting_tInstances = 5;
pub const HALUsageReporting_tInstances_kDriverStationEIO_DigitalIn: HALUsageReporting_tInstances =
    6;
pub const HALUsageReporting_tInstances_kDriverStationEIO_DigitalOut: HALUsageReporting_tInstances =
    7;
pub const HALUsageReporting_tInstances_kDriverStationEIO_FixedDigitalOut:
    HALUsageReporting_tInstances = 8;
pub const HALUsageReporting_tInstances_kDriverStationEIO_PWM: HALUsageReporting_tInstances = 9;
pub const HALUsageReporting_tInstances_kDriverStationEIO_Encoder: HALUsageReporting_tInstances = 10;
pub const HALUsageReporting_tInstances_kDriverStationEIO_TouchSlider: HALUsageReporting_tInstances =
    11;
pub const HALUsageReporting_tInstances_kADXL345_SPI: HALUsageReporting_tInstances = 1;
pub const HALUsageReporting_tInstances_kADXL345_I2C: HALUsageReporting_tInstances = 2;
pub const HALUsageReporting_tInstances_kCommand_Scheduler: HALUsageReporting_tInstances = 1;
pub const HALUsageReporting_tInstances_kCommand2_Scheduler: HALUsageReporting_tInstances = 2;
pub const HALUsageReporting_tInstances_kSmartDashboard_Instance: HALUsageReporting_tInstances = 1;
pub const HALUsageReporting_tInstances_kKinematics_DifferentialDrive: HALUsageReporting_tInstances =
    1;
pub const HALUsageReporting_tInstances_kKinematics_MecanumDrive: HALUsageReporting_tInstances = 2;
pub const HALUsageReporting_tInstances_kKinematics_SwerveDrive: HALUsageReporting_tInstances = 3;
pub const HALUsageReporting_tInstances_kOdometry_DifferentialDrive: HALUsageReporting_tInstances =
    1;
pub const HALUsageReporting_tInstances_kOdometry_MecanumDrive: HALUsageReporting_tInstances = 2;
pub const HALUsageReporting_tInstances_kOdometry_SwerveDrive: HALUsageReporting_tInstances = 3;
pub type HALUsageReporting_tInstances = i32;
pub const HAL_RuntimeType_HAL_Runtime_RoboRIO: HAL_RuntimeType = 0;
pub const HAL_RuntimeType_HAL_Runtime_RoboRIO2: HAL_RuntimeType = 1;
pub const HAL_RuntimeType_HAL_Runtime_Simulation: HAL_RuntimeType = 2;
#[doc = " @defgroup hal_capi WPILib HAL API\n Hardware Abstraction Layer to hardware or simulator\n @{"]
pub type HAL_RuntimeType = i32;
extern "C" {
    #[doc = " Gets the last error set on this thread, or the message for the status code.\n\n If passed HAL_USE_LAST_ERROR, the last error set on the thread will be\n returned.\n\n @param[out] status the status code, set to the error status code if input is\n               HAL_USE_LAST_ERROR\n @return the error message for the code. This does not need to be freed,\n               but can be overwritten by another hal call on the same thread."]
    pub fn HAL_GetLastError(status: *mut i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the error message for a specific status code.\n\n @param code the status code\n @return the error message for the code. This does not need to be freed."]
    pub fn HAL_GetErrorMessage(code: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the FPGA Version number.\n\n For now, expect this to be competition year.\n\n @param[out] status the error code, or 0 for success\n @return FPGA Version number."]
    pub fn HAL_GetFPGAVersion(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Returns the FPGA Revision number.\n\n The format of the revision is 3 numbers.\n The 12 most significant bits are the Major Revision.\n the next 8 bits are the Minor Revision.\n The 12 least significant bits are the Build Number.\n\n @param[out] status the error code, or 0 for success\n @return FPGA Revision number."]
    pub fn HAL_GetFPGARevision(status: *mut i32) -> i64;
}
extern "C" {
    #[doc = " Returns the serial number.\n\n @param[out] buffer The serial number.\n @param size The maximum characters to copy into buffer.\n @return Number of characters copied into buffer."]
    pub fn HAL_GetSerialNumber(buffer: *mut ::std::os::raw::c_char, size: usize) -> usize;
}
extern "C" {
    #[doc = " Returns the comments from the roboRIO web interface.\n\n @param[out] buffer The comments string.\n @param size The maximum characters to copy into buffer.\n @return Number of characters copied into buffer."]
    pub fn HAL_GetComments(buffer: *mut ::std::os::raw::c_char, size: usize) -> usize;
}
extern "C" {
    #[doc = " Returns the runtime type of the HAL.\n\n @return HAL Runtime Type"]
    pub fn HAL_GetRuntimeType() -> HAL_RuntimeType;
}
extern "C" {
    #[doc = " Gets the state of the \"USER\" button on the roboRIO.\n\n @param[out] status the error code, or 0 for success\n @return true if the button is currently pressed down"]
    pub fn HAL_GetFPGAButton(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if the system outputs are currently active\n\n @param[out] status the error code, or 0 for success\n @return true if the system outputs are active, false if disabled"]
    pub fn HAL_GetSystemActive(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets if the system is in a browned out state.\n\n @param[out] status the error code, or 0 for success\n @return true if the system is in a low voltage brown out, false otherwise"]
    pub fn HAL_GetBrownedOut(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets a port handle for a specific channel.\n\n The created handle does not need to be freed.\n\n @param channel the channel number\n @return the created port"]
    pub fn HAL_GetPort(channel: i32) -> HAL_PortHandle;
}
extern "C" {
    #[doc = " Gets a port handle for a specific channel and module.\n\n This is expected to be used for PCMs, as the roboRIO does not work with\n modules anymore.\n\n The created handle does not need to be freed.\n\n @param module  the module number\n @param channel the channel number\n @return the created port"]
    pub fn HAL_GetPortWithModule(module: i32, channel: i32) -> HAL_PortHandle;
}
extern "C" {
    #[doc = " Reads the microsecond-resolution timer on the FPGA.\n\n @param[out] status the error code, or 0 for success\n @return The current time in microseconds according to the FPGA (since FPGA\n reset)."]
    pub fn HAL_GetFPGATime(status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Given an 32 bit FPGA time, expand it to the nearest likely 64 bit FPGA time.\n\n Note: This is making the assumption that the timestamp being converted is\n always in the past.  If you call this with a future timestamp, it probably\n will make it in the past.  If you wait over 70 minutes between capturing the\n bottom 32 bits of the timestamp and expanding it, you will be off by\n multiples of 1<<32 microseconds.\n\n @param[in] unexpandedLower 32 bit FPGA time\n @param[out] status the error code, or 0 for success\n @return The current time in microseconds according to the FPGA (since FPGA\n         reset) as a 64 bit number."]
    pub fn HAL_ExpandFPGATime(unexpandedLower: u32, status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Call this to start up HAL. This is required for robot programs.\n\n This must be called before any other HAL functions. Failure to do so will\n result in undefined behavior, and likely segmentation faults. This means that\n any statically initialized variables in a program MUST call this function in\n their constructors if they want to use other HAL calls.\n\n The common parameters are 500 for timeout and 0 for mode.\n\n This function is safe to call from any thread, and as many times as you wish.\n It internally guards from any reentrancy.\n\n The applicable modes are:\n   0: Try to kill an existing HAL from another program, if not successful,\n error.\n   1: Force kill a HAL from another program.\n   2: Just warn if another hal exists and cannot be killed. Will likely result\n in undefined behavior.\n\n @param timeout the initialization timeout (ms)\n @param mode    the initialization mode (see remarks)\n @return true if initialization was successful, otherwise false."]
    pub fn HAL_Initialize(timeout: i32, mode: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Call this to shut down HAL.\n\n This must be called at termination of the robot program to avoid potential\n segmentation faults with simulation extensions at exit."]
    pub fn HAL_Shutdown();
}
extern "C" {
    #[doc = " Calls registered SimPeriodic \"before\" callbacks (only in simulation mode).\n This should be called prior to user code periodic simulation functions."]
    pub fn HAL_SimPeriodicBefore();
}
extern "C" {
    #[doc = " Calls registered SimPeriodic \"after\" callbacks (only in simulation mode).\n This should be called after user code periodic simulation functions."]
    pub fn HAL_SimPeriodicAfter();
}
pub const HAL_I2CPort_HAL_I2C_kInvalid: HAL_I2CPort = -1;
pub const HAL_I2CPort_HAL_I2C_kOnboard: HAL_I2CPort = 0;
pub const HAL_I2CPort_HAL_I2C_kMXP: HAL_I2CPort = 1;
#[doc = " @defgroup hal_i2c I2C Functions\n @ingroup hal_capi\n @{"]
pub type HAL_I2CPort = i32;
extern "C" {
    #[doc = " Initializes the I2C port.\n\n Opens the port if necessary and saves the handle.\n If opening the MXP port, also sets up the channel functions appropriately.\n\n @param[in] port    The port to open, 0 for the on-board, 1 for the MXP.\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_InitializeI2C(port: HAL_I2CPort, status: *mut i32);
}
extern "C" {
    #[doc = " Generic I2C read/write transaction.\n\n This is a lower-level interface to the I2C hardware giving you more control\n over each transaction.\n\n @param port The I2C port, 0 for the on-board, 1 for the MXP.\n @param deviceAddress The address of the register on the device to be\n                      read/written.\n @param dataToSend Buffer of data to send as part of the transaction.\n @param sendSize Number of bytes to send as part of the transaction.\n @param dataReceived Buffer to read data into.\n @param receiveSize Number of bytes to read from the device.\n @return >= 0 on success or -1 on transfer abort."]
    pub fn HAL_TransactionI2C(
        port: HAL_I2CPort,
        deviceAddress: i32,
        dataToSend: *const u8,
        sendSize: i32,
        dataReceived: *mut u8,
        receiveSize: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Executes a write transaction with the device.\n\n Writes a single byte to a register on a device and wait until the\n   transaction is complete.\n\n @param port The I2C port, 0 for the on-board, 1 for the MXP.\n @param deviceAddress The address of the register on the device to be\n                      written.\n @param dataToSend The byte to write to the register on the device.\n @param sendSize Number of bytes to send.\n @return >= 0 on success or -1 on transfer abort."]
    pub fn HAL_WriteI2C(
        port: HAL_I2CPort,
        deviceAddress: i32,
        dataToSend: *const u8,
        sendSize: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Executes a read transaction with the device.\n\n Reads bytes from a device.\n Most I2C devices will auto-increment the register pointer internally allowing\n   you to read consecutive registers on a device in a single transaction.\n\n @param port The I2C port, 0 for the on-board, 1 for the MXP.\n @param deviceAddress The register to read first in the transaction.\n @param count The number of bytes to read in the transaction.\n @param buffer A pointer to the array of bytes to store the data read from the\n device.\n @return >= 0 on success or -1 on transfer abort."]
    pub fn HAL_ReadI2C(port: HAL_I2CPort, deviceAddress: i32, buffer: *mut u8, count: i32) -> i32;
}
extern "C" {
    #[doc = " Closes an I2C port\n\n @param port The I2C port, 0 for the on-board, 1 for the MXP."]
    pub fn HAL_CloseI2C(port: HAL_I2CPort);
}
extern "C" {
    #[doc = " Initializes an interrupt.\n\n @param[out] status Error status variable. 0 on success.\n @return the created interrupt handle"]
    pub fn HAL_InitializeInterrupts(status: *mut i32) -> HAL_InterruptHandle;
}
extern "C" {
    #[doc = " Frees an interrupt.\n\n @param interruptHandle the interrupt handle"]
    pub fn HAL_CleanInterrupts(interruptHandle: HAL_InterruptHandle);
}
extern "C" {
    #[doc = " Waits for the defined interrupt to occur.\n\n @param[in] interruptHandle the interrupt handle\n @param[in] timeout         timeout in seconds\n @param[in] ignorePrevious  if true, ignore interrupts that happened before\n                            waitForInterrupt was called\n @param[out] status         Error status variable. 0 on success.\n @return the mask of interrupts that fired"]
    pub fn HAL_WaitForInterrupt(
        interruptHandle: HAL_InterruptHandle,
        timeout: f64,
        ignorePrevious: HAL_Bool,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Waits for any interrupt covered by the mask to occur.\n\n @param[in] interruptHandle the interrupt handle to use for the context\n @param[in] mask            the mask of interrupts to wait for\n @param[in] timeout         timeout in seconds\n @param[in] ignorePrevious  if true, ignore interrupts that happened before\n                            waitForInterrupt was called\n @param[out] status         Error status variable. 0 on success.\n @return the mask of interrupts that fired"]
    pub fn HAL_WaitForMultipleInterrupts(
        interruptHandle: HAL_InterruptHandle,
        mask: i64,
        timeout: f64,
        ignorePrevious: HAL_Bool,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Returns the timestamp for the rising interrupt that occurred most recently.\n\n This is in the same time domain as HAL_GetFPGATime().  It only contains the\n bottom 32 bits of the timestamp.  If your robot has been running for over 1\n hour, you will need to fill in the upper 32 bits yourself.\n\n @param[in] interruptHandle the interrupt handle\n @param[out] status         Error status variable. 0 on success.\n @return timestamp in microseconds since FPGA Initialization"]
    pub fn HAL_ReadInterruptRisingTimestamp(
        interruptHandle: HAL_InterruptHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Returns the timestamp for the falling interrupt that occurred most recently.\n\n This is in the same time domain as HAL_GetFPGATime().  It only contains the\n bottom 32 bits of the timestamp.  If your robot has been running for over 1\n hour, you will need to fill in the upper 32 bits yourself.\n\n @param[in] interruptHandle the interrupt handle\n @param[out] status         Error status variable. 0 on success.\n @return timestamp in microseconds since FPGA Initialization"]
    pub fn HAL_ReadInterruptFallingTimestamp(
        interruptHandle: HAL_InterruptHandle,
        status: *mut i32,
    ) -> i64;
}
extern "C" {
    #[doc = " Requests interrupts on a specific digital source.\n\n @param[in] interruptHandle     the interrupt handle\n @param[in] digitalSourceHandle the digital source handle (either a\n                                HAL_AnalogTriggerHandle or a\n                                HAL_DigitalHandle)\n @param[in] analogTriggerType   the trigger type if the source is an\n                                AnalogTrigger\n @param[out] status             Error status variable. 0 on success."]
    pub fn HAL_RequestInterrupts(
        interruptHandle: HAL_InterruptHandle,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the edges to trigger the interrupt on.\n\n Note that both edges triggered is a valid configuration.\n\n @param[in] interruptHandle the interrupt handle\n @param[in] risingEdge      true for triggering on rising edge\n @param[in] fallingEdge     true for triggering on falling edge\n @param[out] status         Error status variable. 0 on success."]
    pub fn HAL_SetInterruptUpSourceEdge(
        interruptHandle: HAL_InterruptHandle,
        risingEdge: HAL_Bool,
        fallingEdge: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Releases a waiting interrupt.\n\n This will release both rising and falling waiters.\n\n @param[in] interruptHandle the interrupt handle to release\n @param[out] status         Error status variable. 0 on success."]
    pub fn HAL_ReleaseWaitingInterrupt(interruptHandle: HAL_InterruptHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets up the system to run the provided main loop in the main thread (e.g.\n the thread in which main() starts execution) and run the robot code in a\n separate thread.\n\n Normally the robot code runs in the main thread, but some GUI systems\n require the GUI be run in the main thread.\n\n To be effective, this function must be called before the robot code starts\n the main loop (e.g. by frc::StartRobot()).\n\n @param param parameter data to pass to mainFunc and exitFunc\n @param mainFunc the function to be run when HAL_RunMain() is called.\n @param exitFunc the function to be run when HAL_ExitMain() is called."]
    pub fn HAL_SetMain(
        param: *mut ::std::os::raw::c_void,
        mainFunc: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        exitFunc: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    );
}
extern "C" {
    #[doc = " Returns true if HAL_SetMain() has been called.\n\n @return True if HAL_SetMain() has been called, false otherwise."]
    pub fn HAL_HasMain() -> HAL_Bool;
}
extern "C" {
    #[doc = " Runs the main function provided to HAL_SetMain().\n\n If HAL_SetMain() has not been called, simply sleeps until HAL_ExitMain()\n is called."]
    pub fn HAL_RunMain();
}
extern "C" {
    #[doc = " Causes HAL_RunMain() to exit.\n\n If HAL_SetMain() has been called, this calls the exit function provided\n to that function."]
    pub fn HAL_ExitMain();
}
extern "C" {
    #[doc = " Initializes a notifier.\n\n A notifier is an FPGA controller timer that triggers at requested intervals\n based on the FPGA time. This can be used to make precise control loops.\n\n @param[out] status Error status variable. 0 on success.\n @return the created notifier"]
    pub fn HAL_InitializeNotifier(status: *mut i32) -> HAL_NotifierHandle;
}
extern "C" {
    #[doc = " Sets the HAL notifier thread priority.\n\n The HAL notifier thread is responsible for managing the FPGA's notifier\n interrupt and waking up user's Notifiers when it's their time to run.\n Giving the HAL notifier thread real-time priority helps ensure the user's\n real-time Notifiers, if any, are notified to run in a timely manner.\n\n @param[in] realTime Set to true to set a real-time priority, false for\n                     standard priority.\n @param[in] priority Priority to set the thread to. For real-time, this is\n                     1-99 with 99 being highest. For non-real-time, this is\n                     forced to 0. See \"man 7 sched\" for more details.\n @param[out] status  Error status variable. 0 on success.\n @return True on success."]
    pub fn HAL_SetNotifierThreadPriority(
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the name of a notifier.\n\n @param[in] notifierHandle the notifier handle\n @param[in] name name\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetNotifierName(
        notifierHandle: HAL_NotifierHandle,
        name: *const ::std::os::raw::c_char,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Stops a notifier from running.\n\n This will cause any call into HAL_WaitForNotifierAlarm to return.\n\n @param[in] notifierHandle the notifier handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_StopNotifier(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Cleans a notifier.\n\n Note this also stops a notifier if it is already running.\n\n @param[in] notifierHandle the notifier handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_CleanNotifier(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Updates the trigger time for a notifier.\n\n Note that this time is an absolute time relative to HAL_GetFPGATime()\n\n @param[in] notifierHandle the notifier handle\n @param[in] triggerTime    the updated trigger time\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_UpdateNotifierAlarm(
        notifierHandle: HAL_NotifierHandle,
        triggerTime: u64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Cancels the next notifier alarm.\n\n This does not cause HAL_WaitForNotifierAlarm to return.\n\n @param[in] notifierHandle the notifier handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_CancelNotifierAlarm(notifierHandle: HAL_NotifierHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Waits for the next alarm for the specific notifier.\n\n This is a blocking call until either the time elapses or HAL_StopNotifier\n gets called. If the latter occurs, this function will return zero and any\n loops using this function should exit. Failing to do so can lead to\n use-after-frees.\n\n @param[in] notifierHandle the notifier handle\n @param[out] status        Error status variable. 0 on success.\n @return the FPGA time the notifier returned"]
    pub fn HAL_WaitForNotifierAlarm(notifierHandle: HAL_NotifierHandle, status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Initializes a PWM port.\n\n @param[in] portHandle the port to initialize\n @param[in] allocationLocation  the location where the allocation is occurring\n                                (can be null)\n @param[out] status             Error status variable. 0 on success.\n @return the created pwm handle"]
    pub fn HAL_InitializePWMPort(
        portHandle: HAL_PortHandle,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_DigitalHandle;
}
extern "C" {
    #[doc = " Frees a PWM port.\n\n @param[in] pwmPortHandle the pwm handle\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_FreePWMPort(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Checks if a pwm channel is valid.\n\n @param channel the channel to check\n @return true if the channel is valid, otherwise false"]
    pub fn HAL_CheckPWMChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the configuration settings for the PWM channel.\n\n All values are in milliseconds.\n\n @param[in] pwmPortHandle  the PWM handle\n @param[in] maxPwm         the maximum PWM value\n @param[in] deadbandMaxPwm the high range of the center deadband\n @param[in] centerPwm      the center PWM value\n @param[in] deadbandMinPwm the low range of the center deadband\n @param[in] minPwm         the minimum PWM value\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetPWMConfig(
        pwmPortHandle: HAL_DigitalHandle,
        maxPwm: f64,
        deadbandMaxPwm: f64,
        centerPwm: f64,
        deadbandMinPwm: f64,
        minPwm: f64,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets the raw configuration settings for the PWM channel.\n\n We recommend using HAL_SetPWMConfig() instead, as those values are properly\n scaled. Usually used for values grabbed by HAL_GetPWMConfigRaw().\n\n Values are in raw FPGA units.\n\n @param[in] pwmPortHandle  the PWM handle\n @param[in] maxPwm         the maximum PWM value\n @param[in] deadbandMaxPwm the high range of the center deadband\n @param[in] centerPwm      the center PWM value\n @param[in] deadbandMinPwm the low range of the center deadband\n @param[in] minPwm         the minimum PWM value\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_SetPWMConfigRaw(
        pwmPortHandle: HAL_DigitalHandle,
        maxPwm: i32,
        deadbandMaxPwm: i32,
        centerPwm: i32,
        deadbandMinPwm: i32,
        minPwm: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the raw pwm configuration settings for the PWM channel.\n\n Values are in raw FPGA units. These units have the potential to change for\n any FPGA release.\n\n @param[in] pwmPortHandle  the PWM handle\n @param[in] maxPwm         the maximum PWM value\n @param[in] deadbandMaxPwm the high range of the center deadband\n @param[in] centerPwm      the center PWM value\n @param[in] deadbandMinPwm the low range of the center deadband\n @param[in] minPwm         the minimum PWM value\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_GetPWMConfigRaw(
        pwmPortHandle: HAL_DigitalHandle,
        maxPwm: *mut i32,
        deadbandMaxPwm: *mut i32,
        centerPwm: *mut i32,
        deadbandMinPwm: *mut i32,
        minPwm: *mut i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Sets if the FPGA should output the center value if the input value is within\n the deadband.\n\n @param[in] pwmPortHandle     the PWM handle\n @param[in] eliminateDeadband true to eliminate deadband, otherwise false\n @param[out] status           Error status variable. 0 on success."]
    pub fn HAL_SetPWMEliminateDeadband(
        pwmPortHandle: HAL_DigitalHandle,
        eliminateDeadband: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the current eliminate deadband value.\n\n @param[in] pwmPortHandle the PWM handle\n @param[out] status       Error status variable. 0 on success.\n @return true if set, otherwise false"]
    pub fn HAL_GetPWMEliminateDeadband(
        pwmPortHandle: HAL_DigitalHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets a PWM channel to the desired value.\n\n The values are in raw FPGA units, and have the potential to change with any\n FPGA release.\n\n @param[in] pwmPortHandle the PWM handle\n @param[in] value         the PWM value to set\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMRaw(pwmPortHandle: HAL_DigitalHandle, value: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets a PWM channel to the desired scaled value.\n\n The values range from -1 to 1 and the period is controlled by the PWM Period\n and MinHigh registers.\n\n @param[in] pwmPortHandle the PWM handle\n @param[in] speed         the scaled PWM value to set\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMSpeed(pwmPortHandle: HAL_DigitalHandle, speed: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets a PWM channel to the desired position value.\n\n The values range from 0 to 1 and the period is controlled by the PWM Period\n and MinHigh registers.\n\n @param[in] pwmPortHandle the PWM handle\n @param[in] position      the positional PWM value to set\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMPosition(pwmPortHandle: HAL_DigitalHandle, position: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets a PWM channel to be disabled.\n\n The channel is disabled until the next time it is set. Note this is different\n from just setting a 0 speed, as this will actively stop all signaling on the\n channel.\n\n @param[in] pwmPortHandle the PWM handle.\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMDisabled(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Gets a value from a PWM channel.\n\n The values are in raw FPGA units, and have the potential to change with any\n FPGA release.\n\n @param[in] pwmPortHandle the PWM handle\n @param[out] status       Error status variable. 0 on success.\n @return the current raw PWM value"]
    pub fn HAL_GetPWMRaw(pwmPortHandle: HAL_DigitalHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets a scaled value from a PWM channel.\n\n The values range from -1 to 1.\n\n @param[in] pwmPortHandle the PWM handle\n @param[out] status       Error status variable. 0 on success.\n @return the current speed PWM value"]
    pub fn HAL_GetPWMSpeed(pwmPortHandle: HAL_DigitalHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets a position value from a PWM channel.\n\n The values range from 0 to 1.\n\n @param[in] pwmPortHandle the PWM handle\n @param[out] status       Error status variable. 0 on success.\n @return the current positional PWM value"]
    pub fn HAL_GetPWMPosition(pwmPortHandle: HAL_DigitalHandle, status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Forces a PWM signal to go to 0 temporarily.\n\n @param[in] pwmPortHandle the PWM handle.\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_LatchPWMZero(pwmPortHandle: HAL_DigitalHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets how how often the PWM signal is squelched, thus scaling the period.\n\n @param[in] pwmPortHandle the PWM handle.\n @param[in] squelchMask   the 2-bit mask of outputs to squelch\n @param[out] status       Error status variable. 0 on success."]
    pub fn HAL_SetPWMPeriodScale(
        pwmPortHandle: HAL_DigitalHandle,
        squelchMask: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the loop timing of the PWM system.\n\n @param[out] status Error status variable. 0 on success.\n @return the loop time"]
    pub fn HAL_GetPWMLoopTiming(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the pwm starting cycle time.\n\n This time is relative to the FPGA time.\n\n @param[out] status Error status variable. 0 on success.\n @return the pwm cycle start time"]
    pub fn HAL_GetPWMCycleStartTime(status: *mut i32) -> u64;
}
extern "C" {
    #[doc = " Gets the number of analog accumulators in the current system.\n\n @return the number of analog accumulators"]
    pub fn HAL_GetNumAccumulators() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog triggers in the current system.\n\n @return the number of analog triggers"]
    pub fn HAL_GetNumAnalogTriggers() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog inputs in the current system.\n\n @return the number of analog inputs"]
    pub fn HAL_GetNumAnalogInputs() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog outputs in the current system.\n\n @return the number of analog outputs"]
    pub fn HAL_GetNumAnalogOutputs() -> i32;
}
extern "C" {
    #[doc = " Gets the number of analog counters in the current system.\n\n @return the number of counters"]
    pub fn HAL_GetNumCounters() -> i32;
}
extern "C" {
    #[doc = " Gets the number of digital headers in the current system.\n\n @return the number of digital headers"]
    pub fn HAL_GetNumDigitalHeaders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PWM headers in the current system.\n\n @return the number of PWM headers"]
    pub fn HAL_GetNumPWMHeaders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of digital channels in the current system.\n\n @return the number of digital channels"]
    pub fn HAL_GetNumDigitalChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PWM channels in the current system.\n\n @return the number of PWM channels"]
    pub fn HAL_GetNumPWMChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of digital IO PWM outputs in the current system.\n\n @return the number of digital IO PWM outputs"]
    pub fn HAL_GetNumDigitalPWMOutputs() -> i32;
}
extern "C" {
    #[doc = " Gets the number of quadrature encoders in the current system.\n\n @return the number of quadrature encoders"]
    pub fn HAL_GetNumEncoders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of interrupts in the current system.\n\n @return the number of interrupts"]
    pub fn HAL_GetNumInterrupts() -> i32;
}
extern "C" {
    #[doc = " Gets the number of relay channels in the current system.\n\n @return the number of relay channels"]
    pub fn HAL_GetNumRelayChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of relay headers in the current system.\n\n @return the number of relay headers"]
    pub fn HAL_GetNumRelayHeaders() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PCM modules in the current system.\n\n @return the number of PCM modules"]
    pub fn HAL_GetNumCTREPCMModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of solenoid channels in the current system.\n\n @return the number of solenoid channels"]
    pub fn HAL_GetNumCTRESolenoidChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDP modules in the current system.\n\n @return the number of PDP modules"]
    pub fn HAL_GetNumCTREPDPModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDP channels in the current system.\n\n @return the number of PDP channels"]
    pub fn HAL_GetNumCTREPDPChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDH modules in the current system.\n\n @return the number of PDH modules"]
    pub fn HAL_GetNumREVPDHModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PDH channels in the current system.\n\n @return the number of PDH channels"]
    pub fn HAL_GetNumREVPDHChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PH modules in the current system.\n\n @return the number of PH modules"]
    pub fn HAL_GetNumREVPHModules() -> i32;
}
extern "C" {
    #[doc = " Gets the number of PH channels in the current system.\n\n @return the number of PH channels"]
    pub fn HAL_GetNumREVPHChannels() -> i32;
}
extern "C" {
    #[doc = " Gets the number of duty cycle inputs in the current system.\n\n @return the number of Duty Cycle inputs"]
    pub fn HAL_GetNumDutyCycles() -> i32;
}
extern "C" {
    #[doc = " Gets the number of addressable LED generators in the current system.\n\n @return the number of Addressable LED generators"]
    pub fn HAL_GetNumAddressableLEDs() -> i32;
}
extern "C" {
    #[doc = " Gets the roboRIO input voltage.\n\n @param[out] status the error code, or 0 for success\n @return the input voltage (volts)"]
    pub fn HAL_GetVinVoltage(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the roboRIO input current.\n\n @param[out] status the error code, or 0 for success\n @return the input current (amps)"]
    pub fn HAL_GetVinCurrent(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 6V rail voltage.\n\n @param[out] status the error code, or 0 for success\n @return the 6V rail voltage (volts)"]
    pub fn HAL_GetUserVoltage6V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 6V rail current.\n\n @param[out] status the error code, or 0 for success\n @return the 6V rail current (amps)"]
    pub fn HAL_GetUserCurrent6V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the active state of the 6V rail.\n\n @param[out] status the error code, or 0 for success\n @return true if the rail is active, otherwise false"]
    pub fn HAL_GetUserActive6V(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the fault count for the 6V rail.\n\n @param[out] status the error code, or 0 for success\n @return the number of 6V fault counts"]
    pub fn HAL_GetUserCurrentFaults6V(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the 5V rail voltage.\n\n @param[out] status the error code, or 0 for success\n @return the 5V rail voltage (volts)"]
    pub fn HAL_GetUserVoltage5V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 5V rail current.\n\n @param[out] status the error code, or 0 for success\n @return the 5V rail current (amps)"]
    pub fn HAL_GetUserCurrent5V(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the active state of the 5V rail.\n\n @param[out] status the error code, or 0 for success\n @return true if the rail is active, otherwise false"]
    pub fn HAL_GetUserActive5V(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the fault count for the 5V rail.\n\n @param[out] status the error code, or 0 for success\n @return the number of 5V fault counts"]
    pub fn HAL_GetUserCurrentFaults5V(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Gets the 3V3 rail voltage.\n\n @param[out] status the error code, or 0 for success\n @return the 3V3 rail voltage (volts)"]
    pub fn HAL_GetUserVoltage3V3(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the 3V3 rail current.\n\n @param[out] status the error code, or 0 for success\n @return the 3V3 rail current (amps)"]
    pub fn HAL_GetUserCurrent3V3(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Gets the active state of the 3V3 rail.\n\n @param[out] status the error code, or 0 for success\n @return true if the rail is active, otherwise false"]
    pub fn HAL_GetUserActive3V3(status: *mut i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the fault count for the 3V3 rail.\n\n @param[out] status the error code, or 0 for success\n @return the number of 3V3 fault counts"]
    pub fn HAL_GetUserCurrentFaults3V3(status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Get the current brownout voltage setting.\n\n @param[out] status the error code, or 0 for success\n @return The brownout voltage"]
    pub fn HAL_GetBrownoutVoltage(status: *mut i32) -> f64;
}
extern "C" {
    #[doc = " Set the voltage the roboRIO will brownout and disable all outputs.\n\n Note that this only does anything on the roboRIO 2.\n On the roboRIO it is a no-op.\n\n @param[in] voltage The brownout voltage\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetBrownoutVoltage(voltage: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Initializes a relay.\n\n Note this call will only initialize either the forward or reverse port of the\n relay. If you need both, you will need to initialize 2 relays.\n\n @param[in] portHandle         the port handle to initialize\n @param[in] fwd                true for the forward port, false for the\n                               reverse port\n @param[in] allocationLocation the location where the allocation is occurring\n                               (can be null)\n @param[out] status            Error status variable. 0 on success.\n @return the created relay handle"]
    pub fn HAL_InitializeRelayPort(
        portHandle: HAL_PortHandle,
        fwd: HAL_Bool,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_RelayHandle;
}
extern "C" {
    #[doc = " Frees a relay port.\n\n @param relayPortHandle the relay handle"]
    pub fn HAL_FreeRelayPort(relayPortHandle: HAL_RelayHandle);
}
extern "C" {
    #[doc = " Checks if a relay channel is valid.\n\n @param channel the channel to check\n @return true if the channel is valid, otherwise false"]
    pub fn HAL_CheckRelayChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the state of a relay output.\n\n @param[in] relayPortHandle the relay handle\n @param[in] on              true for on, false for off\n @param[out] status         Error status variable. 0 on success."]
    pub fn HAL_SetRelay(relayPortHandle: HAL_RelayHandle, on: HAL_Bool, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the current state of the relay channel.\n\n @param[in] relayPortHandle the relay handle\n @param[out] status         Error status variable. 0 on success.\n @return true for on, false for off"]
    pub fn HAL_GetRelay(relayPortHandle: HAL_RelayHandle, status: *mut i32) -> HAL_Bool;
}
pub const HAL_SPIPort_HAL_SPI_kInvalid: HAL_SPIPort = -1;
pub const HAL_SPIPort_HAL_SPI_kOnboardCS0: HAL_SPIPort = 0;
pub const HAL_SPIPort_HAL_SPI_kOnboardCS1: HAL_SPIPort = 1;
pub const HAL_SPIPort_HAL_SPI_kOnboardCS2: HAL_SPIPort = 2;
pub const HAL_SPIPort_HAL_SPI_kOnboardCS3: HAL_SPIPort = 3;
pub const HAL_SPIPort_HAL_SPI_kMXP: HAL_SPIPort = 4;
#[doc = " @defgroup hal_spi SPI Functions\n @ingroup hal_capi\n @{"]
pub type HAL_SPIPort = i32;
pub const HAL_SPIMode_HAL_SPI_kMode0: HAL_SPIMode = 0;
pub const HAL_SPIMode_HAL_SPI_kMode1: HAL_SPIMode = 1;
pub const HAL_SPIMode_HAL_SPI_kMode2: HAL_SPIMode = 2;
pub const HAL_SPIMode_HAL_SPI_kMode3: HAL_SPIMode = 3;
pub type HAL_SPIMode = i32;
extern "C" {
    #[doc = " Initializes the SPI port. Opens the port if necessary and saves the handle.\n\n If opening the MXP port, also sets up the channel functions appropriately.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS3, 4\n                    for MXP\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_InitializeSPI(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Performs an SPI send/receive transaction.\n\n This is a lower-level interface to the spi hardware giving you more control\n over each transaction.\n\n @param port         The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                     for MXP\n @param dataToSend   Buffer of data to send as part of the transaction.\n @param dataReceived Buffer to read data into.\n @param size         Number of bytes to transfer. [0..7]\n @return Number of bytes transferred, -1 for error"]
    pub fn HAL_TransactionSPI(
        port: HAL_SPIPort,
        dataToSend: *const u8,
        dataReceived: *mut u8,
        size: i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Executes a write transaction with the device.\n\n Writes to a device and wait until the transaction is complete.\n\n @param port       The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                   for MXP\n @param dataToSend The data to write to the register on the device.\n @param sendSize   The number of bytes to be written\n @return The number of bytes written. -1 for an error"]
    pub fn HAL_WriteSPI(port: HAL_SPIPort, dataToSend: *const u8, sendSize: i32) -> i32;
}
extern "C" {
    #[doc = " Executes a read from the device.\n\n This method does not write any data out to the device.\n\n Most spi devices will require a register address to be written before they\n begin returning data.\n\n @param port   The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n               MXP\n @param buffer A pointer to the array of bytes to store the data read from the\n               device.\n @param count  The number of bytes to read in the transaction. [1..7]\n @return Number of bytes read. -1 for error."]
    pub fn HAL_ReadSPI(port: HAL_SPIPort, buffer: *mut u8, count: i32) -> i32;
}
extern "C" {
    #[doc = " Closes the SPI port.\n\n @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP"]
    pub fn HAL_CloseSPI(port: HAL_SPIPort);
}
extern "C" {
    #[doc = " Sets the clock speed for the SPI bus.\n\n @param port  The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n              MXP\n @param speed The speed in Hz (500KHz-10MHz)"]
    pub fn HAL_SetSPISpeed(port: HAL_SPIPort, speed: i32);
}
extern "C" {
    #[doc = " Sets the SPI Mode.\n\n @param port  The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n MXP\n @param mode  The SPI mode to use"]
    pub fn HAL_SetSPIMode(port: HAL_SPIPort, mode: HAL_SPIMode);
}
extern "C" {
    #[doc = " Gets the SPI Mode.\n\n @param port  The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n MXP\n @returns     The SPI mode currently set"]
    pub fn HAL_GetSPIMode(port: HAL_SPIPort) -> HAL_SPIMode;
}
extern "C" {
    #[doc = " Sets the CS Active high for a SPI port.\n\n @param[in] port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n                 MXP\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSPIChipSelectActiveHigh(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the CS Active low for a SPI port.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSPIChipSelectActiveLow(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the stored handle for a SPI port.\n\n @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for MXP\n @return The stored handle for the SPI port. 0 represents no stored\n         handle."]
    pub fn HAL_GetSPIHandle(port: HAL_SPIPort) -> i32;
}
extern "C" {
    #[doc = " Sets the stored handle for a SPI port.\n\n @param port   The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n               MXP.\n @param handle The value of the handle for the port."]
    pub fn HAL_SetSPIHandle(port: HAL_SPIPort, handle: i32);
}
extern "C" {
    #[doc = " Initializes the SPI automatic accumulator.\n\n @param[in] port       The number of the port to use. 0-3 for Onboard CS0-CS2,\n                       4 for MXP.\n @param[in] bufferSize The accumulator buffer size.\n @param[out] status    the error code, or 0 for success"]
    pub fn HAL_InitSPIAuto(port: HAL_SPIPort, bufferSize: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Frees an SPI automatic accumulator.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_FreeSPIAuto(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the period for automatic SPI accumulation.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[in] period  The accumlation period (seconds).\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_StartSPIAutoRate(port: HAL_SPIPort, period: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Starts the auto SPI accumulator on a specific trigger.\n\n Note that triggering on both rising and falling edges is a valid\n configuration.\n\n @param[in] port                The number of the port to use. 0-3 for Onboard\n                                CS0-CS2, 4 for MXP.\n @param[in] digitalSourceHandle The trigger source to use (Either\n                                HAL_AnalogTriggerHandle or HAL_DigitalHandle).\n @param[in] analogTriggerType   The analog trigger type, if the source is an\n                                analog trigger.\n @param[in] triggerRising       Trigger on the rising edge if true.\n @param[in] triggerFalling      Trigger on the falling edge if true.\n @param[out] status             the error code, or 0 for success"]
    pub fn HAL_StartSPIAutoTrigger(
        port: HAL_SPIPort,
        digitalSourceHandle: HAL_Handle,
        analogTriggerType: HAL_AnalogTriggerType,
        triggerRising: HAL_Bool,
        triggerFalling: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Stops an automatic SPI accumlation.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_StopSPIAuto(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the data to be transmitted to the device to initiate a read.\n\n @param[in] port       The number of the port to use. 0-3 for Onboard CS0-CS2,\n                       4 for MXP.\n @param[in] dataToSend Pointer to the data to send (Gets copied for continue\n                       use, so no need to keep alive).\n @param[in] dataSize   The length of the data to send.\n @param[in] zeroSize   The number of zeros to send after the data.\n @param[out] status    the error code, or 0 for success"]
    pub fn HAL_SetSPIAutoTransmitData(
        port: HAL_SPIPort,
        dataToSend: *const u8,
        dataSize: i32,
        zeroSize: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Immediately forces an SPI read to happen.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_ForceSPIAutoRead(port: HAL_SPIPort, status: *mut i32);
}
extern "C" {
    #[doc = " Reads data received by the SPI accumulator.  Each received data sequence\n consists of a timestamp followed by the received data bytes, one byte per\n word (in the least significant byte).  The length of each received data\n sequence is the same as the combined dataSize + zeroSize set in\n HAL_SetSPIAutoTransmitData.\n\n @param[in] port      The number of the port to use. 0-3 for Onboard CS0-CS2,\n                      4 for MXP.\n @param[out] buffer   The buffer to store the data into.\n @param[in] numToRead The number of words to read.\n @param[in] timeout   The read timeout (in seconds).\n @param[out] status   the error code, or 0 for success\n @return The number of words actually read."]
    pub fn HAL_ReadSPIAutoReceivedData(
        port: HAL_SPIPort,
        buffer: *mut u32,
        numToRead: i32,
        timeout: f64,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the count of how many SPI accumulations have been missed.\n\n @param[in] port    The number of the port to use. 0-3 for Onboard CS0-CS2, 4\n                    for MXP.\n @param[out] status the error code, or 0 for success\n @return The number of missed accumulations."]
    pub fn HAL_GetSPIAutoDroppedCount(port: HAL_SPIPort, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Configure the Auto SPI Stall time between reads.\n\n @param[in] port             The number of the port to use. 0-3 for Onboard\n                             CS0-CS2, 4 for MXP.\n @param[in] csToSclkTicks    the number of ticks to wait before asserting the\n                             cs pin\n @param[in] stallTicks       the number of ticks to stall for\n @param[in] pow2BytesPerRead the number of bytes to read before stalling\n @param[out] status          the error code, or 0 for success"]
    pub fn HAL_ConfigureSPIAutoStall(
        port: HAL_SPIPort,
        csToSclkTicks: i32,
        stallTicks: i32,
        pow2BytesPerRead: i32,
        status: *mut i32,
    );
}
pub const HAL_SerialPort_HAL_SerialPort_Onboard: HAL_SerialPort = 0;
pub const HAL_SerialPort_HAL_SerialPort_MXP: HAL_SerialPort = 1;
pub const HAL_SerialPort_HAL_SerialPort_USB1: HAL_SerialPort = 2;
pub const HAL_SerialPort_HAL_SerialPort_USB2: HAL_SerialPort = 3;
#[doc = " @defgroup hal_serialport Serial Port Functions\n @ingroup hal_capi\n @{"]
pub type HAL_SerialPort = i32;
extern "C" {
    #[doc = " Initializes a serial port.\n\n The channels are either the onboard RS232, the mxp uart, or 2 USB ports. The\n top port is USB1, the bottom port is USB2.\n\n @param[in] port the serial port to initialize\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_InitializeSerialPort(port: HAL_SerialPort, status: *mut i32)
        -> HAL_SerialPortHandle;
}
extern "C" {
    #[doc = " Initializes a serial port with a direct name.\n\n This name is the /dev name for a specific port.\n Note these are not always consistent between roboRIO reboots.\n\n @param[in] port     the serial port to initialize\n @param[in] portName the dev port name\n @param[out] status  the error code, or 0 for success"]
    pub fn HAL_InitializeSerialPortDirect(
        port: HAL_SerialPort,
        portName: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_SerialPortHandle;
}
extern "C" {
    #[doc = " Gets the raw serial port file descriptor from a handle.\n\n @param[in] handle the serial port handle\n @param[out] status the error code, or 0 for success\n @return the raw port descriptor"]
    pub fn HAL_GetSerialFD(handle: HAL_SerialPortHandle, status: *mut i32)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the baud rate of a serial port.\n\n Any value between 0 and 0xFFFFFFFF may be used. Default is 9600.\n\n @param[in] handle  the serial port handle\n @param[in] baud    the baud rate to set\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialBaudRate(handle: HAL_SerialPortHandle, baud: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the number of data bits on a serial port.\n\n Defaults to 8.\n\n @param[in] handle  the serial port handle\n @param[in] bits    the number of data bits (5-8)\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialDataBits(handle: HAL_SerialPortHandle, bits: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the number of parity bits on a serial port.\n\n Valid values are:\n   0: None (default)\n   1: Odd\n   2: Even\n   3: Mark - Means exists and always 1\n   4: Space - Means exists and always 0\n\n @param[in] handle  the serial port handle\n @param[in] parity  the parity bit mode (see remarks for valid values)\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialParity(handle: HAL_SerialPortHandle, parity: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the number of stop bits on a serial port.\n\n Valid values are:\n   10: One stop bit (default)\n   15: One and a half stop bits\n   20: Two stop bits\n\n @param[in] handle    the serial port handle\n @param[in] stopBits  the stop bit value (see remarks for valid values)\n @param[out] status   the error code, or 0 for success"]
    pub fn HAL_SetSerialStopBits(handle: HAL_SerialPortHandle, stopBits: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the write mode on a serial port.\n\n Valid values are:\n   1: Flush on access\n   2: Flush when full (default)\n\n @param[in] handle  the serial port handle\n @param[in] mode    the mode to set (see remarks for valid values)\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialWriteMode(handle: HAL_SerialPortHandle, mode: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the flow control mode of a serial port.\n\n Valid values are:\n   0: None (default)\n   1: XON-XOFF\n   2: RTS-CTS\n   3: DTR-DSR\n\n @param[in] handle  the serial port handle\n @param[in] flow    the mode to set (see remarks for valid values)\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialFlowControl(handle: HAL_SerialPortHandle, flow: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the minimum serial read timeout of a port.\n\n @param[in] handle   the serial port handle\n @param[in] timeout  the timeout in milliseconds\n @param[out] status  the error code, or 0 for success"]
    pub fn HAL_SetSerialTimeout(handle: HAL_SerialPortHandle, timeout: f64, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the termination character that terminates a read.\n\n By default this is disabled.\n\n @param[in] handle      the serial port handle\n @param[in] terminator  the termination character to set\n @param[out] status     the error code, or 0 for success"]
    pub fn HAL_EnableSerialTermination(
        handle: HAL_SerialPortHandle,
        terminator: ::std::os::raw::c_char,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Disables a termination character for reads.\n\n @param[in] handle  the serial port handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_DisableSerialTermination(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the size of the read buffer.\n\n @param[in] handle  the serial port handle\n @param[in] size    the read buffer size\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialReadBufferSize(handle: HAL_SerialPortHandle, size: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Sets the size of the write buffer.\n\n @param[in] handle  the serial port handle\n @param[in] size    the write buffer size\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_SetSerialWriteBufferSize(handle: HAL_SerialPortHandle, size: i32, status: *mut i32);
}
extern "C" {
    #[doc = " Gets the number of bytes currently in the read buffer.\n\n @param[in] handle  the serial port handle\n @param[out] status the error code, or 0 for success\n @return the number of bytes in the read buffer"]
    pub fn HAL_GetSerialBytesReceived(handle: HAL_SerialPortHandle, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Reads data from the serial port.\n\n Will wait for either timeout (if set), the termination char (if set), or the\n count to be full. Whichever one comes first.\n\n @param[in] handle  the serial port handle\n @param[out] buffer the buffer in which to store bytes read\n @param[in] count   the number of bytes maximum to read\n @param[out] status the error code, or 0 for success\n @return the number of bytes actually read"]
    pub fn HAL_ReadSerial(
        handle: HAL_SerialPortHandle,
        buffer: *mut ::std::os::raw::c_char,
        count: i32,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Writes data to the serial port.\n\n @param[in] handle  the serial port handle\n @param[in] buffer  the buffer to write\n @param[in] count   the number of bytes to write from the buffer\n @param[out] status the error code, or 0 for success\n @return the number of bytes actually written"]
    pub fn HAL_WriteSerial(
        handle: HAL_SerialPortHandle,
        buffer: *const ::std::os::raw::c_char,
        count: i32,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Flushes the serial write buffer out to the port.\n\n @param[in] handle  the serial port handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_FlushSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Clears the receive buffer of the serial port.\n\n @param[in] handle  the serial port handle\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_ClearSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
extern "C" {
    #[doc = " Closes a serial port.\n\n @param[in] handle  the serial port handle to close\n @param[out] status the error code, or 0 for success"]
    pub fn HAL_CloseSerial(handle: HAL_SerialPortHandle, status: *mut i32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cxxabiv1___class_type_info {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        44usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
pub type pthread_once_t = ::std::os::raw::c_int;
pub type __gthread_once_t = pthread_once_t;
pub type _Atomic_word = ::std::os::raw::c_int;
pub const HAL_Type_HAL_UNASSIGNED: HAL_Type = 0;
pub const HAL_Type_HAL_BOOLEAN: HAL_Type = 1;
pub const HAL_Type_HAL_DOUBLE: HAL_Type = 2;
pub const HAL_Type_HAL_ENUM: HAL_Type = 4;
pub const HAL_Type_HAL_INT: HAL_Type = 8;
pub const HAL_Type_HAL_LONG: HAL_Type = 16;
#[doc = " HAL data types."]
pub type HAL_Type = ::std::os::raw::c_uint;
#[doc = " HAL Entry Value.  Note this is a typed union."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct HAL_Value {
    pub data: HAL_Value__bindgen_ty_1,
    pub type_: HAL_Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union HAL_Value__bindgen_ty_1 {
    pub v_boolean: HAL_Bool,
    pub v_enum: i32,
    pub v_int: i32,
    pub v_long: i64,
    pub v_double: f64,
}
#[test]
fn bindgen_test_layout_HAL_Value__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_Value__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_Value__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(HAL_Value__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_Value__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(HAL_Value__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_enum) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_enum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_long) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_long)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
}
#[test]
fn bindgen_test_layout_HAL_Value() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_Value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_Value>(),
        16usize,
        concat!("Size of: ", stringify!(HAL_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(HAL_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_Value),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = "< input to user code from the simulator"]
pub const HAL_SimValueDirection_HAL_SimValueInput: HAL_SimValueDirection = 0;
#[doc = "< output from user code to the simulator"]
pub const HAL_SimValueDirection_HAL_SimValueOutput: HAL_SimValueDirection = 1;
#[doc = "< bidirectional between user code and simulator"]
pub const HAL_SimValueDirection_HAL_SimValueBidir: HAL_SimValueDirection = 2;
#[doc = " Direction of a simulated value (from the perspective of user code)."]
pub type HAL_SimValueDirection = i32;
extern "C" {
    #[doc = " Creates a simulated device.\n\n The device name must be unique.  0 is returned if the device name already\n exists.  If multiple instances of the same device are desired, recommend\n appending the instance/unique identifer in brackets to the base name,\n e.g. \"device[1]\".\n\n 0 is returned if not in simulation.\n\n @param name device name\n @return simulated device handle"]
    pub fn HAL_CreateSimDevice(name: *const ::std::os::raw::c_char) -> HAL_SimDeviceHandle;
}
extern "C" {
    #[doc = " Frees a simulated device.\n\n This also allows the same device name to be used again.\n This also frees all the simulated values created on the device.\n\n @param handle simulated device handle"]
    pub fn HAL_FreeSimDevice(handle: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Get the name of a simulated device\n\n @param handle simulated device handle\n @return name of the simulated device"]
    pub fn HAL_GetSimDeviceName(handle: HAL_SimDeviceHandle) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Creates a value on a simulated device.\n\n Returns 0 if not in simulation; this can be used to avoid calls\n to Set/Get functions.\n\n @param device simulated device handle\n @param name value name\n @param direction input/output/bidir (from perspective of user code)\n @param initialValue initial value\n @return simulated value handle"]
    pub fn HAL_CreateSimValue(
        device: HAL_SimDeviceHandle,
        name: *const ::std::os::raw::c_char,
        direction: i32,
        initialValue: *const HAL_Value,
    ) -> HAL_SimValueHandle;
}
extern "C" {
    #[doc = " Creates an enumerated value on a simulated device.\n\n Enumerated values are always in the range 0 to numOptions-1.\n\n Returns 0 if not in simulation; this can be used to avoid calls\n to Set/Get functions.\n\n @param device simulated device handle\n @param name value name\n @param direction input/output/bidir (from perspective of user code)\n @param numOptions number of enumerated value options (length of options)\n @param options array of option descriptions\n @param initialValue initial value (selection)\n @return simulated value handle"]
    pub fn HAL_CreateSimValueEnum(
        device: HAL_SimDeviceHandle,
        name: *const ::std::os::raw::c_char,
        direction: i32,
        numOptions: i32,
        options: *mut *const ::std::os::raw::c_char,
        initialValue: i32,
    ) -> HAL_SimValueHandle;
}
extern "C" {
    #[doc = " Creates an enumerated value on a simulated device with double values.\n\n Enumerated values are always in the range 0 to numOptions-1.\n\n Returns 0 if not in simulation; this can be used to avoid calls\n to Set/Get functions.\n\n @param device simulated device handle\n @param name value name\n @param direction input/output/bidir (from perspective of user code)\n @param numOptions number of enumerated value options (length of options)\n @param options array of option descriptions\n @param optionValues array of option double values\n @param initialValue initial value (selection)\n @return simulated value handle"]
    pub fn HAL_CreateSimValueEnumDouble(
        device: HAL_SimDeviceHandle,
        name: *const ::std::os::raw::c_char,
        direction: i32,
        numOptions: i32,
        options: *mut *const ::std::os::raw::c_char,
        optionValues: *const f64,
        initialValue: i32,
    ) -> HAL_SimValueHandle;
}
extern "C" {
    #[doc = " Gets a simulated value.\n\n @param handle simulated value handle\n @param value value (output parameter)"]
    pub fn HAL_GetSimValue(handle: HAL_SimValueHandle, value: *mut HAL_Value);
}
extern "C" {
    #[doc = " Sets a simulated value.\n\n @param handle simulated value handle\n @param value the value to set"]
    pub fn HAL_SetSimValue(handle: HAL_SimValueHandle, value: *const HAL_Value);
}
extern "C" {
    #[doc = " Resets a simulated double or integral value to 0.\n Has no effect on other value types.\n Use this instead of Set(0) for resetting incremental sensor values like\n encoder counts or gyro accumulated angle to ensure correct behavior in a\n distributed system (e.g. WebSockets).\n\n @param handle simulated value handle"]
    pub fn HAL_ResetSimValue(handle: HAL_SimValueHandle);
}
#[doc = " @defgroup hal_threads Threads Functions\n @ingroup hal_capi\n @{"]
pub type NativeThreadHandle = *const ::std::os::raw::c_void;
extern "C" {
    #[doc = " Gets the thread priority for the specified thread.\n\n @param[in] handle      Native handle pointer to the thread to get the\n                        priority for.\n @param[out] isRealTime Set to true if thread is real-time, otherwise false.\n @param[out] status     Error status variable. 0 on success.\n @return The current thread priority. For real-time, this is 1-99 with 99\n         being highest. For non-real-time, this is 0. See \"man 7 sched\" for\n         details."]
    pub fn HAL_GetThreadPriority(
        handle: NativeThreadHandle,
        isRealTime: *mut HAL_Bool,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the thread priority for the current thread.\n\n @param[out] isRealTime Set to true if thread is real-time, otherwise false.\n @param[out] status     Error status variable. 0 on success.\n @return The current thread priority. For real-time, this is 1-99 with 99\n         being highest. For non-real-time, this is 0. See \"man 7 sched\" for\n         details."]
    pub fn HAL_GetCurrentThreadPriority(isRealTime: *mut HAL_Bool, status: *mut i32) -> i32;
}
extern "C" {
    #[doc = " Sets the thread priority for the specified thread.\n\n @param[in] handle   Reference to the thread to set the priority of.\n @param[in] realTime Set to true to set a real-time priority, false for\n                     standard priority.\n @param[in] priority Priority to set the thread to. For real-time, this is\n                     1-99 with 99 being highest. For non-real-time, this is\n                     forced to 0. See \"man 7 sched\" for more details.\n @param[out] status  Error status variable. 0 on success.\n @return True on success."]
    pub fn HAL_SetThreadPriority(
        handle: NativeThreadHandle,
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Sets the thread priority for the current thread.\n\n @param[in] realTime Set to true to set a real-time priority, false for\n                     standard priority.\n @param[in] priority Priority to set the thread to. For real-time, this is\n                     1-99 with 99 being highest. For non-real-time, this is\n                     forced to 0. See \"man 7 sched\" for more details.\n @param[out] status  Error status variable. 0 on success.\n @return True on success."]
    pub fn HAL_SetCurrentThreadPriority(
        realTime: HAL_Bool,
        priority: i32,
        status: *mut i32,
    ) -> HAL_Bool;
}
pub const HAL_PowerDistributionType_HAL_PowerDistributionType_kAutomatic:
    HAL_PowerDistributionType = 0;
pub const HAL_PowerDistributionType_HAL_PowerDistributionType_kCTRE: HAL_PowerDistributionType = 1;
pub const HAL_PowerDistributionType_HAL_PowerDistributionType_kRev: HAL_PowerDistributionType = 2;
#[doc = " The acceptable accelerometer ranges."]
pub type HAL_PowerDistributionType = i32;
extern "C" {
    #[doc = " Initializes a Power Distribution Panel.\n\n @param[in] moduleNumber       the module number to initialize\n @param[in] type               the type of module to intialize\n @param[in] allocationLocation the location where the allocation is occurring\n @param[out] status            Error status variable. 0 on success.\n @return the created PowerDistribution"]
    pub fn HAL_InitializePowerDistribution(
        moduleNumber: i32,
        type_: HAL_PowerDistributionType,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_PowerDistributionHandle;
}
extern "C" {
    #[doc = " Gets the module number for a specific handle.\n\n @param[in] handle the module handle\n @param[out] status Error status variable. 0 on success.\n @return the module number"]
    pub fn HAL_GetPowerDistributionModuleNumber(
        handle: HAL_PowerDistributionHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Cleans a PowerDistribution module.\n\n @param handle the module handle"]
    pub fn HAL_CleanPowerDistribution(handle: HAL_PowerDistributionHandle);
}
extern "C" {
    #[doc = " Checks if a PowerDistribution channel is valid.\n\n @param handle  the module handle\n @param channel the channel to check\n @return true if the channel is valid, otherwise false"]
    pub fn HAL_CheckPowerDistributionChannel(
        handle: HAL_PowerDistributionHandle,
        channel: i32,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Checks if a PowerDistribution module is valid.\n\n @param module the module to check\n @param type   the type of module\n @return true if the module is valid, otherwise false"]
    pub fn HAL_CheckPowerDistributionModule(
        module: i32,
        type_: HAL_PowerDistributionType,
    ) -> HAL_Bool;
}
extern "C" {
    #[doc = " Gets the type of PowerDistribution module.\n\n @param[in] handle the module handle\n @param[out] status Error status variable. 0 on success.\n @return the type of module"]
    pub fn HAL_GetPowerDistributionType(
        handle: HAL_PowerDistributionHandle,
        status: *mut i32,
    ) -> HAL_PowerDistributionType;
}
extern "C" {
    #[doc = " Gets the number of channels for this handle.\n\n @param[in] handle the handle\n @param[out] status Error status variable. 0 on success.\n @return number of channels"]
    pub fn HAL_GetPowerDistributionNumChannels(
        handle: HAL_PowerDistributionHandle,
        status: *mut i32,
    ) -> i32;
}
extern "C" {
    #[doc = " Gets the temperature of the PowerDistribution.\n\n @param[in] handle the module handle\n @param[out] status Error status variable. 0 on success.\n @return the module temperature (celsius)"]
    pub fn HAL_GetPowerDistributionTemperature(
        handle: HAL_PowerDistributionHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the PowerDistribution input voltage.\n\n @param[in] handle the module handle\n @param[out] status Error status variable. 0 on success.\n @return the input voltage (volts)"]
    pub fn HAL_GetPowerDistributionVoltage(
        handle: HAL_PowerDistributionHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the current of a specific PowerDistribution channel.\n\n @param[in] handle   the module handle\n @param[in] channel  the channel\n @param[out] status  Error status variable. 0 on success.\n @return the channel current (amps)"]
    pub fn HAL_GetPowerDistributionChannelCurrent(
        handle: HAL_PowerDistributionHandle,
        channel: i32,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the current of all 24 channels on the PowerDistribution.\n\n The array must be large enough to hold all channels.\n\n @param[in] handle         the module handle\n @param[out] currents      the currents\n @param[in] currentsLength the length of the currents array\n @param[out] status        Error status variable. 0 on success."]
    pub fn HAL_GetPowerDistributionAllChannelCurrents(
        handle: HAL_PowerDistributionHandle,
        currents: *mut f64,
        currentsLength: i32,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Gets the total current of the PowerDistribution.\n\n @param[in] handle the module handle\n @param[out] status Error status variable. 0 on success.\n @return the total current (amps)"]
    pub fn HAL_GetPowerDistributionTotalCurrent(
        handle: HAL_PowerDistributionHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the total power of the PowerDistribution.\n\n @param[in] handle the module handle\n @param[out] status Error status variable. 0 on success.\n @return the total power (watts)"]
    pub fn HAL_GetPowerDistributionTotalPower(
        handle: HAL_PowerDistributionHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Gets the total energy of the PowerDistribution.\n\n @param[in] handle the module handle\n @param[out] status Error status variable. 0 on success.\n @return the total energy (joules)"]
    pub fn HAL_GetPowerDistributionTotalEnergy(
        handle: HAL_PowerDistributionHandle,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    #[doc = " Resets the PowerDistribution accumulated energy.\n\n @param[in] handle the module handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_ResetPowerDistributionTotalEnergy(
        handle: HAL_PowerDistributionHandle,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Clears any PowerDistribution sticky faults.\n\n @param[in] handle the module handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_ClearPowerDistributionStickyFaults(
        handle: HAL_PowerDistributionHandle,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Power on/off switchable channel.\n\n This is a REV PDH-specific function. This function will no-op on CTRE PDP.\n\n @param[in] handle the module handle\n @param[in] enabled true to turn on switchable channel\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_SetPowerDistributionSwitchableChannel(
        handle: HAL_PowerDistributionHandle,
        enabled: HAL_Bool,
        status: *mut i32,
    );
}
extern "C" {
    #[doc = " Returns true if switchable channel is powered on.\n\n This is a REV PDH-specific function. This function will no-op on CTRE PDP.\n\n @param[in] handle the module handle\n @param[out] status Error status variable. 0 on success."]
    pub fn HAL_GetPowerDistributionSwitchableChannel(
        handle: HAL_PowerDistributionHandle,
        status: *mut i32,
    ) -> HAL_Bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_PowerDistributionVersion {
    pub firmwareMajor: u32,
    pub firmwareMinor: u32,
    pub firmwareFix: u32,
    pub hardwareMinor: u32,
    pub hardwareMajor: u32,
    pub uniqueId: u32,
}
#[test]
fn bindgen_test_layout_HAL_PowerDistributionVersion() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_PowerDistributionVersion> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_PowerDistributionVersion>(),
        24usize,
        concat!("Size of: ", stringify!(HAL_PowerDistributionVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_PowerDistributionVersion>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_PowerDistributionVersion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmwareMajor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_PowerDistributionVersion),
            "::",
            stringify!(firmwareMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmwareMinor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_PowerDistributionVersion),
            "::",
            stringify!(firmwareMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmwareFix) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_PowerDistributionVersion),
            "::",
            stringify!(firmwareFix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hardwareMinor) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_PowerDistributionVersion),
            "::",
            stringify!(hardwareMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hardwareMajor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_PowerDistributionVersion),
            "::",
            stringify!(hardwareMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uniqueId) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_PowerDistributionVersion),
            "::",
            stringify!(uniqueId)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HAL_PowerDistributionFaults {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_HAL_PowerDistributionFaults() {
    assert_eq!(
        ::std::mem::size_of::<HAL_PowerDistributionFaults>(),
        4usize,
        concat!("Size of: ", stringify!(HAL_PowerDistributionFaults))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_PowerDistributionFaults>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_PowerDistributionFaults))
    );
}
impl HAL_PowerDistributionFaults {
    #[inline]
    pub fn channel0BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel0BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel1BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel1BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel2BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel2BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel3BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel3BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel4BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel4BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel5BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel5BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel6BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel6BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel7BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel7BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel8BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel8BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel9BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel9BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel10BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel10BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel11BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel11BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel12BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel12BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel13BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel13BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel14BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel14BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel15BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel15BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel16BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel16BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel17BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel17BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel18BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel18BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel19BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel19BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel20BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel20BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel21BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel21BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel22BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel22BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel23BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel23BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brownout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brownout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn canWarning(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_canWarning(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hardwareFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hardwareFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        channel0BreakerFault: u32,
        channel1BreakerFault: u32,
        channel2BreakerFault: u32,
        channel3BreakerFault: u32,
        channel4BreakerFault: u32,
        channel5BreakerFault: u32,
        channel6BreakerFault: u32,
        channel7BreakerFault: u32,
        channel8BreakerFault: u32,
        channel9BreakerFault: u32,
        channel10BreakerFault: u32,
        channel11BreakerFault: u32,
        channel12BreakerFault: u32,
        channel13BreakerFault: u32,
        channel14BreakerFault: u32,
        channel15BreakerFault: u32,
        channel16BreakerFault: u32,
        channel17BreakerFault: u32,
        channel18BreakerFault: u32,
        channel19BreakerFault: u32,
        channel20BreakerFault: u32,
        channel21BreakerFault: u32,
        channel22BreakerFault: u32,
        channel23BreakerFault: u32,
        brownout: u32,
        canWarning: u32,
        hardwareFault: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let channel0BreakerFault: u32 = unsafe { ::std::mem::transmute(channel0BreakerFault) };
            channel0BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let channel1BreakerFault: u32 = unsafe { ::std::mem::transmute(channel1BreakerFault) };
            channel1BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let channel2BreakerFault: u32 = unsafe { ::std::mem::transmute(channel2BreakerFault) };
            channel2BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let channel3BreakerFault: u32 = unsafe { ::std::mem::transmute(channel3BreakerFault) };
            channel3BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let channel4BreakerFault: u32 = unsafe { ::std::mem::transmute(channel4BreakerFault) };
            channel4BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let channel5BreakerFault: u32 = unsafe { ::std::mem::transmute(channel5BreakerFault) };
            channel5BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let channel6BreakerFault: u32 = unsafe { ::std::mem::transmute(channel6BreakerFault) };
            channel6BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let channel7BreakerFault: u32 = unsafe { ::std::mem::transmute(channel7BreakerFault) };
            channel7BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let channel8BreakerFault: u32 = unsafe { ::std::mem::transmute(channel8BreakerFault) };
            channel8BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let channel9BreakerFault: u32 = unsafe { ::std::mem::transmute(channel9BreakerFault) };
            channel9BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let channel10BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel10BreakerFault) };
            channel10BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let channel11BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel11BreakerFault) };
            channel11BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let channel12BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel12BreakerFault) };
            channel12BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let channel13BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel13BreakerFault) };
            channel13BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let channel14BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel14BreakerFault) };
            channel14BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let channel15BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel15BreakerFault) };
            channel15BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let channel16BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel16BreakerFault) };
            channel16BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let channel17BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel17BreakerFault) };
            channel17BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let channel18BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel18BreakerFault) };
            channel18BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let channel19BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel19BreakerFault) };
            channel19BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let channel20BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel20BreakerFault) };
            channel20BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let channel21BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel21BreakerFault) };
            channel21BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let channel22BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel22BreakerFault) };
            channel22BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let channel23BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel23BreakerFault) };
            channel23BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let brownout: u32 = unsafe { ::std::mem::transmute(brownout) };
            brownout as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let canWarning: u32 = unsafe { ::std::mem::transmute(canWarning) };
            canWarning as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let hardwareFault: u32 = unsafe { ::std::mem::transmute(hardwareFault) };
            hardwareFault as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Storage for REV PDH Sticky Faults"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HAL_PowerDistributionStickyFaults {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_HAL_PowerDistributionStickyFaults() {
    assert_eq!(
        ::std::mem::size_of::<HAL_PowerDistributionStickyFaults>(),
        4usize,
        concat!("Size of: ", stringify!(HAL_PowerDistributionStickyFaults))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_PowerDistributionStickyFaults>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(HAL_PowerDistributionStickyFaults)
        )
    );
}
impl HAL_PowerDistributionStickyFaults {
    #[inline]
    pub fn channel0BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel0BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel1BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel1BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel2BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel2BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel3BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel3BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel4BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel4BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel5BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel5BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel6BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel6BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel7BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel7BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel8BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel8BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel9BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel9BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel10BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel10BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel11BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel11BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel12BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel12BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel13BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel13BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel14BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel14BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel15BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel15BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel16BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel16BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel17BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel17BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel18BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel18BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel19BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel19BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel20BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel20BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel21BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel21BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel22BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel22BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel23BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel23BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brownout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brownout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn canWarning(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_canWarning(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn canBusOff(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_canBusOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasReset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasReset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        channel0BreakerFault: u32,
        channel1BreakerFault: u32,
        channel2BreakerFault: u32,
        channel3BreakerFault: u32,
        channel4BreakerFault: u32,
        channel5BreakerFault: u32,
        channel6BreakerFault: u32,
        channel7BreakerFault: u32,
        channel8BreakerFault: u32,
        channel9BreakerFault: u32,
        channel10BreakerFault: u32,
        channel11BreakerFault: u32,
        channel12BreakerFault: u32,
        channel13BreakerFault: u32,
        channel14BreakerFault: u32,
        channel15BreakerFault: u32,
        channel16BreakerFault: u32,
        channel17BreakerFault: u32,
        channel18BreakerFault: u32,
        channel19BreakerFault: u32,
        channel20BreakerFault: u32,
        channel21BreakerFault: u32,
        channel22BreakerFault: u32,
        channel23BreakerFault: u32,
        brownout: u32,
        canWarning: u32,
        canBusOff: u32,
        hasReset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let channel0BreakerFault: u32 = unsafe { ::std::mem::transmute(channel0BreakerFault) };
            channel0BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let channel1BreakerFault: u32 = unsafe { ::std::mem::transmute(channel1BreakerFault) };
            channel1BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let channel2BreakerFault: u32 = unsafe { ::std::mem::transmute(channel2BreakerFault) };
            channel2BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let channel3BreakerFault: u32 = unsafe { ::std::mem::transmute(channel3BreakerFault) };
            channel3BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let channel4BreakerFault: u32 = unsafe { ::std::mem::transmute(channel4BreakerFault) };
            channel4BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let channel5BreakerFault: u32 = unsafe { ::std::mem::transmute(channel5BreakerFault) };
            channel5BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let channel6BreakerFault: u32 = unsafe { ::std::mem::transmute(channel6BreakerFault) };
            channel6BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let channel7BreakerFault: u32 = unsafe { ::std::mem::transmute(channel7BreakerFault) };
            channel7BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let channel8BreakerFault: u32 = unsafe { ::std::mem::transmute(channel8BreakerFault) };
            channel8BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let channel9BreakerFault: u32 = unsafe { ::std::mem::transmute(channel9BreakerFault) };
            channel9BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let channel10BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel10BreakerFault) };
            channel10BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let channel11BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel11BreakerFault) };
            channel11BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let channel12BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel12BreakerFault) };
            channel12BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let channel13BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel13BreakerFault) };
            channel13BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let channel14BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel14BreakerFault) };
            channel14BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let channel15BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel15BreakerFault) };
            channel15BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let channel16BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel16BreakerFault) };
            channel16BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let channel17BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel17BreakerFault) };
            channel17BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let channel18BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel18BreakerFault) };
            channel18BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let channel19BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel19BreakerFault) };
            channel19BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let channel20BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel20BreakerFault) };
            channel20BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let channel21BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel21BreakerFault) };
            channel21BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let channel22BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel22BreakerFault) };
            channel22BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let channel23BreakerFault: u32 =
                unsafe { ::std::mem::transmute(channel23BreakerFault) };
            channel23BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let brownout: u32 = unsafe { ::std::mem::transmute(brownout) };
            brownout as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let canWarning: u32 = unsafe { ::std::mem::transmute(canWarning) };
            canWarning as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let canBusOff: u32 = unsafe { ::std::mem::transmute(canBusOff) };
            canBusOff as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let hasReset: u32 = unsafe { ::std::mem::transmute(hasReset) };
            hasReset as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn HAL_GetPowerDistributionVersion(
        handle: HAL_PowerDistributionHandle,
        version: *mut HAL_PowerDistributionVersion,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetPowerDistributionFaults(
        handle: HAL_PowerDistributionHandle,
        faults: *mut HAL_PowerDistributionFaults,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetPowerDistributionStickyFaults(
        handle: HAL_PowerDistributionHandle,
        stickyFaults: *mut HAL_PowerDistributionStickyFaults,
        status: *mut i32,
    );
}
pub const HAL_REVPHCompressorConfigType_HAL_REVPHCompressorConfigType_kDisabled:
    HAL_REVPHCompressorConfigType = 0;
pub const HAL_REVPHCompressorConfigType_HAL_REVPHCompressorConfigType_kDigital:
    HAL_REVPHCompressorConfigType = 1;
pub const HAL_REVPHCompressorConfigType_HAL_REVPHCompressorConfigType_kAnalog:
    HAL_REVPHCompressorConfigType = 2;
pub const HAL_REVPHCompressorConfigType_HAL_REVPHCompressorConfigType_kHybrid:
    HAL_REVPHCompressorConfigType = 3;
#[doc = " The compressor configuration type"]
pub type HAL_REVPHCompressorConfigType = i32;
#[doc = " Storage for REV PH Version"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_REVPHVersion {
    pub firmwareMajor: u32,
    pub firmwareMinor: u32,
    pub firmwareFix: u32,
    pub hardwareMinor: u32,
    pub hardwareMajor: u32,
    pub uniqueId: u32,
}
#[test]
fn bindgen_test_layout_HAL_REVPHVersion() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_REVPHVersion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_REVPHVersion>(),
        24usize,
        concat!("Size of: ", stringify!(HAL_REVPHVersion))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_REVPHVersion>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_REVPHVersion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmwareMajor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHVersion),
            "::",
            stringify!(firmwareMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmwareMinor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHVersion),
            "::",
            stringify!(firmwareMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).firmwareFix) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHVersion),
            "::",
            stringify!(firmwareFix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hardwareMinor) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHVersion),
            "::",
            stringify!(hardwareMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hardwareMajor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHVersion),
            "::",
            stringify!(hardwareMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uniqueId) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHVersion),
            "::",
            stringify!(uniqueId)
        )
    );
}
#[doc = " Storage for compressor config"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HAL_REVPHCompressorConfig {
    pub minAnalogVoltage: f64,
    pub maxAnalogVoltage: f64,
    pub forceDisable: HAL_Bool,
    pub useDigital: HAL_Bool,
}
#[test]
fn bindgen_test_layout_HAL_REVPHCompressorConfig() {
    const UNINIT: ::std::mem::MaybeUninit<HAL_REVPHCompressorConfig> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HAL_REVPHCompressorConfig>(),
        24usize,
        concat!("Size of: ", stringify!(HAL_REVPHCompressorConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_REVPHCompressorConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(HAL_REVPHCompressorConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minAnalogVoltage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHCompressorConfig),
            "::",
            stringify!(minAnalogVoltage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxAnalogVoltage) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHCompressorConfig),
            "::",
            stringify!(maxAnalogVoltage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).forceDisable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHCompressorConfig),
            "::",
            stringify!(forceDisable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).useDigital) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HAL_REVPHCompressorConfig),
            "::",
            stringify!(useDigital)
        )
    );
}
#[doc = " Storage for REV PH Faults"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HAL_REVPHFaults {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_HAL_REVPHFaults() {
    assert_eq!(
        ::std::mem::size_of::<HAL_REVPHFaults>(),
        4usize,
        concat!("Size of: ", stringify!(HAL_REVPHFaults))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_REVPHFaults>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_REVPHFaults))
    );
}
impl HAL_REVPHFaults {
    #[inline]
    pub fn channel0Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel0Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel1Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel1Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel2Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel2Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel3Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel3Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel4Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel4Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel5Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel5Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel6Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel6Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel7Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel7Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel8Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel8Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel9Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel9Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel10Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel10Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel11Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel11Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel12Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel12Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel13Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel13Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel14Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel14Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel15Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_channel15Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn compressorOverCurrent(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compressorOverCurrent(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn compressorOpen(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compressorOpen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn solenoidOverCurrent(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_solenoidOverCurrent(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brownout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brownout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn canWarning(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_canWarning(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hardwareFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hardwareFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        channel0Fault: u32,
        channel1Fault: u32,
        channel2Fault: u32,
        channel3Fault: u32,
        channel4Fault: u32,
        channel5Fault: u32,
        channel6Fault: u32,
        channel7Fault: u32,
        channel8Fault: u32,
        channel9Fault: u32,
        channel10Fault: u32,
        channel11Fault: u32,
        channel12Fault: u32,
        channel13Fault: u32,
        channel14Fault: u32,
        channel15Fault: u32,
        compressorOverCurrent: u32,
        compressorOpen: u32,
        solenoidOverCurrent: u32,
        brownout: u32,
        canWarning: u32,
        hardwareFault: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let channel0Fault: u32 = unsafe { ::std::mem::transmute(channel0Fault) };
            channel0Fault as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let channel1Fault: u32 = unsafe { ::std::mem::transmute(channel1Fault) };
            channel1Fault as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let channel2Fault: u32 = unsafe { ::std::mem::transmute(channel2Fault) };
            channel2Fault as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let channel3Fault: u32 = unsafe { ::std::mem::transmute(channel3Fault) };
            channel3Fault as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let channel4Fault: u32 = unsafe { ::std::mem::transmute(channel4Fault) };
            channel4Fault as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let channel5Fault: u32 = unsafe { ::std::mem::transmute(channel5Fault) };
            channel5Fault as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let channel6Fault: u32 = unsafe { ::std::mem::transmute(channel6Fault) };
            channel6Fault as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let channel7Fault: u32 = unsafe { ::std::mem::transmute(channel7Fault) };
            channel7Fault as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let channel8Fault: u32 = unsafe { ::std::mem::transmute(channel8Fault) };
            channel8Fault as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let channel9Fault: u32 = unsafe { ::std::mem::transmute(channel9Fault) };
            channel9Fault as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let channel10Fault: u32 = unsafe { ::std::mem::transmute(channel10Fault) };
            channel10Fault as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let channel11Fault: u32 = unsafe { ::std::mem::transmute(channel11Fault) };
            channel11Fault as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let channel12Fault: u32 = unsafe { ::std::mem::transmute(channel12Fault) };
            channel12Fault as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let channel13Fault: u32 = unsafe { ::std::mem::transmute(channel13Fault) };
            channel13Fault as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let channel14Fault: u32 = unsafe { ::std::mem::transmute(channel14Fault) };
            channel14Fault as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let channel15Fault: u32 = unsafe { ::std::mem::transmute(channel15Fault) };
            channel15Fault as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let compressorOverCurrent: u32 =
                unsafe { ::std::mem::transmute(compressorOverCurrent) };
            compressorOverCurrent as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let compressorOpen: u32 = unsafe { ::std::mem::transmute(compressorOpen) };
            compressorOpen as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let solenoidOverCurrent: u32 = unsafe { ::std::mem::transmute(solenoidOverCurrent) };
            solenoidOverCurrent as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let brownout: u32 = unsafe { ::std::mem::transmute(brownout) };
            brownout as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let canWarning: u32 = unsafe { ::std::mem::transmute(canWarning) };
            canWarning as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let hardwareFault: u32 = unsafe { ::std::mem::transmute(hardwareFault) };
            hardwareFault as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = " Storage for REV PH Sticky Faults"]
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct HAL_REVPHStickyFaults {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_HAL_REVPHStickyFaults() {
    assert_eq!(
        ::std::mem::size_of::<HAL_REVPHStickyFaults>(),
        4usize,
        concat!("Size of: ", stringify!(HAL_REVPHStickyFaults))
    );
    assert_eq!(
        ::std::mem::align_of::<HAL_REVPHStickyFaults>(),
        4usize,
        concat!("Alignment of ", stringify!(HAL_REVPHStickyFaults))
    );
}
impl HAL_REVPHStickyFaults {
    #[inline]
    pub fn compressorOverCurrent(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compressorOverCurrent(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn compressorOpen(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_compressorOpen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn solenoidOverCurrent(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_solenoidOverCurrent(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn brownout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_brownout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn canWarning(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_canWarning(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn canBusOff(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_canBusOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hasReset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_hasReset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        compressorOverCurrent: u32,
        compressorOpen: u32,
        solenoidOverCurrent: u32,
        brownout: u32,
        canWarning: u32,
        canBusOff: u32,
        hasReset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let compressorOverCurrent: u32 =
                unsafe { ::std::mem::transmute(compressorOverCurrent) };
            compressorOverCurrent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let compressorOpen: u32 = unsafe { ::std::mem::transmute(compressorOpen) };
            compressorOpen as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let solenoidOverCurrent: u32 = unsafe { ::std::mem::transmute(solenoidOverCurrent) };
            solenoidOverCurrent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let brownout: u32 = unsafe { ::std::mem::transmute(brownout) };
            brownout as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let canWarning: u32 = unsafe { ::std::mem::transmute(canWarning) };
            canWarning as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let canBusOff: u32 = unsafe { ::std::mem::transmute(canBusOff) };
            canBusOff as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hasReset: u32 = unsafe { ::std::mem::transmute(hasReset) };
            hasReset as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn HAL_InitializeREVPH(
        module: i32,
        allocationLocation: *const ::std::os::raw::c_char,
        status: *mut i32,
    ) -> HAL_REVPHHandle;
}
extern "C" {
    pub fn HAL_FreeREVPH(handle: HAL_REVPHHandle);
}
extern "C" {
    pub fn HAL_CheckREVPHSolenoidChannel(channel: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_CheckREVPHModuleNumber(module: i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetREVPHCompressor(handle: HAL_REVPHHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_SetREVPHCompressorConfig(
        handle: HAL_REVPHHandle,
        config: *const HAL_REVPHCompressorConfig,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetREVPHClosedLoopControlDisabled(handle: HAL_REVPHHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetREVPHClosedLoopControlDigital(handle: HAL_REVPHHandle, status: *mut i32);
}
extern "C" {
    pub fn HAL_SetREVPHClosedLoopControlAnalog(
        handle: HAL_REVPHHandle,
        minAnalogVoltage: f64,
        maxAnalogVoltage: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_SetREVPHClosedLoopControlHybrid(
        handle: HAL_REVPHHandle,
        minAnalogVoltage: f64,
        maxAnalogVoltage: f64,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetREVPHCompressorConfig(
        handle: HAL_REVPHHandle,
        status: *mut i32,
    ) -> HAL_REVPHCompressorConfigType;
}
extern "C" {
    pub fn HAL_GetREVPHPressureSwitch(handle: HAL_REVPHHandle, status: *mut i32) -> HAL_Bool;
}
extern "C" {
    pub fn HAL_GetREVPHCompressorCurrent(handle: HAL_REVPHHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetREVPHAnalogVoltage(
        handle: HAL_REVPHHandle,
        channel: i32,
        status: *mut i32,
    ) -> f64;
}
extern "C" {
    pub fn HAL_GetREVPHVoltage(handle: HAL_REVPHHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetREVPH5VVoltage(handle: HAL_REVPHHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetREVPHSolenoidCurrent(handle: HAL_REVPHHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetREVPHSolenoidVoltage(handle: HAL_REVPHHandle, status: *mut i32) -> f64;
}
extern "C" {
    pub fn HAL_GetREVPHVersion(
        handle: HAL_REVPHHandle,
        version: *mut HAL_REVPHVersion,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetREVPHSolenoids(handle: HAL_REVPHHandle, status: *mut i32) -> i32;
}
extern "C" {
    pub fn HAL_SetREVPHSolenoids(handle: HAL_REVPHHandle, mask: i32, values: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_FireREVPHOneShot(handle: HAL_REVPHHandle, index: i32, durMs: i32, status: *mut i32);
}
extern "C" {
    pub fn HAL_GetREVPHFaults(
        handle: HAL_REVPHHandle,
        faults: *mut HAL_REVPHFaults,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_GetREVPHStickyFaults(
        handle: HAL_REVPHHandle,
        stickyFaults: *mut HAL_REVPHStickyFaults,
        status: *mut i32,
    );
}
extern "C" {
    pub fn HAL_ClearREVPHStickyFaults(handle: HAL_REVPHHandle, status: *mut i32);
}
#[doc = "An implementation of ``std::basic_string_view`` for pre-C++17. It provides a\nsubset of the API. ``fmt::basic_string_view`` is used for format strings even\nif ``std::string_view`` is available to prevent issues when a library is\ncompiled with a different ``-std`` option than the client code (which is not\nrecommended)."]
pub type fmt_string_view = [u32; 2usize];
#[doc = "\\rst\nA view of a collection of formatting arguments. To avoid lifetime issues it\nshould only be used as a parameter type in type-erased functions such as\n``vformat``::\n\nvoid vlog(string_view format_str, format_args args);  // OK\nformat_args args = make_format_args(42);  // Error: dangling reference\n\\endrst"]
pub type fmt_format_args = [u64; 2usize];
#[doc = " @brief\t\thelper type to identify base units.\n @details\t\tA non-templated base class for `base_unit` which enables RTTI testing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct units_detail__base_unit_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_units_detail__base_unit_t() {
    assert_eq!(
        ::std::mem::size_of::<units_detail__base_unit_t>(),
        1usize,
        concat!("Size of: ", stringify!(units_detail__base_unit_t))
    );
    assert_eq!(
        ::std::mem::align_of::<units_detail__base_unit_t>(),
        1usize,
        concat!("Alignment of ", stringify!(units_detail__base_unit_t))
    );
}
#[doc = " @brief\t\thelper type to identify units.\n @details\t\tA non-templated base class for `unit` which enables RTTI testing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct units_detail__unit {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_units_detail__unit() {
    assert_eq!(
        ::std::mem::size_of::<units_detail__unit>(),
        1usize,
        concat!("Size of: ", stringify!(units_detail__unit))
    );
    assert_eq!(
        ::std::mem::align_of::<units_detail__unit>(),
        1usize,
        concat!("Alignment of ", stringify!(units_detail__unit))
    );
}
#[doc = " @brief\t\thelper type to identify units.\n @details\t\tA non-templated base class for `unit` which enables RTTI testing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct units_detail__unit_t {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_units_detail__unit_t() {
    assert_eq!(
        ::std::mem::size_of::<units_detail__unit_t>(),
        1usize,
        concat!("Size of: ", stringify!(units_detail__unit_t))
    );
    assert_eq!(
        ::std::mem::align_of::<units_detail__unit_t>(),
        1usize,
        concat!("Alignment of ", stringify!(units_detail__unit_t))
    );
}
#[doc = " @brief\t\tunit traits implementation for classes which are not units."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct units_traits_unit_traits {
    pub _address: u8,
}
pub type units_traits_unit_traits_base_unit_type = ::std::os::raw::c_void;
pub type units_traits_unit_traits_conversion_ratio = ::std::os::raw::c_void;
pub type units_traits_unit_traits_pi_exponent_ratio = ::std::os::raw::c_void;
pub type units_traits_unit_traits_translation_ratio = ::std::os::raw::c_void;
#[doc = " @ingroup\t\tUnitTypes\n @brief\t\tClass representing SI base unit types.\n @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each\n\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second\n\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:\n\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`\n @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters.\n @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms.\n @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds.\n @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.\n @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes.\n @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin.\n @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles.\n @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas.\n @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes.\n @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct units_base_unit {
    pub _address: u8,
}
pub type units_base_unit_meter_ratio<Meter> = Meter;
pub type units_base_unit_kilogram_ratio<Kilogram> = Kilogram;
pub type units_base_unit_second_ratio<Second> = Second;
pub type units_base_unit_radian_ratio<Radian> = Radian;
pub type units_base_unit_ampere_ratio<Ampere> = Ampere;
pub type units_base_unit_kelvin_ratio<Kelvin> = Kelvin;
pub type units_base_unit_mole_ratio<Mole> = Mole;
pub type units_base_unit_candela_ratio<Candela> = Candela;
pub type units_base_unit_byte_ratio<Byte> = Byte;
#[doc = " @ingroup\t\tUnitTypes\n @brief\t\tClass representing SI base unit types.\n @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each\n\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second\n\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:\n\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`\n @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters.\n @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms.\n @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds.\n @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.\n @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes.\n @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin.\n @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles.\n @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas.\n @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes.\n @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
pub type units_category_length_unit = units_base_unit;
pub type units_category_mass_unit = units_base_unit;
#[doc = " @ingroup\t\tUnitTypes\n @brief\t\tClass representing SI base unit types.\n @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each\n\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second\n\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:\n\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`\n @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters.\n @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms.\n @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds.\n @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.\n @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes.\n @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin.\n @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles.\n @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas.\n @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes.\n @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
pub type units_category_time_unit = units_base_unit;
#[doc = " @ingroup\t\tUnitTypes\n @brief\t\tClass representing SI base unit types.\n @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each\n\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second\n\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:\n\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`\n @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters.\n @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms.\n @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds.\n @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.\n @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes.\n @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin.\n @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles.\n @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas.\n @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes.\n @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
pub type units_category_angle_unit = units_base_unit;
#[doc = " @ingroup\t\tUnitTypes\n @brief\t\tClass representing SI base unit types.\n @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each\n\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second\n\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:\n\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`\n @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters.\n @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms.\n @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds.\n @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.\n @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes.\n @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin.\n @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles.\n @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas.\n @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes.\n @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
pub type units_category_current_unit = units_base_unit;
#[doc = " @ingroup\t\tUnitTypes\n @brief\t\tClass representing SI base unit types.\n @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each\n\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second\n\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:\n\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`\n @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters.\n @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms.\n @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds.\n @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.\n @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes.\n @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin.\n @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles.\n @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas.\n @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes.\n @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
pub type units_category_velocity_unit = units_base_unit;
#[doc = " @ingroup\t\tUnitTypes\n @brief\t\tClass representing SI base unit types.\n @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each\n\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second\n\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:\n\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`\n @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters.\n @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms.\n @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds.\n @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.\n @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes.\n @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin.\n @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles.\n @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas.\n @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes.\n @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
pub type units_category_angular_velocity_unit = units_base_unit;
#[doc = " @ingroup\t\tUnitTypes\n @brief\t\tClass representing SI base unit types.\n @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each\n\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second\n\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:\n\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`\n @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters.\n @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms.\n @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds.\n @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.\n @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes.\n @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin.\n @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles.\n @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas.\n @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes.\n @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
pub type units_category_energy_unit = units_base_unit;
#[doc = " @ingroup\t\tUnitTypes\n @brief\t\tClass representing SI base unit types.\n @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each\n\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second\n\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:\n\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`\n @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters.\n @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms.\n @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds.\n @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.\n @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes.\n @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin.\n @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles.\n @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas.\n @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes.\n @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
pub type units_category_voltage_unit = units_base_unit;
#[doc = " @ingroup\t\tUnitTypes\n @brief\t\tClass representing SI base unit types.\n @details\t\tBase units are represented by a combination of `std::ratio` template parameters, each\n\t\t\t\tdescribing the exponent of the type of unit they represent. Example: meters per second\n\t\t\t\twould be described by a +1 exponent for meters, and a -1 exponent for seconds, thus:\n\t\t\t\t`base_unit<std::ratio<1>, std::ratio<0>, std::ratio<-1>>`\n @tparam\t\tMeter\t\t`std::ratio` representing the exponent value for meters.\n @tparam\t\tKilogram\t`std::ratio` representing the exponent value for kilograms.\n @tparam\t\tSecond\t\t`std::ratio` representing the exponent value for seconds.\n @tparam\t\tRadian\t\t`std::ratio` representing the exponent value for radians. Although radians are not SI base units, they are included because radians are described by the SI as m * m^-1, which would make them indistinguishable from scalars.\n @tparam\t\tAmpere\t\t`std::ratio` representing the exponent value for amperes.\n @tparam\t\tKelvin\t\t`std::ratio` representing the exponent value for Kelvin.\n @tparam\t\tMole\t\t`std::ratio` representing the exponent value for moles.\n @tparam\t\tCandela\t\t`std::ratio` representing the exponent value for candelas.\n @tparam\t\tByte\t\t`std::ratio` representing the exponent value for bytes.\n @sa\t\t\tcategory\t for type aliases for SI base_unit types."]
pub type units_category_impedance_unit = units_base_unit;
pub type units_category_area_unit = units_base_unit;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct units_unit {
    pub _address: u8,
}
pub type units_unit_base_unit_type = units_traits_unit_traits;
pub type units_unit_conversion_ratio = u8;
pub type units_unit_pi_exponent_ratio = u8;
pub type units_unit_translation_ratio = std_ratio_add;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
#[repr(C)]
pub struct units_unit_t {
    pub _base: units_linear_scale<[u8; 0usize]>,
}
pub type units_unit_t_nls = units_linear_scale<[u8; 0usize]>;
pub type units_unit_t_non_linear_scale_type = units_linear_scale<[u8; 0usize]>;
pub type units_unit_t_underlying_type<T> = T;
pub type units_unit_t_value_type<T> = T;
pub type units_unit_t_unit_type<Units> = Units;
#[doc = " @cond"]
#[repr(C)]
#[derive(Debug)]
pub struct units_linear_scale<T> {
    #[doc = "< linearized value."]
    pub m_value: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub type units_time_seconds = u8;
pub type units_time_second = units_time_seconds;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_time_second_t = units_unit_t;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_time_nanoseconds = units_unit;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_time_nanosecond = units_time_nanoseconds;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_time_nanosecond_t = units_unit_t;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_time_microseconds = units_unit;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_time_microsecond = units_time_microseconds;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_time_microsecond_t = units_unit_t;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_time_milliseconds = units_unit;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_time_millisecond = units_time_milliseconds;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_time_millisecond_t = units_unit_t;
pub type units_angle_radians = u8;
pub type units_angle_radian = units_angle_radians;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_angle_radian_t = units_unit_t;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_angle_degrees = units_unit;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_angle_degree = units_angle_degrees;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_angle_degree_t = units_unit_t;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_angle_turns = units_unit;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_angle_turn = units_angle_turns;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_angle_turn_t = units_unit_t;
pub type units_current_amperes = u8;
pub type units_current_ampere = units_current_amperes;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_current_ampere_t = units_unit_t;
pub type units_length_meters = u8;
pub type units_length_meter = units_length_meters;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_length_meter_t = units_unit_t;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_length_feet = units_unit;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_length_foot = units_length_feet;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_length_inches = units_unit;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_length_inch = units_length_inches;
pub type units_mass_grams = u8;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_mass_kilograms = units_unit;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_mass_kilogram = units_mass_kilograms;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_mass_kilogram_t = units_unit_t;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_mass_slugs = units_unit;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_mass_slug = units_mass_slugs;
pub type units_force_pounds = u8;
pub type units_pressure_pounds_per_square_inch = u8;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_pressure_pounds_per_square_inch_t = units_unit_t;
pub type units_voltage_volts = u8;
pub type units_voltage_volt = units_voltage_volts;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_voltage_volt_t = units_unit_t;
pub type units_velocity_meters_per_second = u8;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_velocity_meters_per_second_t = units_unit_t;
pub type units_velocity_feet_per_second = u8;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_velocity_feet_per_second_t = units_unit_t;
pub type units_angular_velocity_radians_per_second = u8;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_angular_velocity_radians_per_second_t = units_unit_t;
pub type units_impedance_ohms = u8;
pub type units_impedance_ohm = units_impedance_ohms;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_impedance_ohm_t = units_unit_t;
pub type units_energy_joules = u8;
pub type units_energy_joule = units_energy_joules;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_torque_newton_meters = units_unit;
#[doc = " @brief\t\tunit type template specialization for units derived from base units."]
pub type units_torque_newton_meter = units_torque_newton_meters;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_torque_newton_meter_t = units_unit_t;
pub type units_area_square_meters = u8;
pub type units_moment_of_inertia_kilogram_square_meters = u8;
pub type units_moment_of_inertia_kilogram_square_meter =
    units_moment_of_inertia_kilogram_square_meters;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type units_moment_of_inertia_kilogram_square_meter_t = units_unit_t;
#[doc = " Represents colors that can be used with Addressable LEDs.\n\n Limited to 12 bits of precision."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_Color {
    pub red: f64,
    pub green: f64,
    pub blue: f64,
}
extern "C" {
    #[doc = " 0x1560BD."]
    #[link_name = "\u{1}_ZN3frc5Color6kDenimE"]
    pub static frc_Color_kDenim: frc_Color;
}
extern "C" {
    #[doc = " 0x0066B3."]
    #[link_name = "\u{1}_ZN3frc5Color10kFirstBlueE"]
    pub static frc_Color_kFirstBlue: frc_Color;
}
extern "C" {
    #[doc = " 0xED1C24."]
    #[link_name = "\u{1}_ZN3frc5Color9kFirstRedE"]
    pub static frc_Color_kFirstRed: frc_Color;
}
extern "C" {
    #[doc = " 0xF0F8FF."]
    #[link_name = "\u{1}_ZN3frc5Color10kAliceBlueE"]
    pub static frc_Color_kAliceBlue: frc_Color;
}
extern "C" {
    #[doc = " 0xFAEBD7."]
    #[link_name = "\u{1}_ZN3frc5Color13kAntiqueWhiteE"]
    pub static frc_Color_kAntiqueWhite: frc_Color;
}
extern "C" {
    #[doc = " 0x00FFFF."]
    #[link_name = "\u{1}_ZN3frc5Color5kAquaE"]
    pub static frc_Color_kAqua: frc_Color;
}
extern "C" {
    #[doc = " 0x7FFFD4."]
    #[link_name = "\u{1}_ZN3frc5Color11kAquamarineE"]
    pub static frc_Color_kAquamarine: frc_Color;
}
extern "C" {
    #[doc = " 0xF0FFFF."]
    #[link_name = "\u{1}_ZN3frc5Color6kAzureE"]
    pub static frc_Color_kAzure: frc_Color;
}
extern "C" {
    #[doc = " 0xF5F5DC."]
    #[link_name = "\u{1}_ZN3frc5Color6kBeigeE"]
    pub static frc_Color_kBeige: frc_Color;
}
extern "C" {
    #[doc = " 0xFFE4C4."]
    #[link_name = "\u{1}_ZN3frc5Color7kBisqueE"]
    pub static frc_Color_kBisque: frc_Color;
}
extern "C" {
    #[doc = " 0x000000."]
    #[link_name = "\u{1}_ZN3frc5Color6kBlackE"]
    pub static frc_Color_kBlack: frc_Color;
}
extern "C" {
    #[doc = " 0xFFEBCD."]
    #[link_name = "\u{1}_ZN3frc5Color15kBlanchedAlmondE"]
    pub static frc_Color_kBlanchedAlmond: frc_Color;
}
extern "C" {
    #[doc = " 0x0000FF."]
    #[link_name = "\u{1}_ZN3frc5Color5kBlueE"]
    pub static frc_Color_kBlue: frc_Color;
}
extern "C" {
    #[doc = " 0x8A2BE2."]
    #[link_name = "\u{1}_ZN3frc5Color11kBlueVioletE"]
    pub static frc_Color_kBlueViolet: frc_Color;
}
extern "C" {
    #[doc = " 0xA52A2A."]
    #[link_name = "\u{1}_ZN3frc5Color6kBrownE"]
    pub static frc_Color_kBrown: frc_Color;
}
extern "C" {
    #[doc = " 0xDEB887."]
    #[link_name = "\u{1}_ZN3frc5Color10kBurlywoodE"]
    pub static frc_Color_kBurlywood: frc_Color;
}
extern "C" {
    #[doc = " 0x5F9EA0."]
    #[link_name = "\u{1}_ZN3frc5Color10kCadetBlueE"]
    pub static frc_Color_kCadetBlue: frc_Color;
}
extern "C" {
    #[doc = " 0x7FFF00."]
    #[link_name = "\u{1}_ZN3frc5Color11kChartreuseE"]
    pub static frc_Color_kChartreuse: frc_Color;
}
extern "C" {
    #[doc = " 0xD2691E."]
    #[link_name = "\u{1}_ZN3frc5Color10kChocolateE"]
    pub static frc_Color_kChocolate: frc_Color;
}
extern "C" {
    #[doc = " 0xFF7F50."]
    #[link_name = "\u{1}_ZN3frc5Color6kCoralE"]
    pub static frc_Color_kCoral: frc_Color;
}
extern "C" {
    #[doc = " 0x6495ED."]
    #[link_name = "\u{1}_ZN3frc5Color15kCornflowerBlueE"]
    pub static frc_Color_kCornflowerBlue: frc_Color;
}
extern "C" {
    #[doc = " 0xFFF8DC."]
    #[link_name = "\u{1}_ZN3frc5Color9kCornsilkE"]
    pub static frc_Color_kCornsilk: frc_Color;
}
extern "C" {
    #[doc = " 0xDC143C."]
    #[link_name = "\u{1}_ZN3frc5Color8kCrimsonE"]
    pub static frc_Color_kCrimson: frc_Color;
}
extern "C" {
    #[doc = " 0x00FFFF."]
    #[link_name = "\u{1}_ZN3frc5Color5kCyanE"]
    pub static frc_Color_kCyan: frc_Color;
}
extern "C" {
    #[doc = " 0x00008B."]
    #[link_name = "\u{1}_ZN3frc5Color9kDarkBlueE"]
    pub static frc_Color_kDarkBlue: frc_Color;
}
extern "C" {
    #[doc = " 0x008B8B."]
    #[link_name = "\u{1}_ZN3frc5Color9kDarkCyanE"]
    pub static frc_Color_kDarkCyan: frc_Color;
}
extern "C" {
    #[doc = " 0xB8860B."]
    #[link_name = "\u{1}_ZN3frc5Color14kDarkGoldenrodE"]
    pub static frc_Color_kDarkGoldenrod: frc_Color;
}
extern "C" {
    #[doc = " 0xA9A9A9."]
    #[link_name = "\u{1}_ZN3frc5Color9kDarkGrayE"]
    pub static frc_Color_kDarkGray: frc_Color;
}
extern "C" {
    #[doc = " 0x006400."]
    #[link_name = "\u{1}_ZN3frc5Color10kDarkGreenE"]
    pub static frc_Color_kDarkGreen: frc_Color;
}
extern "C" {
    #[doc = " 0xBDB76B."]
    #[link_name = "\u{1}_ZN3frc5Color10kDarkKhakiE"]
    pub static frc_Color_kDarkKhaki: frc_Color;
}
extern "C" {
    #[doc = " 0x8B008B."]
    #[link_name = "\u{1}_ZN3frc5Color12kDarkMagentaE"]
    pub static frc_Color_kDarkMagenta: frc_Color;
}
extern "C" {
    #[doc = " 0x556B2F."]
    #[link_name = "\u{1}_ZN3frc5Color15kDarkOliveGreenE"]
    pub static frc_Color_kDarkOliveGreen: frc_Color;
}
extern "C" {
    #[doc = " 0xFF8C00."]
    #[link_name = "\u{1}_ZN3frc5Color11kDarkOrangeE"]
    pub static frc_Color_kDarkOrange: frc_Color;
}
extern "C" {
    #[doc = " 0x9932CC."]
    #[link_name = "\u{1}_ZN3frc5Color11kDarkOrchidE"]
    pub static frc_Color_kDarkOrchid: frc_Color;
}
extern "C" {
    #[doc = " 0x8B0000."]
    #[link_name = "\u{1}_ZN3frc5Color8kDarkRedE"]
    pub static frc_Color_kDarkRed: frc_Color;
}
extern "C" {
    #[doc = " 0xE9967A."]
    #[link_name = "\u{1}_ZN3frc5Color11kDarkSalmonE"]
    pub static frc_Color_kDarkSalmon: frc_Color;
}
extern "C" {
    #[doc = " 0x8FBC8F."]
    #[link_name = "\u{1}_ZN3frc5Color13kDarkSeaGreenE"]
    pub static frc_Color_kDarkSeaGreen: frc_Color;
}
extern "C" {
    #[doc = " 0x483D8B."]
    #[link_name = "\u{1}_ZN3frc5Color14kDarkSlateBlueE"]
    pub static frc_Color_kDarkSlateBlue: frc_Color;
}
extern "C" {
    #[doc = " 0x2F4F4F."]
    #[link_name = "\u{1}_ZN3frc5Color14kDarkSlateGrayE"]
    pub static frc_Color_kDarkSlateGray: frc_Color;
}
extern "C" {
    #[doc = " 0x00CED1."]
    #[link_name = "\u{1}_ZN3frc5Color14kDarkTurquoiseE"]
    pub static frc_Color_kDarkTurquoise: frc_Color;
}
extern "C" {
    #[doc = " 0x9400D3."]
    #[link_name = "\u{1}_ZN3frc5Color11kDarkVioletE"]
    pub static frc_Color_kDarkViolet: frc_Color;
}
extern "C" {
    #[doc = " 0xFF1493."]
    #[link_name = "\u{1}_ZN3frc5Color9kDeepPinkE"]
    pub static frc_Color_kDeepPink: frc_Color;
}
extern "C" {
    #[doc = " 0x00BFFF."]
    #[link_name = "\u{1}_ZN3frc5Color12kDeepSkyBlueE"]
    pub static frc_Color_kDeepSkyBlue: frc_Color;
}
extern "C" {
    #[doc = " 0x696969."]
    #[link_name = "\u{1}_ZN3frc5Color8kDimGrayE"]
    pub static frc_Color_kDimGray: frc_Color;
}
extern "C" {
    #[doc = " 0x1E90FF."]
    #[link_name = "\u{1}_ZN3frc5Color11kDodgerBlueE"]
    pub static frc_Color_kDodgerBlue: frc_Color;
}
extern "C" {
    #[doc = " 0xB22222."]
    #[link_name = "\u{1}_ZN3frc5Color10kFirebrickE"]
    pub static frc_Color_kFirebrick: frc_Color;
}
extern "C" {
    #[doc = " 0xFFFAF0."]
    #[link_name = "\u{1}_ZN3frc5Color12kFloralWhiteE"]
    pub static frc_Color_kFloralWhite: frc_Color;
}
extern "C" {
    #[doc = " 0x228B22."]
    #[link_name = "\u{1}_ZN3frc5Color12kForestGreenE"]
    pub static frc_Color_kForestGreen: frc_Color;
}
extern "C" {
    #[doc = " 0xFF00FF."]
    #[link_name = "\u{1}_ZN3frc5Color8kFuchsiaE"]
    pub static frc_Color_kFuchsia: frc_Color;
}
extern "C" {
    #[doc = " 0xDCDCDC."]
    #[link_name = "\u{1}_ZN3frc5Color10kGainsboroE"]
    pub static frc_Color_kGainsboro: frc_Color;
}
extern "C" {
    #[doc = " 0xF8F8FF."]
    #[link_name = "\u{1}_ZN3frc5Color11kGhostWhiteE"]
    pub static frc_Color_kGhostWhite: frc_Color;
}
extern "C" {
    #[doc = " 0xFFD700."]
    #[link_name = "\u{1}_ZN3frc5Color5kGoldE"]
    pub static frc_Color_kGold: frc_Color;
}
extern "C" {
    #[doc = " 0xDAA520."]
    #[link_name = "\u{1}_ZN3frc5Color10kGoldenrodE"]
    pub static frc_Color_kGoldenrod: frc_Color;
}
extern "C" {
    #[doc = " 0x808080."]
    #[link_name = "\u{1}_ZN3frc5Color5kGrayE"]
    pub static frc_Color_kGray: frc_Color;
}
extern "C" {
    #[doc = " 0x008000."]
    #[link_name = "\u{1}_ZN3frc5Color6kGreenE"]
    pub static frc_Color_kGreen: frc_Color;
}
extern "C" {
    #[doc = " 0xADFF2F."]
    #[link_name = "\u{1}_ZN3frc5Color12kGreenYellowE"]
    pub static frc_Color_kGreenYellow: frc_Color;
}
extern "C" {
    #[doc = " 0xF0FFF0."]
    #[link_name = "\u{1}_ZN3frc5Color9kHoneydewE"]
    pub static frc_Color_kHoneydew: frc_Color;
}
extern "C" {
    #[doc = " 0xFF69B4."]
    #[link_name = "\u{1}_ZN3frc5Color8kHotPinkE"]
    pub static frc_Color_kHotPink: frc_Color;
}
extern "C" {
    #[doc = " 0xCD5C5C."]
    #[link_name = "\u{1}_ZN3frc5Color10kIndianRedE"]
    pub static frc_Color_kIndianRed: frc_Color;
}
extern "C" {
    #[doc = " 0x4B0082."]
    #[link_name = "\u{1}_ZN3frc5Color7kIndigoE"]
    pub static frc_Color_kIndigo: frc_Color;
}
extern "C" {
    #[doc = " 0xFFFFF0."]
    #[link_name = "\u{1}_ZN3frc5Color6kIvoryE"]
    pub static frc_Color_kIvory: frc_Color;
}
extern "C" {
    #[doc = " 0xF0E68C."]
    #[link_name = "\u{1}_ZN3frc5Color6kKhakiE"]
    pub static frc_Color_kKhaki: frc_Color;
}
extern "C" {
    #[doc = " 0xE6E6FA."]
    #[link_name = "\u{1}_ZN3frc5Color9kLavenderE"]
    pub static frc_Color_kLavender: frc_Color;
}
extern "C" {
    #[doc = " 0xFFF0F5."]
    #[link_name = "\u{1}_ZN3frc5Color14kLavenderBlushE"]
    pub static frc_Color_kLavenderBlush: frc_Color;
}
extern "C" {
    #[doc = " 0x7CFC00."]
    #[link_name = "\u{1}_ZN3frc5Color10kLawnGreenE"]
    pub static frc_Color_kLawnGreen: frc_Color;
}
extern "C" {
    #[doc = " 0xFFFACD."]
    #[link_name = "\u{1}_ZN3frc5Color13kLemonChiffonE"]
    pub static frc_Color_kLemonChiffon: frc_Color;
}
extern "C" {
    #[doc = " 0xADD8E6."]
    #[link_name = "\u{1}_ZN3frc5Color10kLightBlueE"]
    pub static frc_Color_kLightBlue: frc_Color;
}
extern "C" {
    #[doc = " 0xF08080."]
    #[link_name = "\u{1}_ZN3frc5Color11kLightCoralE"]
    pub static frc_Color_kLightCoral: frc_Color;
}
extern "C" {
    #[doc = " 0xE0FFFF."]
    #[link_name = "\u{1}_ZN3frc5Color10kLightCyanE"]
    pub static frc_Color_kLightCyan: frc_Color;
}
extern "C" {
    #[doc = " 0xFAFAD2."]
    #[link_name = "\u{1}_ZN3frc5Color21kLightGoldenrodYellowE"]
    pub static frc_Color_kLightGoldenrodYellow: frc_Color;
}
extern "C" {
    #[doc = " 0xD3D3D3."]
    #[link_name = "\u{1}_ZN3frc5Color10kLightGrayE"]
    pub static frc_Color_kLightGray: frc_Color;
}
extern "C" {
    #[doc = " 0x90EE90."]
    #[link_name = "\u{1}_ZN3frc5Color11kLightGreenE"]
    pub static frc_Color_kLightGreen: frc_Color;
}
extern "C" {
    #[doc = " 0xFFB6C1."]
    #[link_name = "\u{1}_ZN3frc5Color10kLightPinkE"]
    pub static frc_Color_kLightPink: frc_Color;
}
extern "C" {
    #[doc = " 0xFFA07A."]
    #[link_name = "\u{1}_ZN3frc5Color12kLightSalmonE"]
    pub static frc_Color_kLightSalmon: frc_Color;
}
extern "C" {
    #[doc = " 0x20B2AA."]
    #[link_name = "\u{1}_ZN3frc5Color14kLightSeaGreenE"]
    pub static frc_Color_kLightSeaGreen: frc_Color;
}
extern "C" {
    #[doc = " 0x87CEFA."]
    #[link_name = "\u{1}_ZN3frc5Color13kLightSkyBlueE"]
    pub static frc_Color_kLightSkyBlue: frc_Color;
}
extern "C" {
    #[doc = " 0x778899."]
    #[link_name = "\u{1}_ZN3frc5Color15kLightSlateGrayE"]
    pub static frc_Color_kLightSlateGray: frc_Color;
}
extern "C" {
    #[doc = " 0xB0C4DE."]
    #[link_name = "\u{1}_ZN3frc5Color15kLightSteelBlueE"]
    pub static frc_Color_kLightSteelBlue: frc_Color;
}
extern "C" {
    #[doc = " 0xFFFFE0."]
    #[link_name = "\u{1}_ZN3frc5Color12kLightYellowE"]
    pub static frc_Color_kLightYellow: frc_Color;
}
extern "C" {
    #[doc = " 0x00FF00."]
    #[link_name = "\u{1}_ZN3frc5Color5kLimeE"]
    pub static frc_Color_kLime: frc_Color;
}
extern "C" {
    #[doc = " 0x32CD32."]
    #[link_name = "\u{1}_ZN3frc5Color10kLimeGreenE"]
    pub static frc_Color_kLimeGreen: frc_Color;
}
extern "C" {
    #[doc = " 0xFAF0E6."]
    #[link_name = "\u{1}_ZN3frc5Color6kLinenE"]
    pub static frc_Color_kLinen: frc_Color;
}
extern "C" {
    #[doc = " 0xFF00FF."]
    #[link_name = "\u{1}_ZN3frc5Color8kMagentaE"]
    pub static frc_Color_kMagenta: frc_Color;
}
extern "C" {
    #[doc = " 0x800000."]
    #[link_name = "\u{1}_ZN3frc5Color7kMaroonE"]
    pub static frc_Color_kMaroon: frc_Color;
}
extern "C" {
    #[doc = " 0x66CDAA."]
    #[link_name = "\u{1}_ZN3frc5Color17kMediumAquamarineE"]
    pub static frc_Color_kMediumAquamarine: frc_Color;
}
extern "C" {
    #[doc = " 0x0000CD."]
    #[link_name = "\u{1}_ZN3frc5Color11kMediumBlueE"]
    pub static frc_Color_kMediumBlue: frc_Color;
}
extern "C" {
    #[doc = " 0xBA55D3."]
    #[link_name = "\u{1}_ZN3frc5Color13kMediumOrchidE"]
    pub static frc_Color_kMediumOrchid: frc_Color;
}
extern "C" {
    #[doc = " 0x9370DB."]
    #[link_name = "\u{1}_ZN3frc5Color13kMediumPurpleE"]
    pub static frc_Color_kMediumPurple: frc_Color;
}
extern "C" {
    #[doc = " 0x3CB371."]
    #[link_name = "\u{1}_ZN3frc5Color15kMediumSeaGreenE"]
    pub static frc_Color_kMediumSeaGreen: frc_Color;
}
extern "C" {
    #[doc = " 0x7B68EE."]
    #[link_name = "\u{1}_ZN3frc5Color16kMediumSlateBlueE"]
    pub static frc_Color_kMediumSlateBlue: frc_Color;
}
extern "C" {
    #[doc = " 0x00FA9A."]
    #[link_name = "\u{1}_ZN3frc5Color18kMediumSpringGreenE"]
    pub static frc_Color_kMediumSpringGreen: frc_Color;
}
extern "C" {
    #[doc = " 0x48D1CC."]
    #[link_name = "\u{1}_ZN3frc5Color16kMediumTurquoiseE"]
    pub static frc_Color_kMediumTurquoise: frc_Color;
}
extern "C" {
    #[doc = " 0xC71585."]
    #[link_name = "\u{1}_ZN3frc5Color16kMediumVioletRedE"]
    pub static frc_Color_kMediumVioletRed: frc_Color;
}
extern "C" {
    #[doc = " 0x191970."]
    #[link_name = "\u{1}_ZN3frc5Color13kMidnightBlueE"]
    pub static frc_Color_kMidnightBlue: frc_Color;
}
extern "C" {
    #[doc = " 0xF5FFFA."]
    #[link_name = "\u{1}_ZN3frc5Color10kMintcreamE"]
    pub static frc_Color_kMintcream: frc_Color;
}
extern "C" {
    #[doc = " 0xFFE4E1."]
    #[link_name = "\u{1}_ZN3frc5Color10kMistyRoseE"]
    pub static frc_Color_kMistyRose: frc_Color;
}
extern "C" {
    #[doc = " 0xFFE4B5."]
    #[link_name = "\u{1}_ZN3frc5Color9kMoccasinE"]
    pub static frc_Color_kMoccasin: frc_Color;
}
extern "C" {
    #[doc = " 0xFFDEAD."]
    #[link_name = "\u{1}_ZN3frc5Color12kNavajoWhiteE"]
    pub static frc_Color_kNavajoWhite: frc_Color;
}
extern "C" {
    #[doc = " 0x000080."]
    #[link_name = "\u{1}_ZN3frc5Color5kNavyE"]
    pub static frc_Color_kNavy: frc_Color;
}
extern "C" {
    #[doc = " 0xFDF5E6."]
    #[link_name = "\u{1}_ZN3frc5Color8kOldLaceE"]
    pub static frc_Color_kOldLace: frc_Color;
}
extern "C" {
    #[doc = " 0x808000."]
    #[link_name = "\u{1}_ZN3frc5Color6kOliveE"]
    pub static frc_Color_kOlive: frc_Color;
}
extern "C" {
    #[doc = " 0x6B8E23."]
    #[link_name = "\u{1}_ZN3frc5Color10kOliveDrabE"]
    pub static frc_Color_kOliveDrab: frc_Color;
}
extern "C" {
    #[doc = " 0xFFA500."]
    #[link_name = "\u{1}_ZN3frc5Color7kOrangeE"]
    pub static frc_Color_kOrange: frc_Color;
}
extern "C" {
    #[doc = " 0xFF4500."]
    #[link_name = "\u{1}_ZN3frc5Color10kOrangeRedE"]
    pub static frc_Color_kOrangeRed: frc_Color;
}
extern "C" {
    #[doc = " 0xDA70D6."]
    #[link_name = "\u{1}_ZN3frc5Color7kOrchidE"]
    pub static frc_Color_kOrchid: frc_Color;
}
extern "C" {
    #[doc = " 0xEEE8AA."]
    #[link_name = "\u{1}_ZN3frc5Color14kPaleGoldenrodE"]
    pub static frc_Color_kPaleGoldenrod: frc_Color;
}
extern "C" {
    #[doc = " 0x98FB98."]
    #[link_name = "\u{1}_ZN3frc5Color10kPaleGreenE"]
    pub static frc_Color_kPaleGreen: frc_Color;
}
extern "C" {
    #[doc = " 0xAFEEEE."]
    #[link_name = "\u{1}_ZN3frc5Color14kPaleTurquoiseE"]
    pub static frc_Color_kPaleTurquoise: frc_Color;
}
extern "C" {
    #[doc = " 0xDB7093."]
    #[link_name = "\u{1}_ZN3frc5Color14kPaleVioletRedE"]
    pub static frc_Color_kPaleVioletRed: frc_Color;
}
extern "C" {
    #[doc = " 0xFFEFD5."]
    #[link_name = "\u{1}_ZN3frc5Color11kPapayaWhipE"]
    pub static frc_Color_kPapayaWhip: frc_Color;
}
extern "C" {
    #[doc = " 0xFFDAB9."]
    #[link_name = "\u{1}_ZN3frc5Color10kPeachPuffE"]
    pub static frc_Color_kPeachPuff: frc_Color;
}
extern "C" {
    #[doc = " 0xCD853F."]
    #[link_name = "\u{1}_ZN3frc5Color5kPeruE"]
    pub static frc_Color_kPeru: frc_Color;
}
extern "C" {
    #[doc = " 0xFFC0CB."]
    #[link_name = "\u{1}_ZN3frc5Color5kPinkE"]
    pub static frc_Color_kPink: frc_Color;
}
extern "C" {
    #[doc = " 0xDDA0DD."]
    #[link_name = "\u{1}_ZN3frc5Color5kPlumE"]
    pub static frc_Color_kPlum: frc_Color;
}
extern "C" {
    #[doc = " 0xB0E0E6."]
    #[link_name = "\u{1}_ZN3frc5Color11kPowderBlueE"]
    pub static frc_Color_kPowderBlue: frc_Color;
}
extern "C" {
    #[doc = " 0x800080."]
    #[link_name = "\u{1}_ZN3frc5Color7kPurpleE"]
    pub static frc_Color_kPurple: frc_Color;
}
extern "C" {
    #[doc = " 0xFF0000."]
    #[link_name = "\u{1}_ZN3frc5Color4kRedE"]
    pub static frc_Color_kRed: frc_Color;
}
extern "C" {
    #[doc = " 0xBC8F8F."]
    #[link_name = "\u{1}_ZN3frc5Color10kRosyBrownE"]
    pub static frc_Color_kRosyBrown: frc_Color;
}
extern "C" {
    #[doc = " 0x4169E1."]
    #[link_name = "\u{1}_ZN3frc5Color10kRoyalBlueE"]
    pub static frc_Color_kRoyalBlue: frc_Color;
}
extern "C" {
    #[doc = " 0x8B4513."]
    #[link_name = "\u{1}_ZN3frc5Color12kSaddleBrownE"]
    pub static frc_Color_kSaddleBrown: frc_Color;
}
extern "C" {
    #[doc = " 0xFA8072."]
    #[link_name = "\u{1}_ZN3frc5Color7kSalmonE"]
    pub static frc_Color_kSalmon: frc_Color;
}
extern "C" {
    #[doc = " 0xF4A460."]
    #[link_name = "\u{1}_ZN3frc5Color11kSandyBrownE"]
    pub static frc_Color_kSandyBrown: frc_Color;
}
extern "C" {
    #[doc = " 0x2E8B57."]
    #[link_name = "\u{1}_ZN3frc5Color9kSeaGreenE"]
    pub static frc_Color_kSeaGreen: frc_Color;
}
extern "C" {
    #[doc = " 0xFFF5EE."]
    #[link_name = "\u{1}_ZN3frc5Color9kSeashellE"]
    pub static frc_Color_kSeashell: frc_Color;
}
extern "C" {
    #[doc = " 0xA0522D."]
    #[link_name = "\u{1}_ZN3frc5Color7kSiennaE"]
    pub static frc_Color_kSienna: frc_Color;
}
extern "C" {
    #[doc = " 0xC0C0C0."]
    #[link_name = "\u{1}_ZN3frc5Color7kSilverE"]
    pub static frc_Color_kSilver: frc_Color;
}
extern "C" {
    #[doc = " 0x87CEEB."]
    #[link_name = "\u{1}_ZN3frc5Color8kSkyBlueE"]
    pub static frc_Color_kSkyBlue: frc_Color;
}
extern "C" {
    #[doc = " 0x6A5ACD."]
    #[link_name = "\u{1}_ZN3frc5Color10kSlateBlueE"]
    pub static frc_Color_kSlateBlue: frc_Color;
}
extern "C" {
    #[doc = " 0x708090."]
    #[link_name = "\u{1}_ZN3frc5Color10kSlateGrayE"]
    pub static frc_Color_kSlateGray: frc_Color;
}
extern "C" {
    #[doc = " 0xFFFAFA."]
    #[link_name = "\u{1}_ZN3frc5Color5kSnowE"]
    pub static frc_Color_kSnow: frc_Color;
}
extern "C" {
    #[doc = " 0x00FF7F."]
    #[link_name = "\u{1}_ZN3frc5Color12kSpringGreenE"]
    pub static frc_Color_kSpringGreen: frc_Color;
}
extern "C" {
    #[doc = " 0x4682B4."]
    #[link_name = "\u{1}_ZN3frc5Color10kSteelBlueE"]
    pub static frc_Color_kSteelBlue: frc_Color;
}
extern "C" {
    #[doc = " 0xD2B48C."]
    #[link_name = "\u{1}_ZN3frc5Color4kTanE"]
    pub static frc_Color_kTan: frc_Color;
}
extern "C" {
    #[doc = " 0x008080."]
    #[link_name = "\u{1}_ZN3frc5Color5kTealE"]
    pub static frc_Color_kTeal: frc_Color;
}
extern "C" {
    #[doc = " 0xD8BFD8."]
    #[link_name = "\u{1}_ZN3frc5Color8kThistleE"]
    pub static frc_Color_kThistle: frc_Color;
}
extern "C" {
    #[doc = " 0xFF6347."]
    #[link_name = "\u{1}_ZN3frc5Color7kTomatoE"]
    pub static frc_Color_kTomato: frc_Color;
}
extern "C" {
    #[doc = " 0x40E0D0."]
    #[link_name = "\u{1}_ZN3frc5Color10kTurquoiseE"]
    pub static frc_Color_kTurquoise: frc_Color;
}
extern "C" {
    #[doc = " 0xEE82EE."]
    #[link_name = "\u{1}_ZN3frc5Color7kVioletE"]
    pub static frc_Color_kViolet: frc_Color;
}
extern "C" {
    #[doc = " 0xF5DEB3."]
    #[link_name = "\u{1}_ZN3frc5Color6kWheatE"]
    pub static frc_Color_kWheat: frc_Color;
}
extern "C" {
    #[doc = " 0xFFFFFF."]
    #[link_name = "\u{1}_ZN3frc5Color6kWhiteE"]
    pub static frc_Color_kWhite: frc_Color;
}
extern "C" {
    #[doc = " 0xF5F5F5."]
    #[link_name = "\u{1}_ZN3frc5Color11kWhiteSmokeE"]
    pub static frc_Color_kWhiteSmoke: frc_Color;
}
extern "C" {
    #[doc = " 0xFFFF00."]
    #[link_name = "\u{1}_ZN3frc5Color7kYellowE"]
    pub static frc_Color_kYellow: frc_Color;
}
extern "C" {
    #[doc = " 0x9ACD32."]
    #[link_name = "\u{1}_ZN3frc5Color12kYellowGreenE"]
    pub static frc_Color_kYellowGreen: frc_Color;
}
pub const frc_Color_kPrecision: f64 = 0.000244140625;
#[test]
fn bindgen_test_layout_frc_Color() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Color> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Color>(),
        24usize,
        concat!("Size of: ", stringify!(frc_Color))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Color>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_Color))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Color),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Color),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Color),
            "::",
            stringify!(blue)
        )
    );
}
extern "C" {
    #[doc = " Return this color represented as a hex string.\n\n @return a string of the format <tt>\\#RRGGBB</tt>"]
    #[link_name = "\u{1}_ZNK3frc5Color9HexStringB5cxx11Ev"]
    pub fn frc_Color_HexString(this: *const frc_Color) -> std_string;
}
impl frc_Color {
    #[inline]
    pub unsafe fn HexString(&self) -> std_string {
        frc_Color_HexString(self)
    }
}
#[doc = " Represents colors that can be used with Addressable LEDs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_Color8Bit {
    pub red: ::std::os::raw::c_int,
    pub green: ::std::os::raw::c_int,
    pub blue: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_frc_Color8Bit() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Color8Bit> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Color8Bit>(),
        12usize,
        concat!("Size of: ", stringify!(frc_Color8Bit))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Color8Bit>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_Color8Bit))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).red) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Color8Bit),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).green) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Color8Bit),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Color8Bit),
            "::",
            stringify!(blue)
        )
    );
}
extern "C" {
    #[doc = " Return this color represented as a hex string.\n\n @return a string of the format <tt>\\#RRGGBB</tt>"]
    #[link_name = "\u{1}_ZNK3frc9Color8Bit9HexStringB5cxx11Ev"]
    pub fn frc_Color8Bit_HexString(this: *const frc_Color8Bit) -> std_string;
}
impl frc_Color8Bit {
    #[inline]
    pub unsafe fn HexString(&self) -> std_string {
        frc_Color8Bit_HexString(self)
    }
}
#[doc = " A class for driving addressable LEDs, such as WS2812s and NeoPixels.\n\n <p>Only 1 LED driver is currently supported by the roboRIO."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_AddressableLED {
    pub m_pwmHandle: u32,
    pub m_handle: u32,
    pub m_port: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_AddressableLED_LEDData {
    pub _base: HAL_AddressableLEDData,
}
#[test]
fn bindgen_test_layout_frc_AddressableLED_LEDData() {
    assert_eq!(
        ::std::mem::size_of::<frc_AddressableLED_LEDData>(),
        4usize,
        concat!("Size of: ", stringify!(frc_AddressableLED_LEDData))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_AddressableLED_LEDData>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_AddressableLED_LEDData))
    );
}
extern "C" {
    #[doc = " A helper method to set all values of the LED.\n\n @param h the h value [0-180]\n @param s the s value [0-255]\n @param v the v value [0-255]"]
    #[link_name = "\u{1}_ZN3frc14AddressableLED7LEDData6SetHSVEiii"]
    pub fn frc_AddressableLED_LEDData_SetHSV(
        this: *mut frc_AddressableLED_LEDData,
        h: ::std::os::raw::c_int,
        s: ::std::os::raw::c_int,
        v: ::std::os::raw::c_int,
    );
}
impl frc_AddressableLED_LEDData {
    #[inline]
    pub unsafe fn SetHSV(
        &mut self,
        h: ::std::os::raw::c_int,
        s: ::std::os::raw::c_int,
        v: ::std::os::raw::c_int,
    ) {
        frc_AddressableLED_LEDData_SetHSV(self, h, s, v)
    }
}
#[test]
fn bindgen_test_layout_frc_AddressableLED() {
    const UNINIT: ::std::mem::MaybeUninit<frc_AddressableLED> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_AddressableLED>(),
        12usize,
        concat!("Size of: ", stringify!(frc_AddressableLED))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_AddressableLED>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_AddressableLED))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pwmHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AddressableLED),
            "::",
            stringify!(m_pwmHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AddressableLED),
            "::",
            stringify!(m_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AddressableLED),
            "::",
            stringify!(m_port)
        )
    );
}
extern "C" {
    #[doc = " Sets the length of the LED strip.\n\n <p>Calling this is an expensive call, so its best to call it once, then\n just update data.\n\n <p>The max length is 5460 LEDs.\n\n @param length the strip length"]
    #[link_name = "\u{1}_ZN3frc14AddressableLED9SetLengthEi"]
    pub fn frc_AddressableLED_SetLength(
        this: *mut frc_AddressableLED,
        length: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Sets the led output data.\n\n <p>If the output is enabled, this will start writing the next data cycle.\n It is safe to call, even while output is enabled.\n\n @param ledData the buffer to write"]
    #[link_name = "\u{1}_ZN3frc14AddressableLED7SetDataESt4spanIKNS0_7LEDDataELj4294967295EE"]
    pub fn frc_AddressableLED_SetData(this: *mut frc_AddressableLED, ledData: u8);
}
extern "C" {
    #[doc = " Sets the led output data.\n\n <p>If the output is enabled, this will start writing the next data cycle.\n It is safe to call, even while output is enabled.\n\n @param ledData the buffer to write"]
    #[link_name = "\u{1}_ZN3frc14AddressableLED7SetDataESt16initializer_listINS0_7LEDDataEE"]
    pub fn frc_AddressableLED_SetData1(this: *mut frc_AddressableLED, ledData: u8);
}
extern "C" {
    #[doc = " Sets the bit timing.\n\n <p>By default, the driver is set up to drive WS2812s, so nothing needs to\n be set for those.\n\n @param lowTime0 low time for 0 bit\n @param highTime0 high time for 0 bit\n @param lowTime1 low time for 1 bit\n @param highTime1 high time for 1 bit"]
    #[link_name = "\u{1}_ZN3frc14AddressableLED12SetBitTimingEN5units6unit_tINS1_4unitISt5ratioILx1ELx1000000000EENS3_IS4_ILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES8_S6_S8_S8_S8_S8_S8_S8_EES8_S8_EES8_S8_EEdNS1_12linear_scaleEEESD_SD_SD_"]
    pub fn frc_AddressableLED_SetBitTiming(
        this: *mut frc_AddressableLED,
        lowTime0: units_time_nanosecond_t,
        highTime0: units_time_nanosecond_t,
        lowTime1: units_time_nanosecond_t,
        highTime1: units_time_nanosecond_t,
    );
}
extern "C" {
    #[doc = " Sets the sync time.\n\n <p>The sync time is the time to hold output so LEDs enable. Default set for\n WS2812.\n\n @param syncTime the sync time"]
    #[link_name = "\u{1}_ZN3frc14AddressableLED11SetSyncTimeEN5units6unit_tINS1_4unitISt5ratioILx1ELx1000000EENS3_IS4_ILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES8_S6_S8_S8_S8_S8_S8_S8_EES8_S8_EES8_S8_EEdNS1_12linear_scaleEEE"]
    pub fn frc_AddressableLED_SetSyncTime(
        this: *mut frc_AddressableLED,
        syncTime: units_time_microsecond_t,
    );
}
extern "C" {
    #[doc = " Starts the output.\n\n <p>The output writes continuously."]
    #[link_name = "\u{1}_ZN3frc14AddressableLED5StartEv"]
    pub fn frc_AddressableLED_Start(this: *mut frc_AddressableLED);
}
extern "C" {
    #[doc = " Stops the output."]
    #[link_name = "\u{1}_ZN3frc14AddressableLED4StopEv"]
    pub fn frc_AddressableLED_Stop(this: *mut frc_AddressableLED);
}
extern "C" {
    #[doc = " Constructs a new driver for a specific port.\n\n @param port the output port to use (Must be a PWM header)"]
    #[link_name = "\u{1}_ZN3frc14AddressableLEDC1Ei"]
    pub fn frc_AddressableLED_AddressableLED(
        this: *mut frc_AddressableLED,
        port: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc14AddressableLEDD1Ev"]
    pub fn frc_AddressableLED_AddressableLED_destructor(this: *mut frc_AddressableLED);
}
impl frc_AddressableLED {
    #[inline]
    pub unsafe fn SetLength(&mut self, length: ::std::os::raw::c_int) {
        frc_AddressableLED_SetLength(self, length)
    }
    #[inline]
    pub unsafe fn SetData(&mut self, ledData: u8) {
        frc_AddressableLED_SetData(self, ledData)
    }
    #[inline]
    pub unsafe fn SetData1(&mut self, ledData: u8) {
        frc_AddressableLED_SetData1(self, ledData)
    }
    #[inline]
    pub unsafe fn SetBitTiming(
        &mut self,
        lowTime0: units_time_nanosecond_t,
        highTime0: units_time_nanosecond_t,
        lowTime1: units_time_nanosecond_t,
        highTime1: units_time_nanosecond_t,
    ) {
        frc_AddressableLED_SetBitTiming(self, lowTime0, highTime0, lowTime1, highTime1)
    }
    #[inline]
    pub unsafe fn SetSyncTime(&mut self, syncTime: units_time_microsecond_t) {
        frc_AddressableLED_SetSyncTime(self, syncTime)
    }
    #[inline]
    pub unsafe fn Start(&mut self) {
        frc_AddressableLED_Start(self)
    }
    #[inline]
    pub unsafe fn Stop(&mut self) {
        frc_AddressableLED_Stop(self)
    }
    #[inline]
    pub unsafe fn new(port: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AddressableLED_AddressableLED(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        frc_AddressableLED_AddressableLED_destructor(self)
    }
}
#[doc = " I2C bus interface class.\n\n This class is intended to be used by sensor (and other I2C device) drivers.\n It probably should not be used directly.\n\n The Onboard I2C port is subject to system lockups. See <a\n href=\"https://docs.wpilib.org/en/stable/docs/yearly-overview/known-issues.html#onboard-i2c-causing-system-lockups\">\n WPILib Known Issues</a> page for details."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_I2C {
    pub m_port: hal_I2CPort,
    pub m_deviceAddress: ::std::os::raw::c_int,
}
pub const frc_I2C_Port_kOnboard: frc_I2C_Port = 0;
pub const frc_I2C_Port_kMXP: frc_I2C_Port = 1;
pub type frc_I2C_Port = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_frc_I2C() {
    const UNINIT: ::std::mem::MaybeUninit<frc_I2C> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_I2C>(),
        8usize,
        concat!("Size of: ", stringify!(frc_I2C))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_I2C>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_I2C))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_I2C),
            "::",
            stringify!(m_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_deviceAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_I2C),
            "::",
            stringify!(m_deviceAddress)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc3I2C7GetPortEv"]
    pub fn frc_I2C_GetPort(this: *const frc_I2C) -> frc_I2C_Port;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc3I2C16GetDeviceAddressEv"]
    pub fn frc_I2C_GetDeviceAddress(this: *const frc_I2C) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generic transaction.\n\n This is a lower-level interface to the I2C hardware giving you more control\n over each transaction. If you intend to write multiple bytes in the same\n transaction and do not plan to receive anything back, use writeBulk()\n instead. Calling this with a receiveSize of 0 will result in an error.\n\n @param dataToSend   Buffer of data to send as part of the transaction.\n @param sendSize     Number of bytes to send as part of the transaction.\n @param dataReceived Buffer to read data into.\n @param receiveSize  Number of bytes to read from the device.\n @return Transfer Aborted... false for success, true for aborted."]
    #[link_name = "\u{1}_ZN3frc3I2C11TransactionEPhiS1_i"]
    pub fn frc_I2C_Transaction(
        this: *mut frc_I2C,
        dataToSend: *mut u8,
        sendSize: ::std::os::raw::c_int,
        dataReceived: *mut u8,
        receiveSize: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Attempt to address a device on the I2C bus.\n\n This allows you to figure out if there is a device on the I2C bus that\n responds to the address specified in the constructor.\n\n @return Transfer Aborted... false for success, true for aborted."]
    #[link_name = "\u{1}_ZN3frc3I2C11AddressOnlyEv"]
    pub fn frc_I2C_AddressOnly(this: *mut frc_I2C) -> bool;
}
extern "C" {
    #[doc = " Execute a write transaction with the device.\n\n Write a single byte to a register on a device and wait until the\n   transaction is complete.\n\n @param registerAddress The address of the register on the device to be\n                        written.\n @param data            The byte to write to the register on the device.\n @return Transfer Aborted... false for success, true for aborted."]
    #[link_name = "\u{1}_ZN3frc3I2C5WriteEih"]
    pub fn frc_I2C_Write(
        this: *mut frc_I2C,
        registerAddress: ::std::os::raw::c_int,
        data: u8,
    ) -> bool;
}
extern "C" {
    #[doc = " Execute a bulk write transaction with the device.\n\n Write multiple bytes to a device and wait until the\n   transaction is complete.\n\n @param data  The data to write to the register on the device.\n @param count The number of bytes to be written.\n @return Transfer Aborted... false for success, true for aborted."]
    #[link_name = "\u{1}_ZN3frc3I2C9WriteBulkEPhi"]
    pub fn frc_I2C_WriteBulk(
        this: *mut frc_I2C,
        data: *mut u8,
        count: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Execute a read transaction with the device.\n\n Read bytes from a device.\n Most I2C devices will auto-increment the register pointer internally\n allowing you to read consecutive registers on a device in a single\n transaction.\n\n @param registerAddress The register to read first in the transaction.\n @param count           The number of bytes to read in the transaction.\n @param data            A pointer to the array of bytes to store the data\n                        read from the device.\n @return Transfer Aborted... false for success, true for aborted."]
    #[link_name = "\u{1}_ZN3frc3I2C4ReadEiiPh"]
    pub fn frc_I2C_Read(
        this: *mut frc_I2C,
        registerAddress: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        data: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = " Execute a read only transaction with the device.\n\n Read bytes from a device. This method does not write any data to prompt the\n device.\n\n @param buffer A pointer to the array of bytes to store the data read from\n               the device.\n @param count  The number of bytes to read in the transaction.\n @return Transfer Aborted... false for success, true for aborted."]
    #[link_name = "\u{1}_ZN3frc3I2C8ReadOnlyEiPh"]
    pub fn frc_I2C_ReadOnly(
        this: *mut frc_I2C,
        count: ::std::os::raw::c_int,
        buffer: *mut u8,
    ) -> bool;
}
extern "C" {
    #[doc = " Verify that a device's registers contain expected values.\n\n Most devices will have a set of registers that contain a known value that\n can be used to identify them.  This allows an I2C device driver to easily\n verify that the device contains the expected value.\n\n @pre The device must support and be configured to use register\n auto-increment.\n\n @param registerAddress The base register to start reading from the device.\n @param count           The size of the field to be verified.\n @param expected        A buffer containing the values expected from the\n                        device."]
    #[link_name = "\u{1}_ZN3frc3I2C12VerifySensorEiiPKh"]
    pub fn frc_I2C_VerifySensor(
        this: *mut frc_I2C,
        registerAddress: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        expected: *const u8,
    ) -> bool;
}
extern "C" {
    #[doc = " Constructor.\n\n @param port          The I2C port to which the device is connected.\n @param deviceAddress The address of the device on the I2C bus."]
    #[link_name = "\u{1}_ZN3frc3I2CC1ENS0_4PortEi"]
    pub fn frc_I2C_I2C(
        this: *mut frc_I2C,
        port: frc_I2C_Port,
        deviceAddress: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3I2CD1Ev"]
    pub fn frc_I2C_I2C_destructor(this: *mut frc_I2C);
}
impl frc_I2C {
    #[inline]
    pub unsafe fn GetPort(&self) -> frc_I2C_Port {
        frc_I2C_GetPort(self)
    }
    #[inline]
    pub unsafe fn GetDeviceAddress(&self) -> ::std::os::raw::c_int {
        frc_I2C_GetDeviceAddress(self)
    }
    #[inline]
    pub unsafe fn Transaction(
        &mut self,
        dataToSend: *mut u8,
        sendSize: ::std::os::raw::c_int,
        dataReceived: *mut u8,
        receiveSize: ::std::os::raw::c_int,
    ) -> bool {
        frc_I2C_Transaction(self, dataToSend, sendSize, dataReceived, receiveSize)
    }
    #[inline]
    pub unsafe fn AddressOnly(&mut self) -> bool {
        frc_I2C_AddressOnly(self)
    }
    #[inline]
    pub unsafe fn Write(&mut self, registerAddress: ::std::os::raw::c_int, data: u8) -> bool {
        frc_I2C_Write(self, registerAddress, data)
    }
    #[inline]
    pub unsafe fn WriteBulk(&mut self, data: *mut u8, count: ::std::os::raw::c_int) -> bool {
        frc_I2C_WriteBulk(self, data, count)
    }
    #[inline]
    pub unsafe fn Read(
        &mut self,
        registerAddress: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        data: *mut u8,
    ) -> bool {
        frc_I2C_Read(self, registerAddress, count, data)
    }
    #[inline]
    pub unsafe fn ReadOnly(&mut self, count: ::std::os::raw::c_int, buffer: *mut u8) -> bool {
        frc_I2C_ReadOnly(self, count, buffer)
    }
    #[inline]
    pub unsafe fn VerifySensor(
        &mut self,
        registerAddress: ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        expected: *const u8,
    ) -> bool {
        frc_I2C_VerifySensor(self, registerAddress, count, expected)
    }
    #[inline]
    pub unsafe fn new(port: frc_I2C_Port, deviceAddress: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_I2C_I2C(__bindgen_tmp.as_mut_ptr(), port, deviceAddress);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        frc_I2C_I2C_destructor(self)
    }
}
#[repr(C)]
pub struct frc_Accelerometer__bindgen_vtable {
    pub frc_Accelerometer_SetRange:
        unsafe extern "C" fn(this: *mut frc_Accelerometer, range: frc_Accelerometer_Range),
    pub frc_Accelerometer_GetX: unsafe extern "C" fn(this: *mut frc_Accelerometer) -> f64,
    pub frc_Accelerometer_GetY: unsafe extern "C" fn(this: *mut frc_Accelerometer) -> f64,
    pub frc_Accelerometer_GetZ: unsafe extern "C" fn(this: *mut frc_Accelerometer) -> f64,
}
#[doc = " Interface for 3-axis accelerometers."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Accelerometer {
    pub vtable_: *const frc_Accelerometer__bindgen_vtable,
}
pub const frc_Accelerometer_Range_kRange_2G: frc_Accelerometer_Range = 0;
pub const frc_Accelerometer_Range_kRange_4G: frc_Accelerometer_Range = 1;
pub const frc_Accelerometer_Range_kRange_8G: frc_Accelerometer_Range = 2;
pub const frc_Accelerometer_Range_kRange_16G: frc_Accelerometer_Range = 3;
pub type frc_Accelerometer_Range = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_frc_Accelerometer() {
    assert_eq!(
        ::std::mem::size_of::<frc_Accelerometer>(),
        4usize,
        concat!("Size of: ", stringify!(frc_Accelerometer))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Accelerometer>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_Accelerometer))
    );
}
#[doc = " ADXL345 Accelerometer on I2C.\n\n This class allows access to a Analog Devices ADXL345 3-axis accelerometer on\n an I2C bus. This class assumes the default (not alternate) sensor address of\n 0x1D (7-bit address).\n\n The Onboard I2C port is subject to system lockups. See <a\n href=\"https://docs.wpilib.org/en/stable/docs/yearly-overview/known-issues.html#onboard-i2c-causing-system-lockups\">\n WPILib Known Issues</a> page for details."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_ADXL345_I2C {
    pub _base: frc_Accelerometer,
    pub _base_1: nt_NTSendable,
    pub m_i2c: frc_I2C,
    pub m_simDevice: hal_SimDevice,
    pub m_simRange: hal_SimEnum,
    pub m_simX: hal_SimDouble,
    pub m_simY: hal_SimDouble,
    pub m_simZ: hal_SimDouble,
}
pub const frc_ADXL345_I2C_Axes_kAxis_X: frc_ADXL345_I2C_Axes = 0;
pub const frc_ADXL345_I2C_Axes_kAxis_Y: frc_ADXL345_I2C_Axes = 2;
pub const frc_ADXL345_I2C_Axes_kAxis_Z: frc_ADXL345_I2C_Axes = 4;
pub type frc_ADXL345_I2C_Axes = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_ADXL345_I2C_AllAxes {
    pub XAxis: f64,
    pub YAxis: f64,
    pub ZAxis: f64,
}
#[test]
fn bindgen_test_layout_frc_ADXL345_I2C_AllAxes() {
    const UNINIT: ::std::mem::MaybeUninit<frc_ADXL345_I2C_AllAxes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_ADXL345_I2C_AllAxes>(),
        24usize,
        concat!("Size of: ", stringify!(frc_ADXL345_I2C_AllAxes))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ADXL345_I2C_AllAxes>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_ADXL345_I2C_AllAxes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).XAxis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ADXL345_I2C_AllAxes),
            "::",
            stringify!(XAxis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).YAxis) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ADXL345_I2C_AllAxes),
            "::",
            stringify!(YAxis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ZAxis) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ADXL345_I2C_AllAxes),
            "::",
            stringify!(ZAxis)
        )
    );
}
pub const frc_ADXL345_I2C_PowerCtlFields_kPowerCtl_Link: frc_ADXL345_I2C_PowerCtlFields = 32;
pub const frc_ADXL345_I2C_PowerCtlFields_kPowerCtl_AutoSleep: frc_ADXL345_I2C_PowerCtlFields = 16;
pub const frc_ADXL345_I2C_PowerCtlFields_kPowerCtl_Measure: frc_ADXL345_I2C_PowerCtlFields = 8;
pub const frc_ADXL345_I2C_PowerCtlFields_kPowerCtl_Sleep: frc_ADXL345_I2C_PowerCtlFields = 4;
pub type frc_ADXL345_I2C_PowerCtlFields = ::std::os::raw::c_uint;
pub const frc_ADXL345_I2C_DataFormatFields_kDataFormat_SelfTest: frc_ADXL345_I2C_DataFormatFields =
    128;
pub const frc_ADXL345_I2C_DataFormatFields_kDataFormat_SPI: frc_ADXL345_I2C_DataFormatFields = 64;
pub const frc_ADXL345_I2C_DataFormatFields_kDataFormat_IntInvert: frc_ADXL345_I2C_DataFormatFields =
    32;
pub const frc_ADXL345_I2C_DataFormatFields_kDataFormat_FullRes: frc_ADXL345_I2C_DataFormatFields =
    8;
pub const frc_ADXL345_I2C_DataFormatFields_kDataFormat_Justify: frc_ADXL345_I2C_DataFormatFields =
    4;
pub type frc_ADXL345_I2C_DataFormatFields = ::std::os::raw::c_uint;
pub const frc_ADXL345_I2C_kAddress: ::std::os::raw::c_int = 29;
pub const frc_ADXL345_I2C_kPowerCtlRegister: ::std::os::raw::c_int = 45;
pub const frc_ADXL345_I2C_kDataFormatRegister: ::std::os::raw::c_int = 49;
pub const frc_ADXL345_I2C_kDataRegister: ::std::os::raw::c_int = 50;
pub const frc_ADXL345_I2C_kGsPerLSB: f64 = 0.00390625;
#[test]
fn bindgen_test_layout_frc_ADXL345_I2C() {
    assert_eq!(
        ::std::mem::size_of::<frc_ADXL345_I2C>(),
        36usize,
        concat!("Size of: ", stringify!(frc_ADXL345_I2C))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ADXL345_I2C>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_ADXL345_I2C))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc11ADXL345_I2C10GetI2CPortEv"]
    pub fn frc_ADXL345_I2C_GetI2CPort(this: *const frc_ADXL345_I2C) -> frc_I2C_Port;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc11ADXL345_I2C19GetI2CDeviceAddressEv"]
    pub fn frc_ADXL345_I2C_GetI2CDeviceAddress(
        this: *const frc_ADXL345_I2C,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Constructs the ADXL345 Accelerometer over I2C.\n\n @param port          The I2C port the accelerometer is attached to\n @param range         The range (+ or -) that the accelerometer will measure\n @param deviceAddress The I2C address of the accelerometer (0x1D or 0x53)"]
    #[link_name = "\u{1}_ZN3frc11ADXL345_I2CC1ENS_3I2C4PortENS_13Accelerometer5RangeEi"]
    pub fn frc_ADXL345_I2C_ADXL345_I2C(
        this: *mut frc_ADXL345_I2C,
        port: frc_I2C_Port,
        range: frc_Accelerometer_Range,
        deviceAddress: ::std::os::raw::c_int,
    );
}
impl frc_ADXL345_I2C {
    #[inline]
    pub unsafe fn GetI2CPort(&self) -> frc_I2C_Port {
        frc_ADXL345_I2C_GetI2CPort(self)
    }
    #[inline]
    pub unsafe fn GetI2CDeviceAddress(&self) -> ::std::os::raw::c_int {
        frc_ADXL345_I2C_GetI2CDeviceAddress(self)
    }
    #[inline]
    pub unsafe fn new(
        port: frc_I2C_Port,
        range: frc_Accelerometer_Range,
        deviceAddress: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_ADXL345_I2C_ADXL345_I2C(__bindgen_tmp.as_mut_ptr(), port, range, deviceAddress);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11ADXL345_I2C8SetRangeENS_13Accelerometer5RangeE"]
    pub fn frc_ADXL345_I2C_SetRange(
        this: *mut ::std::os::raw::c_void,
        range: frc_Accelerometer_Range,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11ADXL345_I2C4GetXEv"]
    pub fn frc_ADXL345_I2C_GetX(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11ADXL345_I2C4GetYEv"]
    pub fn frc_ADXL345_I2C_GetY(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11ADXL345_I2C4GetZEv"]
    pub fn frc_ADXL345_I2C_GetZ(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " Get the acceleration of one axis in Gs.\n\n @param axis The axis to read from.\n @return Acceleration of the ADXL345 in Gs."]
    #[link_name = "\u{1}_ZN3frc11ADXL345_I2C15GetAccelerationENS0_4AxesE"]
    pub fn frc_ADXL345_I2C_GetAcceleration(
        this: *mut ::std::os::raw::c_void,
        axis: frc_ADXL345_I2C_Axes,
    ) -> f64;
}
extern "C" {
    #[doc = " Get the acceleration of all axes in Gs.\n\n @return An object containing the acceleration measured on each axis of the\n         ADXL345 in Gs."]
    #[link_name = "\u{1}_ZN3frc11ADXL345_I2C16GetAccelerationsEv"]
    pub fn frc_ADXL345_I2C_GetAccelerations(
        this: *mut ::std::os::raw::c_void,
    ) -> frc_ADXL345_I2C_AllAxes;
}
extern "C" {
    #[link_name = "\u{1}_ZThn4_N3frc11ADXL345_I2C12InitSendableERN2nt17NTSendableBuilderE"]
    pub fn frc_ADXL345_I2C_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut nt_NTSendableBuilder,
    );
}
#[repr(C)]
pub struct frc_SPI__bindgen_vtable(::std::os::raw::c_void);
#[doc = " SPI bus interface class.\n\n This class is intended to be used by sensor (and other SPI device) drivers.\n It probably should not be used directly.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct frc_SPI {
    pub vtable_: *const frc_SPI__bindgen_vtable,
    pub m_port: hal_SPIPort,
    pub m_mode: HAL_SPIMode,
    pub m_accum: u32,
}
pub const frc_SPI_Port_kOnboardCS0: frc_SPI_Port = 0;
pub const frc_SPI_Port_kOnboardCS1: frc_SPI_Port = 1;
pub const frc_SPI_Port_kOnboardCS2: frc_SPI_Port = 2;
pub const frc_SPI_Port_kOnboardCS3: frc_SPI_Port = 3;
pub const frc_SPI_Port_kMXP: frc_SPI_Port = 4;
pub type frc_SPI_Port = ::std::os::raw::c_uint;
pub const frc_SPI_Mode_kMode0: frc_SPI_Mode = 0;
pub const frc_SPI_Mode_kMode1: frc_SPI_Mode = 1;
pub const frc_SPI_Mode_kMode2: frc_SPI_Mode = 2;
pub const frc_SPI_Mode_kMode3: frc_SPI_Mode = 3;
pub type frc_SPI_Mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_SPI_Accumulator {
    _unused: [u8; 0],
}
#[test]
fn bindgen_test_layout_frc_SPI() {
    const UNINIT: ::std::mem::MaybeUninit<frc_SPI> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_SPI>(),
        16usize,
        concat!("Size of: ", stringify!(frc_SPI))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_SPI>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_SPI))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SPI),
            "::",
            stringify!(m_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SPI),
            "::",
            stringify!(m_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_accum) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SPI),
            "::",
            stringify!(m_accum)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc3SPI7GetPortEv"]
    pub fn frc_SPI_GetPort(this: *const frc_SPI) -> frc_SPI_Port;
}
extern "C" {
    #[doc = " Configure the rate of the generated clock signal.\n\n The default value is 500,000Hz.\n The maximum value is 4,000,000Hz.\n\n @param hz The clock rate in Hertz."]
    #[link_name = "\u{1}_ZN3frc3SPI12SetClockRateEi"]
    pub fn frc_SPI_SetClockRate(this: *mut frc_SPI, hz: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Configure the order that bits are sent and received on the wire\n to be most significant bit first.\n\n @deprecated Does not work, will be removed."]
    #[link_name = "\u{1}_ZN3frc3SPI11SetMSBFirstEv"]
    pub fn frc_SPI_SetMSBFirst(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Configure the order that bits are sent and received on the wire\n to be least significant bit first.\n\n @deprecated Does not work, will be removed."]
    #[link_name = "\u{1}_ZN3frc3SPI11SetLSBFirstEv"]
    pub fn frc_SPI_SetLSBFirst(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Configure that the data is stable on the leading edge and the data\n changes on the trailing edge.\n\n @deprecated Use SetMode() instead."]
    #[link_name = "\u{1}_ZN3frc3SPI26SetSampleDataOnLeadingEdgeEv"]
    pub fn frc_SPI_SetSampleDataOnLeadingEdge(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Configure that the data is stable on the trailing edge and the data\n changes on the leading edge.\n\n @deprecated Use SetMode() instead."]
    #[link_name = "\u{1}_ZN3frc3SPI27SetSampleDataOnTrailingEdgeEv"]
    pub fn frc_SPI_SetSampleDataOnTrailingEdge(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Configure the clock output line to be active low.\n This is sometimes called clock polarity high or clock idle high.\n\n @deprecated Use SetMode() instead."]
    #[link_name = "\u{1}_ZN3frc3SPI17SetClockActiveLowEv"]
    pub fn frc_SPI_SetClockActiveLow(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Configure the clock output line to be active high.\n This is sometimes called clock polarity low or clock idle low.\n\n @deprecated Use SetMode() instead."]
    #[link_name = "\u{1}_ZN3frc3SPI18SetClockActiveHighEv"]
    pub fn frc_SPI_SetClockActiveHigh(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Sets the mode for the SPI device.\n\n <p>Mode 0 is Clock idle low, data sampled on rising edge\n\n <p>Mode 1 is Clock idle low, data sampled on falling edge\n\n <p>Mode 2 is Clock idle high, data sampled on falling edge\n\n <p>Mode 3 is Clock idle high, data sampled on rising edge\n\n @param mode The mode to set."]
    #[link_name = "\u{1}_ZN3frc3SPI7SetModeENS0_4ModeE"]
    pub fn frc_SPI_SetMode(this: *mut frc_SPI, mode: frc_SPI_Mode);
}
extern "C" {
    #[doc = " Configure the chip select line to be active high."]
    #[link_name = "\u{1}_ZN3frc3SPI23SetChipSelectActiveHighEv"]
    pub fn frc_SPI_SetChipSelectActiveHigh(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Configure the chip select line to be active low."]
    #[link_name = "\u{1}_ZN3frc3SPI22SetChipSelectActiveLowEv"]
    pub fn frc_SPI_SetChipSelectActiveLow(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Initialize automatic SPI transfer engine.\n\n Only a single engine is available, and use of it blocks use of all other\n chip select usage on the same physical SPI port while it is running.\n\n @param bufferSize buffer size in bytes"]
    #[link_name = "\u{1}_ZN3frc3SPI8InitAutoEi"]
    pub fn frc_SPI_InitAuto(this: *mut frc_SPI, bufferSize: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Frees the automatic SPI transfer engine."]
    #[link_name = "\u{1}_ZN3frc3SPI8FreeAutoEv"]
    pub fn frc_SPI_FreeAuto(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Set the data to be transmitted by the engine.\n\n Up to 16 bytes are configurable, and may be followed by up to 127 zero\n bytes.\n\n @param dataToSend data to send (maximum 16 bytes)\n @param zeroSize number of zeros to send after the data"]
    #[link_name = "\u{1}_ZN3frc3SPI19SetAutoTransmitDataESt4spanIKhLj4294967295EEi"]
    pub fn frc_SPI_SetAutoTransmitData(
        this: *mut frc_SPI,
        dataToSend: [u32; 2usize],
        zeroSize: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Start running the automatic SPI transfer engine at a periodic rate.\n\n InitAuto() and SetAutoTransmitData() must be called before calling this\n function.\n\n @param period period between transfers (us resolution)"]
    #[link_name = "\u{1}_ZN3frc3SPI13StartAutoRateEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_SPI_StartAutoRate(this: *mut frc_SPI, period: units_time_second_t);
}
extern "C" {
    #[doc = " Start running the automatic SPI transfer engine when a trigger occurs.\n\n InitAuto() and SetAutoTransmitData() must be called before calling this\n function.\n\n @param source digital source for the trigger (may be an analog trigger)\n @param rising trigger on the rising edge\n @param falling trigger on the falling edge"]
    #[link_name = "\u{1}_ZN3frc3SPI16StartAutoTriggerERNS_13DigitalSourceEbb"]
    pub fn frc_SPI_StartAutoTrigger(
        this: *mut frc_SPI,
        source: *mut frc_DigitalSource,
        rising: bool,
        falling: bool,
    );
}
extern "C" {
    #[doc = " Stop running the automatic SPI transfer engine."]
    #[link_name = "\u{1}_ZN3frc3SPI8StopAutoEv"]
    pub fn frc_SPI_StopAuto(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Force the engine to make a single transfer."]
    #[link_name = "\u{1}_ZN3frc3SPI13ForceAutoReadEv"]
    pub fn frc_SPI_ForceAutoRead(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Read data that has been transferred by the automatic SPI transfer engine.\n\n Transfers may be made a byte at a time, so it's necessary for the caller\n to handle cases where an entire transfer has not been completed.\n\n Each received data sequence consists of a timestamp followed by the\n received data bytes, one byte per word (in the least significant byte).\n The length of each received data sequence is the same as the combined\n size of the data and zeroSize set in SetAutoTransmitData().\n\n Blocks until numToRead words have been read or timeout expires.\n May be called with numToRead=0 to retrieve how many words are available.\n\n @param buffer buffer where read words are stored\n @param numToRead number of words to read\n @param timeout timeout (ms resolution)\n @return Number of words remaining to be read"]
    #[link_name = "\u{1}_ZN3frc3SPI20ReadAutoReceivedDataEPjiN5units6unit_tINS2_4unitISt5ratioILx1ELx1EENS2_9base_unitIS5_ILx0ELx1EES8_S6_S8_S8_S8_S8_S8_S8_EES8_S8_EEdNS2_12linear_scaleEEE"]
    pub fn frc_SPI_ReadAutoReceivedData(
        this: *mut frc_SPI,
        buffer: *mut u32,
        numToRead: ::std::os::raw::c_int,
        timeout: units_time_second_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of bytes dropped by the automatic SPI transfer engine due\n to the receive buffer being full.\n\n @return Number of bytes dropped"]
    #[link_name = "\u{1}_ZN3frc3SPI19GetAutoDroppedCountEv"]
    pub fn frc_SPI_GetAutoDroppedCount(this: *mut frc_SPI) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure the Auto SPI Stall time between reads.\n\n @param port The number of the port to use. 0-3 for Onboard CS0-CS2, 4 for\n MXP.\n @param csToSclkTicks the number of ticks to wait before asserting the cs\n pin\n @param stallTicks the number of ticks to stall for\n @param pow2BytesPerRead the number of bytes to read before stalling"]
    #[link_name = "\u{1}_ZN3frc3SPI18ConfigureAutoStallE11HAL_SPIPortiii"]
    pub fn frc_SPI_ConfigureAutoStall(
        this: *mut frc_SPI,
        port: HAL_SPIPort,
        csToSclkTicks: ::std::os::raw::c_int,
        stallTicks: ::std::os::raw::c_int,
        pow2BytesPerRead: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Initialize the accumulator.\n\n @param period     Time between reads\n @param cmd        SPI command to send to request data\n @param xferSize   SPI transfer size, in bytes\n @param validMask  Mask to apply to received data for validity checking\n @param validValue After valid_mask is applied, required matching value for\n                   validity checking\n @param dataShift  Bit shift to apply to received data to get actual data\n                   value\n @param dataSize   Size (in bits) of data field\n @param isSigned   Is data field signed?\n @param bigEndian  Is device big endian?"]
    #[link_name = "\u{1}_ZN3frc3SPI15InitAccumulatorEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEEiiiiiibb"]
    pub fn frc_SPI_InitAccumulator(
        this: *mut frc_SPI,
        period: units_time_second_t,
        cmd: ::std::os::raw::c_int,
        xferSize: ::std::os::raw::c_int,
        validMask: ::std::os::raw::c_int,
        validValue: ::std::os::raw::c_int,
        dataShift: ::std::os::raw::c_int,
        dataSize: ::std::os::raw::c_int,
        isSigned: bool,
        bigEndian: bool,
    );
}
extern "C" {
    #[doc = " Frees the accumulator."]
    #[link_name = "\u{1}_ZN3frc3SPI15FreeAccumulatorEv"]
    pub fn frc_SPI_FreeAccumulator(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Resets the accumulator to zero."]
    #[link_name = "\u{1}_ZN3frc3SPI16ResetAccumulatorEv"]
    pub fn frc_SPI_ResetAccumulator(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Set the center value of the accumulator.\n\n The center value is subtracted from each value before it is added to the\n accumulator. This is used for the center value of devices like gyros and\n accelerometers to make integration work and to take the device offset into\n account when integrating."]
    #[link_name = "\u{1}_ZN3frc3SPI20SetAccumulatorCenterEi"]
    pub fn frc_SPI_SetAccumulatorCenter(this: *mut frc_SPI, center: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the accumulator's deadband."]
    #[link_name = "\u{1}_ZN3frc3SPI22SetAccumulatorDeadbandEi"]
    pub fn frc_SPI_SetAccumulatorDeadband(this: *mut frc_SPI, deadband: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Read the last value read by the accumulator engine."]
    #[link_name = "\u{1}_ZNK3frc3SPI23GetAccumulatorLastValueEv"]
    pub fn frc_SPI_GetAccumulatorLastValue(this: *const frc_SPI) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read the accumulated value.\n\n @return The 64-bit value accumulated since the last Reset()."]
    #[link_name = "\u{1}_ZNK3frc3SPI19GetAccumulatorValueEv"]
    pub fn frc_SPI_GetAccumulatorValue(this: *const frc_SPI) -> i64;
}
extern "C" {
    #[doc = " Read the number of accumulated values.\n\n Read the count of the accumulated values since the accumulator was last\n Reset().\n\n @return The number of times samples from the channel were accumulated."]
    #[link_name = "\u{1}_ZNK3frc3SPI19GetAccumulatorCountEv"]
    pub fn frc_SPI_GetAccumulatorCount(this: *const frc_SPI) -> i64;
}
extern "C" {
    #[doc = " Read the average of the accumulated value.\n\n @return The accumulated average value (value / count)."]
    #[link_name = "\u{1}_ZNK3frc3SPI21GetAccumulatorAverageEv"]
    pub fn frc_SPI_GetAccumulatorAverage(this: *const frc_SPI) -> f64;
}
extern "C" {
    #[doc = " Read the accumulated value and the number of accumulated values atomically.\n\n This function reads the value and count atomically.\n This can be used for averaging.\n\n @param value Pointer to the 64-bit accumulated output.\n @param count Pointer to the number of accumulation cycles."]
    #[link_name = "\u{1}_ZNK3frc3SPI20GetAccumulatorOutputERxS1_"]
    pub fn frc_SPI_GetAccumulatorOutput(this: *const frc_SPI, value: *mut i64, count: *mut i64);
}
extern "C" {
    #[doc = " Set the center value of the accumulator integrator.\n\n The center value is subtracted from each value*dt before it is added to the\n integrated value. This is used for the center value of devices like gyros\n and accelerometers to take the device offset into account when integrating."]
    #[link_name = "\u{1}_ZN3frc3SPI30SetAccumulatorIntegratedCenterEd"]
    pub fn frc_SPI_SetAccumulatorIntegratedCenter(this: *mut frc_SPI, center: f64);
}
extern "C" {
    #[doc = " Read the integrated value.  This is the sum of (each value * time between\n values).\n\n @return The integrated value accumulated since the last Reset()."]
    #[link_name = "\u{1}_ZNK3frc3SPI29GetAccumulatorIntegratedValueEv"]
    pub fn frc_SPI_GetAccumulatorIntegratedValue(this: *const frc_SPI) -> f64;
}
extern "C" {
    #[doc = " Read the average of the integrated value.  This is the sum of (each value\n times the time between values), divided by the count.\n\n @return The average of the integrated value accumulated since the last\n         Reset()."]
    #[link_name = "\u{1}_ZNK3frc3SPI31GetAccumulatorIntegratedAverageEv"]
    pub fn frc_SPI_GetAccumulatorIntegratedAverage(this: *const frc_SPI) -> f64;
}
extern "C" {
    #[doc = " Constructor\n\n @param port the physical SPI port"]
    #[link_name = "\u{1}_ZN3frc3SPIC1ENS0_4PortE"]
    pub fn frc_SPI_SPI(this: *mut frc_SPI, port: frc_SPI_Port);
}
impl frc_SPI {
    #[inline]
    pub unsafe fn GetPort(&self) -> frc_SPI_Port {
        frc_SPI_GetPort(self)
    }
    #[inline]
    pub unsafe fn SetClockRate(&mut self, hz: ::std::os::raw::c_int) {
        frc_SPI_SetClockRate(self, hz)
    }
    #[inline]
    pub unsafe fn SetMSBFirst(&mut self) {
        frc_SPI_SetMSBFirst(self)
    }
    #[inline]
    pub unsafe fn SetLSBFirst(&mut self) {
        frc_SPI_SetLSBFirst(self)
    }
    #[inline]
    pub unsafe fn SetSampleDataOnLeadingEdge(&mut self) {
        frc_SPI_SetSampleDataOnLeadingEdge(self)
    }
    #[inline]
    pub unsafe fn SetSampleDataOnTrailingEdge(&mut self) {
        frc_SPI_SetSampleDataOnTrailingEdge(self)
    }
    #[inline]
    pub unsafe fn SetClockActiveLow(&mut self) {
        frc_SPI_SetClockActiveLow(self)
    }
    #[inline]
    pub unsafe fn SetClockActiveHigh(&mut self) {
        frc_SPI_SetClockActiveHigh(self)
    }
    #[inline]
    pub unsafe fn SetMode(&mut self, mode: frc_SPI_Mode) {
        frc_SPI_SetMode(self, mode)
    }
    #[inline]
    pub unsafe fn SetChipSelectActiveHigh(&mut self) {
        frc_SPI_SetChipSelectActiveHigh(self)
    }
    #[inline]
    pub unsafe fn SetChipSelectActiveLow(&mut self) {
        frc_SPI_SetChipSelectActiveLow(self)
    }
    #[inline]
    pub unsafe fn InitAuto(&mut self, bufferSize: ::std::os::raw::c_int) {
        frc_SPI_InitAuto(self, bufferSize)
    }
    #[inline]
    pub unsafe fn FreeAuto(&mut self) {
        frc_SPI_FreeAuto(self)
    }
    #[inline]
    pub unsafe fn SetAutoTransmitData(
        &mut self,
        dataToSend: [u32; 2usize],
        zeroSize: ::std::os::raw::c_int,
    ) {
        frc_SPI_SetAutoTransmitData(self, dataToSend, zeroSize)
    }
    #[inline]
    pub unsafe fn StartAutoRate(&mut self, period: units_time_second_t) {
        frc_SPI_StartAutoRate(self, period)
    }
    #[inline]
    pub unsafe fn StartAutoTrigger(
        &mut self,
        source: *mut frc_DigitalSource,
        rising: bool,
        falling: bool,
    ) {
        frc_SPI_StartAutoTrigger(self, source, rising, falling)
    }
    #[inline]
    pub unsafe fn StopAuto(&mut self) {
        frc_SPI_StopAuto(self)
    }
    #[inline]
    pub unsafe fn ForceAutoRead(&mut self) {
        frc_SPI_ForceAutoRead(self)
    }
    #[inline]
    pub unsafe fn ReadAutoReceivedData(
        &mut self,
        buffer: *mut u32,
        numToRead: ::std::os::raw::c_int,
        timeout: units_time_second_t,
    ) -> ::std::os::raw::c_int {
        frc_SPI_ReadAutoReceivedData(self, buffer, numToRead, timeout)
    }
    #[inline]
    pub unsafe fn GetAutoDroppedCount(&mut self) -> ::std::os::raw::c_int {
        frc_SPI_GetAutoDroppedCount(self)
    }
    #[inline]
    pub unsafe fn ConfigureAutoStall(
        &mut self,
        port: HAL_SPIPort,
        csToSclkTicks: ::std::os::raw::c_int,
        stallTicks: ::std::os::raw::c_int,
        pow2BytesPerRead: ::std::os::raw::c_int,
    ) {
        frc_SPI_ConfigureAutoStall(self, port, csToSclkTicks, stallTicks, pow2BytesPerRead)
    }
    #[inline]
    pub unsafe fn InitAccumulator(
        &mut self,
        period: units_time_second_t,
        cmd: ::std::os::raw::c_int,
        xferSize: ::std::os::raw::c_int,
        validMask: ::std::os::raw::c_int,
        validValue: ::std::os::raw::c_int,
        dataShift: ::std::os::raw::c_int,
        dataSize: ::std::os::raw::c_int,
        isSigned: bool,
        bigEndian: bool,
    ) {
        frc_SPI_InitAccumulator(
            self, period, cmd, xferSize, validMask, validValue, dataShift, dataSize, isSigned,
            bigEndian,
        )
    }
    #[inline]
    pub unsafe fn FreeAccumulator(&mut self) {
        frc_SPI_FreeAccumulator(self)
    }
    #[inline]
    pub unsafe fn ResetAccumulator(&mut self) {
        frc_SPI_ResetAccumulator(self)
    }
    #[inline]
    pub unsafe fn SetAccumulatorCenter(&mut self, center: ::std::os::raw::c_int) {
        frc_SPI_SetAccumulatorCenter(self, center)
    }
    #[inline]
    pub unsafe fn SetAccumulatorDeadband(&mut self, deadband: ::std::os::raw::c_int) {
        frc_SPI_SetAccumulatorDeadband(self, deadband)
    }
    #[inline]
    pub unsafe fn GetAccumulatorLastValue(&self) -> ::std::os::raw::c_int {
        frc_SPI_GetAccumulatorLastValue(self)
    }
    #[inline]
    pub unsafe fn GetAccumulatorValue(&self) -> i64 {
        frc_SPI_GetAccumulatorValue(self)
    }
    #[inline]
    pub unsafe fn GetAccumulatorCount(&self) -> i64 {
        frc_SPI_GetAccumulatorCount(self)
    }
    #[inline]
    pub unsafe fn GetAccumulatorAverage(&self) -> f64 {
        frc_SPI_GetAccumulatorAverage(self)
    }
    #[inline]
    pub unsafe fn GetAccumulatorOutput(&self, value: *mut i64, count: *mut i64) {
        frc_SPI_GetAccumulatorOutput(self, value, count)
    }
    #[inline]
    pub unsafe fn SetAccumulatorIntegratedCenter(&mut self, center: f64) {
        frc_SPI_SetAccumulatorIntegratedCenter(self, center)
    }
    #[inline]
    pub unsafe fn GetAccumulatorIntegratedValue(&self) -> f64 {
        frc_SPI_GetAccumulatorIntegratedValue(self)
    }
    #[inline]
    pub unsafe fn GetAccumulatorIntegratedAverage(&self) -> f64 {
        frc_SPI_GetAccumulatorIntegratedAverage(self)
    }
    #[inline]
    pub unsafe fn new(port: frc_SPI_Port) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_SPI_SPI(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3SPID1Ev"]
    pub fn frc_SPI_SPI_destructor(this: *mut frc_SPI);
}
extern "C" {
    #[doc = " Write data to the peripheral device.  Blocks until there is space in the\n output FIFO.\n\n If not running in output only mode, also saves the data received\n on the CIPO input during the transfer into the receive FIFO."]
    #[link_name = "\u{1}_ZN3frc3SPI5WriteEPhi"]
    pub fn frc_SPI_Write(
        this: *mut ::std::os::raw::c_void,
        data: *mut u8,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read a word from the receive FIFO.\n\n Waits for the current transfer to complete if the receive FIFO is empty.\n\n If the receive FIFO is empty, there is no active transfer, and initiate\n is false, errors.\n\n @param initiate     If true, this function pushes \"0\" into the transmit\n                     buffer and initiates a transfer. If false, this\n                     function assumes that data is already in the receive\n                     FIFO from a previous write.\n @param dataReceived Buffer to receive data from the device\n @param size         The length of the transaction, in bytes"]
    #[link_name = "\u{1}_ZN3frc3SPI4ReadEbPhi"]
    pub fn frc_SPI_Read(
        this: *mut ::std::os::raw::c_void,
        initiate: bool,
        dataReceived: *mut u8,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Perform a simultaneous read/write transaction with the device\n\n @param dataToSend   The data to be written out to the device\n @param dataReceived Buffer to receive data from the device\n @param size         The length of the transaction, in bytes"]
    #[link_name = "\u{1}_ZN3frc3SPI11TransactionEPhS1_i"]
    pub fn frc_SPI_Transaction(
        this: *mut ::std::os::raw::c_void,
        dataToSend: *mut u8,
        dataReceived: *mut u8,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " ADXL345 Accelerometer on SPI.\n\n This class allows access to an Analog Devices ADXL345 3-axis accelerometer\n via SPI. This class assumes the sensor is wired in 4-wire SPI mode."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_ADXL345_SPI {
    pub _base: frc_Accelerometer,
    pub _base_1: nt_NTSendable,
    pub m_spi: frc_SPI,
    pub m_simDevice: hal_SimDevice,
    pub m_simRange: hal_SimEnum,
    pub m_simX: hal_SimDouble,
    pub m_simY: hal_SimDouble,
    pub m_simZ: hal_SimDouble,
}
pub const frc_ADXL345_SPI_Axes_kAxis_X: frc_ADXL345_SPI_Axes = 0;
pub const frc_ADXL345_SPI_Axes_kAxis_Y: frc_ADXL345_SPI_Axes = 2;
pub const frc_ADXL345_SPI_Axes_kAxis_Z: frc_ADXL345_SPI_Axes = 4;
pub type frc_ADXL345_SPI_Axes = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_ADXL345_SPI_AllAxes {
    pub XAxis: f64,
    pub YAxis: f64,
    pub ZAxis: f64,
}
#[test]
fn bindgen_test_layout_frc_ADXL345_SPI_AllAxes() {
    const UNINIT: ::std::mem::MaybeUninit<frc_ADXL345_SPI_AllAxes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_ADXL345_SPI_AllAxes>(),
        24usize,
        concat!("Size of: ", stringify!(frc_ADXL345_SPI_AllAxes))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ADXL345_SPI_AllAxes>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_ADXL345_SPI_AllAxes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).XAxis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ADXL345_SPI_AllAxes),
            "::",
            stringify!(XAxis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).YAxis) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ADXL345_SPI_AllAxes),
            "::",
            stringify!(YAxis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ZAxis) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ADXL345_SPI_AllAxes),
            "::",
            stringify!(ZAxis)
        )
    );
}
pub const frc_ADXL345_SPI_SPIAddressFields_kAddress_Read: frc_ADXL345_SPI_SPIAddressFields = 128;
pub const frc_ADXL345_SPI_SPIAddressFields_kAddress_MultiByte: frc_ADXL345_SPI_SPIAddressFields =
    64;
pub type frc_ADXL345_SPI_SPIAddressFields = ::std::os::raw::c_uint;
pub const frc_ADXL345_SPI_PowerCtlFields_kPowerCtl_Link: frc_ADXL345_SPI_PowerCtlFields = 32;
pub const frc_ADXL345_SPI_PowerCtlFields_kPowerCtl_AutoSleep: frc_ADXL345_SPI_PowerCtlFields = 16;
pub const frc_ADXL345_SPI_PowerCtlFields_kPowerCtl_Measure: frc_ADXL345_SPI_PowerCtlFields = 8;
pub const frc_ADXL345_SPI_PowerCtlFields_kPowerCtl_Sleep: frc_ADXL345_SPI_PowerCtlFields = 4;
pub type frc_ADXL345_SPI_PowerCtlFields = ::std::os::raw::c_uint;
pub const frc_ADXL345_SPI_DataFormatFields_kDataFormat_SelfTest: frc_ADXL345_SPI_DataFormatFields =
    128;
pub const frc_ADXL345_SPI_DataFormatFields_kDataFormat_SPI: frc_ADXL345_SPI_DataFormatFields = 64;
pub const frc_ADXL345_SPI_DataFormatFields_kDataFormat_IntInvert: frc_ADXL345_SPI_DataFormatFields =
    32;
pub const frc_ADXL345_SPI_DataFormatFields_kDataFormat_FullRes: frc_ADXL345_SPI_DataFormatFields =
    8;
pub const frc_ADXL345_SPI_DataFormatFields_kDataFormat_Justify: frc_ADXL345_SPI_DataFormatFields =
    4;
pub type frc_ADXL345_SPI_DataFormatFields = ::std::os::raw::c_uint;
pub const frc_ADXL345_SPI_kPowerCtlRegister: ::std::os::raw::c_int = 45;
pub const frc_ADXL345_SPI_kDataFormatRegister: ::std::os::raw::c_int = 49;
pub const frc_ADXL345_SPI_kDataRegister: ::std::os::raw::c_int = 50;
pub const frc_ADXL345_SPI_kGsPerLSB: f64 = 0.00390625;
#[test]
fn bindgen_test_layout_frc_ADXL345_SPI() {
    assert_eq!(
        ::std::mem::size_of::<frc_ADXL345_SPI>(),
        44usize,
        concat!("Size of: ", stringify!(frc_ADXL345_SPI))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ADXL345_SPI>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_ADXL345_SPI))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc11ADXL345_SPI10GetSpiPortEv"]
    pub fn frc_ADXL345_SPI_GetSpiPort(this: *const frc_ADXL345_SPI) -> frc_SPI_Port;
}
extern "C" {
    #[doc = " Constructor.\n\n @param port  The SPI port the accelerometer is attached to\n @param range The range (+ or -) that the accelerometer will measure"]
    #[link_name = "\u{1}_ZN3frc11ADXL345_SPIC1ENS_3SPI4PortENS_13Accelerometer5RangeE"]
    pub fn frc_ADXL345_SPI_ADXL345_SPI(
        this: *mut frc_ADXL345_SPI,
        port: frc_SPI_Port,
        range: frc_Accelerometer_Range,
    );
}
impl frc_ADXL345_SPI {
    #[inline]
    pub unsafe fn GetSpiPort(&self) -> frc_SPI_Port {
        frc_ADXL345_SPI_GetSpiPort(self)
    }
    #[inline]
    pub unsafe fn new(port: frc_SPI_Port, range: frc_Accelerometer_Range) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_ADXL345_SPI_ADXL345_SPI(__bindgen_tmp.as_mut_ptr(), port, range);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11ADXL345_SPI8SetRangeENS_13Accelerometer5RangeE"]
    pub fn frc_ADXL345_SPI_SetRange(
        this: *mut ::std::os::raw::c_void,
        range: frc_Accelerometer_Range,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11ADXL345_SPI4GetXEv"]
    pub fn frc_ADXL345_SPI_GetX(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11ADXL345_SPI4GetYEv"]
    pub fn frc_ADXL345_SPI_GetY(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11ADXL345_SPI4GetZEv"]
    pub fn frc_ADXL345_SPI_GetZ(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " Get the acceleration of one axis in Gs.\n\n @param axis The axis to read from.\n @return Acceleration of the ADXL345 in Gs."]
    #[link_name = "\u{1}_ZN3frc11ADXL345_SPI15GetAccelerationENS0_4AxesE"]
    pub fn frc_ADXL345_SPI_GetAcceleration(
        this: *mut ::std::os::raw::c_void,
        axis: frc_ADXL345_SPI_Axes,
    ) -> f64;
}
extern "C" {
    #[doc = " Get the acceleration of all axes in Gs.\n\n @return An object containing the acceleration measured on each axis of the\n         ADXL345 in Gs."]
    #[link_name = "\u{1}_ZN3frc11ADXL345_SPI16GetAccelerationsEv"]
    pub fn frc_ADXL345_SPI_GetAccelerations(
        this: *mut ::std::os::raw::c_void,
    ) -> frc_ADXL345_SPI_AllAxes;
}
extern "C" {
    #[link_name = "\u{1}_ZThn4_N3frc11ADXL345_SPI12InitSendableERN2nt17NTSendableBuilderE"]
    pub fn frc_ADXL345_SPI_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut nt_NTSendableBuilder,
    );
}
#[doc = " ADXL362 SPI Accelerometer.\n\n This class allows access to an Analog Devices ADXL362 3-axis accelerometer."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_ADXL362 {
    pub _base: frc_Accelerometer,
    pub _base_1: nt_NTSendable,
    pub m_spi: frc_SPI,
    pub m_simDevice: hal_SimDevice,
    pub m_simRange: hal_SimEnum,
    pub m_simX: hal_SimDouble,
    pub m_simY: hal_SimDouble,
    pub m_simZ: hal_SimDouble,
    pub m_gsPerLSB: f64,
}
pub const frc_ADXL362_Axes_kAxis_X: frc_ADXL362_Axes = 0;
pub const frc_ADXL362_Axes_kAxis_Y: frc_ADXL362_Axes = 2;
pub const frc_ADXL362_Axes_kAxis_Z: frc_ADXL362_Axes = 4;
pub type frc_ADXL362_Axes = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_ADXL362_AllAxes {
    pub XAxis: f64,
    pub YAxis: f64,
    pub ZAxis: f64,
}
#[test]
fn bindgen_test_layout_frc_ADXL362_AllAxes() {
    const UNINIT: ::std::mem::MaybeUninit<frc_ADXL362_AllAxes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_ADXL362_AllAxes>(),
        24usize,
        concat!("Size of: ", stringify!(frc_ADXL362_AllAxes))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ADXL362_AllAxes>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_ADXL362_AllAxes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).XAxis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ADXL362_AllAxes),
            "::",
            stringify!(XAxis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).YAxis) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ADXL362_AllAxes),
            "::",
            stringify!(YAxis)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ZAxis) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ADXL362_AllAxes),
            "::",
            stringify!(ZAxis)
        )
    );
}
#[test]
fn bindgen_test_layout_frc_ADXL362() {
    assert_eq!(
        ::std::mem::size_of::<frc_ADXL362>(),
        56usize,
        concat!("Size of: ", stringify!(frc_ADXL362))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ADXL362>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_ADXL362))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc7ADXL36210GetSpiPortEv"]
    pub fn frc_ADXL362_GetSpiPort(this: *const frc_ADXL362) -> frc_SPI_Port;
}
extern "C" {
    #[doc = " Constructor.  Uses the onboard CS1.\n\n @param range The range (+ or -) that the accelerometer will measure."]
    #[link_name = "\u{1}_ZN3frc7ADXL362C1ENS_13Accelerometer5RangeE"]
    pub fn frc_ADXL362_ADXL362(this: *mut frc_ADXL362, range: frc_Accelerometer_Range);
}
extern "C" {
    #[doc = " Constructor.\n\n @param port  The SPI port the accelerometer is attached to\n @param range The range (+ or -) that the accelerometer will measure."]
    #[link_name = "\u{1}_ZN3frc7ADXL362C1ENS_3SPI4PortENS_13Accelerometer5RangeE"]
    pub fn frc_ADXL362_ADXL3621(
        this: *mut frc_ADXL362,
        port: frc_SPI_Port,
        range: frc_Accelerometer_Range,
    );
}
impl frc_ADXL362 {
    #[inline]
    pub unsafe fn GetSpiPort(&self) -> frc_SPI_Port {
        frc_ADXL362_GetSpiPort(self)
    }
    #[inline]
    pub unsafe fn new(range: frc_Accelerometer_Range) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_ADXL362_ADXL362(__bindgen_tmp.as_mut_ptr(), range);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(port: frc_SPI_Port, range: frc_Accelerometer_Range) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_ADXL362_ADXL3621(__bindgen_tmp.as_mut_ptr(), port, range);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7ADXL3628SetRangeENS_13Accelerometer5RangeE"]
    pub fn frc_ADXL362_SetRange(this: *mut ::std::os::raw::c_void, range: frc_Accelerometer_Range);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7ADXL3624GetXEv"]
    pub fn frc_ADXL362_GetX(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7ADXL3624GetYEv"]
    pub fn frc_ADXL362_GetY(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7ADXL3624GetZEv"]
    pub fn frc_ADXL362_GetZ(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " Get the acceleration of one axis in Gs.\n\n @param axis The axis to read from.\n @return Acceleration of the ADXL362 in Gs."]
    #[link_name = "\u{1}_ZN3frc7ADXL36215GetAccelerationENS0_4AxesE"]
    pub fn frc_ADXL362_GetAcceleration(
        this: *mut ::std::os::raw::c_void,
        axis: frc_ADXL362_Axes,
    ) -> f64;
}
extern "C" {
    #[doc = " Get the acceleration of all axes in Gs.\n\n @return An object containing the acceleration measured on each axis of the\n         ADXL362 in Gs."]
    #[link_name = "\u{1}_ZN3frc7ADXL36216GetAccelerationsEv"]
    pub fn frc_ADXL362_GetAccelerations(this: *mut ::std::os::raw::c_void) -> frc_ADXL362_AllAxes;
}
extern "C" {
    #[link_name = "\u{1}_ZThn4_N3frc7ADXL36212InitSendableERN2nt17NTSendableBuilderE"]
    pub fn frc_ADXL362_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut nt_NTSendableBuilder,
    );
}
#[doc = " A rotation in a 2D coordinate frame represented by a point on the unit circle\n (cosine and sine).\n\n The angle is continuous, that is if a Rotation2d is constructed with 361\n degrees, it will return 361 degrees. This allows algorithms that wouldn't\n want to see a discontinuity in the rotations as it sweeps past from 360 to 0\n on the second time around."]
#[repr(C)]
pub struct frc_Rotation2d {
    pub m_value: units_angle_radian_t,
    pub m_cos: f64,
    pub m_sin: f64,
}
#[test]
fn bindgen_test_layout_frc_Rotation2d() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Rotation2d> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Rotation2d>(),
        24usize,
        concat!("Size of: ", stringify!(frc_Rotation2d))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Rotation2d>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_Rotation2d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Rotation2d),
            "::",
            stringify!(m_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Rotation2d),
            "::",
            stringify!(m_cos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Rotation2d),
            "::",
            stringify!(m_sin)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7to_jsonERN3wpi4jsonERKNS_10Rotation2dE"]
    pub fn frc_to_json(json: *mut wpi_json, rotation: *const frc_Rotation2d);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc9from_jsonERKN3wpi4jsonERNS_10Rotation2dE"]
    pub fn frc_from_json(json: *const wpi_json, rotation: *mut frc_Rotation2d);
}
#[repr(C)]
pub struct frc_Gyro__bindgen_vtable {
    pub frc_Gyro_Calibrate: unsafe extern "C" fn(this: *mut frc_Gyro),
    pub frc_Gyro_Reset: unsafe extern "C" fn(this: *mut frc_Gyro),
    pub frc_Gyro_GetAngle: unsafe extern "C" fn(this: *const frc_Gyro) -> f64,
    pub frc_Gyro_GetRate: unsafe extern "C" fn(this: *const frc_Gyro) -> f64,
}
#[doc = " Interface for yaw rate gyros."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Gyro {
    pub vtable_: *const frc_Gyro__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_frc_Gyro() {
    assert_eq!(
        ::std::mem::size_of::<frc_Gyro>(),
        4usize,
        concat!("Size of: ", stringify!(frc_Gyro))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Gyro>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_Gyro))
    );
}
#[doc = " Use a rate gyro to return the robots heading relative to a starting position.\n\n The %Gyro class tracks the robots heading based on the starting position. As\n the robot rotates the new heading is computed by integrating the rate of\n rotation returned by the sensor. When the class is instantiated, it does a\n short calibration routine where it samples the gyro while at rest to\n determine the default offset. This is subtracted from each sample to\n determine the heading.\n\n This class is for the digital ADXRS450 gyro sensor that connects via SPI.\n Only one instance of an ADXRS %Gyro is supported."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_ADXRS450_Gyro {
    pub _base: frc_Gyro,
    pub _base_1: wpi_Sendable,
    pub m_spi: frc_SPI,
    pub m_port: frc_SPI_Port,
    pub m_connected: bool,
    pub m_simDevice: hal_SimDevice,
    pub m_simConnected: hal_SimBoolean,
    pub m_simAngle: hal_SimDouble,
    pub m_simRate: hal_SimDouble,
}
#[test]
fn bindgen_test_layout_frc_ADXRS450_Gyro() {
    assert_eq!(
        ::std::mem::size_of::<frc_ADXRS450_Gyro>(),
        48usize,
        concat!("Size of: ", stringify!(frc_ADXRS450_Gyro))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ADXRS450_Gyro>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_ADXRS450_Gyro))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc13ADXRS450_Gyro11IsConnectedEv"]
    pub fn frc_ADXRS450_Gyro_IsConnected(this: *const frc_ADXRS450_Gyro) -> bool;
}
extern "C" {
    #[doc = " Get the SPI port number.\n\n @return The SPI port number."]
    #[link_name = "\u{1}_ZNK3frc13ADXRS450_Gyro7GetPortEv"]
    pub fn frc_ADXRS450_Gyro_GetPort(this: *const frc_ADXRS450_Gyro) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " %Gyro constructor on onboard CS0."]
    #[link_name = "\u{1}_ZN3frc13ADXRS450_GyroC1Ev"]
    pub fn frc_ADXRS450_Gyro_ADXRS450_Gyro(this: *mut frc_ADXRS450_Gyro);
}
extern "C" {
    #[doc = " %Gyro constructor on the specified SPI port.\n\n @param port The SPI port the gyro is attached to."]
    #[link_name = "\u{1}_ZN3frc13ADXRS450_GyroC1ENS_3SPI4PortE"]
    pub fn frc_ADXRS450_Gyro_ADXRS450_Gyro1(this: *mut frc_ADXRS450_Gyro, port: frc_SPI_Port);
}
impl frc_ADXRS450_Gyro {
    #[inline]
    pub unsafe fn IsConnected(&self) -> bool {
        frc_ADXRS450_Gyro_IsConnected(self)
    }
    #[inline]
    pub unsafe fn GetPort(&self) -> ::std::os::raw::c_int {
        frc_ADXRS450_Gyro_GetPort(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_ADXRS450_Gyro_ADXRS450_Gyro(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(port: frc_SPI_Port) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_ADXRS450_Gyro_ADXRS450_Gyro1(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Return the actual angle in degrees that the robot is currently facing.\n\n The angle is based on integration of the returned rate from the gyro.\n The angle is continuous, that is it will continue from 360->361 degrees.\n This allows algorithms that wouldn't want to see a discontinuity in the\n gyro output as it sweeps from 360 to 0 on the second time around.\n\n @return the current heading of the robot in degrees."]
    #[link_name = "\u{1}_ZNK3frc13ADXRS450_Gyro8GetAngleEv"]
    pub fn frc_ADXRS450_Gyro_GetAngle(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " Return the rate of rotation of the gyro\n\n The rate is based on the most recent reading of the gyro.\n\n @return the current rate in degrees per second"]
    #[link_name = "\u{1}_ZNK3frc13ADXRS450_Gyro7GetRateEv"]
    pub fn frc_ADXRS450_Gyro_GetRate(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " Reset the gyro.\n\n Resets the gyro to a heading of zero. This can be used if there is\n significant drift in the gyro and it needs to be recalibrated after it has\n been running."]
    #[link_name = "\u{1}_ZN3frc13ADXRS450_Gyro5ResetEv"]
    pub fn frc_ADXRS450_Gyro_Reset(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Initialize the gyro.\n\n Calibrate the gyro by running for a number of samples and computing the\n center value. Then use the center value as the Accumulator center value for\n subsequent measurements.\n\n It's important to make sure that the robot is not moving while the\n centering calculations are in progress, this is typically done when the\n robot is first turned on while it's sitting at rest before the competition\n starts."]
    #[link_name = "\u{1}_ZN3frc13ADXRS450_Gyro9CalibrateEv"]
    pub fn frc_ADXRS450_Gyro_Calibrate(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZThn4_N3frc13ADXRS450_Gyro12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_ADXRS450_Gyro_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Analog input class.\n\n Connected to each analog channel is an averaging and oversampling engine.\n This engine accumulates the specified ( by SetAverageBits() and\n SetOversampleBits() ) number of samples before returning a new value. This is\n not a sliding window average. The only difference between the oversampled\n samples and the averaged samples is that the oversampled samples are simply\n accumulated effectively increasing the resolution, while the averaged samples\n are divided by the number of samples to retain the resolution, but get more\n stable values."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_AnalogInput {
    pub _base: wpi_Sendable,
    pub m_channel: ::std::os::raw::c_int,
    pub m_port: u32,
    pub m_accumulatorOffset: i64,
}
pub const frc_AnalogInput_kAccumulatorModuleNumber: ::std::os::raw::c_int = 1;
pub const frc_AnalogInput_kAccumulatorNumChannels: ::std::os::raw::c_int = 2;
extern "C" {
    #[link_name = "\u{1}_ZN3frc11AnalogInput20kAccumulatorChannelsE"]
    pub static frc_AnalogInput_kAccumulatorChannels: [::std::os::raw::c_int; 2usize];
}
#[test]
fn bindgen_test_layout_frc_AnalogInput() {
    const UNINIT: ::std::mem::MaybeUninit<frc_AnalogInput> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_AnalogInput>(),
        24usize,
        concat!("Size of: ", stringify!(frc_AnalogInput))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_AnalogInput>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_AnalogInput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_channel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogInput),
            "::",
            stringify!(m_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogInput),
            "::",
            stringify!(m_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_accumulatorOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogInput),
            "::",
            stringify!(m_accumulatorOffset)
        )
    );
}
extern "C" {
    #[doc = " Get a sample straight from this channel.\n\n The sample is a 12-bit value representing the 0V to 5V range of the A/D\n converter in the module.  The units are in A/D converter codes.  Use\n GetVoltage() to get the analog value in calibrated units.\n\n @return A sample straight from this channel."]
    #[link_name = "\u{1}_ZNK3frc11AnalogInput8GetValueEv"]
    pub fn frc_AnalogInput_GetValue(this: *const frc_AnalogInput) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a sample from the output of the oversample and average engine for this\n channel.\n\n The sample is 12-bit + the bits configured in SetOversampleBits().\n The value configured in SetAverageBits() will cause this value to be\n averaged 2**bits number of samples.\n\n This is not a sliding window. The sample will not change until\n 2**(OversampleBits + AverageBits) samples have been acquired from the\n module on this channel.\n\n Use GetAverageVoltage() to get the analog value in calibrated units.\n\n @return A sample from the oversample and average engine for this channel."]
    #[link_name = "\u{1}_ZNK3frc11AnalogInput15GetAverageValueEv"]
    pub fn frc_AnalogInput_GetAverageValue(this: *const frc_AnalogInput) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get a scaled sample straight from this channel.\n\n The value is scaled to units of Volts using the calibrated scaling data\n from GetLSBWeight() and GetOffset().\n\n @return A scaled sample straight from this channel."]
    #[link_name = "\u{1}_ZNK3frc11AnalogInput10GetVoltageEv"]
    pub fn frc_AnalogInput_GetVoltage(this: *const frc_AnalogInput) -> f64;
}
extern "C" {
    #[doc = " Get a scaled sample from the output of the oversample and average engine\n for this channel.\n\n The value is scaled to units of Volts using the calibrated scaling data\n from GetLSBWeight() and GetOffset().\n\n Using oversampling will cause this value to be higher resolution, but it\n will update more slowly.\n\n Using averaging will cause this value to be more stable, but it will update\n more slowly.\n\n @return A scaled sample from the output of the oversample and average\n engine for this channel."]
    #[link_name = "\u{1}_ZNK3frc11AnalogInput17GetAverageVoltageEv"]
    pub fn frc_AnalogInput_GetAverageVoltage(this: *const frc_AnalogInput) -> f64;
}
extern "C" {
    #[doc = " Get the channel number.\n\n @return The channel number."]
    #[link_name = "\u{1}_ZNK3frc11AnalogInput10GetChannelEv"]
    pub fn frc_AnalogInput_GetChannel(this: *const frc_AnalogInput) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the number of averaging bits.\n\n This sets the number of averaging bits. The actual number of averaged\n samples is 2^bits.\n\n Use averaging to improve the stability of your measurement at the expense\n of sampling rate. The averaging is done automatically in the FPGA.\n\n @param bits Number of bits of averaging."]
    #[link_name = "\u{1}_ZN3frc11AnalogInput14SetAverageBitsEi"]
    pub fn frc_AnalogInput_SetAverageBits(this: *mut frc_AnalogInput, bits: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the number of averaging bits previously configured.\n\n This gets the number of averaging bits from the FPGA. The actual number of\n averaged samples is 2^bits. The averaging is done automatically in the\n FPGA.\n\n @return Number of bits of averaging previously configured."]
    #[link_name = "\u{1}_ZNK3frc11AnalogInput14GetAverageBitsEv"]
    pub fn frc_AnalogInput_GetAverageBits(this: *const frc_AnalogInput) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the number of oversample bits.\n\n This sets the number of oversample bits. The actual number of oversampled\n values is 2^bits. Use oversampling to improve the resolution of your\n measurements at the expense of sampling rate. The oversampling is done\n automatically in the FPGA.\n\n @param bits Number of bits of oversampling."]
    #[link_name = "\u{1}_ZN3frc11AnalogInput17SetOversampleBitsEi"]
    pub fn frc_AnalogInput_SetOversampleBits(
        this: *mut frc_AnalogInput,
        bits: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get the number of oversample bits previously configured.\n\n This gets the number of oversample bits from the FPGA. The actual number of\n oversampled values is 2^bits. The oversampling is done automatically in the\n FPGA.\n\n @return Number of bits of oversampling previously configured."]
    #[link_name = "\u{1}_ZNK3frc11AnalogInput17GetOversampleBitsEv"]
    pub fn frc_AnalogInput_GetOversampleBits(this: *const frc_AnalogInput)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the factory scaling least significant bit weight constant.\n\n Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n\n @return Least significant bit weight."]
    #[link_name = "\u{1}_ZNK3frc11AnalogInput12GetLSBWeightEv"]
    pub fn frc_AnalogInput_GetLSBWeight(this: *const frc_AnalogInput) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the factory scaling offset constant.\n\n Volts = ((LSB_Weight * 1e-9) * raw) - (Offset * 1e-9)\n\n @return Offset constant."]
    #[link_name = "\u{1}_ZNK3frc11AnalogInput9GetOffsetEv"]
    pub fn frc_AnalogInput_GetOffset(this: *const frc_AnalogInput) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Is the channel attached to an accumulator.\n\n @return The analog input is attached to an accumulator."]
    #[link_name = "\u{1}_ZNK3frc11AnalogInput20IsAccumulatorChannelEv"]
    pub fn frc_AnalogInput_IsAccumulatorChannel(this: *const frc_AnalogInput) -> bool;
}
extern "C" {
    #[doc = " Initialize the accumulator."]
    #[link_name = "\u{1}_ZN3frc11AnalogInput15InitAccumulatorEv"]
    pub fn frc_AnalogInput_InitAccumulator(this: *mut frc_AnalogInput);
}
extern "C" {
    #[doc = " Set an initial value for the accumulator.\n\n This will be added to all values returned to the user.\n\n @param value The value that the accumulator should start from when reset."]
    #[link_name = "\u{1}_ZN3frc11AnalogInput26SetAccumulatorInitialValueEx"]
    pub fn frc_AnalogInput_SetAccumulatorInitialValue(this: *mut frc_AnalogInput, value: i64);
}
extern "C" {
    #[doc = " Resets the accumulator to the initial value."]
    #[link_name = "\u{1}_ZN3frc11AnalogInput16ResetAccumulatorEv"]
    pub fn frc_AnalogInput_ResetAccumulator(this: *mut frc_AnalogInput);
}
extern "C" {
    #[doc = " Set the center value of the accumulator.\n\n The center value is subtracted from each A/D value before it is added to\n the accumulator. This is used for the center value of devices like gyros\n and accelerometers to take the device offset into account when integrating.\n\n This center value is based on the output of the oversampled and averaged\n source from the accumulator channel. Because of this, any non-zero\n oversample bits will affect the size of the value for this field."]
    #[link_name = "\u{1}_ZN3frc11AnalogInput20SetAccumulatorCenterEi"]
    pub fn frc_AnalogInput_SetAccumulatorCenter(
        this: *mut frc_AnalogInput,
        center: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Set the accumulator's deadband."]
    #[link_name = "\u{1}_ZN3frc11AnalogInput22SetAccumulatorDeadbandEi"]
    pub fn frc_AnalogInput_SetAccumulatorDeadband(
        this: *mut frc_AnalogInput,
        deadband: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Read the accumulated value.\n\n Read the value that has been accumulating.\n The accumulator is attached after the oversample and average engine.\n\n @return The 64-bit value accumulated since the last Reset()."]
    #[link_name = "\u{1}_ZNK3frc11AnalogInput19GetAccumulatorValueEv"]
    pub fn frc_AnalogInput_GetAccumulatorValue(this: *const frc_AnalogInput) -> i64;
}
extern "C" {
    #[doc = " Read the number of accumulated values.\n\n Read the count of the accumulated values since the accumulator was last\n Reset().\n\n @return The number of times samples from the channel were accumulated."]
    #[link_name = "\u{1}_ZNK3frc11AnalogInput19GetAccumulatorCountEv"]
    pub fn frc_AnalogInput_GetAccumulatorCount(this: *const frc_AnalogInput) -> i64;
}
extern "C" {
    #[doc = " Read the accumulated value and the number of accumulated values atomically.\n\n This function reads the value and count from the FPGA atomically.\n This can be used for averaging.\n\n @param value Reference to the 64-bit accumulated output.\n @param count Reference to the number of accumulation cycles."]
    #[link_name = "\u{1}_ZNK3frc11AnalogInput20GetAccumulatorOutputERxS1_"]
    pub fn frc_AnalogInput_GetAccumulatorOutput(
        this: *const frc_AnalogInput,
        value: *mut i64,
        count: *mut i64,
    );
}
extern "C" {
    #[doc = " Set the sample rate per channel for all analog channels.\n\n The maximum rate is 500kS/s divided by the number of channels in use.\n This is 62500 samples/s per channel.\n\n @param samplesPerSecond The number of samples per second."]
    #[link_name = "\u{1}_ZN3frc11AnalogInput13SetSampleRateEd"]
    pub fn frc_AnalogInput_SetSampleRate(samplesPerSecond: f64);
}
extern "C" {
    #[doc = " Get the current sample rate for all channels\n\n @return Sample rate."]
    #[link_name = "\u{1}_ZN3frc11AnalogInput13GetSampleRateEv"]
    pub fn frc_AnalogInput_GetSampleRate() -> f64;
}
extern "C" {
    #[doc = " Indicates this input is used by a simulated device.\n\n @param device simulated device handle"]
    #[link_name = "\u{1}_ZN3frc11AnalogInput12SetSimDeviceEi"]
    pub fn frc_AnalogInput_SetSimDevice(this: *mut frc_AnalogInput, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Construct an analog input.\n\n @param channel The channel number on the roboRIO to represent. 0-3 are\n                on-board 4-7 are on the MXP port."]
    #[link_name = "\u{1}_ZN3frc11AnalogInputC1Ei"]
    pub fn frc_AnalogInput_AnalogInput(this: *mut frc_AnalogInput, channel: ::std::os::raw::c_int);
}
impl frc_AnalogInput {
    #[inline]
    pub unsafe fn GetValue(&self) -> ::std::os::raw::c_int {
        frc_AnalogInput_GetValue(self)
    }
    #[inline]
    pub unsafe fn GetAverageValue(&self) -> ::std::os::raw::c_int {
        frc_AnalogInput_GetAverageValue(self)
    }
    #[inline]
    pub unsafe fn GetVoltage(&self) -> f64 {
        frc_AnalogInput_GetVoltage(self)
    }
    #[inline]
    pub unsafe fn GetAverageVoltage(&self) -> f64 {
        frc_AnalogInput_GetAverageVoltage(self)
    }
    #[inline]
    pub unsafe fn GetChannel(&self) -> ::std::os::raw::c_int {
        frc_AnalogInput_GetChannel(self)
    }
    #[inline]
    pub unsafe fn SetAverageBits(&mut self, bits: ::std::os::raw::c_int) {
        frc_AnalogInput_SetAverageBits(self, bits)
    }
    #[inline]
    pub unsafe fn GetAverageBits(&self) -> ::std::os::raw::c_int {
        frc_AnalogInput_GetAverageBits(self)
    }
    #[inline]
    pub unsafe fn SetOversampleBits(&mut self, bits: ::std::os::raw::c_int) {
        frc_AnalogInput_SetOversampleBits(self, bits)
    }
    #[inline]
    pub unsafe fn GetOversampleBits(&self) -> ::std::os::raw::c_int {
        frc_AnalogInput_GetOversampleBits(self)
    }
    #[inline]
    pub unsafe fn GetLSBWeight(&self) -> ::std::os::raw::c_int {
        frc_AnalogInput_GetLSBWeight(self)
    }
    #[inline]
    pub unsafe fn GetOffset(&self) -> ::std::os::raw::c_int {
        frc_AnalogInput_GetOffset(self)
    }
    #[inline]
    pub unsafe fn IsAccumulatorChannel(&self) -> bool {
        frc_AnalogInput_IsAccumulatorChannel(self)
    }
    #[inline]
    pub unsafe fn InitAccumulator(&mut self) {
        frc_AnalogInput_InitAccumulator(self)
    }
    #[inline]
    pub unsafe fn SetAccumulatorInitialValue(&mut self, value: i64) {
        frc_AnalogInput_SetAccumulatorInitialValue(self, value)
    }
    #[inline]
    pub unsafe fn ResetAccumulator(&mut self) {
        frc_AnalogInput_ResetAccumulator(self)
    }
    #[inline]
    pub unsafe fn SetAccumulatorCenter(&mut self, center: ::std::os::raw::c_int) {
        frc_AnalogInput_SetAccumulatorCenter(self, center)
    }
    #[inline]
    pub unsafe fn SetAccumulatorDeadband(&mut self, deadband: ::std::os::raw::c_int) {
        frc_AnalogInput_SetAccumulatorDeadband(self, deadband)
    }
    #[inline]
    pub unsafe fn GetAccumulatorValue(&self) -> i64 {
        frc_AnalogInput_GetAccumulatorValue(self)
    }
    #[inline]
    pub unsafe fn GetAccumulatorCount(&self) -> i64 {
        frc_AnalogInput_GetAccumulatorCount(self)
    }
    #[inline]
    pub unsafe fn GetAccumulatorOutput(&self, value: *mut i64, count: *mut i64) {
        frc_AnalogInput_GetAccumulatorOutput(self, value, count)
    }
    #[inline]
    pub unsafe fn SetSampleRate(samplesPerSecond: f64) {
        frc_AnalogInput_SetSampleRate(samplesPerSecond)
    }
    #[inline]
    pub unsafe fn GetSampleRate() -> f64 {
        frc_AnalogInput_GetSampleRate()
    }
    #[inline]
    pub unsafe fn SetSimDevice(&mut self, device: HAL_SimDeviceHandle) {
        frc_AnalogInput_SetSimDevice(self, device)
    }
    #[inline]
    pub unsafe fn new(channel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogInput_AnalogInput(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11AnalogInputD1Ev"]
    pub fn frc_AnalogInput_AnalogInput_destructor(this: *mut frc_AnalogInput);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11AnalogInput12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_AnalogInput_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Handle operation of an analog accelerometer.\n\n The accelerometer reads acceleration directly through the sensor. Many\n sensors have multiple axis and can be treated as multiple devices. Each is\n calibrated by finding the center value over a period of time."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_AnalogAccelerometer {
    pub _base: wpi_Sendable,
    pub m_analogInput: [u32; 2usize],
    pub m_voltsPerG: f64,
    pub m_zeroGVoltage: f64,
}
#[test]
fn bindgen_test_layout_frc_AnalogAccelerometer() {
    const UNINIT: ::std::mem::MaybeUninit<frc_AnalogAccelerometer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_AnalogAccelerometer>(),
        32usize,
        concat!("Size of: ", stringify!(frc_AnalogAccelerometer))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_AnalogAccelerometer>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_AnalogAccelerometer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_analogInput) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogAccelerometer),
            "::",
            stringify!(m_analogInput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_voltsPerG) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogAccelerometer),
            "::",
            stringify!(m_voltsPerG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_zeroGVoltage) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogAccelerometer),
            "::",
            stringify!(m_zeroGVoltage)
        )
    );
}
extern "C" {
    #[doc = " Return the acceleration in Gs.\n\n The acceleration is returned units of Gs.\n\n @return The current acceleration of the sensor in Gs."]
    #[link_name = "\u{1}_ZNK3frc19AnalogAccelerometer15GetAccelerationEv"]
    pub fn frc_AnalogAccelerometer_GetAcceleration(this: *const frc_AnalogAccelerometer) -> f64;
}
extern "C" {
    #[doc = " Set the accelerometer sensitivity.\n\n This sets the sensitivity of the accelerometer used for calculating the\n acceleration. The sensitivity varies by accelerometer model. There are\n constants defined for various models.\n\n @param sensitivity The sensitivity of accelerometer in Volts per G."]
    #[link_name = "\u{1}_ZN3frc19AnalogAccelerometer14SetSensitivityEd"]
    pub fn frc_AnalogAccelerometer_SetSensitivity(
        this: *mut frc_AnalogAccelerometer,
        sensitivity: f64,
    );
}
extern "C" {
    #[doc = " Set the voltage that corresponds to 0 G.\n\n The zero G voltage varies by accelerometer model. There are constants\n defined for various models.\n\n @param zero The zero G voltage."]
    #[link_name = "\u{1}_ZN3frc19AnalogAccelerometer7SetZeroEd"]
    pub fn frc_AnalogAccelerometer_SetZero(this: *mut frc_AnalogAccelerometer, zero: f64);
}
extern "C" {
    #[doc = " Create a new instance of an accelerometer.\n\n The constructor allocates desired analog input.\n\n @param channel The channel number for the analog input the accelerometer is\n                connected to"]
    #[link_name = "\u{1}_ZN3frc19AnalogAccelerometerC1Ei"]
    pub fn frc_AnalogAccelerometer_AnalogAccelerometer(
        this: *mut frc_AnalogAccelerometer,
        channel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Create a new instance of Accelerometer from an existing AnalogInput.\n\n Make a new instance of accelerometer given an AnalogInput. This is\n particularly useful if the port is going to be read as an analog channel as\n well as through the Accelerometer class.\n\n @param channel The existing AnalogInput object for the analog input the\n                accelerometer is connected to"]
    #[link_name = "\u{1}_ZN3frc19AnalogAccelerometerC1EPNS_11AnalogInputE"]
    pub fn frc_AnalogAccelerometer_AnalogAccelerometer1(
        this: *mut frc_AnalogAccelerometer,
        channel: *mut frc_AnalogInput,
    );
}
extern "C" {
    #[doc = " Create a new instance of Accelerometer from an existing AnalogInput.\n\n Make a new instance of accelerometer given an AnalogInput. This is\n particularly useful if the port is going to be read as an analog channel as\n well as through the Accelerometer class.\n\n @param channel The existing AnalogInput object for the analog input the\n                accelerometer is connected to"]
    #[link_name = "\u{1}_ZN3frc19AnalogAccelerometerC1ESt10shared_ptrINS_11AnalogInputEE"]
    pub fn frc_AnalogAccelerometer_AnalogAccelerometer2(
        this: *mut frc_AnalogAccelerometer,
        channel: [u32; 2usize],
    );
}
impl frc_AnalogAccelerometer {
    #[inline]
    pub unsafe fn GetAcceleration(&self) -> f64 {
        frc_AnalogAccelerometer_GetAcceleration(self)
    }
    #[inline]
    pub unsafe fn SetSensitivity(&mut self, sensitivity: f64) {
        frc_AnalogAccelerometer_SetSensitivity(self, sensitivity)
    }
    #[inline]
    pub unsafe fn SetZero(&mut self, zero: f64) {
        frc_AnalogAccelerometer_SetZero(self, zero)
    }
    #[inline]
    pub unsafe fn new(channel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogAccelerometer_AnalogAccelerometer(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(channel: *mut frc_AnalogInput) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogAccelerometer_AnalogAccelerometer1(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(channel: [u32; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogAccelerometer_AnalogAccelerometer2(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19AnalogAccelerometer12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_AnalogAccelerometer_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
pub const frc_AnalogTriggerType_kInWindow: frc_AnalogTriggerType = 0;
pub const frc_AnalogTriggerType_kState: frc_AnalogTriggerType = 1;
pub const frc_AnalogTriggerType_kRisingPulse: frc_AnalogTriggerType = 2;
pub const frc_AnalogTriggerType_kFallingPulse: frc_AnalogTriggerType = 3;
pub type frc_AnalogTriggerType = ::std::os::raw::c_int;
#[repr(C)]
pub struct frc_DigitalSource__bindgen_vtable {
    pub frc_DigitalSource_GetPortHandleForRouting:
        unsafe extern "C" fn(this: *const frc_DigitalSource) -> HAL_Handle,
    pub frc_DigitalSource_GetAnalogTriggerTypeForRouting:
        unsafe extern "C" fn(this: *const frc_DigitalSource) -> frc_AnalogTriggerType,
    pub frc_DigitalSource_IsAnalogTrigger:
        unsafe extern "C" fn(this: *const frc_DigitalSource) -> bool,
    pub frc_DigitalSource_GetChannel:
        unsafe extern "C" fn(this: *const frc_DigitalSource) -> ::std::os::raw::c_int,
}
#[doc = " DigitalSource Interface.\n\n The DigitalSource represents all the possible inputs for a counter or a\n quadrature encoder. The source may be either a digital input or an analog\n input. If the caller just provides a channel, then a digital input will be\n constructed and freed when finished for the source. The source can either be\n a digital input or analog trigger but not both."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_DigitalSource {
    pub vtable_: *const frc_DigitalSource__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_frc_DigitalSource() {
    assert_eq!(
        ::std::mem::size_of::<frc_DigitalSource>(),
        4usize,
        concat!("Size of: ", stringify!(frc_DigitalSource))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_DigitalSource>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_DigitalSource))
    );
}
#[doc = " Class to represent a specific output from an analog trigger.\n\n This class is used to get the current output value and also as a\n DigitalSource to provide routing of an output to digital subsystems on the\n FPGA such as Counter, Encoder, and Interrupt.\n\n The TriggerState output indicates the primary output value of the trigger.\n If the analog signal is less than the lower limit, the output is false. If\n the analog value is greater than the upper limit, then the output is true.\n If the analog value is in between, then the trigger output state maintains\n its most recent value.\n\n The InWindow output indicates whether or not the analog signal is inside the\n range defined by the limits.\n\n The RisingPulse and FallingPulse outputs detect an instantaneous transition\n from above the upper limit to below the lower limit, and vise versa. These\n pulses represent a rollover condition of a sensor and can be routed to an up\n / down counter or to interrupts. Because the outputs generate a pulse, they\n cannot be read directly. To help ensure that a rollover condition is not\n missed, there is an average rejection filter available that operates on the\n upper 8 bits of a 12 bit number and selects the nearest outlyer of 3 samples.\n This will reject a sample that is (due to averaging or sampling) errantly\n between the two limits. This filter will fail if more than one sample in a\n row is errantly in between the two limits. You may see this problem if\n attempting to use this feature with a mechanical rollover sensor, such as a\n 360 degree no-stop potentiometer without signal conditioning, because the\n rollover transition is not sharp / clean enough. Using the averaging engine\n may help with this, but rotational speeds of the sensor will then be limited."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_AnalogTriggerOutput {
    pub _base: frc_DigitalSource,
    pub _base_1: wpi_Sendable,
    pub m_trigger: *const frc_AnalogTrigger,
    pub m_outputType: frc_AnalogTriggerType,
}
#[test]
fn bindgen_test_layout_frc_AnalogTriggerOutput() {
    assert_eq!(
        ::std::mem::size_of::<frc_AnalogTriggerOutput>(),
        16usize,
        concat!("Size of: ", stringify!(frc_AnalogTriggerOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_AnalogTriggerOutput>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_AnalogTriggerOutput))
    );
}
extern "C" {
    #[doc = " Get the state of the analog trigger output.\n\n @return The state of the analog trigger output."]
    #[link_name = "\u{1}_ZNK3frc19AnalogTriggerOutput3GetEv"]
    pub fn frc_AnalogTriggerOutput_Get(this: *const frc_AnalogTriggerOutput) -> bool;
}
extern "C" {
    #[doc = " Create an object that represents one of the four outputs from an analog\n trigger.\n\n Because this class derives from DigitalSource, it can be passed into\n routing functions for Counter, Encoder, etc.\n\n @param trigger    A pointer to the trigger for which this is an output.\n @param outputType An enum that specifies the output on the trigger to\n                   represent."]
    #[link_name = "\u{1}_ZN3frc19AnalogTriggerOutputC1ERKNS_13AnalogTriggerENS_17AnalogTriggerTypeE"]
    pub fn frc_AnalogTriggerOutput_AnalogTriggerOutput(
        this: *mut frc_AnalogTriggerOutput,
        trigger: *const frc_AnalogTrigger,
        outputType: frc_AnalogTriggerType,
    );
}
impl frc_AnalogTriggerOutput {
    #[inline]
    pub unsafe fn Get(&self) -> bool {
        frc_AnalogTriggerOutput_Get(self)
    }
    #[inline]
    pub unsafe fn new(
        trigger: *const frc_AnalogTrigger,
        outputType: frc_AnalogTriggerType,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogTriggerOutput_AnalogTriggerOutput(
            __bindgen_tmp.as_mut_ptr(),
            trigger,
            outputType,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " @return The HAL Handle to the specified source."]
    #[link_name = "\u{1}_ZNK3frc19AnalogTriggerOutput23GetPortHandleForRoutingEv"]
    pub fn frc_AnalogTriggerOutput_GetPortHandleForRouting(
        this: *mut ::std::os::raw::c_void,
    ) -> HAL_Handle;
}
extern "C" {
    #[doc = " @return The type of analog trigger output to be used."]
    #[link_name = "\u{1}_ZNK3frc19AnalogTriggerOutput30GetAnalogTriggerTypeForRoutingEv"]
    pub fn frc_AnalogTriggerOutput_GetAnalogTriggerTypeForRouting(
        this: *mut ::std::os::raw::c_void,
    ) -> frc_AnalogTriggerType;
}
extern "C" {
    #[doc = " Is source an AnalogTrigger"]
    #[link_name = "\u{1}_ZNK3frc19AnalogTriggerOutput15IsAnalogTriggerEv"]
    pub fn frc_AnalogTriggerOutput_IsAnalogTrigger(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " @return The channel of the source."]
    #[link_name = "\u{1}_ZNK3frc19AnalogTriggerOutput10GetChannelEv"]
    pub fn frc_AnalogTriggerOutput_GetChannel(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZThn4_N3frc19AnalogTriggerOutput12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_AnalogTriggerOutput_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct frc_AnalogTrigger {
    pub _base: wpi_Sendable,
    pub m_trigger: u32,
    pub m_analogInput: *mut frc_AnalogInput,
    pub m_dutyCycle: *mut frc_DutyCycle,
    pub m_ownsAnalog: bool,
}
#[test]
fn bindgen_test_layout_frc_AnalogTrigger() {
    const UNINIT: ::std::mem::MaybeUninit<frc_AnalogTrigger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_AnalogTrigger>(),
        20usize,
        concat!("Size of: ", stringify!(frc_AnalogTrigger))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_AnalogTrigger>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_AnalogTrigger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_trigger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogTrigger),
            "::",
            stringify!(m_trigger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_analogInput) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogTrigger),
            "::",
            stringify!(m_analogInput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dutyCycle) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogTrigger),
            "::",
            stringify!(m_dutyCycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ownsAnalog) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogTrigger),
            "::",
            stringify!(m_ownsAnalog)
        )
    );
}
extern "C" {
    #[doc = " Set the upper and lower limits of the analog trigger.\n\n The limits are given as floating point voltage values.\n\n @param lower The lower limit of the trigger in Volts.\n @param upper The upper limit of the trigger in Volts."]
    #[link_name = "\u{1}_ZN3frc13AnalogTrigger16SetLimitsVoltageEdd"]
    pub fn frc_AnalogTrigger_SetLimitsVoltage(this: *mut frc_AnalogTrigger, lower: f64, upper: f64);
}
extern "C" {
    #[doc = " Set the upper and lower duty cycle limits of the analog trigger.\n\n The limits are given as floating point values between 0 and 1.\n\n @param lower The lower limit of the trigger in percentage.\n @param upper The upper limit of the trigger in percentage."]
    #[link_name = "\u{1}_ZN3frc13AnalogTrigger18SetLimitsDutyCycleEdd"]
    pub fn frc_AnalogTrigger_SetLimitsDutyCycle(
        this: *mut frc_AnalogTrigger,
        lower: f64,
        upper: f64,
    );
}
extern "C" {
    #[doc = " Set the upper and lower limits of the analog trigger.\n\n The limits are given in ADC codes.  If oversampling is used, the units must\n be scaled appropriately.\n\n @param lower The lower limit of the trigger in ADC codes (12-bit values).\n @param upper The upper limit of the trigger in ADC codes (12-bit values)."]
    #[link_name = "\u{1}_ZN3frc13AnalogTrigger12SetLimitsRawEii"]
    pub fn frc_AnalogTrigger_SetLimitsRaw(
        this: *mut frc_AnalogTrigger,
        lower: ::std::os::raw::c_int,
        upper: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Configure the analog trigger to use the averaged vs. raw values.\n\n If the value is true, then the averaged value is selected for the analog\n trigger, otherwise the immediate value is used.\n\n @param useAveragedValue If true, use the Averaged value, otherwise use the\n                         instantaneous reading"]
    #[link_name = "\u{1}_ZN3frc13AnalogTrigger11SetAveragedEb"]
    pub fn frc_AnalogTrigger_SetAveraged(this: *mut frc_AnalogTrigger, useAveragedValue: bool);
}
extern "C" {
    #[doc = " Configure the analog trigger to use a filtered value.\n\n The analog trigger will operate with a 3 point average rejection filter.\n This is designed to help with 360 degree pot applications for the period\n where the pot crosses through zero.\n\n @param useFilteredValue If true, use the 3 point rejection filter,\n                         otherwise use the unfiltered value"]
    #[link_name = "\u{1}_ZN3frc13AnalogTrigger11SetFilteredEb"]
    pub fn frc_AnalogTrigger_SetFiltered(this: *mut frc_AnalogTrigger, useFilteredValue: bool);
}
extern "C" {
    #[doc = " Return the index of the analog trigger.\n\n This is the FPGA index of this analog trigger instance.\n\n @return The index of the analog trigger."]
    #[link_name = "\u{1}_ZNK3frc13AnalogTrigger8GetIndexEv"]
    pub fn frc_AnalogTrigger_GetIndex(this: *const frc_AnalogTrigger) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the InWindow output of the analog trigger.\n\n True if the analog input is between the upper and lower limits.\n\n @return True if the analog input is between the upper and lower limits."]
    #[link_name = "\u{1}_ZN3frc13AnalogTrigger11GetInWindowEv"]
    pub fn frc_AnalogTrigger_GetInWindow(this: *mut frc_AnalogTrigger) -> bool;
}
extern "C" {
    #[doc = " Return the TriggerState output of the analog trigger.\n\n True if above upper limit.\n False if below lower limit.\n If in Hysteresis, maintain previous state.\n\n @return True if above upper limit. False if below lower limit. If in\n         Hysteresis, maintain previous state."]
    #[link_name = "\u{1}_ZN3frc13AnalogTrigger15GetTriggerStateEv"]
    pub fn frc_AnalogTrigger_GetTriggerState(this: *mut frc_AnalogTrigger) -> bool;
}
extern "C" {
    #[doc = " Creates an AnalogTriggerOutput object.\n\n Gets an output object that can be used for routing. Caller is responsible\n for deleting the AnalogTriggerOutput object.\n\n @param type An enum of the type of output object to create.\n @return A pointer to a new AnalogTriggerOutput object."]
    #[link_name = "\u{1}_ZNK3frc13AnalogTrigger12CreateOutputENS_17AnalogTriggerTypeE"]
    pub fn frc_AnalogTrigger_CreateOutput(
        this: *const frc_AnalogTrigger,
        type_: frc_AnalogTriggerType,
    ) -> u8;
}
extern "C" {
    #[doc = " Constructor for an analog trigger given a channel number.\n\n @param channel The channel number on the roboRIO to represent. 0-3 are\n                on-board 4-7 are on the MXP port."]
    #[link_name = "\u{1}_ZN3frc13AnalogTriggerC1Ei"]
    pub fn frc_AnalogTrigger_AnalogTrigger(
        this: *mut frc_AnalogTrigger,
        channel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Construct an analog trigger given an analog input.\n\n This should be used in the case of sharing an analog channel between the\n trigger and an analog input object.\n\n @param input The pointer to the existing AnalogInput object"]
    #[link_name = "\u{1}_ZN3frc13AnalogTriggerC1EPNS_11AnalogInputE"]
    pub fn frc_AnalogTrigger_AnalogTrigger1(
        this: *mut frc_AnalogTrigger,
        input: *mut frc_AnalogInput,
    );
}
extern "C" {
    #[doc = " Construct an analog trigger given a duty cycle input.\n\n @param dutyCycle The pointer to the existing DutyCycle object"]
    #[link_name = "\u{1}_ZN3frc13AnalogTriggerC1EPNS_9DutyCycleE"]
    pub fn frc_AnalogTrigger_AnalogTrigger2(
        this: *mut frc_AnalogTrigger,
        dutyCycle: *mut frc_DutyCycle,
    );
}
impl frc_AnalogTrigger {
    #[inline]
    pub unsafe fn SetLimitsVoltage(&mut self, lower: f64, upper: f64) {
        frc_AnalogTrigger_SetLimitsVoltage(self, lower, upper)
    }
    #[inline]
    pub unsafe fn SetLimitsDutyCycle(&mut self, lower: f64, upper: f64) {
        frc_AnalogTrigger_SetLimitsDutyCycle(self, lower, upper)
    }
    #[inline]
    pub unsafe fn SetLimitsRaw(
        &mut self,
        lower: ::std::os::raw::c_int,
        upper: ::std::os::raw::c_int,
    ) {
        frc_AnalogTrigger_SetLimitsRaw(self, lower, upper)
    }
    #[inline]
    pub unsafe fn SetAveraged(&mut self, useAveragedValue: bool) {
        frc_AnalogTrigger_SetAveraged(self, useAveragedValue)
    }
    #[inline]
    pub unsafe fn SetFiltered(&mut self, useFilteredValue: bool) {
        frc_AnalogTrigger_SetFiltered(self, useFilteredValue)
    }
    #[inline]
    pub unsafe fn GetIndex(&self) -> ::std::os::raw::c_int {
        frc_AnalogTrigger_GetIndex(self)
    }
    #[inline]
    pub unsafe fn GetInWindow(&mut self) -> bool {
        frc_AnalogTrigger_GetInWindow(self)
    }
    #[inline]
    pub unsafe fn GetTriggerState(&mut self) -> bool {
        frc_AnalogTrigger_GetTriggerState(self)
    }
    #[inline]
    pub unsafe fn CreateOutput(&self, type_: frc_AnalogTriggerType) -> u8 {
        frc_AnalogTrigger_CreateOutput(self, type_)
    }
    #[inline]
    pub unsafe fn new(channel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogTrigger_AnalogTrigger(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(input: *mut frc_AnalogInput) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogTrigger_AnalogTrigger1(__bindgen_tmp.as_mut_ptr(), input);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(dutyCycle: *mut frc_DutyCycle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogTrigger_AnalogTrigger2(__bindgen_tmp.as_mut_ptr(), dutyCycle);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc13AnalogTriggerD1Ev"]
    pub fn frc_AnalogTrigger_AnalogTrigger_destructor(this: *mut frc_AnalogTrigger);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc13AnalogTrigger12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_AnalogTrigger_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[repr(C)]
pub struct frc_CounterBase__bindgen_vtable {
    pub frc_CounterBase_Get:
        unsafe extern "C" fn(this: *const frc_CounterBase) -> ::std::os::raw::c_int,
    pub frc_CounterBase_Reset: unsafe extern "C" fn(this: *mut frc_CounterBase),
    pub frc_CounterBase_GetPeriod:
        unsafe extern "C" fn(this: *const frc_CounterBase) -> units_time_second_t,
    pub frc_CounterBase_SetMaxPeriod:
        unsafe extern "C" fn(this: *mut frc_CounterBase, maxPeriod: units_time_second_t),
    pub frc_CounterBase_GetStopped: unsafe extern "C" fn(this: *const frc_CounterBase) -> bool,
    pub frc_CounterBase_GetDirection: unsafe extern "C" fn(this: *const frc_CounterBase) -> bool,
}
#[doc = " Interface for counting the number of ticks on a digital input channel.\n\n Encoders, Gear tooth sensors, and counters should all subclass this so it can\n be used to build more advanced classes for control and driving.\n\n All counters will immediately start counting - Reset() them if you need them\n to be zeroed before use."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_CounterBase {
    pub vtable_: *const frc_CounterBase__bindgen_vtable,
}
pub const frc_CounterBase_EncodingType_k1X: frc_CounterBase_EncodingType = 0;
pub const frc_CounterBase_EncodingType_k2X: frc_CounterBase_EncodingType = 1;
pub const frc_CounterBase_EncodingType_k4X: frc_CounterBase_EncodingType = 2;
pub type frc_CounterBase_EncodingType = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_frc_CounterBase() {
    assert_eq!(
        ::std::mem::size_of::<frc_CounterBase>(),
        4usize,
        concat!("Size of: ", stringify!(frc_CounterBase))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_CounterBase>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_CounterBase))
    );
}
#[doc = " Class for counting the number of ticks on a digital input channel.\n\n This is a general purpose class for counting repetitive events. It can return\n the number of counts, the period of the most recent cycle, and detect when\n the signal being counted has stopped by supplying a maximum cycle time.\n\n All counters will immediately start counting - Reset() them if you need them\n to be zeroed before use."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Counter {
    pub _base: frc_CounterBase,
    pub _base_1: wpi_Sendable,
    pub m_upSource: [u32; 2usize],
    pub m_downSource: [u32; 2usize],
    pub m_counter: u32,
    pub m_index: ::std::os::raw::c_int,
}
pub const frc_Counter_Mode_kTwoPulse: frc_Counter_Mode = 0;
pub const frc_Counter_Mode_kSemiperiod: frc_Counter_Mode = 1;
pub const frc_Counter_Mode_kPulseLength: frc_Counter_Mode = 2;
pub const frc_Counter_Mode_kExternalDirection: frc_Counter_Mode = 3;
pub type frc_Counter_Mode = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_frc_Counter() {
    assert_eq!(
        ::std::mem::size_of::<frc_Counter>(),
        32usize,
        concat!("Size of: ", stringify!(frc_Counter))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Counter>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_Counter))
    );
}
extern "C" {
    #[doc = " Set the upsource for the counter as a digital input channel.\n\n @param channel The DIO channel to use as the up source. 0-9 are on-board,\n                10-25 are on the MXP"]
    #[link_name = "\u{1}_ZN3frc7Counter11SetUpSourceEi"]
    pub fn frc_Counter_SetUpSource(this: *mut frc_Counter, channel: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the up counting source to be an analog trigger.\n\n @param analogTrigger The analog trigger object that is used for the Up\n                      Source\n @param triggerType   The analog trigger output that will trigger the\n                      counter."]
    #[link_name = "\u{1}_ZN3frc7Counter11SetUpSourceEPNS_13AnalogTriggerENS_17AnalogTriggerTypeE"]
    pub fn frc_Counter_SetUpSource1(
        this: *mut frc_Counter,
        analogTrigger: *mut frc_AnalogTrigger,
        triggerType: frc_AnalogTriggerType,
    );
}
extern "C" {
    #[doc = " Set the up counting source to be an analog trigger.\n\n @param analogTrigger The analog trigger object that is used for the Up\n                      Source\n @param triggerType   The analog trigger output that will trigger the\n                      counter."]
    #[link_name = "\u{1}_ZN3frc7Counter11SetUpSourceESt10shared_ptrINS_13AnalogTriggerEENS_17AnalogTriggerTypeE"]
    pub fn frc_Counter_SetUpSource2(
        this: *mut frc_Counter,
        analogTrigger: u8,
        triggerType: frc_AnalogTriggerType,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7Counter11SetUpSourceEPNS_13DigitalSourceE"]
    pub fn frc_Counter_SetUpSource3(this: *mut frc_Counter, source: *mut frc_DigitalSource);
}
extern "C" {
    #[doc = " Set the source object that causes the counter to count up.\n\n Set the up counting DigitalSource.\n\n @param source Pointer to the DigitalSource object to set as the up source"]
    #[link_name = "\u{1}_ZN3frc7Counter11SetUpSourceESt10shared_ptrINS_13DigitalSourceEE"]
    pub fn frc_Counter_SetUpSource4(this: *mut frc_Counter, source: [u32; 2usize]);
}
extern "C" {
    #[doc = " Set the source object that causes the counter to count up.\n\n Set the up counting DigitalSource.\n\n @param source Reference to the DigitalSource object to set as the up source"]
    #[link_name = "\u{1}_ZN3frc7Counter11SetUpSourceERNS_13DigitalSourceE"]
    pub fn frc_Counter_SetUpSource5(this: *mut frc_Counter, source: *mut frc_DigitalSource);
}
extern "C" {
    #[doc = " Set the edge sensitivity on an up counting source.\n\n Set the up source to either detect rising edges or falling edges or both.\n\n @param risingEdge  True to trigger on rising edges\n @param fallingEdge True to trigger on falling edges"]
    #[link_name = "\u{1}_ZN3frc7Counter15SetUpSourceEdgeEbb"]
    pub fn frc_Counter_SetUpSourceEdge(this: *mut frc_Counter, risingEdge: bool, fallingEdge: bool);
}
extern "C" {
    #[doc = " Disable the up counting source to the counter."]
    #[link_name = "\u{1}_ZN3frc7Counter13ClearUpSourceEv"]
    pub fn frc_Counter_ClearUpSource(this: *mut frc_Counter);
}
extern "C" {
    #[doc = " Set the down counting source to be a digital input channel.\n\n @param channel The DIO channel to use as the up source. 0-9 are on-board,\n                10-25 are on the MXP"]
    #[link_name = "\u{1}_ZN3frc7Counter13SetDownSourceEi"]
    pub fn frc_Counter_SetDownSource(this: *mut frc_Counter, channel: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the down counting source to be an analog trigger.\n\n @param analogTrigger The analog trigger object that is used for the Down\n                      Source\n @param triggerType   The analog trigger output that will trigger the\n                      counter."]
    #[link_name = "\u{1}_ZN3frc7Counter13SetDownSourceEPNS_13AnalogTriggerENS_17AnalogTriggerTypeE"]
    pub fn frc_Counter_SetDownSource1(
        this: *mut frc_Counter,
        analogTrigger: *mut frc_AnalogTrigger,
        triggerType: frc_AnalogTriggerType,
    );
}
extern "C" {
    #[doc = " Set the down counting source to be an analog trigger.\n\n @param analogTrigger The analog trigger object that is used for the Down\n                      Source\n @param triggerType   The analog trigger output that will trigger the\n                      counter."]
    #[link_name = "\u{1}_ZN3frc7Counter13SetDownSourceESt10shared_ptrINS_13AnalogTriggerEENS_17AnalogTriggerTypeE"]
    pub fn frc_Counter_SetDownSource2(
        this: *mut frc_Counter,
        analogTrigger: u8,
        triggerType: frc_AnalogTriggerType,
    );
}
extern "C" {
    #[doc = " Set the source object that causes the counter to count down.\n\n Set the down counting DigitalSource.\n\n @param source Pointer to the DigitalSource object to set as the down source"]
    #[link_name = "\u{1}_ZN3frc7Counter13SetDownSourceEPNS_13DigitalSourceE"]
    pub fn frc_Counter_SetDownSource3(this: *mut frc_Counter, source: *mut frc_DigitalSource);
}
extern "C" {
    #[doc = " Set the source object that causes the counter to count down.\n\n Set the down counting DigitalSource.\n\n @param source Reference to the DigitalSource object to set as the down\n               source"]
    #[link_name = "\u{1}_ZN3frc7Counter13SetDownSourceERNS_13DigitalSourceE"]
    pub fn frc_Counter_SetDownSource4(this: *mut frc_Counter, source: *mut frc_DigitalSource);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7Counter13SetDownSourceESt10shared_ptrINS_13DigitalSourceEE"]
    pub fn frc_Counter_SetDownSource5(this: *mut frc_Counter, source: [u32; 2usize]);
}
extern "C" {
    #[doc = " Set the edge sensitivity on a down counting source.\n\n Set the down source to either detect rising edges or falling edges.\n\n @param risingEdge  True to trigger on rising edges\n @param fallingEdge True to trigger on falling edges"]
    #[link_name = "\u{1}_ZN3frc7Counter17SetDownSourceEdgeEbb"]
    pub fn frc_Counter_SetDownSourceEdge(
        this: *mut frc_Counter,
        risingEdge: bool,
        fallingEdge: bool,
    );
}
extern "C" {
    #[doc = " Disable the down counting source to the counter."]
    #[link_name = "\u{1}_ZN3frc7Counter15ClearDownSourceEv"]
    pub fn frc_Counter_ClearDownSource(this: *mut frc_Counter);
}
extern "C" {
    #[doc = " Set standard up / down counting mode on this counter.\n\n Up and down counts are sourced independently from two inputs."]
    #[link_name = "\u{1}_ZN3frc7Counter20SetUpDownCounterModeEv"]
    pub fn frc_Counter_SetUpDownCounterMode(this: *mut frc_Counter);
}
extern "C" {
    #[doc = " Set external direction mode on this counter.\n\n Counts are sourced on the Up counter input.\n The Down counter input represents the direction to count."]
    #[link_name = "\u{1}_ZN3frc7Counter24SetExternalDirectionModeEv"]
    pub fn frc_Counter_SetExternalDirectionMode(this: *mut frc_Counter);
}
extern "C" {
    #[doc = " Set Semi-period mode on this counter.\n\n Counts up on both rising and falling edges."]
    #[link_name = "\u{1}_ZN3frc7Counter17SetSemiPeriodModeEb"]
    pub fn frc_Counter_SetSemiPeriodMode(this: *mut frc_Counter, highSemiPeriod: bool);
}
extern "C" {
    #[doc = " Configure the counter to count in up or down based on the length of the\n input pulse.\n\n This mode is most useful for direction sensitive gear tooth sensors.\n\n @param threshold The pulse length beyond which the counter counts the\n                  opposite direction. Units are seconds."]
    #[link_name = "\u{1}_ZN3frc7Counter18SetPulseLengthModeEd"]
    pub fn frc_Counter_SetPulseLengthMode(this: *mut frc_Counter, threshold: f64);
}
extern "C" {
    #[doc = " Set the Counter to return reversed sensing on the direction.\n\n This allows counters to change the direction they are counting in the case\n of 1X and 2X quadrature encoding only. Any other counter mode isn't\n supported.\n\n @param reverseDirection true if the value counted should be negated."]
    #[link_name = "\u{1}_ZN3frc7Counter19SetReverseDirectionEb"]
    pub fn frc_Counter_SetReverseDirection(this: *mut frc_Counter, reverseDirection: bool);
}
extern "C" {
    #[doc = " Set the Samples to Average which specifies the number of samples of the\n timer to average when calculating the period. Perform averaging to account\n for mechanical imperfections or as oversampling to increase resolution.\n\n @param samplesToAverage The number of samples to average from 1 to 127."]
    #[link_name = "\u{1}_ZN3frc7Counter19SetSamplesToAverageEi"]
    pub fn frc_Counter_SetSamplesToAverage(
        this: *mut frc_Counter,
        samplesToAverage: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get the Samples to Average which specifies the number of samples of the\n timer to average when calculating the period.\n\n Perform averaging to account for mechanical imperfections or as\n oversampling to increase resolution.\n\n @return The number of samples being averaged (from 1 to 127)"]
    #[link_name = "\u{1}_ZNK3frc7Counter19GetSamplesToAverageEv"]
    pub fn frc_Counter_GetSamplesToAverage(this: *const frc_Counter) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc7Counter12GetFPGAIndexEv"]
    pub fn frc_Counter_GetFPGAIndex(this: *const frc_Counter) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Select whether you want to continue updating the event timer output when\n there are no samples captured.\n\n The output of the event timer has a buffer of periods that are averaged and\n posted to a register on the FPGA.  When the timer detects that the event\n source has stopped (based on the MaxPeriod) the buffer of samples to be\n averaged is emptied.  If you enable the update when empty, you will be\n notified of the stopped source and the event time will report 0 samples.\n If you disable update when empty, the most recent average will remain on\n the output until a new sample is acquired.  You will never see 0 samples\n output (except when there have been no events since an FPGA reset) and you\n will likely not see the stopped bit become true (since it is updated at the\n end of an average and there are no samples to average).\n\n @param enabled True to enable update when empty"]
    #[link_name = "\u{1}_ZN3frc7Counter18SetUpdateWhenEmptyEb"]
    pub fn frc_Counter_SetUpdateWhenEmpty(this: *mut frc_Counter, enabled: bool);
}
extern "C" {
    #[doc = " Create an instance of a counter where no sources are selected.\n\n They all must be selected by calling functions to specify the upsource and\n the downsource independently.\n\n This creates a ChipObject counter and initializes status variables\n appropriately.\n\n The counter will start counting immediately.\n\n @param mode The counter mode"]
    #[link_name = "\u{1}_ZN3frc7CounterC1ENS0_4ModeE"]
    pub fn frc_Counter_Counter(this: *mut frc_Counter, mode: frc_Counter_Mode);
}
extern "C" {
    #[doc = " Create an instance of a Counter object.\n\n Create an up-Counter instance given a channel.\n\n The counter will start counting immediately.\n\n @param channel The DIO channel to use as the up source. 0-9 are on-board,\n                10-25 are on the MXP"]
    #[link_name = "\u{1}_ZN3frc7CounterC1Ei"]
    pub fn frc_Counter_Counter1(this: *mut frc_Counter, channel: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Create an instance of a counter from a Digital Source (such as a Digital\n Input).\n\n This is used if an existing digital input is to be shared by multiple other\n objects such as encoders or if the Digital Source is not a Digital Input\n channel (such as an Analog %Trigger).\n\n The counter will start counting immediately.\n @param source A pointer to the existing DigitalSource object. It will be\n               set as the Up Source."]
    #[link_name = "\u{1}_ZN3frc7CounterC1EPNS_13DigitalSourceE"]
    pub fn frc_Counter_Counter2(this: *mut frc_Counter, source: *mut frc_DigitalSource);
}
extern "C" {
    #[doc = " Create an instance of a counter from a Digital Source (such as a Digital\n Input).\n\n This is used if an existing digital input is to be shared by multiple other\n objects such as encoders or if the Digital Source is not a Digital Input\n channel (such as an Analog %Trigger).\n\n The counter will start counting immediately.\n\n @param source A pointer to the existing DigitalSource object. It will be\n               set as the Up Source."]
    #[link_name = "\u{1}_ZN3frc7CounterC1ESt10shared_ptrINS_13DigitalSourceEE"]
    pub fn frc_Counter_Counter3(this: *mut frc_Counter, source: [u32; 2usize]);
}
extern "C" {
    #[doc = " Create an instance of a Counter object.\n\n Create an instance of a simple up-Counter given an analog trigger.\n Use the trigger state output from the analog trigger.\n\n The counter will start counting immediately.\n\n @param trigger The reference to the existing AnalogTrigger object."]
    #[link_name = "\u{1}_ZN3frc7CounterC1ERKNS_13AnalogTriggerE"]
    pub fn frc_Counter_Counter4(this: *mut frc_Counter, trigger: *const frc_AnalogTrigger);
}
extern "C" {
    #[doc = " Create an instance of a Counter object.\n\n Creates a full up-down counter given two Digital Sources.\n\n @param encodingType The quadrature decoding mode (1x or 2x)\n @param upSource     The pointer to the DigitalSource to set as the up\n                     source\n @param downSource   The pointer to the DigitalSource to set as the down\n                     source\n @param inverted     True to invert the output (reverse the direction)"]
    #[link_name = "\u{1}_ZN3frc7CounterC1ENS_11CounterBase12EncodingTypeEPNS_13DigitalSourceES4_b"]
    pub fn frc_Counter_Counter5(
        this: *mut frc_Counter,
        encodingType: frc_CounterBase_EncodingType,
        upSource: *mut frc_DigitalSource,
        downSource: *mut frc_DigitalSource,
        inverted: bool,
    );
}
extern "C" {
    #[doc = " Create an instance of a Counter object.\n\n Creates a full up-down counter given two Digital Sources.\n\n @param encodingType The quadrature decoding mode (1x or 2x)\n @param upSource     The pointer to the DigitalSource to set as the up\n                     source\n @param downSource   The pointer to the DigitalSource to set as the down\n                     source\n @param inverted     True to invert the output (reverse the direction)"]
    #[link_name = "\u{1}_ZN3frc7CounterC1ENS_11CounterBase12EncodingTypeESt10shared_ptrINS_13DigitalSourceEES5_b"]
    pub fn frc_Counter_Counter6(
        this: *mut frc_Counter,
        encodingType: frc_CounterBase_EncodingType,
        upSource: [u32; 2usize],
        downSource: [u32; 2usize],
        inverted: bool,
    );
}
impl frc_Counter {
    #[inline]
    pub unsafe fn SetUpSource(&mut self, channel: ::std::os::raw::c_int) {
        frc_Counter_SetUpSource(self, channel)
    }
    #[inline]
    pub unsafe fn SetUpSource1(
        &mut self,
        analogTrigger: *mut frc_AnalogTrigger,
        triggerType: frc_AnalogTriggerType,
    ) {
        frc_Counter_SetUpSource1(self, analogTrigger, triggerType)
    }
    #[inline]
    pub unsafe fn SetUpSource2(&mut self, analogTrigger: u8, triggerType: frc_AnalogTriggerType) {
        frc_Counter_SetUpSource2(self, analogTrigger, triggerType)
    }
    #[inline]
    pub unsafe fn SetUpSource3(&mut self, source: *mut frc_DigitalSource) {
        frc_Counter_SetUpSource3(self, source)
    }
    #[inline]
    pub unsafe fn SetUpSource4(&mut self, source: [u32; 2usize]) {
        frc_Counter_SetUpSource4(self, source)
    }
    #[inline]
    pub unsafe fn SetUpSource5(&mut self, source: *mut frc_DigitalSource) {
        frc_Counter_SetUpSource5(self, source)
    }
    #[inline]
    pub unsafe fn SetUpSourceEdge(&mut self, risingEdge: bool, fallingEdge: bool) {
        frc_Counter_SetUpSourceEdge(self, risingEdge, fallingEdge)
    }
    #[inline]
    pub unsafe fn ClearUpSource(&mut self) {
        frc_Counter_ClearUpSource(self)
    }
    #[inline]
    pub unsafe fn SetDownSource(&mut self, channel: ::std::os::raw::c_int) {
        frc_Counter_SetDownSource(self, channel)
    }
    #[inline]
    pub unsafe fn SetDownSource1(
        &mut self,
        analogTrigger: *mut frc_AnalogTrigger,
        triggerType: frc_AnalogTriggerType,
    ) {
        frc_Counter_SetDownSource1(self, analogTrigger, triggerType)
    }
    #[inline]
    pub unsafe fn SetDownSource2(&mut self, analogTrigger: u8, triggerType: frc_AnalogTriggerType) {
        frc_Counter_SetDownSource2(self, analogTrigger, triggerType)
    }
    #[inline]
    pub unsafe fn SetDownSource3(&mut self, source: *mut frc_DigitalSource) {
        frc_Counter_SetDownSource3(self, source)
    }
    #[inline]
    pub unsafe fn SetDownSource4(&mut self, source: *mut frc_DigitalSource) {
        frc_Counter_SetDownSource4(self, source)
    }
    #[inline]
    pub unsafe fn SetDownSource5(&mut self, source: [u32; 2usize]) {
        frc_Counter_SetDownSource5(self, source)
    }
    #[inline]
    pub unsafe fn SetDownSourceEdge(&mut self, risingEdge: bool, fallingEdge: bool) {
        frc_Counter_SetDownSourceEdge(self, risingEdge, fallingEdge)
    }
    #[inline]
    pub unsafe fn ClearDownSource(&mut self) {
        frc_Counter_ClearDownSource(self)
    }
    #[inline]
    pub unsafe fn SetUpDownCounterMode(&mut self) {
        frc_Counter_SetUpDownCounterMode(self)
    }
    #[inline]
    pub unsafe fn SetExternalDirectionMode(&mut self) {
        frc_Counter_SetExternalDirectionMode(self)
    }
    #[inline]
    pub unsafe fn SetSemiPeriodMode(&mut self, highSemiPeriod: bool) {
        frc_Counter_SetSemiPeriodMode(self, highSemiPeriod)
    }
    #[inline]
    pub unsafe fn SetPulseLengthMode(&mut self, threshold: f64) {
        frc_Counter_SetPulseLengthMode(self, threshold)
    }
    #[inline]
    pub unsafe fn SetReverseDirection(&mut self, reverseDirection: bool) {
        frc_Counter_SetReverseDirection(self, reverseDirection)
    }
    #[inline]
    pub unsafe fn SetSamplesToAverage(&mut self, samplesToAverage: ::std::os::raw::c_int) {
        frc_Counter_SetSamplesToAverage(self, samplesToAverage)
    }
    #[inline]
    pub unsafe fn GetSamplesToAverage(&self) -> ::std::os::raw::c_int {
        frc_Counter_GetSamplesToAverage(self)
    }
    #[inline]
    pub unsafe fn GetFPGAIndex(&self) -> ::std::os::raw::c_int {
        frc_Counter_GetFPGAIndex(self)
    }
    #[inline]
    pub unsafe fn SetUpdateWhenEmpty(&mut self, enabled: bool) {
        frc_Counter_SetUpdateWhenEmpty(self, enabled)
    }
    #[inline]
    pub unsafe fn new(mode: frc_Counter_Mode) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Counter_Counter(__bindgen_tmp.as_mut_ptr(), mode);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(channel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Counter_Counter1(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(source: *mut frc_DigitalSource) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Counter_Counter2(__bindgen_tmp.as_mut_ptr(), source);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(source: [u32; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Counter_Counter3(__bindgen_tmp.as_mut_ptr(), source);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(trigger: *const frc_AnalogTrigger) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Counter_Counter4(__bindgen_tmp.as_mut_ptr(), trigger);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(
        encodingType: frc_CounterBase_EncodingType,
        upSource: *mut frc_DigitalSource,
        downSource: *mut frc_DigitalSource,
        inverted: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Counter_Counter5(
            __bindgen_tmp.as_mut_ptr(),
            encodingType,
            upSource,
            downSource,
            inverted,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(
        encodingType: frc_CounterBase_EncodingType,
        upSource: [u32; 2usize],
        downSource: [u32; 2usize],
        inverted: bool,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Counter_Counter6(
            __bindgen_tmp.as_mut_ptr(),
            encodingType,
            upSource,
            downSource,
            inverted,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7CounterD1Ev"]
    pub fn frc_Counter_Counter_destructor(this: *mut frc_Counter);
}
extern "C" {
    #[doc = " Read the current counter value.\n\n Read the value at this instant. It may still be running, so it reflects the\n current value. Next time it is read, it might have a different value."]
    #[link_name = "\u{1}_ZNK3frc7Counter3GetEv"]
    pub fn frc_Counter_Get(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset the Counter to zero.\n\n Set the counter value to zero. This doesn't effect the running state of the\n counter, just sets the current value to zero."]
    #[link_name = "\u{1}_ZN3frc7Counter5ResetEv"]
    pub fn frc_Counter_Reset(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Get the Period of the most recent count.\n\n Returns the time interval of the most recent count. This can be used for\n velocity calculations to determine shaft speed.\n\n @returns The period between the last two pulses in units of seconds."]
    #[link_name = "\u{1}_ZNK3frc7Counter9GetPeriodEv"]
    pub fn frc_Counter_GetPeriod(this: *mut ::std::os::raw::c_void) -> units_time_second_t;
}
extern "C" {
    #[doc = " Set the maximum period where the device is still considered \"moving\".\n\n Sets the maximum period where the device is considered moving. This value\n is used to determine the \"stopped\" state of the counter using the\n GetStopped method.\n\n @param maxPeriod The maximum period where the counted device is considered\n                  moving in seconds."]
    #[link_name = "\u{1}_ZN3frc7Counter12SetMaxPeriodEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_Counter_SetMaxPeriod(
        this: *mut ::std::os::raw::c_void,
        maxPeriod: units_time_second_t,
    );
}
extern "C" {
    #[doc = " Determine if the clock is stopped.\n\n Determine if the clocked input is stopped based on the MaxPeriod value set\n using the SetMaxPeriod method. If the clock exceeds the MaxPeriod, then the\n device (and counter) are assumed to be stopped and it returns true.\n\n @return Returns true if the most recent counter period exceeds the\n         MaxPeriod value set by SetMaxPeriod."]
    #[link_name = "\u{1}_ZNK3frc7Counter10GetStoppedEv"]
    pub fn frc_Counter_GetStopped(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " The last direction the counter value changed.\n\n @return The last direction the counter value changed."]
    #[link_name = "\u{1}_ZNK3frc7Counter12GetDirectionEv"]
    pub fn frc_Counter_GetDirection(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZThn4_N3frc7Counter12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_Counter_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Class for supporting continuous analog encoders, such as the US Digital MA3."]
#[repr(C)]
pub struct frc_AnalogEncoder {
    pub _base: wpi_Sendable,
    pub m_analogInput: [u32; 2usize],
    pub m_analogTrigger: frc_AnalogTrigger,
    pub m_counter: frc_Counter,
    pub m_positionOffset: f64,
    pub m_distancePerRotation: f64,
    pub m_lastPosition: units_angle_turn_t,
    pub m_simDevice: hal_SimDevice,
    pub m_simPosition: hal_SimDouble,
    pub m_simAbsolutePosition: hal_SimDouble,
}
#[test]
fn bindgen_test_layout_frc_AnalogEncoder() {
    const UNINIT: ::std::mem::MaybeUninit<frc_AnalogEncoder> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_AnalogEncoder>(),
        104usize,
        concat!("Size of: ", stringify!(frc_AnalogEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_AnalogEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_AnalogEncoder))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_analogInput) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogEncoder),
            "::",
            stringify!(m_analogInput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_analogTrigger) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogEncoder),
            "::",
            stringify!(m_analogTrigger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_counter) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogEncoder),
            "::",
            stringify!(m_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_positionOffset) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogEncoder),
            "::",
            stringify!(m_positionOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_distancePerRotation) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogEncoder),
            "::",
            stringify!(m_distancePerRotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_lastPosition) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogEncoder),
            "::",
            stringify!(m_lastPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_simDevice) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogEncoder),
            "::",
            stringify!(m_simDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_simPosition) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogEncoder),
            "::",
            stringify!(m_simPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_simAbsolutePosition) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogEncoder),
            "::",
            stringify!(m_simAbsolutePosition)
        )
    );
}
extern "C" {
    #[doc = " Reset the Encoder distance to zero."]
    #[link_name = "\u{1}_ZN3frc13AnalogEncoder5ResetEv"]
    pub fn frc_AnalogEncoder_Reset(this: *mut frc_AnalogEncoder);
}
extern "C" {
    #[doc = " Get the encoder value since the last reset.\n\n This is reported in rotations since the last reset.\n\n @return the encoder value in rotations"]
    #[link_name = "\u{1}_ZNK3frc13AnalogEncoder3GetEv"]
    pub fn frc_AnalogEncoder_Get(this: *const frc_AnalogEncoder) -> units_angle_turn_t;
}
extern "C" {
    #[doc = " Get the absolute position of the analog encoder.\n\n <p>GetAbsolutePosition() - GetPositionOffset() will give an encoder\n absolute position relative to the last reset. This could potentially be\n negative, which needs to be accounted for.\n\n <p>This will not account for rollovers, and will always be just the raw\n absolute position.\n\n @return the absolute position"]
    #[link_name = "\u{1}_ZNK3frc13AnalogEncoder19GetAbsolutePositionEv"]
    pub fn frc_AnalogEncoder_GetAbsolutePosition(this: *const frc_AnalogEncoder) -> f64;
}
extern "C" {
    #[doc = " Get the offset of position relative to the last reset.\n\n GetAbsolutePosition() - GetPositionOffset() will give an encoder absolute\n position relative to the last reset. This could potentially be negative,\n which needs to be accounted for.\n\n @return the position offset"]
    #[link_name = "\u{1}_ZNK3frc13AnalogEncoder17GetPositionOffsetEv"]
    pub fn frc_AnalogEncoder_GetPositionOffset(this: *const frc_AnalogEncoder) -> f64;
}
extern "C" {
    #[doc = " Set the position offset.\n\n <p>This must be in the range of 0-1.\n\n @param offset the offset"]
    #[link_name = "\u{1}_ZN3frc13AnalogEncoder17SetPositionOffsetEd"]
    pub fn frc_AnalogEncoder_SetPositionOffset(this: *mut frc_AnalogEncoder, offset: f64);
}
extern "C" {
    #[doc = " Set the distance per rotation of the encoder. This sets the multiplier used\n to determine the distance driven based on the rotation value from the\n encoder. Set this value based on the how far the mechanism travels in 1\n rotation of the encoder, and factor in gearing reductions following the\n encoder shaft. This distance can be in any units you like, linear or\n angular.\n\n @param distancePerRotation the distance per rotation of the encoder"]
    #[link_name = "\u{1}_ZN3frc13AnalogEncoder22SetDistancePerRotationEd"]
    pub fn frc_AnalogEncoder_SetDistancePerRotation(
        this: *mut frc_AnalogEncoder,
        distancePerRotation: f64,
    );
}
extern "C" {
    #[doc = " Get the distance per rotation for this encoder.\n\n @return The scale factor that will be used to convert rotation to useful\n units."]
    #[link_name = "\u{1}_ZNK3frc13AnalogEncoder22GetDistancePerRotationEv"]
    pub fn frc_AnalogEncoder_GetDistancePerRotation(this: *const frc_AnalogEncoder) -> f64;
}
extern "C" {
    #[doc = " Get the distance the sensor has driven since the last reset as scaled by\n the value from SetDistancePerRotation.\n\n @return The distance driven since the last reset"]
    #[link_name = "\u{1}_ZNK3frc13AnalogEncoder11GetDistanceEv"]
    pub fn frc_AnalogEncoder_GetDistance(this: *const frc_AnalogEncoder) -> f64;
}
extern "C" {
    #[doc = " Get the channel number.\n\n @return The channel number."]
    #[link_name = "\u{1}_ZNK3frc13AnalogEncoder10GetChannelEv"]
    pub fn frc_AnalogEncoder_GetChannel(this: *const frc_AnalogEncoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Construct a new AnalogEncoder attached to a specific AnalogIn channel.\n\n @param channel the analog input channel to attach to"]
    #[link_name = "\u{1}_ZN3frc13AnalogEncoderC1Ei"]
    pub fn frc_AnalogEncoder_AnalogEncoder(
        this: *mut frc_AnalogEncoder,
        channel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Construct a new AnalogEncoder attached to a specific AnalogInput.\n\n @param analogInput the analog input to attach to"]
    #[link_name = "\u{1}_ZN3frc13AnalogEncoderC1ERNS_11AnalogInputE"]
    pub fn frc_AnalogEncoder_AnalogEncoder1(
        this: *mut frc_AnalogEncoder,
        analogInput: *mut frc_AnalogInput,
    );
}
extern "C" {
    #[doc = " Construct a new AnalogEncoder attached to a specific AnalogInput.\n\n @param analogInput the analog input to attach to"]
    #[link_name = "\u{1}_ZN3frc13AnalogEncoderC1EPNS_11AnalogInputE"]
    pub fn frc_AnalogEncoder_AnalogEncoder2(
        this: *mut frc_AnalogEncoder,
        analogInput: *mut frc_AnalogInput,
    );
}
extern "C" {
    #[doc = " Construct a new AnalogEncoder attached to a specific AnalogInput.\n\n @param analogInput the analog input to attach to"]
    #[link_name = "\u{1}_ZN3frc13AnalogEncoderC1ESt10shared_ptrINS_11AnalogInputEE"]
    pub fn frc_AnalogEncoder_AnalogEncoder3(
        this: *mut frc_AnalogEncoder,
        analogInput: [u32; 2usize],
    );
}
impl frc_AnalogEncoder {
    #[inline]
    pub unsafe fn Reset(&mut self) {
        frc_AnalogEncoder_Reset(self)
    }
    #[inline]
    pub unsafe fn Get(&self) -> units_angle_turn_t {
        frc_AnalogEncoder_Get(self)
    }
    #[inline]
    pub unsafe fn GetAbsolutePosition(&self) -> f64 {
        frc_AnalogEncoder_GetAbsolutePosition(self)
    }
    #[inline]
    pub unsafe fn GetPositionOffset(&self) -> f64 {
        frc_AnalogEncoder_GetPositionOffset(self)
    }
    #[inline]
    pub unsafe fn SetPositionOffset(&mut self, offset: f64) {
        frc_AnalogEncoder_SetPositionOffset(self, offset)
    }
    #[inline]
    pub unsafe fn SetDistancePerRotation(&mut self, distancePerRotation: f64) {
        frc_AnalogEncoder_SetDistancePerRotation(self, distancePerRotation)
    }
    #[inline]
    pub unsafe fn GetDistancePerRotation(&self) -> f64 {
        frc_AnalogEncoder_GetDistancePerRotation(self)
    }
    #[inline]
    pub unsafe fn GetDistance(&self) -> f64 {
        frc_AnalogEncoder_GetDistance(self)
    }
    #[inline]
    pub unsafe fn GetChannel(&self) -> ::std::os::raw::c_int {
        frc_AnalogEncoder_GetChannel(self)
    }
    #[inline]
    pub unsafe fn new(channel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogEncoder_AnalogEncoder(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(analogInput: *mut frc_AnalogInput) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogEncoder_AnalogEncoder1(__bindgen_tmp.as_mut_ptr(), analogInput);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(analogInput: *mut frc_AnalogInput) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogEncoder_AnalogEncoder2(__bindgen_tmp.as_mut_ptr(), analogInput);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(analogInput: [u32; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogEncoder_AnalogEncoder3(__bindgen_tmp.as_mut_ptr(), analogInput);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc13AnalogEncoder12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_AnalogEncoder_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Use a rate gyro to return the robots heading relative to a starting position.\n The Gyro class tracks the robots heading based on the starting position. As\n the robot rotates the new heading is computed by integrating the rate of\n rotation returned by the sensor. When the class is instantiated, it does a\n short calibration routine where it samples the gyro while at rest to\n determine the default offset. This is subtracted from each sample to\n determine the heading. This gyro class must be used with a channel that is\n assigned one of the Analog accumulators from the FPGA. See AnalogInput for\n the current accumulator assignments.\n\n This class is for gyro sensors that connect to an analog input."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_AnalogGyro {
    pub _base: frc_Gyro,
    pub _base_1: wpi_Sendable,
    pub m_analog: [u32; 2usize],
    pub m_gyroHandle: u32,
}
pub const frc_AnalogGyro_kOversampleBits: ::std::os::raw::c_int = 10;
pub const frc_AnalogGyro_kAverageBits: ::std::os::raw::c_int = 0;
pub const frc_AnalogGyro_kSamplesPerSecond: f64 = 50.0;
pub const frc_AnalogGyro_kCalibrationSampleTime: f64 = 5.0;
pub const frc_AnalogGyro_kDefaultVoltsPerDegreePerSecond: f64 = 0.007;
#[test]
fn bindgen_test_layout_frc_AnalogGyro() {
    assert_eq!(
        ::std::mem::size_of::<frc_AnalogGyro>(),
        20usize,
        concat!("Size of: ", stringify!(frc_AnalogGyro))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_AnalogGyro>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_AnalogGyro))
    );
}
extern "C" {
    #[doc = " Set the gyro sensitivity.\n\n This takes the number of volts/degree/second sensitivity of the gyro and\n uses it in subsequent calculations to allow the code to work with multiple\n gyros. This value is typically found in the gyro datasheet.\n\n @param voltsPerDegreePerSecond The sensitivity in Volts/degree/second"]
    #[link_name = "\u{1}_ZN3frc10AnalogGyro14SetSensitivityEd"]
    pub fn frc_AnalogGyro_SetSensitivity(this: *mut frc_AnalogGyro, voltsPerDegreePerSecond: f64);
}
extern "C" {
    #[doc = " Set the size of the neutral zone.\n\n Any voltage from the gyro less than this amount from the center is\n considered stationary.  Setting a deadband will decrease the amount of\n drift when the gyro isn't rotating, but will make it less accurate.\n\n @param volts The size of the deadband in volts"]
    #[link_name = "\u{1}_ZN3frc10AnalogGyro11SetDeadbandEd"]
    pub fn frc_AnalogGyro_SetDeadband(this: *mut frc_AnalogGyro, volts: f64);
}
extern "C" {
    #[doc = " Initialize the gyro.\n\n Calibration is handled by Calibrate()."]
    #[link_name = "\u{1}_ZN3frc10AnalogGyro8InitGyroEv"]
    pub fn frc_AnalogGyro_InitGyro(this: *mut frc_AnalogGyro);
}
extern "C" {
    #[doc = " Gets the analog input for the gyro.\n\n @return AnalogInput"]
    #[link_name = "\u{1}_ZNK3frc10AnalogGyro14GetAnalogInputEv"]
    pub fn frc_AnalogGyro_GetAnalogInput(this: *const frc_AnalogGyro) -> [u32; 2usize];
}
extern "C" {
    #[doc = " %Gyro constructor using the Analog Input channel number.\n\n @param channel The analog channel the gyro is connected to. Gyros can only\n                be used on on-board Analog Inputs 0-1."]
    #[link_name = "\u{1}_ZN3frc10AnalogGyroC1Ei"]
    pub fn frc_AnalogGyro_AnalogGyro(this: *mut frc_AnalogGyro, channel: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Gyro constructor with a precreated AnalogInput object.\n\n Use this constructor when the analog channel needs to be shared.\n This object will not clean up the AnalogInput object when using this\n constructor.\n\n Gyros can only be used on on-board channels 0-1.\n\n @param channel A pointer to the AnalogInput object that the gyro is\n                connected to."]
    #[link_name = "\u{1}_ZN3frc10AnalogGyroC1EPNS_11AnalogInputE"]
    pub fn frc_AnalogGyro_AnalogGyro1(this: *mut frc_AnalogGyro, channel: *mut frc_AnalogInput);
}
extern "C" {
    #[doc = " %Gyro constructor with a precreated AnalogInput object.\n\n Use this constructor when the analog channel needs to be shared.\n This object will not clean up the AnalogInput object when using this\n constructor.\n\n @param channel A pointer to the AnalogInput object that the gyro is\n                connected to."]
    #[link_name = "\u{1}_ZN3frc10AnalogGyroC1ESt10shared_ptrINS_11AnalogInputEE"]
    pub fn frc_AnalogGyro_AnalogGyro2(this: *mut frc_AnalogGyro, channel: [u32; 2usize]);
}
extern "C" {
    #[doc = " %Gyro constructor using the Analog Input channel number with parameters for\n presetting the center and offset values. Bypasses calibration.\n\n @param channel The analog channel the gyro is connected to. Gyros can only\n                be used on on-board Analog Inputs 0-1.\n @param center  Preset uncalibrated value to use as the accumulator center\n                value.\n @param offset  Preset uncalibrated value to use as the gyro offset."]
    #[link_name = "\u{1}_ZN3frc10AnalogGyroC1Eiid"]
    pub fn frc_AnalogGyro_AnalogGyro3(
        this: *mut frc_AnalogGyro,
        channel: ::std::os::raw::c_int,
        center: ::std::os::raw::c_int,
        offset: f64,
    );
}
extern "C" {
    #[doc = " %Gyro constructor with a precreated AnalogInput object and calibrated\n parameters.\n\n Use this constructor when the analog channel needs to be shared.\n This object will not clean up the AnalogInput object when using this\n constructor.\n\n @param channel A pointer to the AnalogInput object that the gyro is\n                connected to.\n @param center  Preset uncalibrated value to use as the accumulator center\n                value.\n @param offset  Preset uncalibrated value to use as the gyro offset."]
    #[link_name = "\u{1}_ZN3frc10AnalogGyroC1ESt10shared_ptrINS_11AnalogInputEEid"]
    pub fn frc_AnalogGyro_AnalogGyro4(
        this: *mut frc_AnalogGyro,
        channel: [u32; 2usize],
        center: ::std::os::raw::c_int,
        offset: f64,
    );
}
impl frc_AnalogGyro {
    #[inline]
    pub unsafe fn SetSensitivity(&mut self, voltsPerDegreePerSecond: f64) {
        frc_AnalogGyro_SetSensitivity(self, voltsPerDegreePerSecond)
    }
    #[inline]
    pub unsafe fn SetDeadband(&mut self, volts: f64) {
        frc_AnalogGyro_SetDeadband(self, volts)
    }
    #[inline]
    pub unsafe fn InitGyro(&mut self) {
        frc_AnalogGyro_InitGyro(self)
    }
    #[inline]
    pub unsafe fn GetAnalogInput(&self) -> [u32; 2usize] {
        frc_AnalogGyro_GetAnalogInput(self)
    }
    #[inline]
    pub unsafe fn new(channel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogGyro_AnalogGyro(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(channel: *mut frc_AnalogInput) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogGyro_AnalogGyro1(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(channel: [u32; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogGyro_AnalogGyro2(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        channel: ::std::os::raw::c_int,
        center: ::std::os::raw::c_int,
        offset: f64,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogGyro_AnalogGyro3(__bindgen_tmp.as_mut_ptr(), channel, center, offset);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(channel: [u32; 2usize], center: ::std::os::raw::c_int, offset: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogGyro_AnalogGyro4(__bindgen_tmp.as_mut_ptr(), channel, center, offset);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10AnalogGyroD1Ev"]
    pub fn frc_AnalogGyro_AnalogGyro_destructor(this: *mut frc_AnalogGyro);
}
extern "C" {
    #[doc = " Return the actual angle in degrees that the robot is currently facing.\n\n The angle is based on the current accumulator value corrected by the\n oversampling rate, the gyro type and the A/D calibration values. The angle\n is continuous, that is it will continue from 360->361 degrees. This allows\n algorithms that wouldn't want to see a discontinuity in the gyro output as\n it sweeps from 360 to 0 on the second time around.\n\n @return The current heading of the robot in degrees. This heading is based\n         on integration of the returned rate from the gyro."]
    #[link_name = "\u{1}_ZNK3frc10AnalogGyro8GetAngleEv"]
    pub fn frc_AnalogGyro_GetAngle(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " Return the rate of rotation of the gyro\n\n The rate is based on the most recent reading of the gyro analog value\n\n @return the current rate in degrees per second"]
    #[link_name = "\u{1}_ZNK3frc10AnalogGyro7GetRateEv"]
    pub fn frc_AnalogGyro_GetRate(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " Return the gyro center value. If run after calibration,\n the center value can be used as a preset later.\n\n @return the current center value"]
    #[link_name = "\u{1}_ZNK3frc10AnalogGyro9GetCenterEv"]
    pub fn frc_AnalogGyro_GetCenter(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the gyro offset value. If run after calibration,\n the offset value can be used as a preset later.\n\n @return the current offset value"]
    #[link_name = "\u{1}_ZNK3frc10AnalogGyro9GetOffsetEv"]
    pub fn frc_AnalogGyro_GetOffset(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " Reset the gyro.\n\n Resets the gyro to a heading of zero. This can be used if there is\n significant drift in the gyro and it needs to be recalibrated after it has\n been running."]
    #[link_name = "\u{1}_ZN3frc10AnalogGyro5ResetEv"]
    pub fn frc_AnalogGyro_Reset(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10AnalogGyro9CalibrateEv"]
    pub fn frc_AnalogGyro_Calibrate(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZThn4_N3frc10AnalogGyro12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_AnalogGyro_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " MXP analog output class."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_AnalogOutput {
    pub _base: wpi_Sendable,
    pub m_channel: ::std::os::raw::c_int,
    pub m_port: u32,
}
#[test]
fn bindgen_test_layout_frc_AnalogOutput() {
    const UNINIT: ::std::mem::MaybeUninit<frc_AnalogOutput> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_AnalogOutput>(),
        12usize,
        concat!("Size of: ", stringify!(frc_AnalogOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_AnalogOutput>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_AnalogOutput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_channel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogOutput),
            "::",
            stringify!(m_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogOutput),
            "::",
            stringify!(m_port)
        )
    );
}
extern "C" {
    #[doc = " Set the value of the analog output.\n\n @param voltage The output value in Volts, from 0.0 to +5.0"]
    #[link_name = "\u{1}_ZN3frc12AnalogOutput10SetVoltageEd"]
    pub fn frc_AnalogOutput_SetVoltage(this: *mut frc_AnalogOutput, voltage: f64);
}
extern "C" {
    #[doc = " Get the voltage of the analog output\n\n @return The value in Volts, from 0.0 to +5.0"]
    #[link_name = "\u{1}_ZNK3frc12AnalogOutput10GetVoltageEv"]
    pub fn frc_AnalogOutput_GetVoltage(this: *const frc_AnalogOutput) -> f64;
}
extern "C" {
    #[doc = " Get the channel of this AnalogOutput."]
    #[link_name = "\u{1}_ZNK3frc12AnalogOutput10GetChannelEv"]
    pub fn frc_AnalogOutput_GetChannel(this: *const frc_AnalogOutput) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Construct an analog output on the given channel.\n\n All analog outputs are located on the MXP port.\n\n @param channel The channel number on the roboRIO to represent."]
    #[link_name = "\u{1}_ZN3frc12AnalogOutputC1Ei"]
    pub fn frc_AnalogOutput_AnalogOutput(
        this: *mut frc_AnalogOutput,
        channel: ::std::os::raw::c_int,
    );
}
impl frc_AnalogOutput {
    #[inline]
    pub unsafe fn SetVoltage(&mut self, voltage: f64) {
        frc_AnalogOutput_SetVoltage(self, voltage)
    }
    #[inline]
    pub unsafe fn GetVoltage(&self) -> f64 {
        frc_AnalogOutput_GetVoltage(self)
    }
    #[inline]
    pub unsafe fn GetChannel(&self) -> ::std::os::raw::c_int {
        frc_AnalogOutput_GetChannel(self)
    }
    #[inline]
    pub unsafe fn new(channel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogOutput_AnalogOutput(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12AnalogOutputD1Ev"]
    pub fn frc_AnalogOutput_AnalogOutput_destructor(this: *mut frc_AnalogOutput);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12AnalogOutput12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_AnalogOutput_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Class for reading analog potentiometers. Analog potentiometers read in an\n analog voltage that corresponds to a position. The position is in whichever\n units you choose, by way of the scaling and offset constants passed to the\n constructor."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_AnalogPotentiometer {
    pub _base: wpi_Sendable,
    pub m_analog_input: [u32; 2usize],
    pub m_fullRange: f64,
    pub m_offset: f64,
}
#[test]
fn bindgen_test_layout_frc_AnalogPotentiometer() {
    const UNINIT: ::std::mem::MaybeUninit<frc_AnalogPotentiometer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_AnalogPotentiometer>(),
        32usize,
        concat!("Size of: ", stringify!(frc_AnalogPotentiometer))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_AnalogPotentiometer>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_AnalogPotentiometer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_analog_input) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogPotentiometer),
            "::",
            stringify!(m_analog_input)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_fullRange) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogPotentiometer),
            "::",
            stringify!(m_fullRange)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AnalogPotentiometer),
            "::",
            stringify!(m_offset)
        )
    );
}
extern "C" {
    #[doc = " Get the current reading of the potentiometer.\n\n @return The current position of the potentiometer (in the units used for\n         fullRange and offset)."]
    #[link_name = "\u{1}_ZNK3frc19AnalogPotentiometer3GetEv"]
    pub fn frc_AnalogPotentiometer_Get(this: *const frc_AnalogPotentiometer) -> f64;
}
extern "C" {
    #[doc = " Construct an Analog Potentiometer object from a channel number.\n\n Use the fullRange and offset values so that the output produces meaningful\n values. I.E: you have a 270 degree potentiometer and you want the output to\n be degrees with the halfway point as 0 degrees. The fullRange value is\n 270.0 degrees and the offset is -135.0 since the halfway point after\n scaling is 135 degrees.\n\n This will calculate the result from the fullRange times the fraction of the\n supply voltage, plus the offset.\n\n @param channel   The Analog Input channel number on the roboRIO the\n                  potentiometer is plugged into. 0-3 are on-board and 4-7\n                  are on the MXP port.\n @param fullRange The value (in desired units) representing the full\n                  0-5V range of the input.\n @param offset    The value (in desired units) representing the\n                  angular output at 0V."]
    #[link_name = "\u{1}_ZN3frc19AnalogPotentiometerC1Eidd"]
    pub fn frc_AnalogPotentiometer_AnalogPotentiometer(
        this: *mut frc_AnalogPotentiometer,
        channel: ::std::os::raw::c_int,
        fullRange: f64,
        offset: f64,
    );
}
extern "C" {
    #[doc = " Construct an Analog Potentiometer object from an existing Analog Input\n pointer.\n\n Use the fullRange and offset values so that the output produces meaningful\n values. I.E: you have a 270 degree potentiometer and you want the output to\n be degrees with the halfway point as 0 degrees. The fullRange value is\n 270.0 degrees and the offset is -135.0 since the halfway point after\n scaling is 135 degrees.\n\n This will calculate the result from the fullRange times the fraction of the\n supply voltage, plus the offset.\n\n @param input     The existing Analog Input pointer\n @param fullRange The value (in desired units) representing the full\n                  0-5V range of the input.\n @param offset    The value (in desired units) representing the\n                  angular output at 0V."]
    #[link_name = "\u{1}_ZN3frc19AnalogPotentiometerC1EPNS_11AnalogInputEdd"]
    pub fn frc_AnalogPotentiometer_AnalogPotentiometer1(
        this: *mut frc_AnalogPotentiometer,
        input: *mut frc_AnalogInput,
        fullRange: f64,
        offset: f64,
    );
}
extern "C" {
    #[doc = " Construct an Analog Potentiometer object from an existing Analog Input\n pointer.\n\n Use the fullRange and offset values so that the output produces meaningful\n values. I.E: you have a 270 degree potentiometer and you want the output to\n be degrees with the halfway point as 0 degrees. The fullRange value is\n 270.0 degrees and the offset is -135.0 since the halfway point after\n scaling is 135 degrees.\n\n This will calculate the result from the fullRange times the fraction of the\n supply voltage, plus the offset.\n\n @param input     The existing Analog Input pointer\n @param fullRange The value (in desired units) representing the full\n                  0-5V range of the input.\n @param offset    The value (in desired units) representing the\n                  angular output at 0V."]
    #[link_name = "\u{1}_ZN3frc19AnalogPotentiometerC1ESt10shared_ptrINS_11AnalogInputEEdd"]
    pub fn frc_AnalogPotentiometer_AnalogPotentiometer2(
        this: *mut frc_AnalogPotentiometer,
        input: [u32; 2usize],
        fullRange: f64,
        offset: f64,
    );
}
impl frc_AnalogPotentiometer {
    #[inline]
    pub unsafe fn Get(&self) -> f64 {
        frc_AnalogPotentiometer_Get(self)
    }
    #[inline]
    pub unsafe fn new(channel: ::std::os::raw::c_int, fullRange: f64, offset: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogPotentiometer_AnalogPotentiometer(
            __bindgen_tmp.as_mut_ptr(),
            channel,
            fullRange,
            offset,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(input: *mut frc_AnalogInput, fullRange: f64, offset: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogPotentiometer_AnalogPotentiometer1(
            __bindgen_tmp.as_mut_ptr(),
            input,
            fullRange,
            offset,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(input: [u32; 2usize], fullRange: f64, offset: f64) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AnalogPotentiometer_AnalogPotentiometer2(
            __bindgen_tmp.as_mut_ptr(),
            input,
            fullRange,
            offset,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19AnalogPotentiometer12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_AnalogPotentiometer_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Class for handling synchronous (blocking) interrupts.\n\n <p> By default, interrupts will occur on rising edge.\n\n <p> Asynchronous interrupts are handled by the AsynchronousInterrupt class."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_SynchronousInterrupt {
    pub m_source: [u32; 2usize],
    pub m_handle: u32,
}
pub const frc_SynchronousInterrupt_WaitResult_kTimeout: frc_SynchronousInterrupt_WaitResult = 0;
pub const frc_SynchronousInterrupt_WaitResult_kRisingEdge: frc_SynchronousInterrupt_WaitResult = 1;
pub const frc_SynchronousInterrupt_WaitResult_kFallingEdge: frc_SynchronousInterrupt_WaitResult =
    256;
pub const frc_SynchronousInterrupt_WaitResult_kBoth: frc_SynchronousInterrupt_WaitResult = 257;
#[doc = " Event trigger combinations for a synchronous interrupt."]
pub type frc_SynchronousInterrupt_WaitResult = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_frc_SynchronousInterrupt() {
    const UNINIT: ::std::mem::MaybeUninit<frc_SynchronousInterrupt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_SynchronousInterrupt>(),
        12usize,
        concat!("Size of: ", stringify!(frc_SynchronousInterrupt))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_SynchronousInterrupt>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_SynchronousInterrupt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SynchronousInterrupt),
            "::",
            stringify!(m_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SynchronousInterrupt),
            "::",
            stringify!(m_handle)
        )
    );
}
extern "C" {
    #[doc = " Wait for an interrupt to occur.\n\n <p> Both rising and falling edge can be returned if both a rising and\n falling happened between calls, and ignorePrevious is false.\n\n @param timeout The timeout to wait for. 0s or less will return immediately.\n @param ignorePrevious True to ignore any previous interrupts, false to\n return interrupt value if an interrupt has occurred since last call.\n @return The edge(s) that were triggered, or timeout."]
    #[link_name = "\u{1}_ZN3frc20SynchronousInterrupt16WaitForInterruptEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEEb"]
    pub fn frc_SynchronousInterrupt_WaitForInterrupt(
        this: *mut frc_SynchronousInterrupt,
        timeout: units_time_second_t,
        ignorePrevious: bool,
    ) -> frc_SynchronousInterrupt_WaitResult;
}
extern "C" {
    #[doc = " Set which edges cause an interrupt to occur.\n\n @param risingEdge true to trigger on rising edge, false otherwise.\n @param fallingEdge true to trigger on falling edge, false otherwise"]
    #[link_name = "\u{1}_ZN3frc20SynchronousInterrupt17SetInterruptEdgesEbb"]
    pub fn frc_SynchronousInterrupt_SetInterruptEdges(
        this: *mut frc_SynchronousInterrupt,
        risingEdge: bool,
        fallingEdge: bool,
    );
}
extern "C" {
    #[doc = " Get the timestamp (relative to FPGA Time) of the last rising edge.\n\n @return the timestamp in seconds relative to getFPGATime"]
    #[link_name = "\u{1}_ZN3frc20SynchronousInterrupt18GetRisingTimestampEv"]
    pub fn frc_SynchronousInterrupt_GetRisingTimestamp(
        this: *mut frc_SynchronousInterrupt,
    ) -> units_time_second_t;
}
extern "C" {
    #[doc = " Get the timestamp of the last falling edge.\n\n <p>This function does not require the interrupt to be enabled to work.\n\n <p>This only works if falling edge was configured using setInterruptEdges.\n @return the timestamp in seconds relative to getFPGATime"]
    #[link_name = "\u{1}_ZN3frc20SynchronousInterrupt19GetFallingTimestampEv"]
    pub fn frc_SynchronousInterrupt_GetFallingTimestamp(
        this: *mut frc_SynchronousInterrupt,
    ) -> units_time_second_t;
}
extern "C" {
    #[doc = " Wake up an existing wait call. Can be called from any thread."]
    #[link_name = "\u{1}_ZN3frc20SynchronousInterrupt22WakeupWaitingInterruptEv"]
    pub fn frc_SynchronousInterrupt_WakeupWaitingInterrupt(this: *mut frc_SynchronousInterrupt);
}
extern "C" {
    #[doc = " Construct a Synchronous Interrupt from a Digital Source.\n\n @param source the DigitalSource the interrupts are triggered from"]
    #[link_name = "\u{1}_ZN3frc20SynchronousInterruptC1ERNS_13DigitalSourceE"]
    pub fn frc_SynchronousInterrupt_SynchronousInterrupt(
        this: *mut frc_SynchronousInterrupt,
        source: *mut frc_DigitalSource,
    );
}
extern "C" {
    #[doc = " Construct a Synchronous Interrupt from a Digital Source.\n\n @param source the DigitalSource the interrupts are triggered from"]
    #[link_name = "\u{1}_ZN3frc20SynchronousInterruptC1EPNS_13DigitalSourceE"]
    pub fn frc_SynchronousInterrupt_SynchronousInterrupt1(
        this: *mut frc_SynchronousInterrupt,
        source: *mut frc_DigitalSource,
    );
}
extern "C" {
    #[doc = " Construct a Synchronous Interrupt from a Digital Source.\n\n @param source the DigitalSource the interrupts are triggered from"]
    #[link_name = "\u{1}_ZN3frc20SynchronousInterruptC1ESt10shared_ptrINS_13DigitalSourceEE"]
    pub fn frc_SynchronousInterrupt_SynchronousInterrupt2(
        this: *mut frc_SynchronousInterrupt,
        source: [u32; 2usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc20SynchronousInterruptD1Ev"]
    pub fn frc_SynchronousInterrupt_SynchronousInterrupt_destructor(
        this: *mut frc_SynchronousInterrupt,
    );
}
impl frc_SynchronousInterrupt {
    #[inline]
    pub unsafe fn WaitForInterrupt(
        &mut self,
        timeout: units_time_second_t,
        ignorePrevious: bool,
    ) -> frc_SynchronousInterrupt_WaitResult {
        frc_SynchronousInterrupt_WaitForInterrupt(self, timeout, ignorePrevious)
    }
    #[inline]
    pub unsafe fn SetInterruptEdges(&mut self, risingEdge: bool, fallingEdge: bool) {
        frc_SynchronousInterrupt_SetInterruptEdges(self, risingEdge, fallingEdge)
    }
    #[inline]
    pub unsafe fn GetRisingTimestamp(&mut self) -> units_time_second_t {
        frc_SynchronousInterrupt_GetRisingTimestamp(self)
    }
    #[inline]
    pub unsafe fn GetFallingTimestamp(&mut self) -> units_time_second_t {
        frc_SynchronousInterrupt_GetFallingTimestamp(self)
    }
    #[inline]
    pub unsafe fn WakeupWaitingInterrupt(&mut self) {
        frc_SynchronousInterrupt_WakeupWaitingInterrupt(self)
    }
    #[inline]
    pub unsafe fn new(source: *mut frc_DigitalSource) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_SynchronousInterrupt_SynchronousInterrupt(__bindgen_tmp.as_mut_ptr(), source);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(source: *mut frc_DigitalSource) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_SynchronousInterrupt_SynchronousInterrupt1(__bindgen_tmp.as_mut_ptr(), source);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(source: [u32; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_SynchronousInterrupt_SynchronousInterrupt2(__bindgen_tmp.as_mut_ptr(), source);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        frc_SynchronousInterrupt_SynchronousInterrupt_destructor(self)
    }
}
#[doc = " Class for handling asynchronous interrupts using a callback thread.\n\n <p> By default, interrupts will occur on rising edge. Callbacks are disabled\n by default, and Enable() must be called before they will occur.\n\n <p> Both rising and falling edges can be indicated in one callback if both a\n rising and falling edge occurred since the previous callback.\n\n <p>Synchronous (blocking) interrupts are handled by the SynchronousInterrupt\n class."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_AsynchronousInterrupt {
    pub m_keepRunning: std_atomic_bool,
    pub m_thread: std_thread,
    pub m_interrupt: frc_SynchronousInterrupt,
    pub m_callback: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_frc_AsynchronousInterrupt() {
    const UNINIT: ::std::mem::MaybeUninit<frc_AsynchronousInterrupt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_AsynchronousInterrupt>(),
        36usize,
        concat!("Size of: ", stringify!(frc_AsynchronousInterrupt))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_AsynchronousInterrupt>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_AsynchronousInterrupt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_keepRunning) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AsynchronousInterrupt),
            "::",
            stringify!(m_keepRunning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_thread) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AsynchronousInterrupt),
            "::",
            stringify!(m_thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_interrupt) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AsynchronousInterrupt),
            "::",
            stringify!(m_interrupt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_callback) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_AsynchronousInterrupt),
            "::",
            stringify!(m_callback)
        )
    );
}
extern "C" {
    #[doc = " Enables interrupt callbacks. Before this, callbacks will not occur. Does\n nothing if already enabled."]
    #[link_name = "\u{1}_ZN3frc21AsynchronousInterrupt6EnableEv"]
    pub fn frc_AsynchronousInterrupt_Enable(this: *mut frc_AsynchronousInterrupt);
}
extern "C" {
    #[doc = " Disables interrupt callbacks. Does nothing if already disabled."]
    #[link_name = "\u{1}_ZN3frc21AsynchronousInterrupt7DisableEv"]
    pub fn frc_AsynchronousInterrupt_Disable(this: *mut frc_AsynchronousInterrupt);
}
extern "C" {
    #[doc = " Set which edges to trigger the interrupt on.\n\n @param risingEdge %Trigger on rising edge\n @param fallingEdge %Trigger on falling edge"]
    #[link_name = "\u{1}_ZN3frc21AsynchronousInterrupt17SetInterruptEdgesEbb"]
    pub fn frc_AsynchronousInterrupt_SetInterruptEdges(
        this: *mut frc_AsynchronousInterrupt,
        risingEdge: bool,
        fallingEdge: bool,
    );
}
extern "C" {
    #[doc = " Get the timestamp of the last rising edge.\n\n <p>This function does not require the interrupt to be enabled to work.\n\n <p>This only works if rising edge was configured using SetInterruptEdges.\n @return the timestamp in seconds relative to GetFPGATime"]
    #[link_name = "\u{1}_ZN3frc21AsynchronousInterrupt18GetRisingTimestampEv"]
    pub fn frc_AsynchronousInterrupt_GetRisingTimestamp(
        this: *mut frc_AsynchronousInterrupt,
    ) -> units_time_second_t;
}
extern "C" {
    #[doc = " Get the timestamp of the last falling edge.\n\n <p>This function does not require the interrupt to be enabled to work.\n\n <p>This only works if falling edge was configured using SetInterruptEdges.\n @return the timestamp in seconds relative to GetFPGATime"]
    #[link_name = "\u{1}_ZN3frc21AsynchronousInterrupt19GetFallingTimestampEv"]
    pub fn frc_AsynchronousInterrupt_GetFallingTimestamp(
        this: *mut frc_AsynchronousInterrupt,
    ) -> units_time_second_t;
}
extern "C" {
    #[doc = " Construct an Asynchronous Interrupt from a Digital Source.\n\n <p> At construction, the interrupt will trigger on the rising edge.\n\n <p> The first bool in the callback indicates the rising edge triggered the\n interrupt, the second bool is falling edge.\n\n @param source the DigitalSource the interrupts are triggered from\n @param callback the callback function to call when the interrupt is\n triggered"]
    #[link_name = "\u{1}_ZN3frc21AsynchronousInterruptC1ERNS_13DigitalSourceESt8functionIFvbbEE"]
    pub fn frc_AsynchronousInterrupt_AsynchronousInterrupt(
        this: *mut frc_AsynchronousInterrupt,
        source: *mut frc_DigitalSource,
        callback: [u32; 4usize],
    );
}
extern "C" {
    #[doc = " Construct an Asynchronous Interrupt from a Digital Source.\n\n <p> At construction, the interrupt will trigger on the rising edge.\n\n <p> The first bool in the callback indicates the rising edge triggered the\n interrupt, the second bool is falling edge.\n\n @param source the DigitalSource the interrupts are triggered from\n @param callback the callback function to call when the interrupt is\n triggered"]
    #[link_name = "\u{1}_ZN3frc21AsynchronousInterruptC1EPNS_13DigitalSourceESt8functionIFvbbEE"]
    pub fn frc_AsynchronousInterrupt_AsynchronousInterrupt1(
        this: *mut frc_AsynchronousInterrupt,
        source: *mut frc_DigitalSource,
        callback: [u32; 4usize],
    );
}
extern "C" {
    #[doc = " Construct an Asynchronous Interrupt from a Digital Source.\n\n <p> At construction, the interrupt will trigger on the rising edge.\n\n <p> The first bool in the callback indicates the rising edge triggered the\n interrupt, the second bool is falling edge.\n\n @param source the DigitalSource the interrupts are triggered from\n @param callback the callback function to call when the interrupt is\n triggered"]
    #[link_name = "\u{1}_ZN3frc21AsynchronousInterruptC1ESt10shared_ptrINS_13DigitalSourceEESt8functionIFvbbEE"]
    pub fn frc_AsynchronousInterrupt_AsynchronousInterrupt2(
        this: *mut frc_AsynchronousInterrupt,
        source: [u32; 2usize],
        callback: [u32; 4usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc21AsynchronousInterruptD1Ev"]
    pub fn frc_AsynchronousInterrupt_AsynchronousInterrupt_destructor(
        this: *mut frc_AsynchronousInterrupt,
    );
}
impl frc_AsynchronousInterrupt {
    #[inline]
    pub unsafe fn Enable(&mut self) {
        frc_AsynchronousInterrupt_Enable(self)
    }
    #[inline]
    pub unsafe fn Disable(&mut self) {
        frc_AsynchronousInterrupt_Disable(self)
    }
    #[inline]
    pub unsafe fn SetInterruptEdges(&mut self, risingEdge: bool, fallingEdge: bool) {
        frc_AsynchronousInterrupt_SetInterruptEdges(self, risingEdge, fallingEdge)
    }
    #[inline]
    pub unsafe fn GetRisingTimestamp(&mut self) -> units_time_second_t {
        frc_AsynchronousInterrupt_GetRisingTimestamp(self)
    }
    #[inline]
    pub unsafe fn GetFallingTimestamp(&mut self) -> units_time_second_t {
        frc_AsynchronousInterrupt_GetFallingTimestamp(self)
    }
    #[inline]
    pub unsafe fn new(source: *mut frc_DigitalSource, callback: [u32; 4usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AsynchronousInterrupt_AsynchronousInterrupt(
            __bindgen_tmp.as_mut_ptr(),
            source,
            callback,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(source: *mut frc_DigitalSource, callback: [u32; 4usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AsynchronousInterrupt_AsynchronousInterrupt1(
            __bindgen_tmp.as_mut_ptr(),
            source,
            callback,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(source: [u32; 2usize], callback: [u32; 4usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_AsynchronousInterrupt_AsynchronousInterrupt2(
            __bindgen_tmp.as_mut_ptr(),
            source,
            callback,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        frc_AsynchronousInterrupt_AsynchronousInterrupt_destructor(self)
    }
}
#[doc = " Built-in accelerometer.\n\n This class allows access to the roboRIO's internal accelerometer."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_BuiltInAccelerometer {
    pub _base: frc_Accelerometer,
    pub _base_1: wpi_Sendable,
}
#[test]
fn bindgen_test_layout_frc_BuiltInAccelerometer() {
    assert_eq!(
        ::std::mem::size_of::<frc_BuiltInAccelerometer>(),
        8usize,
        concat!("Size of: ", stringify!(frc_BuiltInAccelerometer))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_BuiltInAccelerometer>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_BuiltInAccelerometer))
    );
}
extern "C" {
    #[doc = " Constructor.\n\n @param range The range the accelerometer will measure"]
    #[link_name = "\u{1}_ZN3frc20BuiltInAccelerometerC1ENS_13Accelerometer5RangeE"]
    pub fn frc_BuiltInAccelerometer_BuiltInAccelerometer(
        this: *mut frc_BuiltInAccelerometer,
        range: frc_Accelerometer_Range,
    );
}
impl frc_BuiltInAccelerometer {
    #[inline]
    pub unsafe fn new(range: frc_Accelerometer_Range) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_BuiltInAccelerometer_BuiltInAccelerometer(__bindgen_tmp.as_mut_ptr(), range);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Set the measuring range of the accelerometer.\n\n @param range The maximum acceleration, positive or negative, that the\n              accelerometer will measure. Not all accelerometers support all\n              ranges."]
    #[link_name = "\u{1}_ZN3frc20BuiltInAccelerometer8SetRangeENS_13Accelerometer5RangeE"]
    pub fn frc_BuiltInAccelerometer_SetRange(
        this: *mut ::std::os::raw::c_void,
        range: frc_Accelerometer_Range,
    );
}
extern "C" {
    #[doc = " @return The acceleration of the roboRIO along the X axis in g-forces"]
    #[link_name = "\u{1}_ZN3frc20BuiltInAccelerometer4GetXEv"]
    pub fn frc_BuiltInAccelerometer_GetX(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " @return The acceleration of the roboRIO along the Y axis in g-forces"]
    #[link_name = "\u{1}_ZN3frc20BuiltInAccelerometer4GetYEv"]
    pub fn frc_BuiltInAccelerometer_GetY(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " @return The acceleration of the roboRIO along the Z axis in g-forces"]
    #[link_name = "\u{1}_ZN3frc20BuiltInAccelerometer4GetZEv"]
    pub fn frc_BuiltInAccelerometer_GetZ(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZThn4_N3frc20BuiltInAccelerometer12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_BuiltInAccelerometer_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_CANData {
    pub data: [u8; 8usize],
    pub length: i32,
    pub timestamp: u64,
}
#[test]
fn bindgen_test_layout_frc_CANData() {
    const UNINIT: ::std::mem::MaybeUninit<frc_CANData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_CANData>(),
        24usize,
        concat!("Size of: ", stringify!(frc_CANData))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_CANData>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_CANData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_CANData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_CANData),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_CANData),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = " High level class for interfacing with CAN devices conforming to\n the standard CAN spec.\n\n No packets that can be sent gets blocked by the RoboRIO, so all methods\n work identically in all robot modes.\n\n All methods are thread save, however the buffer objects passed in\n by the user need to not be modified for the duration of their calls."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_CAN {
    pub m_handle: u32,
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3CAN17kTeamManufacturerE"]
    pub static frc_CAN_kTeamManufacturer: HAL_CANManufacturer;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3CAN15kTeamDeviceTypeE"]
    pub static frc_CAN_kTeamDeviceType: HAL_CANDeviceType;
}
#[test]
fn bindgen_test_layout_frc_CAN() {
    const UNINIT: ::std::mem::MaybeUninit<frc_CAN> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_CAN>(),
        4usize,
        concat!("Size of: ", stringify!(frc_CAN))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_CAN>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_CAN))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_CAN),
            "::",
            stringify!(m_handle)
        )
    );
}
extern "C" {
    #[doc = " Write a packet to the CAN device with a specific ID. This ID is 10 bits.\n\n @param data The data to write (8 bytes max)\n @param length The data length to write\n @param apiId The API ID to write."]
    #[link_name = "\u{1}_ZN3frc3CAN11WritePacketEPKhii"]
    pub fn frc_CAN_WritePacket(
        this: *mut frc_CAN,
        data: *const u8,
        length: ::std::os::raw::c_int,
        apiId: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Write a repeating packet to the CAN device with a specific ID. This ID is\n 10 bits. The RoboRIO will automatically repeat the packet at the specified\n interval\n\n @param data The data to write (8 bytes max)\n @param length The data length to write\n @param apiId The API ID to write.\n @param repeatMs The period to repeat the packet at."]
    #[link_name = "\u{1}_ZN3frc3CAN20WritePacketRepeatingEPKhiii"]
    pub fn frc_CAN_WritePacketRepeating(
        this: *mut frc_CAN,
        data: *const u8,
        length: ::std::os::raw::c_int,
        apiId: ::std::os::raw::c_int,
        repeatMs: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Write an RTR frame to the CAN device with a specific ID. This ID is 10\n bits. The length by spec must match what is returned by the responding\n device\n\n @param length The length to request (0 to 8)\n @param apiId The API ID to write."]
    #[link_name = "\u{1}_ZN3frc3CAN13WriteRTRFrameEii"]
    pub fn frc_CAN_WriteRTRFrame(
        this: *mut frc_CAN,
        length: ::std::os::raw::c_int,
        apiId: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Write a packet to the CAN device with a specific ID. This ID is 10 bits.\n\n @param data The data to write (8 bytes max)\n @param length The data length to write\n @param apiId The API ID to write."]
    #[link_name = "\u{1}_ZN3frc3CAN18WritePacketNoErrorEPKhii"]
    pub fn frc_CAN_WritePacketNoError(
        this: *mut frc_CAN,
        data: *const u8,
        length: ::std::os::raw::c_int,
        apiId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write a repeating packet to the CAN device with a specific ID. This ID is\n 10 bits. The RoboRIO will automatically repeat the packet at the specified\n interval\n\n @param data The data to write (8 bytes max)\n @param length The data length to write\n @param apiId The API ID to write.\n @param repeatMs The period to repeat the packet at."]
    #[link_name = "\u{1}_ZN3frc3CAN27WritePacketRepeatingNoErrorEPKhiii"]
    pub fn frc_CAN_WritePacketRepeatingNoError(
        this: *mut frc_CAN,
        data: *const u8,
        length: ::std::os::raw::c_int,
        apiId: ::std::os::raw::c_int,
        repeatMs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write an RTR frame to the CAN device with a specific ID. This ID is 10\n bits. The length by spec must match what is returned by the responding\n device\n\n @param length The length to request (0 to 8)\n @param apiId The API ID to write."]
    #[link_name = "\u{1}_ZN3frc3CAN20WriteRTRFrameNoErrorEii"]
    pub fn frc_CAN_WriteRTRFrameNoError(
        this: *mut frc_CAN,
        length: ::std::os::raw::c_int,
        apiId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop a repeating packet with a specific ID. This ID is 10 bits.\n\n @param apiId The API ID to stop repeating"]
    #[link_name = "\u{1}_ZN3frc3CAN19StopPacketRepeatingEi"]
    pub fn frc_CAN_StopPacketRepeating(this: *mut frc_CAN, apiId: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Read a new CAN packet. This will only return properly once per packet\n received. Multiple calls without receiving another packet will return\n false.\n\n @param apiId The API ID to read.\n @param data Storage for the received data.\n @return True if the data is valid, otherwise false."]
    #[link_name = "\u{1}_ZN3frc3CAN13ReadPacketNewEiPNS_7CANDataE"]
    pub fn frc_CAN_ReadPacketNew(
        this: *mut frc_CAN,
        apiId: ::std::os::raw::c_int,
        data: *mut frc_CANData,
    ) -> bool;
}
extern "C" {
    #[doc = " Read a CAN packet. The will continuously return the last packet received,\n without accounting for packet age.\n\n @param apiId The API ID to read.\n @param data Storage for the received data.\n @return True if the data is valid, otherwise false."]
    #[link_name = "\u{1}_ZN3frc3CAN16ReadPacketLatestEiPNS_7CANDataE"]
    pub fn frc_CAN_ReadPacketLatest(
        this: *mut frc_CAN,
        apiId: ::std::os::raw::c_int,
        data: *mut frc_CANData,
    ) -> bool;
}
extern "C" {
    #[doc = " Read a CAN packet. The will return the last packet received until the\n packet is older then the requested timeout. Then it will return false.\n\n @param apiId The API ID to read.\n @param timeoutMs The timeout time for the packet\n @param data Storage for the received data.\n @return True if the data is valid, otherwise false."]
    #[link_name = "\u{1}_ZN3frc3CAN17ReadPacketTimeoutEiiPNS_7CANDataE"]
    pub fn frc_CAN_ReadPacketTimeout(
        this: *mut frc_CAN,
        apiId: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
        data: *mut frc_CANData,
    ) -> bool;
}
extern "C" {
    #[doc = " Create a new CAN communication interface with the specific device ID.\n This uses the team manufacturer and device types.\n The device ID is 6 bits (0-63)\n\n @param deviceId The device id"]
    #[link_name = "\u{1}_ZN3frc3CANC1Ei"]
    pub fn frc_CAN_CAN(this: *mut frc_CAN, deviceId: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Create a new CAN communication interface with a specific device ID,\n manufacturer and device type. The device ID is 6 bits, the\n manufacturer is 8 bits, and the device type is 5 bits.\n\n @param deviceId           The device ID\n @param deviceManufacturer The device manufacturer\n @param deviceType         The device type"]
    #[link_name = "\u{1}_ZN3frc3CANC1Eiii"]
    pub fn frc_CAN_CAN1(
        this: *mut frc_CAN,
        deviceId: ::std::os::raw::c_int,
        deviceManufacturer: ::std::os::raw::c_int,
        deviceType: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Closes the CAN communication."]
    #[link_name = "\u{1}_ZN3frc3CAND1Ev"]
    pub fn frc_CAN_CAN_destructor(this: *mut frc_CAN);
}
impl frc_CAN {
    #[inline]
    pub unsafe fn WritePacket(
        &mut self,
        data: *const u8,
        length: ::std::os::raw::c_int,
        apiId: ::std::os::raw::c_int,
    ) {
        frc_CAN_WritePacket(self, data, length, apiId)
    }
    #[inline]
    pub unsafe fn WritePacketRepeating(
        &mut self,
        data: *const u8,
        length: ::std::os::raw::c_int,
        apiId: ::std::os::raw::c_int,
        repeatMs: ::std::os::raw::c_int,
    ) {
        frc_CAN_WritePacketRepeating(self, data, length, apiId, repeatMs)
    }
    #[inline]
    pub unsafe fn WriteRTRFrame(
        &mut self,
        length: ::std::os::raw::c_int,
        apiId: ::std::os::raw::c_int,
    ) {
        frc_CAN_WriteRTRFrame(self, length, apiId)
    }
    #[inline]
    pub unsafe fn WritePacketNoError(
        &mut self,
        data: *const u8,
        length: ::std::os::raw::c_int,
        apiId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        frc_CAN_WritePacketNoError(self, data, length, apiId)
    }
    #[inline]
    pub unsafe fn WritePacketRepeatingNoError(
        &mut self,
        data: *const u8,
        length: ::std::os::raw::c_int,
        apiId: ::std::os::raw::c_int,
        repeatMs: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        frc_CAN_WritePacketRepeatingNoError(self, data, length, apiId, repeatMs)
    }
    #[inline]
    pub unsafe fn WriteRTRFrameNoError(
        &mut self,
        length: ::std::os::raw::c_int,
        apiId: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        frc_CAN_WriteRTRFrameNoError(self, length, apiId)
    }
    #[inline]
    pub unsafe fn StopPacketRepeating(&mut self, apiId: ::std::os::raw::c_int) {
        frc_CAN_StopPacketRepeating(self, apiId)
    }
    #[inline]
    pub unsafe fn ReadPacketNew(
        &mut self,
        apiId: ::std::os::raw::c_int,
        data: *mut frc_CANData,
    ) -> bool {
        frc_CAN_ReadPacketNew(self, apiId, data)
    }
    #[inline]
    pub unsafe fn ReadPacketLatest(
        &mut self,
        apiId: ::std::os::raw::c_int,
        data: *mut frc_CANData,
    ) -> bool {
        frc_CAN_ReadPacketLatest(self, apiId, data)
    }
    #[inline]
    pub unsafe fn ReadPacketTimeout(
        &mut self,
        apiId: ::std::os::raw::c_int,
        timeoutMs: ::std::os::raw::c_int,
        data: *mut frc_CANData,
    ) -> bool {
        frc_CAN_ReadPacketTimeout(self, apiId, timeoutMs, data)
    }
    #[inline]
    pub unsafe fn new(deviceId: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_CAN_CAN(__bindgen_tmp.as_mut_ptr(), deviceId);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        deviceId: ::std::os::raw::c_int,
        deviceManufacturer: ::std::os::raw::c_int,
        deviceType: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_CAN_CAN1(
            __bindgen_tmp.as_mut_ptr(),
            deviceId,
            deviceManufacturer,
            deviceType,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        frc_CAN_CAN_destructor(self)
    }
}
pub const frc_CompressorConfigType_Disabled: frc_CompressorConfigType = 0;
pub const frc_CompressorConfigType_Digital: frc_CompressorConfigType = 1;
pub const frc_CompressorConfigType_Analog: frc_CompressorConfigType = 2;
pub const frc_CompressorConfigType_Hybrid: frc_CompressorConfigType = 3;
pub type frc_CompressorConfigType = ::std::os::raw::c_int;
pub const frc_PneumaticsModuleType_CTREPCM: frc_PneumaticsModuleType = 0;
pub const frc_PneumaticsModuleType_REVPH: frc_PneumaticsModuleType = 1;
pub type frc_PneumaticsModuleType = ::std::os::raw::c_int;
#[repr(C)]
pub struct frc_PneumaticsBase__bindgen_vtable {
    pub frc_PneumaticsBase_GetCompressor:
        unsafe extern "C" fn(this: *const frc_PneumaticsBase) -> bool,
    pub frc_PneumaticsBase_GetPressureSwitch:
        unsafe extern "C" fn(this: *const frc_PneumaticsBase) -> bool,
    pub frc_PneumaticsBase_GetCompressorCurrent:
        unsafe extern "C" fn(this: *const frc_PneumaticsBase) -> units_current_ampere_t,
    pub frc_PneumaticsBase_DisableCompressor: unsafe extern "C" fn(this: *mut frc_PneumaticsBase),
    pub frc_PneumaticsBase_EnableCompressorDigital:
        unsafe extern "C" fn(this: *mut frc_PneumaticsBase),
    pub frc_PneumaticsBase_EnableCompressorAnalog: unsafe extern "C" fn(
        this: *mut frc_PneumaticsBase,
        minPressure: units_pressure_pounds_per_square_inch_t,
        maxPressure: units_pressure_pounds_per_square_inch_t,
    ),
    pub frc_PneumaticsBase_EnableCompressorHybrid: unsafe extern "C" fn(
        this: *mut frc_PneumaticsBase,
        minPressure: units_pressure_pounds_per_square_inch_t,
        maxPressure: units_pressure_pounds_per_square_inch_t,
    ),
    pub frc_PneumaticsBase_GetCompressorConfigType:
        unsafe extern "C" fn(this: *const frc_PneumaticsBase) -> frc_CompressorConfigType,
    pub frc_PneumaticsBase_SetSolenoids: unsafe extern "C" fn(
        this: *mut frc_PneumaticsBase,
        mask: ::std::os::raw::c_int,
        values: ::std::os::raw::c_int,
    ),
    pub frc_PneumaticsBase_GetSolenoids:
        unsafe extern "C" fn(this: *const frc_PneumaticsBase) -> ::std::os::raw::c_int,
    pub frc_PneumaticsBase_GetModuleNumber:
        unsafe extern "C" fn(this: *const frc_PneumaticsBase) -> ::std::os::raw::c_int,
    pub frc_PneumaticsBase_GetSolenoidDisabledList:
        unsafe extern "C" fn(this: *const frc_PneumaticsBase) -> ::std::os::raw::c_int,
    pub frc_PneumaticsBase_FireOneShot:
        unsafe extern "C" fn(this: *mut frc_PneumaticsBase, index: ::std::os::raw::c_int),
    pub frc_PneumaticsBase_SetOneShotDuration: unsafe extern "C" fn(
        this: *mut frc_PneumaticsBase,
        index: ::std::os::raw::c_int,
        duration: units_time_second_t,
    ),
    pub frc_PneumaticsBase_CheckSolenoidChannel: unsafe extern "C" fn(
        this: *const frc_PneumaticsBase,
        channel: ::std::os::raw::c_int,
    ) -> bool,
    pub frc_PneumaticsBase_CheckAndReserveSolenoids: unsafe extern "C" fn(
        this: *mut frc_PneumaticsBase,
        mask: ::std::os::raw::c_int,
    )
        -> ::std::os::raw::c_int,
    pub frc_PneumaticsBase_UnreserveSolenoids:
        unsafe extern "C" fn(this: *mut frc_PneumaticsBase, mask: ::std::os::raw::c_int),
    pub frc_PneumaticsBase_ReserveCompressor:
        unsafe extern "C" fn(this: *mut frc_PneumaticsBase) -> bool,
    pub frc_PneumaticsBase_UnreserveCompressor: unsafe extern "C" fn(this: *mut frc_PneumaticsBase),
    pub frc_PneumaticsBase_GetAnalogVoltage: unsafe extern "C" fn(
        this: *const frc_PneumaticsBase,
        channel: ::std::os::raw::c_int,
    ) -> units_voltage_volt_t,
    pub frc_PneumaticsBase_GetPressure:
        unsafe extern "C" fn(
            this: *const frc_PneumaticsBase,
            channel: ::std::os::raw::c_int,
        ) -> units_pressure_pounds_per_square_inch_t,
    pub frc_PneumaticsBase_MakeSolenoid: unsafe extern "C" fn(
        this: *mut frc_PneumaticsBase,
        channel: ::std::os::raw::c_int,
    ) -> frc_Solenoid,
    pub frc_PneumaticsBase_MakeDoubleSolenoid: unsafe extern "C" fn(
        this: *mut frc_PneumaticsBase,
        forwardChannel: ::std::os::raw::c_int,
        reverseChannel: ::std::os::raw::c_int,
    ) -> frc_DoubleSolenoid,
    pub frc_PneumaticsBase_MakeCompressor:
        unsafe extern "C" fn(this: *mut frc_PneumaticsBase) -> frc_Compressor,
}
#[repr(C)]
#[derive(Debug)]
pub struct frc_PneumaticsBase {
    pub vtable_: *const frc_PneumaticsBase__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_frc_PneumaticsBase() {
    assert_eq!(
        ::std::mem::size_of::<frc_PneumaticsBase>(),
        4usize,
        concat!("Size of: ", stringify!(frc_PneumaticsBase))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PneumaticsBase>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_PneumaticsBase))
    );
}
extern "C" {
    #[doc = " For internal use to get a module for a specific type.\n\n @param module module number\n @param moduleType module type\n @return module"]
    #[link_name = "\u{1}_ZN3frc14PneumaticsBase10GetForTypeEiNS_20PneumaticsModuleTypeE"]
    pub fn frc_PneumaticsBase_GetForType(
        module: ::std::os::raw::c_int,
        moduleType: frc_PneumaticsModuleType,
    ) -> [u32; 2usize];
}
extern "C" {
    #[doc = " For internal use to get the default for a specific type.\n\n @param moduleType module type\n @return module default"]
    #[link_name = "\u{1}_ZN3frc14PneumaticsBase17GetDefaultForTypeENS_20PneumaticsModuleTypeE"]
    pub fn frc_PneumaticsBase_GetDefaultForType(
        moduleType: frc_PneumaticsModuleType,
    ) -> ::std::os::raw::c_int;
}
impl frc_PneumaticsBase {
    #[inline]
    pub unsafe fn GetForType(
        module: ::std::os::raw::c_int,
        moduleType: frc_PneumaticsModuleType,
    ) -> [u32; 2usize] {
        frc_PneumaticsBase_GetForType(module, moduleType)
    }
    #[inline]
    pub unsafe fn GetDefaultForType(moduleType: frc_PneumaticsModuleType) -> ::std::os::raw::c_int {
        frc_PneumaticsBase_GetDefaultForType(moduleType)
    }
}
#[doc = " Stores most recent status information as well as containing utility functions\n for checking channels and error processing."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_SensorUtil {
    pub _address: u8,
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10SensorUtil16kDigitalChannelsE"]
    pub static frc_SensorUtil_kDigitalChannels: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10SensorUtil13kAnalogInputsE"]
    pub static frc_SensorUtil_kAnalogInputs: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10SensorUtil14kAnalogOutputsE"]
    pub static frc_SensorUtil_kAnalogOutputs: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10SensorUtil12kPwmChannelsE"]
    pub static frc_SensorUtil_kPwmChannels: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10SensorUtil14kRelayChannelsE"]
    pub static frc_SensorUtil_kRelayChannels: ::std::os::raw::c_int;
}
#[test]
fn bindgen_test_layout_frc_SensorUtil() {
    assert_eq!(
        ::std::mem::size_of::<frc_SensorUtil>(),
        1usize,
        concat!("Size of: ", stringify!(frc_SensorUtil))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_SensorUtil>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_SensorUtil))
    );
}
extern "C" {
    #[doc = " Get the number of the default solenoid module.\n\n @return The number of the default solenoid module."]
    #[link_name = "\u{1}_ZN3frc10SensorUtil23GetDefaultCTREPCMModuleEv"]
    pub fn frc_SensorUtil_GetDefaultCTREPCMModule() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of the default solenoid module.\n\n @return The number of the default solenoid module."]
    #[link_name = "\u{1}_ZN3frc10SensorUtil21GetDefaultREVPHModuleEv"]
    pub fn frc_SensorUtil_GetDefaultREVPHModule() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check that the digital channel number is valid.\n\n Verify that the channel number is one of the legal channel numbers. Channel\n numbers are 0-based.\n\n @return Digital channel is valid"]
    #[link_name = "\u{1}_ZN3frc10SensorUtil19CheckDigitalChannelEi"]
    pub fn frc_SensorUtil_CheckDigitalChannel(channel: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " Check that the relay channel number is valid.\n\n Verify that the channel number is one of the legal channel numbers. Channel\n numbers are 0-based.\n\n @return Relay channel is valid"]
    #[link_name = "\u{1}_ZN3frc10SensorUtil17CheckRelayChannelEi"]
    pub fn frc_SensorUtil_CheckRelayChannel(channel: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " Check that the digital channel number is valid.\n\n Verify that the channel number is one of the legal channel numbers. Channel\n numbers are 0-based.\n\n @return PWM channel is valid"]
    #[link_name = "\u{1}_ZN3frc10SensorUtil15CheckPWMChannelEi"]
    pub fn frc_SensorUtil_CheckPWMChannel(channel: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " Check that the analog input number is value.\n\n Verify that the analog input number is one of the legal channel numbers.\n Channel numbers are 0-based.\n\n @return Analog channel is valid"]
    #[link_name = "\u{1}_ZN3frc10SensorUtil23CheckAnalogInputChannelEi"]
    pub fn frc_SensorUtil_CheckAnalogInputChannel(channel: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " Check that the analog output number is valid.\n\n Verify that the analog output number is one of the legal channel numbers.\n Channel numbers are 0-based.\n\n @return Analog channel is valid"]
    #[link_name = "\u{1}_ZN3frc10SensorUtil24CheckAnalogOutputChannelEi"]
    pub fn frc_SensorUtil_CheckAnalogOutputChannel(channel: ::std::os::raw::c_int) -> bool;
}
impl frc_SensorUtil {
    #[inline]
    pub unsafe fn GetDefaultCTREPCMModule() -> ::std::os::raw::c_int {
        frc_SensorUtil_GetDefaultCTREPCMModule()
    }
    #[inline]
    pub unsafe fn GetDefaultREVPHModule() -> ::std::os::raw::c_int {
        frc_SensorUtil_GetDefaultREVPHModule()
    }
    #[inline]
    pub unsafe fn CheckDigitalChannel(channel: ::std::os::raw::c_int) -> bool {
        frc_SensorUtil_CheckDigitalChannel(channel)
    }
    #[inline]
    pub unsafe fn CheckRelayChannel(channel: ::std::os::raw::c_int) -> bool {
        frc_SensorUtil_CheckRelayChannel(channel)
    }
    #[inline]
    pub unsafe fn CheckPWMChannel(channel: ::std::os::raw::c_int) -> bool {
        frc_SensorUtil_CheckPWMChannel(channel)
    }
    #[inline]
    pub unsafe fn CheckAnalogInputChannel(channel: ::std::os::raw::c_int) -> bool {
        frc_SensorUtil_CheckAnalogInputChannel(channel)
    }
    #[inline]
    pub unsafe fn CheckAnalogOutputChannel(channel: ::std::os::raw::c_int) -> bool {
        frc_SensorUtil_CheckAnalogOutputChannel(channel)
    }
}
#[doc = " Class for operating a compressor connected to a pneumatics module.\n\n The module will automatically run in closed loop mode by default whenever a\n Solenoid object is created. For most cases, a Compressor object does not need\n to be instantiated or used in a robot program. This class is only required in\n cases where the robot program needs a more detailed status of the compressor\n or to enable/disable closed loop control.\n\n Note: you cannot operate the compressor directly from this class as doing so\n would circumvent the safety provided by using the pressure switch and closed\n loop control. You can only turn off closed loop control, thereby stopping\n the compressor from operating."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Compressor {
    pub _base: wpi_Sendable,
    pub m_module: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_frc_Compressor() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Compressor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Compressor>(),
        12usize,
        concat!("Size of: ", stringify!(frc_Compressor))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Compressor>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_Compressor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Compressor),
            "::",
            stringify!(m_module)
        )
    );
}
extern "C" {
    #[doc = " Check if compressor output is active.\n To (re)enable the compressor use EnableDigital() or EnableAnalog(...).\n\n @return true if the compressor is on.\n @deprecated To avoid confusion in thinking this (re)enables the compressor\n use IsEnabled()."]
    #[link_name = "\u{1}_ZNK3frc10Compressor7EnabledEv"]
    pub fn frc_Compressor_Enabled(this: *const frc_Compressor) -> bool;
}
extern "C" {
    #[doc = " Returns whether the compressor is active or not.\n\n @return true if the compressor is on - otherwise false."]
    #[link_name = "\u{1}_ZNK3frc10Compressor9IsEnabledEv"]
    pub fn frc_Compressor_IsEnabled(this: *const frc_Compressor) -> bool;
}
extern "C" {
    #[doc = " Returns the state of the pressure switch.\n\n @return True if pressure switch indicates that the system is not full,\n otherwise false."]
    #[link_name = "\u{1}_ZNK3frc10Compressor22GetPressureSwitchValueEv"]
    pub fn frc_Compressor_GetPressureSwitchValue(this: *const frc_Compressor) -> bool;
}
extern "C" {
    #[doc = " Get the current drawn by the compressor.\n\n @return Current drawn by the compressor."]
    #[link_name = "\u{1}_ZNK3frc10Compressor10GetCurrentEv"]
    pub fn frc_Compressor_GetCurrent(this: *const frc_Compressor) -> units_current_ampere_t;
}
extern "C" {
    #[doc = " If supported by the device, returns the analog input voltage (on channel\n 0).\n\n This function is only supported by the REV PH. On CTRE PCM, this will\n return 0.\n\n @return The analog input voltage, in volts."]
    #[link_name = "\u{1}_ZNK3frc10Compressor16GetAnalogVoltageEv"]
    pub fn frc_Compressor_GetAnalogVoltage(this: *const frc_Compressor) -> units_voltage_volt_t;
}
extern "C" {
    #[doc = " If supported by the device, returns the pressure read by the analog\n pressure sensor (on channel 0).\n\n This function is only supported by the REV PH with the REV Analog Pressure\n Sensor. On CTRE PCM, this will return 0.\n\n @return The pressure read by the analog pressure sensor."]
    #[link_name = "\u{1}_ZNK3frc10Compressor11GetPressureEv"]
    pub fn frc_Compressor_GetPressure(
        this: *const frc_Compressor,
    ) -> units_pressure_pounds_per_square_inch_t;
}
extern "C" {
    #[doc = " Disable the compressor."]
    #[link_name = "\u{1}_ZN3frc10Compressor7DisableEv"]
    pub fn frc_Compressor_Disable(this: *mut frc_Compressor);
}
extern "C" {
    #[doc = " Enables the compressor in digital mode using the digital pressure switch.\n The compressor will turn on when the pressure switch indicates that the\n system is not full, and will turn off when the pressure switch indicates\n that the system is full."]
    #[link_name = "\u{1}_ZN3frc10Compressor13EnableDigitalEv"]
    pub fn frc_Compressor_EnableDigital(this: *mut frc_Compressor);
}
extern "C" {
    #[doc = " If supported by the device, enables the compressor in analog mode. This\n mode uses an analog pressure sensor connected to analog channel 0 to cycle\n the compressor. The compressor will turn on when the pressure drops below\n {@code minPressure} and will turn off when the pressure reaches {@code\n maxPressure}. This mode is only supported by the REV PH with the REV Analog\n Pressure Sensor connected to analog channel 0.\n\n On CTRE PCM, this will enable digital control.\n\n @param minPressure The minimum pressure. The compressor will turn on when\n the pressure drops below this value.\n @param maxPressure The maximum pressure. The compressor will turn off when\n the pressure reaches this value."]
    #[link_name = "\u{1}_ZN3frc10Compressor12EnableAnalogEN5units6unit_tINS1_4unitISt5ratioILx437817087ELx63500EENS1_9base_unitIS4_ILxn1ELx1EES4_ILx1ELx1EES4_ILxn2ELx1EES4_ILx0ELx1EESA_SA_SA_SA_SA_EESA_SA_EEdNS1_12linear_scaleEEESE_"]
    pub fn frc_Compressor_EnableAnalog(
        this: *mut frc_Compressor,
        minPressure: units_pressure_pounds_per_square_inch_t,
        maxPressure: units_pressure_pounds_per_square_inch_t,
    );
}
extern "C" {
    #[doc = " If supported by the device, enables the compressor in hybrid mode. This\n mode uses both a digital pressure switch and an analog pressure sensor\n connected to analog channel 0 to cycle the compressor. This mode is only\n supported by the REV PH with the REV Analog Pressure Sensor connected to\n analog channel 0.\n\n The compressor will turn on when \\a both:\n\n - The digital pressure switch indicates the system is not full AND\n - The analog pressure sensor indicates that the pressure in the system\n is below the specified minimum pressure.\n\n The compressor will turn off when \\a either:\n\n - The digital pressure switch is disconnected or indicates that the system\n is full OR\n - The pressure detected by the analog sensor is greater than the specified\n maximum pressure.\n\n On CTRE PCM, this will enable digital control.\n\n @param minPressure The minimum pressure. The compressor will turn on\n when the pressure drops below this value and the pressure switch indicates\n that the system is not full.\n @param maxPressure The maximum pressure. The compressor will turn\n off when the pressure reaches this value or the pressure switch is\n disconnected or indicates that the system is full."]
    #[link_name = "\u{1}_ZN3frc10Compressor12EnableHybridEN5units6unit_tINS1_4unitISt5ratioILx437817087ELx63500EENS1_9base_unitIS4_ILxn1ELx1EES4_ILx1ELx1EES4_ILxn2ELx1EES4_ILx0ELx1EESA_SA_SA_SA_SA_EESA_SA_EEdNS1_12linear_scaleEEESE_"]
    pub fn frc_Compressor_EnableHybrid(
        this: *mut frc_Compressor,
        minPressure: units_pressure_pounds_per_square_inch_t,
        maxPressure: units_pressure_pounds_per_square_inch_t,
    );
}
extern "C" {
    #[doc = " Returns the active compressor configuration.\n\n @return The active compressor configuration."]
    #[link_name = "\u{1}_ZNK3frc10Compressor13GetConfigTypeEv"]
    pub fn frc_Compressor_GetConfigType(this: *const frc_Compressor) -> frc_CompressorConfigType;
}
extern "C" {
    #[doc = " Constructs a compressor for a specified module and type.\n\n @param module The module ID to use.\n @param moduleType The module type to use."]
    #[link_name = "\u{1}_ZN3frc10CompressorC1EiNS_20PneumaticsModuleTypeE"]
    pub fn frc_Compressor_Compressor(
        this: *mut frc_Compressor,
        module: ::std::os::raw::c_int,
        moduleType: frc_PneumaticsModuleType,
    );
}
extern "C" {
    #[doc = " Constructs a compressor for a default module and specified type.\n\n @param moduleType The module type to use."]
    #[link_name = "\u{1}_ZN3frc10CompressorC1ENS_20PneumaticsModuleTypeE"]
    pub fn frc_Compressor_Compressor1(
        this: *mut frc_Compressor,
        moduleType: frc_PneumaticsModuleType,
    );
}
impl frc_Compressor {
    #[inline]
    pub unsafe fn Enabled(&self) -> bool {
        frc_Compressor_Enabled(self)
    }
    #[inline]
    pub unsafe fn IsEnabled(&self) -> bool {
        frc_Compressor_IsEnabled(self)
    }
    #[inline]
    pub unsafe fn GetPressureSwitchValue(&self) -> bool {
        frc_Compressor_GetPressureSwitchValue(self)
    }
    #[inline]
    pub unsafe fn GetCurrent(&self) -> units_current_ampere_t {
        frc_Compressor_GetCurrent(self)
    }
    #[inline]
    pub unsafe fn GetAnalogVoltage(&self) -> units_voltage_volt_t {
        frc_Compressor_GetAnalogVoltage(self)
    }
    #[inline]
    pub unsafe fn GetPressure(&self) -> units_pressure_pounds_per_square_inch_t {
        frc_Compressor_GetPressure(self)
    }
    #[inline]
    pub unsafe fn Disable(&mut self) {
        frc_Compressor_Disable(self)
    }
    #[inline]
    pub unsafe fn EnableDigital(&mut self) {
        frc_Compressor_EnableDigital(self)
    }
    #[inline]
    pub unsafe fn EnableAnalog(
        &mut self,
        minPressure: units_pressure_pounds_per_square_inch_t,
        maxPressure: units_pressure_pounds_per_square_inch_t,
    ) {
        frc_Compressor_EnableAnalog(self, minPressure, maxPressure)
    }
    #[inline]
    pub unsafe fn EnableHybrid(
        &mut self,
        minPressure: units_pressure_pounds_per_square_inch_t,
        maxPressure: units_pressure_pounds_per_square_inch_t,
    ) {
        frc_Compressor_EnableHybrid(self, minPressure, maxPressure)
    }
    #[inline]
    pub unsafe fn GetConfigType(&self) -> frc_CompressorConfigType {
        frc_Compressor_GetConfigType(self)
    }
    #[inline]
    pub unsafe fn new(module: ::std::os::raw::c_int, moduleType: frc_PneumaticsModuleType) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Compressor_Compressor(__bindgen_tmp.as_mut_ptr(), module, moduleType);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(moduleType: frc_PneumaticsModuleType) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Compressor_Compressor1(__bindgen_tmp.as_mut_ptr(), moduleType);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10CompressorD1Ev"]
    pub fn frc_Compressor_Compressor_destructor(this: *mut frc_Compressor);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10Compressor12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_Compressor_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Class to enable glitch filtering on a set of digital inputs.\n\n This class will manage adding and removing digital inputs from a FPGA glitch\n filter. The filter lets the user configure the time that an input must remain\n high or low before it is classified as high or low."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_DigitalGlitchFilter {
    pub _base: wpi_Sendable,
    pub m_channelIndex: ::std::os::raw::c_int,
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilter7m_mutexE"]
    pub static mut frc_DigitalGlitchFilter_m_mutex: wpi_mutex;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilter17m_filterAllocatedE"]
    pub static mut frc_DigitalGlitchFilter_m_filterAllocated: u8;
}
#[test]
fn bindgen_test_layout_frc_DigitalGlitchFilter() {
    const UNINIT: ::std::mem::MaybeUninit<frc_DigitalGlitchFilter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_DigitalGlitchFilter>(),
        8usize,
        concat!("Size of: ", stringify!(frc_DigitalGlitchFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_DigitalGlitchFilter>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_DigitalGlitchFilter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_channelIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DigitalGlitchFilter),
            "::",
            stringify!(m_channelIndex)
        )
    );
}
extern "C" {
    #[doc = " Assigns the DigitalSource to this glitch filter.\n\n @param input The DigitalSource to add."]
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilter3AddEPNS_13DigitalSourceE"]
    pub fn frc_DigitalGlitchFilter_Add(
        this: *mut frc_DigitalGlitchFilter,
        input: *mut frc_DigitalSource,
    );
}
extern "C" {
    #[doc = " Assigns the Encoder to this glitch filter.\n\n @param input The Encoder to add."]
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilter3AddEPNS_7EncoderE"]
    pub fn frc_DigitalGlitchFilter_Add1(
        this: *mut frc_DigitalGlitchFilter,
        input: *mut frc_Encoder,
    );
}
extern "C" {
    #[doc = " Assigns the Counter to this glitch filter.\n\n @param input The Counter to add."]
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilter3AddEPNS_7CounterE"]
    pub fn frc_DigitalGlitchFilter_Add2(
        this: *mut frc_DigitalGlitchFilter,
        input: *mut frc_Counter,
    );
}
extern "C" {
    #[doc = " Removes a digital input from this filter.\n\n Removes the DigitalSource from this glitch filter and re-assigns it to\n the default filter.\n\n @param input The DigitalSource to remove."]
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilter6RemoveEPNS_13DigitalSourceE"]
    pub fn frc_DigitalGlitchFilter_Remove(
        this: *mut frc_DigitalGlitchFilter,
        input: *mut frc_DigitalSource,
    );
}
extern "C" {
    #[doc = " Removes an encoder from this filter.\n\n Removes the Encoder from this glitch filter and re-assigns it to\n the default filter.\n\n @param input The Encoder to remove."]
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilter6RemoveEPNS_7EncoderE"]
    pub fn frc_DigitalGlitchFilter_Remove1(
        this: *mut frc_DigitalGlitchFilter,
        input: *mut frc_Encoder,
    );
}
extern "C" {
    #[doc = " Removes a counter from this filter.\n\n Removes the Counter from this glitch filter and re-assigns it to\n the default filter.\n\n @param input The Counter to remove."]
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilter6RemoveEPNS_7CounterE"]
    pub fn frc_DigitalGlitchFilter_Remove2(
        this: *mut frc_DigitalGlitchFilter,
        input: *mut frc_Counter,
    );
}
extern "C" {
    #[doc = " Sets the number of cycles that the input must not change state for.\n\n @param fpgaCycles The number of FPGA cycles."]
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilter15SetPeriodCyclesEi"]
    pub fn frc_DigitalGlitchFilter_SetPeriodCycles(
        this: *mut frc_DigitalGlitchFilter,
        fpgaCycles: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Sets the number of nanoseconds that the input must not change state for.\n\n @param nanoseconds The number of nanoseconds."]
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilter20SetPeriodNanoSecondsEy"]
    pub fn frc_DigitalGlitchFilter_SetPeriodNanoSeconds(
        this: *mut frc_DigitalGlitchFilter,
        nanoseconds: u64,
    );
}
extern "C" {
    #[doc = " Gets the number of cycles that the input must not change state for.\n\n @return The number of cycles."]
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilter15GetPeriodCyclesEv"]
    pub fn frc_DigitalGlitchFilter_GetPeriodCycles(
        this: *mut frc_DigitalGlitchFilter,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the number of nanoseconds that the input must not change state for.\n\n @return The number of nanoseconds."]
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilter20GetPeriodNanoSecondsEv"]
    pub fn frc_DigitalGlitchFilter_GetPeriodNanoSeconds(this: *mut frc_DigitalGlitchFilter) -> u64;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilterC1Ev"]
    pub fn frc_DigitalGlitchFilter_DigitalGlitchFilter(this: *mut frc_DigitalGlitchFilter);
}
impl frc_DigitalGlitchFilter {
    #[inline]
    pub unsafe fn Add(&mut self, input: *mut frc_DigitalSource) {
        frc_DigitalGlitchFilter_Add(self, input)
    }
    #[inline]
    pub unsafe fn Add1(&mut self, input: *mut frc_Encoder) {
        frc_DigitalGlitchFilter_Add1(self, input)
    }
    #[inline]
    pub unsafe fn Add2(&mut self, input: *mut frc_Counter) {
        frc_DigitalGlitchFilter_Add2(self, input)
    }
    #[inline]
    pub unsafe fn Remove(&mut self, input: *mut frc_DigitalSource) {
        frc_DigitalGlitchFilter_Remove(self, input)
    }
    #[inline]
    pub unsafe fn Remove1(&mut self, input: *mut frc_Encoder) {
        frc_DigitalGlitchFilter_Remove1(self, input)
    }
    #[inline]
    pub unsafe fn Remove2(&mut self, input: *mut frc_Counter) {
        frc_DigitalGlitchFilter_Remove2(self, input)
    }
    #[inline]
    pub unsafe fn SetPeriodCycles(&mut self, fpgaCycles: ::std::os::raw::c_int) {
        frc_DigitalGlitchFilter_SetPeriodCycles(self, fpgaCycles)
    }
    #[inline]
    pub unsafe fn SetPeriodNanoSeconds(&mut self, nanoseconds: u64) {
        frc_DigitalGlitchFilter_SetPeriodNanoSeconds(self, nanoseconds)
    }
    #[inline]
    pub unsafe fn GetPeriodCycles(&mut self) -> ::std::os::raw::c_int {
        frc_DigitalGlitchFilter_GetPeriodCycles(self)
    }
    #[inline]
    pub unsafe fn GetPeriodNanoSeconds(&mut self) -> u64 {
        frc_DigitalGlitchFilter_GetPeriodNanoSeconds(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DigitalGlitchFilter_DigitalGlitchFilter(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilterD1Ev"]
    pub fn frc_DigitalGlitchFilter_DigitalGlitchFilter_destructor(
        this: *mut frc_DigitalGlitchFilter,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19DigitalGlitchFilter12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_DigitalGlitchFilter_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Class to read a digital input.\n\n This class will read digital inputs and return the current value on the\n channel. Other devices such as encoders, gear tooth sensors, etc. that are\n implemented elsewhere will automatically allocate digital inputs and outputs\n as required. This class is only for devices like switches etc. that aren't\n implemented anywhere else."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_DigitalInput {
    pub _base: frc_DigitalSource,
    pub _base_1: wpi_Sendable,
    pub m_channel: ::std::os::raw::c_int,
    pub m_handle: u32,
}
#[test]
fn bindgen_test_layout_frc_DigitalInput() {
    assert_eq!(
        ::std::mem::size_of::<frc_DigitalInput>(),
        16usize,
        concat!("Size of: ", stringify!(frc_DigitalInput))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_DigitalInput>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_DigitalInput))
    );
}
extern "C" {
    #[doc = " Get the value from a digital input channel.\n\n Retrieve the value of a single digital input channel from the FPGA."]
    #[link_name = "\u{1}_ZNK3frc12DigitalInput3GetEv"]
    pub fn frc_DigitalInput_Get(this: *const frc_DigitalInput) -> bool;
}
extern "C" {
    #[doc = " Indicates this input is used by a simulated device.\n\n @param device simulated device handle"]
    #[link_name = "\u{1}_ZN3frc12DigitalInput12SetSimDeviceEi"]
    pub fn frc_DigitalInput_SetSimDevice(this: *mut frc_DigitalInput, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[doc = " Create an instance of a Digital Input class.\n\n Creates a digital input given a channel.\n\n @param channel The DIO channel 0-9 are on-board, 10-25 are on the MXP port"]
    #[link_name = "\u{1}_ZN3frc12DigitalInputC1Ei"]
    pub fn frc_DigitalInput_DigitalInput(
        this: *mut frc_DigitalInput,
        channel: ::std::os::raw::c_int,
    );
}
impl frc_DigitalInput {
    #[inline]
    pub unsafe fn Get(&self) -> bool {
        frc_DigitalInput_Get(self)
    }
    #[inline]
    pub unsafe fn SetSimDevice(&mut self, device: HAL_SimDeviceHandle) {
        frc_DigitalInput_SetSimDevice(self, device)
    }
    #[inline]
    pub unsafe fn new(channel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DigitalInput_DigitalInput(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12DigitalInputD1Ev"]
    pub fn frc_DigitalInput_DigitalInput_destructor(this: *mut frc_DigitalInput);
}
extern "C" {
    #[doc = " @return The HAL Handle to the specified source."]
    #[link_name = "\u{1}_ZNK3frc12DigitalInput23GetPortHandleForRoutingEv"]
    pub fn frc_DigitalInput_GetPortHandleForRouting(
        this: *mut ::std::os::raw::c_void,
    ) -> HAL_Handle;
}
extern "C" {
    #[doc = " @return The type of analog trigger output to be used. 0 for Digitals"]
    #[link_name = "\u{1}_ZNK3frc12DigitalInput30GetAnalogTriggerTypeForRoutingEv"]
    pub fn frc_DigitalInput_GetAnalogTriggerTypeForRouting(
        this: *mut ::std::os::raw::c_void,
    ) -> frc_AnalogTriggerType;
}
extern "C" {
    #[doc = " Is source an AnalogTrigger"]
    #[link_name = "\u{1}_ZNK3frc12DigitalInput15IsAnalogTriggerEv"]
    pub fn frc_DigitalInput_IsAnalogTrigger(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " @return The GPIO channel number that this object represents."]
    #[link_name = "\u{1}_ZNK3frc12DigitalInput10GetChannelEv"]
    pub fn frc_DigitalInput_GetChannel(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZThn4_N3frc12DigitalInput12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_DigitalInput_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Class to write to digital outputs.\n\n Write values to the digital output channels. Other devices implemented\n elsewhere will allocate channels automatically so for those devices it\n shouldn't be done here."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_DigitalOutput {
    pub _base: frc_DigitalSource,
    pub _base_1: wpi_Sendable,
    pub m_channel: ::std::os::raw::c_int,
    pub m_handle: u32,
    pub m_pwmGenerator: u32,
}
#[test]
fn bindgen_test_layout_frc_DigitalOutput() {
    assert_eq!(
        ::std::mem::size_of::<frc_DigitalOutput>(),
        20usize,
        concat!("Size of: ", stringify!(frc_DigitalOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_DigitalOutput>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_DigitalOutput))
    );
}
extern "C" {
    #[doc = " Set the value of a digital output.\n\n Set the value of a digital output to either one (true) or zero (false).\n\n @param value 1 (true) for high, 0 (false) for disabled"]
    #[link_name = "\u{1}_ZN3frc13DigitalOutput3SetEb"]
    pub fn frc_DigitalOutput_Set(this: *mut frc_DigitalOutput, value: bool);
}
extern "C" {
    #[doc = " Gets the value being output from the Digital Output.\n\n @return the state of the digital output."]
    #[link_name = "\u{1}_ZNK3frc13DigitalOutput3GetEv"]
    pub fn frc_DigitalOutput_Get(this: *const frc_DigitalOutput) -> bool;
}
extern "C" {
    #[doc = " Output a single pulse on the digital output line.\n\n Send a single pulse on the digital output line where the pulse duration is\n specified in seconds. Maximum of 65535 microseconds.\n\n @param pulseLength The pulse length in seconds"]
    #[link_name = "\u{1}_ZN3frc13DigitalOutput5PulseEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_DigitalOutput_Pulse(this: *mut frc_DigitalOutput, pulseLength: units_time_second_t);
}
extern "C" {
    #[doc = " Determine if the pulse is still going.\n\n Determine if a previously started pulse is still going."]
    #[link_name = "\u{1}_ZNK3frc13DigitalOutput9IsPulsingEv"]
    pub fn frc_DigitalOutput_IsPulsing(this: *const frc_DigitalOutput) -> bool;
}
extern "C" {
    #[doc = " Change the PWM frequency of the PWM output on a Digital Output line.\n\n The valid range is from 0.6 Hz to 19 kHz.  The frequency resolution is\n logarithmic.\n\n There is only one PWM frequency for all digital channels.\n\n @param rate The frequency to output all digital output PWM signals."]
    #[link_name = "\u{1}_ZN3frc13DigitalOutput10SetPWMRateEd"]
    pub fn frc_DigitalOutput_SetPWMRate(this: *mut frc_DigitalOutput, rate: f64);
}
extern "C" {
    #[doc = " Enable a PWM PPS (Pulse Per Second) Output on this line.\n\n Allocate one of the 6 DO PWM generator resources from this module.\n\n Supply the duty-cycle to output.\n\n The resolution of the duty cycle is 8-bit.\n\n @param dutyCycle The duty-cycle to start generating. [0..1]"]
    #[link_name = "\u{1}_ZN3frc13DigitalOutput9EnablePPSEd"]
    pub fn frc_DigitalOutput_EnablePPS(this: *mut frc_DigitalOutput, dutyCycle: f64);
}
extern "C" {
    #[doc = " Enable a PWM Output on this line.\n\n Allocate one of the 6 DO PWM generator resources from this module.\n\n Supply the initial duty-cycle to output so as to avoid a glitch when first\n starting.\n\n The resolution of the duty cycle is 8-bit for low frequencies (1kHz or\n less) but is reduced the higher the frequency of the PWM signal is.\n\n @param initialDutyCycle The duty-cycle to start generating. [0..1]"]
    #[link_name = "\u{1}_ZN3frc13DigitalOutput9EnablePWMEd"]
    pub fn frc_DigitalOutput_EnablePWM(this: *mut frc_DigitalOutput, initialDutyCycle: f64);
}
extern "C" {
    #[doc = " Change this line from a PWM output back to a static Digital Output line.\n\n Free up one of the 6 DO PWM generator resources that were in use."]
    #[link_name = "\u{1}_ZN3frc13DigitalOutput10DisablePWMEv"]
    pub fn frc_DigitalOutput_DisablePWM(this: *mut frc_DigitalOutput);
}
extern "C" {
    #[doc = " Change the duty-cycle that is being generated on the line.\n\n The resolution of the duty cycle is 8-bit for low frequencies (1kHz or\n less) but is reduced the higher the frequency of the PWM signal is.\n\n @param dutyCycle The duty-cycle to change to. [0..1]"]
    #[link_name = "\u{1}_ZN3frc13DigitalOutput15UpdateDutyCycleEd"]
    pub fn frc_DigitalOutput_UpdateDutyCycle(this: *mut frc_DigitalOutput, dutyCycle: f64);
}
extern "C" {
    #[doc = " Indicates this output is used by a simulated device.\n\n @param device simulated device handle"]
    #[link_name = "\u{1}_ZN3frc13DigitalOutput12SetSimDeviceEi"]
    pub fn frc_DigitalOutput_SetSimDevice(
        this: *mut frc_DigitalOutput,
        device: HAL_SimDeviceHandle,
    );
}
extern "C" {
    #[doc = " Create an instance of a digital output.\n\n Create a digital output given a channel.\n\n @param channel The digital channel 0-9 are on-board, 10-25 are on the MXP\n                port"]
    #[link_name = "\u{1}_ZN3frc13DigitalOutputC1Ei"]
    pub fn frc_DigitalOutput_DigitalOutput(
        this: *mut frc_DigitalOutput,
        channel: ::std::os::raw::c_int,
    );
}
impl frc_DigitalOutput {
    #[inline]
    pub unsafe fn Set(&mut self, value: bool) {
        frc_DigitalOutput_Set(self, value)
    }
    #[inline]
    pub unsafe fn Get(&self) -> bool {
        frc_DigitalOutput_Get(self)
    }
    #[inline]
    pub unsafe fn Pulse(&mut self, pulseLength: units_time_second_t) {
        frc_DigitalOutput_Pulse(self, pulseLength)
    }
    #[inline]
    pub unsafe fn IsPulsing(&self) -> bool {
        frc_DigitalOutput_IsPulsing(self)
    }
    #[inline]
    pub unsafe fn SetPWMRate(&mut self, rate: f64) {
        frc_DigitalOutput_SetPWMRate(self, rate)
    }
    #[inline]
    pub unsafe fn EnablePPS(&mut self, dutyCycle: f64) {
        frc_DigitalOutput_EnablePPS(self, dutyCycle)
    }
    #[inline]
    pub unsafe fn EnablePWM(&mut self, initialDutyCycle: f64) {
        frc_DigitalOutput_EnablePWM(self, initialDutyCycle)
    }
    #[inline]
    pub unsafe fn DisablePWM(&mut self) {
        frc_DigitalOutput_DisablePWM(self)
    }
    #[inline]
    pub unsafe fn UpdateDutyCycle(&mut self, dutyCycle: f64) {
        frc_DigitalOutput_UpdateDutyCycle(self, dutyCycle)
    }
    #[inline]
    pub unsafe fn SetSimDevice(&mut self, device: HAL_SimDeviceHandle) {
        frc_DigitalOutput_SetSimDevice(self, device)
    }
    #[inline]
    pub unsafe fn new(channel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DigitalOutput_DigitalOutput(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc13DigitalOutputD1Ev"]
    pub fn frc_DigitalOutput_DigitalOutput_destructor(this: *mut frc_DigitalOutput);
}
extern "C" {
    #[doc = " @return The HAL Handle to the specified source."]
    #[link_name = "\u{1}_ZNK3frc13DigitalOutput23GetPortHandleForRoutingEv"]
    pub fn frc_DigitalOutput_GetPortHandleForRouting(
        this: *mut ::std::os::raw::c_void,
    ) -> HAL_Handle;
}
extern "C" {
    #[doc = " @return The type of analog trigger output to be used. 0 for Digitals"]
    #[link_name = "\u{1}_ZNK3frc13DigitalOutput30GetAnalogTriggerTypeForRoutingEv"]
    pub fn frc_DigitalOutput_GetAnalogTriggerTypeForRouting(
        this: *mut ::std::os::raw::c_void,
    ) -> frc_AnalogTriggerType;
}
extern "C" {
    #[doc = " Is source an AnalogTrigger"]
    #[link_name = "\u{1}_ZNK3frc13DigitalOutput15IsAnalogTriggerEv"]
    pub fn frc_DigitalOutput_IsAnalogTrigger(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " @return The GPIO channel number that this object represents."]
    #[link_name = "\u{1}_ZNK3frc13DigitalOutput10GetChannelEv"]
    pub fn frc_DigitalOutput_GetChannel(this: *mut ::std::os::raw::c_void)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZThn4_N3frc13DigitalOutput12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_DigitalOutput_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_PWMMotorController {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct frc_DMA {
    pub dmaHandle: u32,
}
#[test]
fn bindgen_test_layout_frc_DMA() {
    const UNINIT: ::std::mem::MaybeUninit<frc_DMA> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_DMA>(),
        4usize,
        concat!("Size of: ", stringify!(frc_DMA))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_DMA>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_DMA))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dmaHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DMA),
            "::",
            stringify!(dmaHandle)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA8SetPauseEb"]
    pub fn frc_DMA_SetPause(this: *mut frc_DMA, pause: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA15SetTimedTriggerEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_DMA_SetTimedTrigger(this: *mut frc_DMA, seconds: units_time_second_t);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA21SetTimedTriggerCyclesEi"]
    pub fn frc_DMA_SetTimedTriggerCycles(this: *mut frc_DMA, cycles: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA10AddEncoderEPKNS_7EncoderE"]
    pub fn frc_DMA_AddEncoder(this: *mut frc_DMA, encoder: *const frc_Encoder);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA16AddEncoderPeriodEPKNS_7EncoderE"]
    pub fn frc_DMA_AddEncoderPeriod(this: *mut frc_DMA, encoder: *const frc_Encoder);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA10AddCounterEPKNS_7CounterE"]
    pub fn frc_DMA_AddCounter(this: *mut frc_DMA, counter: *const frc_Counter);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA16AddCounterPeriodEPKNS_7CounterE"]
    pub fn frc_DMA_AddCounterPeriod(this: *mut frc_DMA, counter: *const frc_Counter);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA16AddDigitalSourceEPKNS_13DigitalSourceE"]
    pub fn frc_DMA_AddDigitalSource(this: *mut frc_DMA, digitalSource: *const frc_DigitalSource);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA12AddDutyCycleEPKNS_9DutyCycleE"]
    pub fn frc_DMA_AddDutyCycle(this: *mut frc_DMA, digitalSource: *const frc_DutyCycle);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA14AddAnalogInputEPKNS_11AnalogInputE"]
    pub fn frc_DMA_AddAnalogInput(this: *mut frc_DMA, analogInput: *const frc_AnalogInput);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA22AddAveragedAnalogInputEPKNS_11AnalogInputE"]
    pub fn frc_DMA_AddAveragedAnalogInput(this: *mut frc_DMA, analogInput: *const frc_AnalogInput);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA20AddAnalogAccumulatorEPKNS_11AnalogInputE"]
    pub fn frc_DMA_AddAnalogAccumulator(this: *mut frc_DMA, analogInput: *const frc_AnalogInput);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA18SetExternalTriggerEPNS_13DigitalSourceEbb"]
    pub fn frc_DMA_SetExternalTrigger(
        this: *mut frc_DMA,
        source: *mut frc_DigitalSource,
        rising: bool,
        falling: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA17SetPwmEdgeTriggerEPNS_3PWMEbb"]
    pub fn frc_DMA_SetPwmEdgeTrigger(
        this: *mut frc_DMA,
        pwm: *mut frc_PWM,
        rising: bool,
        falling: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA17SetPwmEdgeTriggerEPNS_18PWMMotorControllerEbb"]
    pub fn frc_DMA_SetPwmEdgeTrigger1(
        this: *mut frc_DMA,
        pwm: *mut frc_PWMMotorController,
        rising: bool,
        falling: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA12ClearSensorsEv"]
    pub fn frc_DMA_ClearSensors(this: *mut frc_DMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA21ClearExternalTriggersEv"]
    pub fn frc_DMA_ClearExternalTriggers(this: *mut frc_DMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA5StartEi"]
    pub fn frc_DMA_Start(this: *mut frc_DMA, queueDepth: ::std::os::raw::c_int);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMA4StopEv"]
    pub fn frc_DMA_Stop(this: *mut frc_DMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMAC1Ev"]
    pub fn frc_DMA_DMA(this: *mut frc_DMA);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3DMAD1Ev"]
    pub fn frc_DMA_DMA_destructor(this: *mut frc_DMA);
}
impl frc_DMA {
    #[inline]
    pub unsafe fn SetPause(&mut self, pause: bool) {
        frc_DMA_SetPause(self, pause)
    }
    #[inline]
    pub unsafe fn SetTimedTrigger(&mut self, seconds: units_time_second_t) {
        frc_DMA_SetTimedTrigger(self, seconds)
    }
    #[inline]
    pub unsafe fn SetTimedTriggerCycles(&mut self, cycles: ::std::os::raw::c_int) {
        frc_DMA_SetTimedTriggerCycles(self, cycles)
    }
    #[inline]
    pub unsafe fn AddEncoder(&mut self, encoder: *const frc_Encoder) {
        frc_DMA_AddEncoder(self, encoder)
    }
    #[inline]
    pub unsafe fn AddEncoderPeriod(&mut self, encoder: *const frc_Encoder) {
        frc_DMA_AddEncoderPeriod(self, encoder)
    }
    #[inline]
    pub unsafe fn AddCounter(&mut self, counter: *const frc_Counter) {
        frc_DMA_AddCounter(self, counter)
    }
    #[inline]
    pub unsafe fn AddCounterPeriod(&mut self, counter: *const frc_Counter) {
        frc_DMA_AddCounterPeriod(self, counter)
    }
    #[inline]
    pub unsafe fn AddDigitalSource(&mut self, digitalSource: *const frc_DigitalSource) {
        frc_DMA_AddDigitalSource(self, digitalSource)
    }
    #[inline]
    pub unsafe fn AddDutyCycle(&mut self, digitalSource: *const frc_DutyCycle) {
        frc_DMA_AddDutyCycle(self, digitalSource)
    }
    #[inline]
    pub unsafe fn AddAnalogInput(&mut self, analogInput: *const frc_AnalogInput) {
        frc_DMA_AddAnalogInput(self, analogInput)
    }
    #[inline]
    pub unsafe fn AddAveragedAnalogInput(&mut self, analogInput: *const frc_AnalogInput) {
        frc_DMA_AddAveragedAnalogInput(self, analogInput)
    }
    #[inline]
    pub unsafe fn AddAnalogAccumulator(&mut self, analogInput: *const frc_AnalogInput) {
        frc_DMA_AddAnalogAccumulator(self, analogInput)
    }
    #[inline]
    pub unsafe fn SetExternalTrigger(
        &mut self,
        source: *mut frc_DigitalSource,
        rising: bool,
        falling: bool,
    ) -> ::std::os::raw::c_int {
        frc_DMA_SetExternalTrigger(self, source, rising, falling)
    }
    #[inline]
    pub unsafe fn SetPwmEdgeTrigger(
        &mut self,
        pwm: *mut frc_PWM,
        rising: bool,
        falling: bool,
    ) -> ::std::os::raw::c_int {
        frc_DMA_SetPwmEdgeTrigger(self, pwm, rising, falling)
    }
    #[inline]
    pub unsafe fn SetPwmEdgeTrigger1(
        &mut self,
        pwm: *mut frc_PWMMotorController,
        rising: bool,
        falling: bool,
    ) -> ::std::os::raw::c_int {
        frc_DMA_SetPwmEdgeTrigger1(self, pwm, rising, falling)
    }
    #[inline]
    pub unsafe fn ClearSensors(&mut self) {
        frc_DMA_ClearSensors(self)
    }
    #[inline]
    pub unsafe fn ClearExternalTriggers(&mut self) {
        frc_DMA_ClearExternalTriggers(self)
    }
    #[inline]
    pub unsafe fn Start(&mut self, queueDepth: ::std::os::raw::c_int) {
        frc_DMA_Start(self, queueDepth)
    }
    #[inline]
    pub unsafe fn Stop(&mut self) {
        frc_DMA_Stop(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DMA_DMA(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        frc_DMA_DMA_destructor(self)
    }
}
#[doc = " Class to read a duty cycle PWM input.\n\n <p>PWM input signals are specified with a frequency and a ratio of high to\n low in that frequency. There are 8 of these in the roboRIO, and they can be\n attached to any DigitalSource.\n\n <p>These can be combined as the input of an AnalogTrigger to a Counter in\n order to implement rollover checking.\n"]
#[repr(C)]
#[derive(Debug)]
pub struct frc_DutyCycle {
    pub _base: wpi_Sendable,
    pub m_source: [u32; 2usize],
    pub m_handle: u32,
}
#[test]
fn bindgen_test_layout_frc_DutyCycle() {
    const UNINIT: ::std::mem::MaybeUninit<frc_DutyCycle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_DutyCycle>(),
        16usize,
        concat!("Size of: ", stringify!(frc_DutyCycle))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_DutyCycle>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_DutyCycle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_source) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycle),
            "::",
            stringify!(m_source)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycle),
            "::",
            stringify!(m_handle)
        )
    );
}
extern "C" {
    #[doc = " Get the frequency of the duty cycle signal.\n\n @return frequency in Hertz"]
    #[link_name = "\u{1}_ZNK3frc9DutyCycle12GetFrequencyEv"]
    pub fn frc_DutyCycle_GetFrequency(this: *const frc_DutyCycle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the output ratio of the duty cycle signal.\n\n <p> 0 means always low, 1 means always high.\n\n @return output ratio between 0 and 1"]
    #[link_name = "\u{1}_ZNK3frc9DutyCycle9GetOutputEv"]
    pub fn frc_DutyCycle_GetOutput(this: *const frc_DutyCycle) -> f64;
}
extern "C" {
    #[doc = " Get the raw high time of the duty cycle signal.\n\n @return high time of last pulse"]
    #[link_name = "\u{1}_ZNK3frc9DutyCycle11GetHighTimeEv"]
    pub fn frc_DutyCycle_GetHighTime(this: *const frc_DutyCycle) -> units_time_second_t;
}
extern "C" {
    #[doc = " Get the scale factor of the output.\n\n <p> An output equal to this value is always high, and then linearly scales\n down to 0. Divide a raw result by this in order to get the\n percentage between 0 and 1. Used by DMA.\n\n @return the output scale factor"]
    #[link_name = "\u{1}_ZNK3frc9DutyCycle20GetOutputScaleFactorEv"]
    pub fn frc_DutyCycle_GetOutputScaleFactor(this: *const frc_DutyCycle)
        -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Get the FPGA index for the DutyCycle.\n\n @return the FPGA index"]
    #[link_name = "\u{1}_ZNK3frc9DutyCycle12GetFPGAIndexEv"]
    pub fn frc_DutyCycle_GetFPGAIndex(this: *const frc_DutyCycle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the channel of the source.\n\n @return the source channel"]
    #[link_name = "\u{1}_ZNK3frc9DutyCycle16GetSourceChannelEv"]
    pub fn frc_DutyCycle_GetSourceChannel(this: *const frc_DutyCycle) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Constructs a DutyCycle input from a DigitalSource input.\n\n <p> This class does not own the inputted source.\n\n @param source The DigitalSource to use."]
    #[link_name = "\u{1}_ZN3frc9DutyCycleC1ERNS_13DigitalSourceE"]
    pub fn frc_DutyCycle_DutyCycle(this: *mut frc_DutyCycle, source: *mut frc_DigitalSource);
}
extern "C" {
    #[doc = " Constructs a DutyCycle input from a DigitalSource input.\n\n <p> This class does not own the inputted source.\n\n @param source The DigitalSource to use."]
    #[link_name = "\u{1}_ZN3frc9DutyCycleC1EPNS_13DigitalSourceE"]
    pub fn frc_DutyCycle_DutyCycle1(this: *mut frc_DutyCycle, source: *mut frc_DigitalSource);
}
extern "C" {
    #[doc = " Constructs a DutyCycle input from a DigitalSource input.\n\n <p> This class does not own the inputted source.\n\n @param source The DigitalSource to use."]
    #[link_name = "\u{1}_ZN3frc9DutyCycleC1ESt10shared_ptrINS_13DigitalSourceEE"]
    pub fn frc_DutyCycle_DutyCycle2(this: *mut frc_DutyCycle, source: [u32; 2usize]);
}
impl frc_DutyCycle {
    #[inline]
    pub unsafe fn GetFrequency(&self) -> ::std::os::raw::c_int {
        frc_DutyCycle_GetFrequency(self)
    }
    #[inline]
    pub unsafe fn GetOutput(&self) -> f64 {
        frc_DutyCycle_GetOutput(self)
    }
    #[inline]
    pub unsafe fn GetHighTime(&self) -> units_time_second_t {
        frc_DutyCycle_GetHighTime(self)
    }
    #[inline]
    pub unsafe fn GetOutputScaleFactor(&self) -> ::std::os::raw::c_uint {
        frc_DutyCycle_GetOutputScaleFactor(self)
    }
    #[inline]
    pub unsafe fn GetFPGAIndex(&self) -> ::std::os::raw::c_int {
        frc_DutyCycle_GetFPGAIndex(self)
    }
    #[inline]
    pub unsafe fn GetSourceChannel(&self) -> ::std::os::raw::c_int {
        frc_DutyCycle_GetSourceChannel(self)
    }
    #[inline]
    pub unsafe fn new(source: *mut frc_DigitalSource) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DutyCycle_DutyCycle(__bindgen_tmp.as_mut_ptr(), source);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(source: *mut frc_DigitalSource) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DutyCycle_DutyCycle1(__bindgen_tmp.as_mut_ptr(), source);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(source: [u32; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DutyCycle_DutyCycle2(__bindgen_tmp.as_mut_ptr(), source);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Close the DutyCycle and free all resources."]
    #[link_name = "\u{1}_ZN3frc9DutyCycleD1Ev"]
    pub fn frc_DutyCycle_DutyCycle_destructor(this: *mut frc_DutyCycle);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc9DutyCycle12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_DutyCycle_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Class to read quad encoders.\n\n Quadrature encoders are devices that count shaft rotation and can sense\n direction. The output of the QuadEncoder class is an integer that can count\n either up or down, and can go negative for reverse direction counting. When\n creating QuadEncoders, a direction is supplied that changes the sense of the\n output to make code more readable if the encoder is mounted such that forward\n movement generates negative values. Quadrature encoders have two digital\n outputs, an A Channel and a B Channel that are out of phase with each other\n to allow the FPGA to do direction sensing.\n\n All encoders will immediately start counting - Reset() them if you need them\n to be zeroed before use."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Encoder {
    pub _base: frc_CounterBase,
    pub _base_1: wpi_Sendable,
    pub m_aSource: [u32; 2usize],
    pub m_bSource: [u32; 2usize],
    pub m_indexSource: [u32; 2usize],
    pub m_encoder: u32,
}
pub const frc_Encoder_IndexingType_kResetWhileHigh: frc_Encoder_IndexingType = 0;
pub const frc_Encoder_IndexingType_kResetWhileLow: frc_Encoder_IndexingType = 1;
pub const frc_Encoder_IndexingType_kResetOnFallingEdge: frc_Encoder_IndexingType = 2;
pub const frc_Encoder_IndexingType_kResetOnRisingEdge: frc_Encoder_IndexingType = 3;
pub type frc_Encoder_IndexingType = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_frc_Encoder() {
    assert_eq!(
        ::std::mem::size_of::<frc_Encoder>(),
        36usize,
        concat!("Size of: ", stringify!(frc_Encoder))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Encoder>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_Encoder))
    );
}
extern "C" {
    #[doc = " Gets the raw value from the encoder.\n\n The raw value is the actual count unscaled by the 1x, 2x, or 4x scale\n factor.\n\n @return Current raw count from the encoder"]
    #[link_name = "\u{1}_ZNK3frc7Encoder6GetRawEv"]
    pub fn frc_Encoder_GetRaw(this: *const frc_Encoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The encoding scale factor 1x, 2x, or 4x, per the requested encodingType.\n\n Used to divide raw edge counts down to spec'd counts."]
    #[link_name = "\u{1}_ZNK3frc7Encoder16GetEncodingScaleEv"]
    pub fn frc_Encoder_GetEncodingScale(this: *const frc_Encoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the distance the robot has driven since the last reset.\n\n @return The distance driven since the last reset as scaled by the value\n         from SetDistancePerPulse()."]
    #[link_name = "\u{1}_ZNK3frc7Encoder11GetDistanceEv"]
    pub fn frc_Encoder_GetDistance(this: *const frc_Encoder) -> f64;
}
extern "C" {
    #[doc = " Get the current rate of the encoder.\n\n Units are distance per second as scaled by the value from\n SetDistancePerPulse().\n\n @return The current rate of the encoder."]
    #[link_name = "\u{1}_ZNK3frc7Encoder7GetRateEv"]
    pub fn frc_Encoder_GetRate(this: *const frc_Encoder) -> f64;
}
extern "C" {
    #[doc = " Set the minimum rate of the device before the hardware reports it stopped.\n\n @param minRate The minimum rate.  The units are in distance per second as\n                scaled by the value from SetDistancePerPulse()."]
    #[link_name = "\u{1}_ZN3frc7Encoder10SetMinRateEd"]
    pub fn frc_Encoder_SetMinRate(this: *mut frc_Encoder, minRate: f64);
}
extern "C" {
    #[doc = " Set the distance per pulse for this encoder.\n\n This sets the multiplier used to determine the distance driven based on the\n count value from the encoder.\n\n Do not include the decoding type in this scale.  The library already\n compensates for the decoding type.\n\n Set this value based on the encoder's rated Pulses per Revolution and\n factor in gearing reductions following the encoder shaft.\n\n This distance can be in any units you like, linear or angular.\n\n @param distancePerPulse The scale factor that will be used to convert\n                         pulses to useful units."]
    #[link_name = "\u{1}_ZN3frc7Encoder19SetDistancePerPulseEd"]
    pub fn frc_Encoder_SetDistancePerPulse(this: *mut frc_Encoder, distancePerPulse: f64);
}
extern "C" {
    #[doc = " Get the distance per pulse for this encoder.\n\n @return The scale factor that will be used to convert pulses to useful\n         units."]
    #[link_name = "\u{1}_ZNK3frc7Encoder19GetDistancePerPulseEv"]
    pub fn frc_Encoder_GetDistancePerPulse(this: *const frc_Encoder) -> f64;
}
extern "C" {
    #[doc = " Set the direction sensing for this encoder.\n\n This sets the direction sensing on the encoder so that it could count in\n the correct software direction regardless of the mounting.\n\n @param reverseDirection true if the encoder direction should be reversed"]
    #[link_name = "\u{1}_ZN3frc7Encoder19SetReverseDirectionEb"]
    pub fn frc_Encoder_SetReverseDirection(this: *mut frc_Encoder, reverseDirection: bool);
}
extern "C" {
    #[doc = " Set the Samples to Average which specifies the number of samples of the\n timer to average when calculating the period.\n\n Perform averaging to account for mechanical imperfections or as\n oversampling to increase resolution.\n\n @param samplesToAverage The number of samples to average from 1 to 127."]
    #[link_name = "\u{1}_ZN3frc7Encoder19SetSamplesToAverageEi"]
    pub fn frc_Encoder_SetSamplesToAverage(
        this: *mut frc_Encoder,
        samplesToAverage: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get the Samples to Average which specifies the number of samples of the\n timer to average when calculating the period.\n\n Perform averaging to account for mechanical imperfections or as\n oversampling to increase resolution.\n\n @return The number of samples being averaged (from 1 to 127)"]
    #[link_name = "\u{1}_ZNK3frc7Encoder19GetSamplesToAverageEv"]
    pub fn frc_Encoder_GetSamplesToAverage(this: *const frc_Encoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the index source for the encoder.\n\n When this source is activated, the encoder count automatically resets.\n\n @param channel A DIO channel to set as the encoder index\n @param type    The state that will cause the encoder to reset"]
    #[link_name = "\u{1}_ZN3frc7Encoder14SetIndexSourceEiNS0_12IndexingTypeE"]
    pub fn frc_Encoder_SetIndexSource(
        this: *mut frc_Encoder,
        channel: ::std::os::raw::c_int,
        type_: frc_Encoder_IndexingType,
    );
}
extern "C" {
    #[doc = " Set the index source for the encoder.\n\n When this source is activated, the encoder count automatically resets.\n\n @param source A digital source to set as the encoder index\n @param type   The state that will cause the encoder to reset"]
    #[link_name = "\u{1}_ZN3frc7Encoder14SetIndexSourceERKNS_13DigitalSourceENS0_12IndexingTypeE"]
    pub fn frc_Encoder_SetIndexSource1(
        this: *mut frc_Encoder,
        source: *const frc_DigitalSource,
        type_: frc_Encoder_IndexingType,
    );
}
extern "C" {
    #[doc = " Indicates this encoder is used by a simulated device.\n\n @param device simulated device handle"]
    #[link_name = "\u{1}_ZN3frc7Encoder12SetSimDeviceEi"]
    pub fn frc_Encoder_SetSimDevice(this: *mut frc_Encoder, device: HAL_SimDeviceHandle);
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc7Encoder12GetFPGAIndexEv"]
    pub fn frc_Encoder_GetFPGAIndex(this: *const frc_Encoder) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encoder constructor.\n\n Construct a Encoder given a and b channels.\n\n The counter will start counting immediately.\n\n @param aChannel         The a channel DIO channel. 0-9 are on-board, 10-25\n                         are on the MXP port\n @param bChannel         The b channel DIO channel. 0-9 are on-board, 10-25\n                         are on the MXP port\n @param reverseDirection represents the orientation of the encoder and\n                         inverts the output values if necessary so forward\n                         represents positive values.\n @param encodingType     either k1X, k2X, or k4X to indicate 1X, 2X or 4X\n                         decoding. If 4X is selected, then an encoder FPGA\n                         object is used and the returned counts will be 4x\n                         the encoder spec'd value since all rising and\n                         falling edges are counted. If 1X or 2X are selected\n                         then a counter object will be used and the returned\n                         value will either exactly match the spec'd count or\n                         be double (2x) the spec'd count."]
    #[link_name = "\u{1}_ZN3frc7EncoderC1EiibNS_11CounterBase12EncodingTypeE"]
    pub fn frc_Encoder_Encoder(
        this: *mut frc_Encoder,
        aChannel: ::std::os::raw::c_int,
        bChannel: ::std::os::raw::c_int,
        reverseDirection: bool,
        encodingType: frc_CounterBase_EncodingType,
    );
}
extern "C" {
    #[doc = " Encoder constructor.\n\n Construct a Encoder given a and b channels as digital inputs. This is used\n in the case where the digital inputs are shared. The Encoder class will not\n allocate the digital inputs and assume that they already are counted.\n\n The counter will start counting immediately.\n\n @param aSource          The source that should be used for the a channel.\n @param bSource          the source that should be used for the b channel.\n @param reverseDirection represents the orientation of the encoder and\n                         inverts the output values if necessary so forward\n                         represents positive values.\n @param encodingType     either k1X, k2X, or k4X to indicate 1X, 2X or 4X\n                         decoding. If 4X is selected, then an encoder FPGA\n                         object is used and the returned counts will be 4x\n                         the encoder spec'd value since all rising and\n                         falling edges are counted. If 1X or 2X are selected\n                         then a counter object will be used and the returned\n                         value will either exactly match the spec'd count or\n                         be double (2x) the spec'd count."]
    #[link_name = "\u{1}_ZN3frc7EncoderC1EPNS_13DigitalSourceES2_bNS_11CounterBase12EncodingTypeE"]
    pub fn frc_Encoder_Encoder1(
        this: *mut frc_Encoder,
        aSource: *mut frc_DigitalSource,
        bSource: *mut frc_DigitalSource,
        reverseDirection: bool,
        encodingType: frc_CounterBase_EncodingType,
    );
}
extern "C" {
    #[doc = " Encoder constructor.\n\n Construct a Encoder given a and b channels as digital inputs. This is used\n in the case where the digital inputs are shared. The Encoder class will not\n allocate the digital inputs and assume that they already are counted.\n\n The counter will start counting immediately.\n\n @param aSource          The source that should be used for the a channel.\n @param bSource          the source that should be used for the b channel.\n @param reverseDirection represents the orientation of the encoder and\n                         inverts the output values if necessary so forward\n                         represents positive values.\n @param encodingType     either k1X, k2X, or k4X to indicate 1X, 2X or 4X\n                         decoding. If 4X is selected, then an encoder FPGA\n                         object is used and the returned counts will be 4x\n                         the encoder spec'd value since all rising and\n                         falling edges are counted. If 1X or 2X are selected\n                         then a counter object will be used and the returned\n                         value will either exactly match the spec'd count or\n                         be double (2x) the spec'd count."]
    #[link_name = "\u{1}_ZN3frc7EncoderC1ERNS_13DigitalSourceES2_bNS_11CounterBase12EncodingTypeE"]
    pub fn frc_Encoder_Encoder2(
        this: *mut frc_Encoder,
        aSource: *mut frc_DigitalSource,
        bSource: *mut frc_DigitalSource,
        reverseDirection: bool,
        encodingType: frc_CounterBase_EncodingType,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7EncoderC1ESt10shared_ptrINS_13DigitalSourceEES3_bNS_11CounterBase12EncodingTypeE"]
    pub fn frc_Encoder_Encoder3(
        this: *mut frc_Encoder,
        aSource: [u32; 2usize],
        bSource: [u32; 2usize],
        reverseDirection: bool,
        encodingType: frc_CounterBase_EncodingType,
    );
}
impl frc_Encoder {
    #[inline]
    pub unsafe fn GetRaw(&self) -> ::std::os::raw::c_int {
        frc_Encoder_GetRaw(self)
    }
    #[inline]
    pub unsafe fn GetEncodingScale(&self) -> ::std::os::raw::c_int {
        frc_Encoder_GetEncodingScale(self)
    }
    #[inline]
    pub unsafe fn GetDistance(&self) -> f64 {
        frc_Encoder_GetDistance(self)
    }
    #[inline]
    pub unsafe fn GetRate(&self) -> f64 {
        frc_Encoder_GetRate(self)
    }
    #[inline]
    pub unsafe fn SetMinRate(&mut self, minRate: f64) {
        frc_Encoder_SetMinRate(self, minRate)
    }
    #[inline]
    pub unsafe fn SetDistancePerPulse(&mut self, distancePerPulse: f64) {
        frc_Encoder_SetDistancePerPulse(self, distancePerPulse)
    }
    #[inline]
    pub unsafe fn GetDistancePerPulse(&self) -> f64 {
        frc_Encoder_GetDistancePerPulse(self)
    }
    #[inline]
    pub unsafe fn SetReverseDirection(&mut self, reverseDirection: bool) {
        frc_Encoder_SetReverseDirection(self, reverseDirection)
    }
    #[inline]
    pub unsafe fn SetSamplesToAverage(&mut self, samplesToAverage: ::std::os::raw::c_int) {
        frc_Encoder_SetSamplesToAverage(self, samplesToAverage)
    }
    #[inline]
    pub unsafe fn GetSamplesToAverage(&self) -> ::std::os::raw::c_int {
        frc_Encoder_GetSamplesToAverage(self)
    }
    #[inline]
    pub unsafe fn SetIndexSource(
        &mut self,
        channel: ::std::os::raw::c_int,
        type_: frc_Encoder_IndexingType,
    ) {
        frc_Encoder_SetIndexSource(self, channel, type_)
    }
    #[inline]
    pub unsafe fn SetIndexSource1(
        &mut self,
        source: *const frc_DigitalSource,
        type_: frc_Encoder_IndexingType,
    ) {
        frc_Encoder_SetIndexSource1(self, source, type_)
    }
    #[inline]
    pub unsafe fn SetSimDevice(&mut self, device: HAL_SimDeviceHandle) {
        frc_Encoder_SetSimDevice(self, device)
    }
    #[inline]
    pub unsafe fn GetFPGAIndex(&self) -> ::std::os::raw::c_int {
        frc_Encoder_GetFPGAIndex(self)
    }
    #[inline]
    pub unsafe fn new(
        aChannel: ::std::os::raw::c_int,
        bChannel: ::std::os::raw::c_int,
        reverseDirection: bool,
        encodingType: frc_CounterBase_EncodingType,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Encoder_Encoder(
            __bindgen_tmp.as_mut_ptr(),
            aChannel,
            bChannel,
            reverseDirection,
            encodingType,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        aSource: *mut frc_DigitalSource,
        bSource: *mut frc_DigitalSource,
        reverseDirection: bool,
        encodingType: frc_CounterBase_EncodingType,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Encoder_Encoder1(
            __bindgen_tmp.as_mut_ptr(),
            aSource,
            bSource,
            reverseDirection,
            encodingType,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        aSource: *mut frc_DigitalSource,
        bSource: *mut frc_DigitalSource,
        reverseDirection: bool,
        encodingType: frc_CounterBase_EncodingType,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Encoder_Encoder2(
            __bindgen_tmp.as_mut_ptr(),
            aSource,
            bSource,
            reverseDirection,
            encodingType,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        aSource: [u32; 2usize],
        bSource: [u32; 2usize],
        reverseDirection: bool,
        encodingType: frc_CounterBase_EncodingType,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Encoder_Encoder3(
            __bindgen_tmp.as_mut_ptr(),
            aSource,
            bSource,
            reverseDirection,
            encodingType,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7EncoderD1Ev"]
    pub fn frc_Encoder_Encoder_destructor(this: *mut frc_Encoder);
}
extern "C" {
    #[doc = " Gets the current count.\n\n Returns the current count on the Encoder. This method compensates for the\n decoding type.\n\n @return Current count from the Encoder adjusted for the 1x, 2x, or 4x scale\n         factor."]
    #[link_name = "\u{1}_ZNK3frc7Encoder3GetEv"]
    pub fn frc_Encoder_Get(this: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Reset the Encoder distance to zero.\n\n Resets the current count to zero on the encoder."]
    #[link_name = "\u{1}_ZN3frc7Encoder5ResetEv"]
    pub fn frc_Encoder_Reset(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Returns the period of the most recent pulse.\n\n Returns the period of the most recent Encoder pulse in seconds. This method\n compensates for the decoding type.\n\n Warning: This returns unscaled periods. Use GetRate() for rates that are\n scaled using the value from SetDistancePerPulse().\n\n @return Period in seconds of the most recent pulse.\n @deprecated Use getRate() in favor of this method."]
    #[link_name = "\u{1}_ZNK3frc7Encoder9GetPeriodEv"]
    pub fn frc_Encoder_GetPeriod(this: *mut ::std::os::raw::c_void) -> units_time_second_t;
}
extern "C" {
    #[doc = " Sets the maximum period for stopped detection.\n\n Sets the value that represents the maximum period of the Encoder before it\n will assume that the attached device is stopped. This timeout allows users\n to determine if the wheels or other shaft has stopped rotating.\n This method compensates for the decoding type.\n\n @param maxPeriod The maximum time between rising and falling edges before\n                  the FPGA will report the device stopped. This is expressed\n                  in seconds.\n @deprecated Use SetMinRate() in favor of this method.  This takes unscaled\n             periods and SetMinRate() scales using value from\n             SetDistancePerPulse()."]
    #[link_name = "\u{1}_ZN3frc7Encoder12SetMaxPeriodEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_Encoder_SetMaxPeriod(
        this: *mut ::std::os::raw::c_void,
        maxPeriod: units_time_second_t,
    );
}
extern "C" {
    #[doc = " Determine if the encoder is stopped.\n\n Using the MaxPeriod value, a boolean is returned that is true if the\n encoder is considered stopped and false if it is still moving. A stopped\n encoder is one where the most recent pulse width exceeds the MaxPeriod.\n\n @return True if the encoder is considered stopped."]
    #[link_name = "\u{1}_ZNK3frc7Encoder10GetStoppedEv"]
    pub fn frc_Encoder_GetStopped(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " The last direction the encoder value changed.\n\n @return The last direction the encoder value changed."]
    #[link_name = "\u{1}_ZNK3frc7Encoder12GetDirectionEv"]
    pub fn frc_Encoder_GetDirection(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZThn4_N3frc7Encoder12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_Encoder_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_DMASample {
    pub _base: HAL_DMASample,
}
pub const frc_DMASample_DMAReadStatus_kOk: frc_DMASample_DMAReadStatus = 1;
pub const frc_DMASample_DMAReadStatus_kTimeout: frc_DMASample_DMAReadStatus = 2;
pub const frc_DMASample_DMAReadStatus_kError: frc_DMASample_DMAReadStatus = 3;
pub type frc_DMASample_DMAReadStatus = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_frc_DMASample() {
    assert_eq!(
        ::std::mem::size_of::<frc_DMASample>(),
        400usize,
        concat!("Size of: ", stringify!(frc_DMASample))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_DMASample>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_DMASample))
    );
}
#[doc = " DoubleSolenoid class for running 2 channels of high voltage Digital Output\n on a pneumatics module.\n\n The DoubleSolenoid class is typically used for pneumatics solenoids that\n have two positions controlled by two separate channels."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_DoubleSolenoid {
    pub _base: wpi_Sendable,
    pub m_module: [u32; 2usize],
    pub m_forwardChannel: ::std::os::raw::c_int,
    pub m_reverseChannel: ::std::os::raw::c_int,
    pub m_forwardMask: ::std::os::raw::c_int,
    pub m_reverseMask: ::std::os::raw::c_int,
    pub m_mask: ::std::os::raw::c_int,
}
pub const frc_DoubleSolenoid_Value_kOff: frc_DoubleSolenoid_Value = 0;
pub const frc_DoubleSolenoid_Value_kForward: frc_DoubleSolenoid_Value = 1;
pub const frc_DoubleSolenoid_Value_kReverse: frc_DoubleSolenoid_Value = 2;
pub type frc_DoubleSolenoid_Value = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_frc_DoubleSolenoid() {
    const UNINIT: ::std::mem::MaybeUninit<frc_DoubleSolenoid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_DoubleSolenoid>(),
        32usize,
        concat!("Size of: ", stringify!(frc_DoubleSolenoid))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_DoubleSolenoid>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_DoubleSolenoid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DoubleSolenoid),
            "::",
            stringify!(m_module)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_forwardChannel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DoubleSolenoid),
            "::",
            stringify!(m_forwardChannel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_reverseChannel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DoubleSolenoid),
            "::",
            stringify!(m_reverseChannel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_forwardMask) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DoubleSolenoid),
            "::",
            stringify!(m_forwardMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_reverseMask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DoubleSolenoid),
            "::",
            stringify!(m_reverseMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mask) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DoubleSolenoid),
            "::",
            stringify!(m_mask)
        )
    );
}
extern "C" {
    #[doc = " Toggle the value of the solenoid.\n\n If the solenoid is set to forward, it'll be set to reverse. If the solenoid\n is set to reverse, it'll be set to forward. If the solenoid is set to off,\n nothing happens."]
    #[link_name = "\u{1}_ZN3frc14DoubleSolenoid6ToggleEv"]
    pub fn frc_DoubleSolenoid_Toggle(this: *mut frc_DoubleSolenoid);
}
extern "C" {
    #[doc = " Get the forward channel.\n\n @return the forward channel."]
    #[link_name = "\u{1}_ZNK3frc14DoubleSolenoid13GetFwdChannelEv"]
    pub fn frc_DoubleSolenoid_GetFwdChannel(
        this: *const frc_DoubleSolenoid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the reverse channel.\n\n @return the reverse channel."]
    #[link_name = "\u{1}_ZNK3frc14DoubleSolenoid13GetRevChannelEv"]
    pub fn frc_DoubleSolenoid_GetRevChannel(
        this: *const frc_DoubleSolenoid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if the forward solenoid is Disabled.\n\n If a solenoid is shorted, it is added to the DisabledList and disabled\n until power cycle, or until faults are cleared.\n\n @see ClearAllPCMStickyFaults()\n @return If solenoid is disabled due to short."]
    #[link_name = "\u{1}_ZNK3frc14DoubleSolenoid21IsFwdSolenoidDisabledEv"]
    pub fn frc_DoubleSolenoid_IsFwdSolenoidDisabled(this: *const frc_DoubleSolenoid) -> bool;
}
extern "C" {
    #[doc = " Check if the reverse solenoid is Disabled.\n\n If a solenoid is shorted, it is added to the DisabledList and disabled\n until power cycle, or until faults are cleared.\n\n @see ClearAllPCMStickyFaults()\n @return If solenoid is disabled due to short."]
    #[link_name = "\u{1}_ZNK3frc14DoubleSolenoid21IsRevSolenoidDisabledEv"]
    pub fn frc_DoubleSolenoid_IsRevSolenoidDisabled(this: *const frc_DoubleSolenoid) -> bool;
}
extern "C" {
    #[doc = " Constructs a double solenoid for a specified module of a specific module\n type.\n\n @param module The module of the solenoid module to use.\n @param moduleType The module type to use.\n @param forwardChannel The forward channel on the module to control.\n @param reverseChannel The reverse channel on the module to control."]
    #[link_name = "\u{1}_ZN3frc14DoubleSolenoidC1EiNS_20PneumaticsModuleTypeEii"]
    pub fn frc_DoubleSolenoid_DoubleSolenoid(
        this: *mut frc_DoubleSolenoid,
        module: ::std::os::raw::c_int,
        moduleType: frc_PneumaticsModuleType,
        forwardChannel: ::std::os::raw::c_int,
        reverseChannel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Constructs a double solenoid for a default module of a specific module\n type.\n\n @param moduleType The module type to use.\n @param forwardChannel The forward channel on the module to control.\n @param reverseChannel The reverse channel on the module to control."]
    #[link_name = "\u{1}_ZN3frc14DoubleSolenoidC1ENS_20PneumaticsModuleTypeEii"]
    pub fn frc_DoubleSolenoid_DoubleSolenoid1(
        this: *mut frc_DoubleSolenoid,
        moduleType: frc_PneumaticsModuleType,
        forwardChannel: ::std::os::raw::c_int,
        reverseChannel: ::std::os::raw::c_int,
    );
}
impl frc_DoubleSolenoid {
    #[inline]
    pub unsafe fn Toggle(&mut self) {
        frc_DoubleSolenoid_Toggle(self)
    }
    #[inline]
    pub unsafe fn GetFwdChannel(&self) -> ::std::os::raw::c_int {
        frc_DoubleSolenoid_GetFwdChannel(self)
    }
    #[inline]
    pub unsafe fn GetRevChannel(&self) -> ::std::os::raw::c_int {
        frc_DoubleSolenoid_GetRevChannel(self)
    }
    #[inline]
    pub unsafe fn IsFwdSolenoidDisabled(&self) -> bool {
        frc_DoubleSolenoid_IsFwdSolenoidDisabled(self)
    }
    #[inline]
    pub unsafe fn IsRevSolenoidDisabled(&self) -> bool {
        frc_DoubleSolenoid_IsRevSolenoidDisabled(self)
    }
    #[inline]
    pub unsafe fn new(
        module: ::std::os::raw::c_int,
        moduleType: frc_PneumaticsModuleType,
        forwardChannel: ::std::os::raw::c_int,
        reverseChannel: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DoubleSolenoid_DoubleSolenoid(
            __bindgen_tmp.as_mut_ptr(),
            module,
            moduleType,
            forwardChannel,
            reverseChannel,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        moduleType: frc_PneumaticsModuleType,
        forwardChannel: ::std::os::raw::c_int,
        reverseChannel: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DoubleSolenoid_DoubleSolenoid1(
            __bindgen_tmp.as_mut_ptr(),
            moduleType,
            forwardChannel,
            reverseChannel,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc14DoubleSolenoidD1Ev"]
    pub fn frc_DoubleSolenoid_DoubleSolenoid_destructor(this: *mut frc_DoubleSolenoid);
}
extern "C" {
    #[doc = " Set the value of a solenoid.\n\n @param value The value to set (Off, Forward or Reverse)"]
    #[link_name = "\u{1}_ZN3frc14DoubleSolenoid3SetENS0_5ValueE"]
    pub fn frc_DoubleSolenoid_Set(
        this: *mut ::std::os::raw::c_void,
        value: frc_DoubleSolenoid_Value,
    );
}
extern "C" {
    #[doc = " Read the current value of the solenoid.\n\n @return The current value of the solenoid."]
    #[link_name = "\u{1}_ZNK3frc14DoubleSolenoid3GetEv"]
    pub fn frc_DoubleSolenoid_Get(this: *mut ::std::os::raw::c_void) -> frc_DoubleSolenoid_Value;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc14DoubleSolenoid12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_DoubleSolenoid_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Provide access to the network communication data to / from the Driver\n Station."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_DriverStation {
    pub _address: u8,
}
pub const frc_DriverStation_Alliance_kRed: frc_DriverStation_Alliance = 0;
pub const frc_DriverStation_Alliance_kBlue: frc_DriverStation_Alliance = 1;
pub const frc_DriverStation_Alliance_kInvalid: frc_DriverStation_Alliance = 2;
pub type frc_DriverStation_Alliance = ::std::os::raw::c_uint;
pub const frc_DriverStation_MatchType_kNone: frc_DriverStation_MatchType = 0;
pub const frc_DriverStation_MatchType_kPractice: frc_DriverStation_MatchType = 1;
pub const frc_DriverStation_MatchType_kQualification: frc_DriverStation_MatchType = 2;
pub const frc_DriverStation_MatchType_kElimination: frc_DriverStation_MatchType = 3;
pub type frc_DriverStation_MatchType = ::std::os::raw::c_uint;
pub const frc_DriverStation_kJoystickPorts: ::std::os::raw::c_int = 6;
#[test]
fn bindgen_test_layout_frc_DriverStation() {
    assert_eq!(
        ::std::mem::size_of::<frc_DriverStation>(),
        1usize,
        concat!("Size of: ", stringify!(frc_DriverStation))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_DriverStation>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_DriverStation))
    );
}
extern "C" {
    #[doc = " The state of one joystick button. %Button indexes begin at 1.\n\n @param stick  The joystick to read.\n @param button The button index, beginning at 1.\n @return The state of the joystick button."]
    #[link_name = "\u{1}_ZN3frc13DriverStation14GetStickButtonEii"]
    pub fn frc_DriverStation_GetStickButton(
        stick: ::std::os::raw::c_int,
        button: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Whether one joystick button was pressed since the last check. %Button\n indexes begin at 1.\n\n @param stick  The joystick to read.\n @param button The button index, beginning at 1.\n @return Whether the joystick button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13DriverStation21GetStickButtonPressedEii"]
    pub fn frc_DriverStation_GetStickButtonPressed(
        stick: ::std::os::raw::c_int,
        button: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Whether one joystick button was released since the last check. %Button\n indexes begin at 1.\n\n @param stick  The joystick to read.\n @param button The button index, beginning at 1.\n @return Whether the joystick button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13DriverStation22GetStickButtonReleasedEii"]
    pub fn frc_DriverStation_GetStickButtonReleased(
        stick: ::std::os::raw::c_int,
        button: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the value of the axis on a joystick.\n\n This depends on the mapping of the joystick connected to the specified\n port.\n\n @param stick The joystick to read.\n @param axis  The analog axis value to read from the joystick.\n @return The value of the axis on the joystick."]
    #[link_name = "\u{1}_ZN3frc13DriverStation12GetStickAxisEii"]
    pub fn frc_DriverStation_GetStickAxis(
        stick: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " Get the state of a POV on the joystick.\n\n @return the angle of the POV in degrees, or -1 if the POV is not pressed."]
    #[link_name = "\u{1}_ZN3frc13DriverStation11GetStickPOVEii"]
    pub fn frc_DriverStation_GetStickPOV(
        stick: ::std::os::raw::c_int,
        pov: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " The state of the buttons on the joystick.\n\n @param stick The joystick to read.\n @return The state of the buttons on the joystick."]
    #[link_name = "\u{1}_ZN3frc13DriverStation15GetStickButtonsEi"]
    pub fn frc_DriverStation_GetStickButtons(stick: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of axes on a given joystick port.\n\n @param stick The joystick port number\n @return The number of axes on the indicated joystick"]
    #[link_name = "\u{1}_ZN3frc13DriverStation17GetStickAxisCountEi"]
    pub fn frc_DriverStation_GetStickAxisCount(
        stick: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of POVs on a given joystick port.\n\n @param stick The joystick port number\n @return The number of POVs on the indicated joystick"]
    #[link_name = "\u{1}_ZN3frc13DriverStation16GetStickPOVCountEi"]
    pub fn frc_DriverStation_GetStickPOVCount(
        stick: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of buttons on a given joystick port.\n\n @param stick The joystick port number\n @return The number of buttons on the indicated joystick"]
    #[link_name = "\u{1}_ZN3frc13DriverStation19GetStickButtonCountEi"]
    pub fn frc_DriverStation_GetStickButtonCount(
        stick: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns a boolean indicating if the controller is an xbox controller.\n\n @param stick The joystick port number\n @return A boolean that is true if the controller is an xbox controller."]
    #[link_name = "\u{1}_ZN3frc13DriverStation17GetJoystickIsXboxEi"]
    pub fn frc_DriverStation_GetJoystickIsXbox(stick: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " Returns the type of joystick at a given port.\n\n @param stick The joystick port number\n @return The HID type of joystick at the given port"]
    #[link_name = "\u{1}_ZN3frc13DriverStation15GetJoystickTypeEi"]
    pub fn frc_DriverStation_GetJoystickType(stick: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the name of the joystick at the given port.\n\n @param stick The joystick port number\n @return The name of the joystick at the given port"]
    #[link_name = "\u{1}_ZN3frc13DriverStation15GetJoystickNameB5cxx11Ei"]
    pub fn frc_DriverStation_GetJoystickName(stick: ::std::os::raw::c_int) -> std_string;
}
extern "C" {
    #[doc = " Returns the types of Axes on a given joystick port.\n\n @param stick The joystick port number and the target axis\n @param axis  The analog axis value to read from the joystick.\n @return What type of axis the axis is reporting to be"]
    #[link_name = "\u{1}_ZN3frc13DriverStation19GetJoystickAxisTypeEii"]
    pub fn frc_DriverStation_GetJoystickAxisType(
        stick: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns if a joystick is connected to the Driver Station.\n\n This makes a best effort guess by looking at the reported number of axis,\n buttons, and POVs attached.\n\n @param stick The joystick port number\n @return true if a joystick is connected"]
    #[link_name = "\u{1}_ZN3frc13DriverStation19IsJoystickConnectedEi"]
    pub fn frc_DriverStation_IsJoystickConnected(stick: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " Check if the DS has enabled the robot.\n\n @return True if the robot is enabled and the DS is connected"]
    #[link_name = "\u{1}_ZN3frc13DriverStation9IsEnabledEv"]
    pub fn frc_DriverStation_IsEnabled() -> bool;
}
extern "C" {
    #[doc = " Check if the robot is disabled.\n\n @return True if the robot is explicitly disabled or the DS is not connected"]
    #[link_name = "\u{1}_ZN3frc13DriverStation10IsDisabledEv"]
    pub fn frc_DriverStation_IsDisabled() -> bool;
}
extern "C" {
    #[doc = " Check if the robot is e-stopped.\n\n @return True if the robot is e-stopped"]
    #[link_name = "\u{1}_ZN3frc13DriverStation10IsEStoppedEv"]
    pub fn frc_DriverStation_IsEStopped() -> bool;
}
extern "C" {
    #[doc = " Check if the DS is commanding autonomous mode.\n\n @return True if the robot is being commanded to be in autonomous mode"]
    #[link_name = "\u{1}_ZN3frc13DriverStation12IsAutonomousEv"]
    pub fn frc_DriverStation_IsAutonomous() -> bool;
}
extern "C" {
    #[doc = " Check if the DS is commanding autonomous mode and if it has enabled the\n robot.\n\n @return True if the robot is being commanded to be in autonomous mode and\n enabled."]
    #[link_name = "\u{1}_ZN3frc13DriverStation19IsAutonomousEnabledEv"]
    pub fn frc_DriverStation_IsAutonomousEnabled() -> bool;
}
extern "C" {
    #[doc = " Check if the DS is commanding teleop mode.\n\n @return True if the robot is being commanded to be in teleop mode"]
    #[link_name = "\u{1}_ZN3frc13DriverStation8IsTeleopEv"]
    pub fn frc_DriverStation_IsTeleop() -> bool;
}
extern "C" {
    #[doc = " Check if the DS is commanding teleop mode and if it has enabled the robot.\n\n @return True if the robot is being commanded to be in teleop mode and\n enabled."]
    #[link_name = "\u{1}_ZN3frc13DriverStation15IsTeleopEnabledEv"]
    pub fn frc_DriverStation_IsTeleopEnabled() -> bool;
}
extern "C" {
    #[doc = " Check if the DS is commanding test mode.\n\n @return True if the robot is being commanded to be in test mode"]
    #[link_name = "\u{1}_ZN3frc13DriverStation6IsTestEv"]
    pub fn frc_DriverStation_IsTest() -> bool;
}
extern "C" {
    #[doc = " Check if the DS is attached.\n\n @return True if the DS is connected to the robot"]
    #[link_name = "\u{1}_ZN3frc13DriverStation12IsDSAttachedEv"]
    pub fn frc_DriverStation_IsDSAttached() -> bool;
}
extern "C" {
    #[doc = " Is the driver station attached to a Field Management System?\n\n @return True if the robot is competing on a field being controlled by a\n         Field Management System"]
    #[link_name = "\u{1}_ZN3frc13DriverStation13IsFMSAttachedEv"]
    pub fn frc_DriverStation_IsFMSAttached() -> bool;
}
extern "C" {
    #[doc = " Returns the game specific message provided by the FMS.\n\n @return A string containing the game specific message."]
    #[link_name = "\u{1}_ZN3frc13DriverStation22GetGameSpecificMessageB5cxx11Ev"]
    pub fn frc_DriverStation_GetGameSpecificMessage() -> std_string;
}
extern "C" {
    #[doc = " Returns the name of the competition event provided by the FMS.\n\n @return A string containing the event name"]
    #[link_name = "\u{1}_ZN3frc13DriverStation12GetEventNameB5cxx11Ev"]
    pub fn frc_DriverStation_GetEventName() -> std_string;
}
extern "C" {
    #[doc = " Returns the type of match being played provided by the FMS.\n\n @return The match type enum (kNone, kPractice, kQualification,\n         kElimination)"]
    #[link_name = "\u{1}_ZN3frc13DriverStation12GetMatchTypeEv"]
    pub fn frc_DriverStation_GetMatchType() -> frc_DriverStation_MatchType;
}
extern "C" {
    #[doc = " Returns the match number provided by the FMS.\n\n @return The number of the match"]
    #[link_name = "\u{1}_ZN3frc13DriverStation14GetMatchNumberEv"]
    pub fn frc_DriverStation_GetMatchNumber() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of times the current match has been replayed from the\n FMS.\n\n @return The number of replays"]
    #[link_name = "\u{1}_ZN3frc13DriverStation15GetReplayNumberEv"]
    pub fn frc_DriverStation_GetReplayNumber() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the alliance that the driver station says it is on.\n\n This could return kRed or kBlue.\n\n @return The Alliance enum (kRed, kBlue or kInvalid)"]
    #[link_name = "\u{1}_ZN3frc13DriverStation11GetAllianceEv"]
    pub fn frc_DriverStation_GetAlliance() -> frc_DriverStation_Alliance;
}
extern "C" {
    #[doc = " Return the driver station location on the field.\n\n This could return 1, 2, or 3.\n\n @return The location of the driver station (1-3, 0 for invalid)"]
    #[link_name = "\u{1}_ZN3frc13DriverStation11GetLocationEv"]
    pub fn frc_DriverStation_GetLocation() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the approximate match time.\n\n The FMS does not send an official match time to the robots, but does send\n an approximate match time. The value will count down the time remaining in\n the current period (auto or teleop).\n\n Warning: This is not an official time (so it cannot be used to dispute ref\n calls or guarantee that a function will trigger before the match ends).\n\n The Practice Match function of the DS approximates the behavior seen on\n the field.\n\n @return Time remaining in current match period (auto or teleop)"]
    #[link_name = "\u{1}_ZN3frc13DriverStation12GetMatchTimeEv"]
    pub fn frc_DriverStation_GetMatchTime() -> f64;
}
extern "C" {
    #[doc = " Read the battery voltage.\n\n @return The battery voltage in Volts."]
    #[link_name = "\u{1}_ZN3frc13DriverStation17GetBatteryVoltageEv"]
    pub fn frc_DriverStation_GetBatteryVoltage() -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc13DriverStation11RefreshDataEv"]
    pub fn frc_DriverStation_RefreshData();
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc13DriverStation31ProvideRefreshedDataEventHandleEj"]
    pub fn frc_DriverStation_ProvideRefreshedDataEventHandle(handle: WPI_EventHandle);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc13DriverStation30RemoveRefreshedDataEventHandleEj"]
    pub fn frc_DriverStation_RemoveRefreshedDataEventHandle(handle: WPI_EventHandle);
}
extern "C" {
    #[doc = " Allows the user to specify whether they want joystick connection warnings\n to be printed to the console. This setting is ignored when the FMS is\n connected -- warnings will always be on in that scenario.\n\n @param silence Whether warning messages should be silenced."]
    #[link_name = "\u{1}_ZN3frc13DriverStation32SilenceJoystickConnectionWarningEb"]
    pub fn frc_DriverStation_SilenceJoystickConnectionWarning(silence: bool);
}
extern "C" {
    #[doc = " Returns whether joystick connection warnings are silenced. This will\n always return false when connected to the FMS.\n\n @return Whether joystick connection warnings are silenced."]
    #[link_name = "\u{1}_ZN3frc13DriverStation35IsJoystickConnectionWarningSilencedEv"]
    pub fn frc_DriverStation_IsJoystickConnectionWarningSilenced() -> bool;
}
extern "C" {
    #[doc = " Starts logging DriverStation data to data log. Repeated calls are ignored.\n\n @param log data log\n @param logJoysticks if true, log joystick data"]
    #[link_name = "\u{1}_ZN3frc13DriverStation12StartDataLogERN3wpi3log7DataLogEb"]
    pub fn frc_DriverStation_StartDataLog(log: *mut wpi_log_DataLog, logJoysticks: bool);
}
impl frc_DriverStation {
    #[inline]
    pub unsafe fn GetStickButton(
        stick: ::std::os::raw::c_int,
        button: ::std::os::raw::c_int,
    ) -> bool {
        frc_DriverStation_GetStickButton(stick, button)
    }
    #[inline]
    pub unsafe fn GetStickButtonPressed(
        stick: ::std::os::raw::c_int,
        button: ::std::os::raw::c_int,
    ) -> bool {
        frc_DriverStation_GetStickButtonPressed(stick, button)
    }
    #[inline]
    pub unsafe fn GetStickButtonReleased(
        stick: ::std::os::raw::c_int,
        button: ::std::os::raw::c_int,
    ) -> bool {
        frc_DriverStation_GetStickButtonReleased(stick, button)
    }
    #[inline]
    pub unsafe fn GetStickAxis(stick: ::std::os::raw::c_int, axis: ::std::os::raw::c_int) -> f64 {
        frc_DriverStation_GetStickAxis(stick, axis)
    }
    #[inline]
    pub unsafe fn GetStickPOV(
        stick: ::std::os::raw::c_int,
        pov: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        frc_DriverStation_GetStickPOV(stick, pov)
    }
    #[inline]
    pub unsafe fn GetStickButtons(stick: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        frc_DriverStation_GetStickButtons(stick)
    }
    #[inline]
    pub unsafe fn GetStickAxisCount(stick: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        frc_DriverStation_GetStickAxisCount(stick)
    }
    #[inline]
    pub unsafe fn GetStickPOVCount(stick: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        frc_DriverStation_GetStickPOVCount(stick)
    }
    #[inline]
    pub unsafe fn GetStickButtonCount(stick: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        frc_DriverStation_GetStickButtonCount(stick)
    }
    #[inline]
    pub unsafe fn GetJoystickIsXbox(stick: ::std::os::raw::c_int) -> bool {
        frc_DriverStation_GetJoystickIsXbox(stick)
    }
    #[inline]
    pub unsafe fn GetJoystickType(stick: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        frc_DriverStation_GetJoystickType(stick)
    }
    #[inline]
    pub unsafe fn GetJoystickName(stick: ::std::os::raw::c_int) -> std_string {
        frc_DriverStation_GetJoystickName(stick)
    }
    #[inline]
    pub unsafe fn GetJoystickAxisType(
        stick: ::std::os::raw::c_int,
        axis: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        frc_DriverStation_GetJoystickAxisType(stick, axis)
    }
    #[inline]
    pub unsafe fn IsJoystickConnected(stick: ::std::os::raw::c_int) -> bool {
        frc_DriverStation_IsJoystickConnected(stick)
    }
    #[inline]
    pub unsafe fn IsEnabled() -> bool {
        frc_DriverStation_IsEnabled()
    }
    #[inline]
    pub unsafe fn IsDisabled() -> bool {
        frc_DriverStation_IsDisabled()
    }
    #[inline]
    pub unsafe fn IsEStopped() -> bool {
        frc_DriverStation_IsEStopped()
    }
    #[inline]
    pub unsafe fn IsAutonomous() -> bool {
        frc_DriverStation_IsAutonomous()
    }
    #[inline]
    pub unsafe fn IsAutonomousEnabled() -> bool {
        frc_DriverStation_IsAutonomousEnabled()
    }
    #[inline]
    pub unsafe fn IsTeleop() -> bool {
        frc_DriverStation_IsTeleop()
    }
    #[inline]
    pub unsafe fn IsTeleopEnabled() -> bool {
        frc_DriverStation_IsTeleopEnabled()
    }
    #[inline]
    pub unsafe fn IsTest() -> bool {
        frc_DriverStation_IsTest()
    }
    #[inline]
    pub unsafe fn IsDSAttached() -> bool {
        frc_DriverStation_IsDSAttached()
    }
    #[inline]
    pub unsafe fn IsFMSAttached() -> bool {
        frc_DriverStation_IsFMSAttached()
    }
    #[inline]
    pub unsafe fn GetGameSpecificMessage() -> std_string {
        frc_DriverStation_GetGameSpecificMessage()
    }
    #[inline]
    pub unsafe fn GetEventName() -> std_string {
        frc_DriverStation_GetEventName()
    }
    #[inline]
    pub unsafe fn GetMatchType() -> frc_DriverStation_MatchType {
        frc_DriverStation_GetMatchType()
    }
    #[inline]
    pub unsafe fn GetMatchNumber() -> ::std::os::raw::c_int {
        frc_DriverStation_GetMatchNumber()
    }
    #[inline]
    pub unsafe fn GetReplayNumber() -> ::std::os::raw::c_int {
        frc_DriverStation_GetReplayNumber()
    }
    #[inline]
    pub unsafe fn GetAlliance() -> frc_DriverStation_Alliance {
        frc_DriverStation_GetAlliance()
    }
    #[inline]
    pub unsafe fn GetLocation() -> ::std::os::raw::c_int {
        frc_DriverStation_GetLocation()
    }
    #[inline]
    pub unsafe fn GetMatchTime() -> f64 {
        frc_DriverStation_GetMatchTime()
    }
    #[inline]
    pub unsafe fn GetBatteryVoltage() -> f64 {
        frc_DriverStation_GetBatteryVoltage()
    }
    #[inline]
    pub unsafe fn RefreshData() {
        frc_DriverStation_RefreshData()
    }
    #[inline]
    pub unsafe fn ProvideRefreshedDataEventHandle(handle: WPI_EventHandle) {
        frc_DriverStation_ProvideRefreshedDataEventHandle(handle)
    }
    #[inline]
    pub unsafe fn RemoveRefreshedDataEventHandle(handle: WPI_EventHandle) {
        frc_DriverStation_RemoveRefreshedDataEventHandle(handle)
    }
    #[inline]
    pub unsafe fn SilenceJoystickConnectionWarning(silence: bool) {
        frc_DriverStation_SilenceJoystickConnectionWarning(silence)
    }
    #[inline]
    pub unsafe fn IsJoystickConnectionWarningSilenced() -> bool {
        frc_DriverStation_IsJoystickConnectionWarningSilenced()
    }
    #[inline]
    pub unsafe fn StartDataLog(log: *mut wpi_log_DataLog, logJoysticks: bool) {
        frc_DriverStation_StartDataLog(log, logJoysticks)
    }
}
#[doc = " A wrapper around Driver Station control word."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_DSControlWord {
    pub m_controlWord: HAL_ControlWord,
}
#[test]
fn bindgen_test_layout_frc_DSControlWord() {
    const UNINIT: ::std::mem::MaybeUninit<frc_DSControlWord> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_DSControlWord>(),
        4usize,
        concat!("Size of: ", stringify!(frc_DSControlWord))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_DSControlWord>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_DSControlWord))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_controlWord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DSControlWord),
            "::",
            stringify!(m_controlWord)
        )
    );
}
extern "C" {
    #[doc = " Check if the DS has enabled the robot.\n\n @return True if the robot is enabled and the DS is connected"]
    #[link_name = "\u{1}_ZNK3frc13DSControlWord9IsEnabledEv"]
    pub fn frc_DSControlWord_IsEnabled(this: *const frc_DSControlWord) -> bool;
}
extern "C" {
    #[doc = " Check if the robot is disabled.\n\n @return True if the robot is explicitly disabled or the DS is not connected"]
    #[link_name = "\u{1}_ZNK3frc13DSControlWord10IsDisabledEv"]
    pub fn frc_DSControlWord_IsDisabled(this: *const frc_DSControlWord) -> bool;
}
extern "C" {
    #[doc = " Check if the robot is e-stopped.\n\n @return True if the robot is e-stopped"]
    #[link_name = "\u{1}_ZNK3frc13DSControlWord10IsEStoppedEv"]
    pub fn frc_DSControlWord_IsEStopped(this: *const frc_DSControlWord) -> bool;
}
extern "C" {
    #[doc = " Check if the DS is commanding autonomous mode.\n\n @return True if the robot is being commanded to be in autonomous mode"]
    #[link_name = "\u{1}_ZNK3frc13DSControlWord12IsAutonomousEv"]
    pub fn frc_DSControlWord_IsAutonomous(this: *const frc_DSControlWord) -> bool;
}
extern "C" {
    #[doc = " Check if the DS is commanding autonomous mode and if it has enabled the\n robot.\n\n @return True if the robot is being commanded to be in autonomous mode and\n enabled."]
    #[link_name = "\u{1}_ZNK3frc13DSControlWord19IsAutonomousEnabledEv"]
    pub fn frc_DSControlWord_IsAutonomousEnabled(this: *const frc_DSControlWord) -> bool;
}
extern "C" {
    #[doc = " Check if the DS is commanding teleop mode.\n\n @return True if the robot is being commanded to be in teleop mode"]
    #[link_name = "\u{1}_ZNK3frc13DSControlWord8IsTeleopEv"]
    pub fn frc_DSControlWord_IsTeleop(this: *const frc_DSControlWord) -> bool;
}
extern "C" {
    #[doc = " Check if the DS is commanding teleop mode and if it has enabled the robot.\n\n @return True if the robot is being commanded to be in teleop mode and\n enabled."]
    #[link_name = "\u{1}_ZNK3frc13DSControlWord15IsTeleopEnabledEv"]
    pub fn frc_DSControlWord_IsTeleopEnabled(this: *const frc_DSControlWord) -> bool;
}
extern "C" {
    #[doc = " Check if the DS is commanding test mode.\n\n @return True if the robot is being commanded to be in test mode"]
    #[link_name = "\u{1}_ZNK3frc13DSControlWord6IsTestEv"]
    pub fn frc_DSControlWord_IsTest(this: *const frc_DSControlWord) -> bool;
}
extern "C" {
    #[doc = " Check if the DS is attached.\n\n @return True if the DS is connected to the robot"]
    #[link_name = "\u{1}_ZNK3frc13DSControlWord12IsDSAttachedEv"]
    pub fn frc_DSControlWord_IsDSAttached(this: *const frc_DSControlWord) -> bool;
}
extern "C" {
    #[doc = " Is the driver station attached to a Field Management System?\n\n @return True if the robot is competing on a field being controlled by a\n         Field Management System"]
    #[link_name = "\u{1}_ZNK3frc13DSControlWord13IsFMSAttachedEv"]
    pub fn frc_DSControlWord_IsFMSAttached(this: *const frc_DSControlWord) -> bool;
}
extern "C" {
    #[doc = " DSControlWord constructor.\n\n Upon construction, the current Driver Station control word is read and\n stored internally."]
    #[link_name = "\u{1}_ZN3frc13DSControlWordC1Ev"]
    pub fn frc_DSControlWord_DSControlWord(this: *mut frc_DSControlWord);
}
impl frc_DSControlWord {
    #[inline]
    pub unsafe fn IsEnabled(&self) -> bool {
        frc_DSControlWord_IsEnabled(self)
    }
    #[inline]
    pub unsafe fn IsDisabled(&self) -> bool {
        frc_DSControlWord_IsDisabled(self)
    }
    #[inline]
    pub unsafe fn IsEStopped(&self) -> bool {
        frc_DSControlWord_IsEStopped(self)
    }
    #[inline]
    pub unsafe fn IsAutonomous(&self) -> bool {
        frc_DSControlWord_IsAutonomous(self)
    }
    #[inline]
    pub unsafe fn IsAutonomousEnabled(&self) -> bool {
        frc_DSControlWord_IsAutonomousEnabled(self)
    }
    #[inline]
    pub unsafe fn IsTeleop(&self) -> bool {
        frc_DSControlWord_IsTeleop(self)
    }
    #[inline]
    pub unsafe fn IsTeleopEnabled(&self) -> bool {
        frc_DSControlWord_IsTeleopEnabled(self)
    }
    #[inline]
    pub unsafe fn IsTest(&self) -> bool {
        frc_DSControlWord_IsTest(self)
    }
    #[inline]
    pub unsafe fn IsDSAttached(&self) -> bool {
        frc_DSControlWord_IsDSAttached(self)
    }
    #[inline]
    pub unsafe fn IsFMSAttached(&self) -> bool {
        frc_DSControlWord_IsFMSAttached(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DSControlWord_DSControlWord(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Class for supporting duty cycle/PWM encoders, such as the US Digital MA3 with\n PWM Output, the CTRE Mag Encoder, the Rev Hex Encoder, and the AM Mag\n Encoder."]
#[repr(C)]
pub struct frc_DutyCycleEncoder {
    pub _base: wpi_Sendable,
    pub m_dutyCycle: [u32; 2usize],
    pub m_analogTrigger: u32,
    pub m_counter: u32,
    pub m_frequencyThreshold: ::std::os::raw::c_int,
    pub m_positionOffset: f64,
    pub m_distancePerRotation: f64,
    pub m_lastPosition: units_angle_turn_t,
    pub m_sensorMin: f64,
    pub m_sensorMax: f64,
    pub m_simDevice: hal_SimDevice,
    pub m_simPosition: hal_SimDouble,
    pub m_simAbsolutePosition: hal_SimDouble,
    pub m_simDistancePerRotation: hal_SimDouble,
    pub m_simIsConnected: hal_SimBoolean,
}
#[test]
fn bindgen_test_layout_frc_DutyCycleEncoder() {
    const UNINIT: ::std::mem::MaybeUninit<frc_DutyCycleEncoder> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_DutyCycleEncoder>(),
        88usize,
        concat!("Size of: ", stringify!(frc_DutyCycleEncoder))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_DutyCycleEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_DutyCycleEncoder))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dutyCycle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_dutyCycle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_analogTrigger) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_analogTrigger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_counter) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_frequencyThreshold) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_frequencyThreshold)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_positionOffset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_positionOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_distancePerRotation) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_distancePerRotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_lastPosition) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_lastPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sensorMin) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_sensorMin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sensorMax) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_sensorMax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_simDevice) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_simDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_simPosition) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_simPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_simAbsolutePosition) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_simAbsolutePosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_simDistancePerRotation) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_simDistancePerRotation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_simIsConnected) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DutyCycleEncoder),
            "::",
            stringify!(m_simIsConnected)
        )
    );
}
extern "C" {
    #[doc = " Get the frequency in Hz of the duty cycle signal from the encoder.\n\n @return duty cycle frequency in Hz"]
    #[link_name = "\u{1}_ZNK3frc16DutyCycleEncoder12GetFrequencyEv"]
    pub fn frc_DutyCycleEncoder_GetFrequency(
        this: *const frc_DutyCycleEncoder,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get if the sensor is connected\n\n This uses the duty cycle frequency to determine if the sensor is connected.\n By default, a value of 100 Hz is used as the threshold, and this value can\n be changed with SetConnectedFrequencyThreshold.\n\n @return true if the sensor is connected"]
    #[link_name = "\u{1}_ZNK3frc16DutyCycleEncoder11IsConnectedEv"]
    pub fn frc_DutyCycleEncoder_IsConnected(this: *const frc_DutyCycleEncoder) -> bool;
}
extern "C" {
    #[doc = " Change the frequency threshold for detecting connection used by\n IsConnected.\n\n @param frequency the minimum frequency in Hz."]
    #[link_name = "\u{1}_ZN3frc16DutyCycleEncoder30SetConnectedFrequencyThresholdEi"]
    pub fn frc_DutyCycleEncoder_SetConnectedFrequencyThreshold(
        this: *mut frc_DutyCycleEncoder,
        frequency: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Reset the Encoder distance to zero."]
    #[link_name = "\u{1}_ZN3frc16DutyCycleEncoder5ResetEv"]
    pub fn frc_DutyCycleEncoder_Reset(this: *mut frc_DutyCycleEncoder);
}
extern "C" {
    #[doc = " Get the encoder value since the last reset.\n\n This is reported in rotations since the last reset.\n\n @return the encoder value in rotations"]
    #[link_name = "\u{1}_ZNK3frc16DutyCycleEncoder3GetEv"]
    pub fn frc_DutyCycleEncoder_Get(this: *const frc_DutyCycleEncoder) -> units_angle_turn_t;
}
extern "C" {
    #[doc = " Get the absolute position of the duty cycle encoder encoder.\n\n <p>GetAbsolutePosition() - GetPositionOffset() will give an encoder\n absolute position relative to the last reset. This could potentially be\n negative, which needs to be accounted for.\n\n <p>This will not account for rollovers, and will always be just the raw\n absolute position.\n\n @return the absolute position"]
    #[link_name = "\u{1}_ZNK3frc16DutyCycleEncoder19GetAbsolutePositionEv"]
    pub fn frc_DutyCycleEncoder_GetAbsolutePosition(this: *const frc_DutyCycleEncoder) -> f64;
}
extern "C" {
    #[doc = " Get the offset of position relative to the last reset.\n\n GetAbsolutePosition() - GetPositionOffset() will give an encoder absolute\n position relative to the last reset. This could potentially be negative,\n which needs to be accounted for.\n\n @return the position offset"]
    #[link_name = "\u{1}_ZNK3frc16DutyCycleEncoder17GetPositionOffsetEv"]
    pub fn frc_DutyCycleEncoder_GetPositionOffset(this: *const frc_DutyCycleEncoder) -> f64;
}
extern "C" {
    #[doc = " Set the position offset.\n\n <p>This must be in the range of 0-1.\n\n @param offset the offset"]
    #[link_name = "\u{1}_ZN3frc16DutyCycleEncoder17SetPositionOffsetEd"]
    pub fn frc_DutyCycleEncoder_SetPositionOffset(this: *mut frc_DutyCycleEncoder, offset: f64);
}
extern "C" {
    #[doc = " Set the encoder duty cycle range. As the encoder needs to maintain a duty\n cycle, the duty cycle cannot go all the way to 0% or all the way to 100%.\n For example, an encoder with a 4096 us period might have a minimum duty\n cycle of 1 us / 4096 us and a maximum duty cycle of 4095 / 4096 us. Setting\n the range will result in an encoder duty cycle less than or equal to the\n minimum being output as 0 rotation, the duty cycle greater than or equal to\n the maximum being output as 1 rotation, and values in between linearly\n scaled from 0 to 1.\n\n @param min minimum duty cycle (0-1 range)\n @param max maximum duty cycle (0-1 range)"]
    #[link_name = "\u{1}_ZN3frc16DutyCycleEncoder17SetDutyCycleRangeEdd"]
    pub fn frc_DutyCycleEncoder_SetDutyCycleRange(
        this: *mut frc_DutyCycleEncoder,
        min: f64,
        max: f64,
    );
}
extern "C" {
    #[doc = " Set the distance per rotation of the encoder. This sets the multiplier used\n to determine the distance driven based on the rotation value from the\n encoder. Set this value based on the how far the mechanism travels in 1\n rotation of the encoder, and factor in gearing reductions following the\n encoder shaft. This distance can be in any units you like, linear or\n angular.\n\n @param distancePerRotation the distance per rotation of the encoder"]
    #[link_name = "\u{1}_ZN3frc16DutyCycleEncoder22SetDistancePerRotationEd"]
    pub fn frc_DutyCycleEncoder_SetDistancePerRotation(
        this: *mut frc_DutyCycleEncoder,
        distancePerRotation: f64,
    );
}
extern "C" {
    #[doc = " Get the distance per rotation for this encoder.\n\n @return The scale factor that will be used to convert rotation to useful\n units."]
    #[link_name = "\u{1}_ZNK3frc16DutyCycleEncoder22GetDistancePerRotationEv"]
    pub fn frc_DutyCycleEncoder_GetDistancePerRotation(this: *const frc_DutyCycleEncoder) -> f64;
}
extern "C" {
    #[doc = " Get the distance the sensor has driven since the last reset as scaled by\n the value from SetDistancePerRotation.\n\n @return The distance driven since the last reset"]
    #[link_name = "\u{1}_ZNK3frc16DutyCycleEncoder11GetDistanceEv"]
    pub fn frc_DutyCycleEncoder_GetDistance(this: *const frc_DutyCycleEncoder) -> f64;
}
extern "C" {
    #[doc = " Get the FPGA index for the DutyCycleEncoder.\n\n @return the FPGA index"]
    #[link_name = "\u{1}_ZNK3frc16DutyCycleEncoder12GetFPGAIndexEv"]
    pub fn frc_DutyCycleEncoder_GetFPGAIndex(
        this: *const frc_DutyCycleEncoder,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the channel of the source.\n\n @return the source channel"]
    #[link_name = "\u{1}_ZNK3frc16DutyCycleEncoder16GetSourceChannelEv"]
    pub fn frc_DutyCycleEncoder_GetSourceChannel(
        this: *const frc_DutyCycleEncoder,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Construct a new DutyCycleEncoder on a specific channel.\n\n @param channel the channel to attach to"]
    #[link_name = "\u{1}_ZN3frc16DutyCycleEncoderC1Ei"]
    pub fn frc_DutyCycleEncoder_DutyCycleEncoder(
        this: *mut frc_DutyCycleEncoder,
        channel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Construct a new DutyCycleEncoder attached to an existing DutyCycle object.\n\n @param dutyCycle the duty cycle to attach to"]
    #[link_name = "\u{1}_ZN3frc16DutyCycleEncoderC1ERNS_9DutyCycleE"]
    pub fn frc_DutyCycleEncoder_DutyCycleEncoder1(
        this: *mut frc_DutyCycleEncoder,
        dutyCycle: *mut frc_DutyCycle,
    );
}
extern "C" {
    #[doc = " Construct a new DutyCycleEncoder attached to an existing DutyCycle object.\n\n @param dutyCycle the duty cycle to attach to"]
    #[link_name = "\u{1}_ZN3frc16DutyCycleEncoderC1EPNS_9DutyCycleE"]
    pub fn frc_DutyCycleEncoder_DutyCycleEncoder2(
        this: *mut frc_DutyCycleEncoder,
        dutyCycle: *mut frc_DutyCycle,
    );
}
extern "C" {
    #[doc = " Construct a new DutyCycleEncoder attached to an existing DutyCycle object.\n\n @param dutyCycle the duty cycle to attach to"]
    #[link_name = "\u{1}_ZN3frc16DutyCycleEncoderC1ESt10shared_ptrINS_9DutyCycleEE"]
    pub fn frc_DutyCycleEncoder_DutyCycleEncoder3(
        this: *mut frc_DutyCycleEncoder,
        dutyCycle: [u32; 2usize],
    );
}
extern "C" {
    #[doc = " Construct a new DutyCycleEncoder attached to a DigitalSource object.\n\n @param digitalSource the digital source to attach to"]
    #[link_name = "\u{1}_ZN3frc16DutyCycleEncoderC1ERNS_13DigitalSourceE"]
    pub fn frc_DutyCycleEncoder_DutyCycleEncoder4(
        this: *mut frc_DutyCycleEncoder,
        digitalSource: *mut frc_DigitalSource,
    );
}
extern "C" {
    #[doc = " Construct a new DutyCycleEncoder attached to a DigitalSource object.\n\n @param digitalSource the digital source to attach to"]
    #[link_name = "\u{1}_ZN3frc16DutyCycleEncoderC1EPNS_13DigitalSourceE"]
    pub fn frc_DutyCycleEncoder_DutyCycleEncoder5(
        this: *mut frc_DutyCycleEncoder,
        digitalSource: *mut frc_DigitalSource,
    );
}
extern "C" {
    #[doc = " Construct a new DutyCycleEncoder attached to a DigitalSource object.\n\n @param digitalSource the digital source to attach to"]
    #[link_name = "\u{1}_ZN3frc16DutyCycleEncoderC1ESt10shared_ptrINS_13DigitalSourceEE"]
    pub fn frc_DutyCycleEncoder_DutyCycleEncoder6(
        this: *mut frc_DutyCycleEncoder,
        digitalSource: [u32; 2usize],
    );
}
impl frc_DutyCycleEncoder {
    #[inline]
    pub unsafe fn GetFrequency(&self) -> ::std::os::raw::c_int {
        frc_DutyCycleEncoder_GetFrequency(self)
    }
    #[inline]
    pub unsafe fn IsConnected(&self) -> bool {
        frc_DutyCycleEncoder_IsConnected(self)
    }
    #[inline]
    pub unsafe fn SetConnectedFrequencyThreshold(&mut self, frequency: ::std::os::raw::c_int) {
        frc_DutyCycleEncoder_SetConnectedFrequencyThreshold(self, frequency)
    }
    #[inline]
    pub unsafe fn Reset(&mut self) {
        frc_DutyCycleEncoder_Reset(self)
    }
    #[inline]
    pub unsafe fn Get(&self) -> units_angle_turn_t {
        frc_DutyCycleEncoder_Get(self)
    }
    #[inline]
    pub unsafe fn GetAbsolutePosition(&self) -> f64 {
        frc_DutyCycleEncoder_GetAbsolutePosition(self)
    }
    #[inline]
    pub unsafe fn GetPositionOffset(&self) -> f64 {
        frc_DutyCycleEncoder_GetPositionOffset(self)
    }
    #[inline]
    pub unsafe fn SetPositionOffset(&mut self, offset: f64) {
        frc_DutyCycleEncoder_SetPositionOffset(self, offset)
    }
    #[inline]
    pub unsafe fn SetDutyCycleRange(&mut self, min: f64, max: f64) {
        frc_DutyCycleEncoder_SetDutyCycleRange(self, min, max)
    }
    #[inline]
    pub unsafe fn SetDistancePerRotation(&mut self, distancePerRotation: f64) {
        frc_DutyCycleEncoder_SetDistancePerRotation(self, distancePerRotation)
    }
    #[inline]
    pub unsafe fn GetDistancePerRotation(&self) -> f64 {
        frc_DutyCycleEncoder_GetDistancePerRotation(self)
    }
    #[inline]
    pub unsafe fn GetDistance(&self) -> f64 {
        frc_DutyCycleEncoder_GetDistance(self)
    }
    #[inline]
    pub unsafe fn GetFPGAIndex(&self) -> ::std::os::raw::c_int {
        frc_DutyCycleEncoder_GetFPGAIndex(self)
    }
    #[inline]
    pub unsafe fn GetSourceChannel(&self) -> ::std::os::raw::c_int {
        frc_DutyCycleEncoder_GetSourceChannel(self)
    }
    #[inline]
    pub unsafe fn new(channel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DutyCycleEncoder_DutyCycleEncoder(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(dutyCycle: *mut frc_DutyCycle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DutyCycleEncoder_DutyCycleEncoder1(__bindgen_tmp.as_mut_ptr(), dutyCycle);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(dutyCycle: *mut frc_DutyCycle) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DutyCycleEncoder_DutyCycleEncoder2(__bindgen_tmp.as_mut_ptr(), dutyCycle);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(dutyCycle: [u32; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DutyCycleEncoder_DutyCycleEncoder3(__bindgen_tmp.as_mut_ptr(), dutyCycle);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(digitalSource: *mut frc_DigitalSource) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DutyCycleEncoder_DutyCycleEncoder4(__bindgen_tmp.as_mut_ptr(), digitalSource);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(digitalSource: *mut frc_DigitalSource) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DutyCycleEncoder_DutyCycleEncoder5(__bindgen_tmp.as_mut_ptr(), digitalSource);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new6(digitalSource: [u32; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_DutyCycleEncoder_DutyCycleEncoder6(__bindgen_tmp.as_mut_ptr(), digitalSource);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc16DutyCycleEncoder12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_DutyCycleEncoder_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Runtime error exception."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_RuntimeError {
    pub _base: std_runtime_error,
    pub m_data: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_RuntimeError_Data {
    pub code: i32,
    pub loc: std_string,
    pub stack: std_string,
}
#[test]
fn bindgen_test_layout_frc_RuntimeError_Data() {
    const UNINIT: ::std::mem::MaybeUninit<frc_RuntimeError_Data> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_RuntimeError_Data>(),
        52usize,
        concat!("Size of: ", stringify!(frc_RuntimeError_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_RuntimeError_Data>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_RuntimeError_Data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_RuntimeError_Data),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loc) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_RuntimeError_Data),
            "::",
            stringify!(loc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stack) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_RuntimeError_Data),
            "::",
            stringify!(stack)
        )
    );
}
#[test]
fn bindgen_test_layout_frc_RuntimeError() {
    const UNINIT: ::std::mem::MaybeUninit<frc_RuntimeError> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_RuntimeError>(),
        16usize,
        concat!("Size of: ", stringify!(frc_RuntimeError))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_RuntimeError>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_RuntimeError))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_RuntimeError),
            "::",
            stringify!(m_data)
        )
    );
}
extern "C" {
    #[doc = " Reports error to Driver Station (using HAL_SendError)."]
    #[link_name = "\u{1}_ZNK3frc12RuntimeError6ReportEv"]
    pub fn frc_RuntimeError_Report(this: *const frc_RuntimeError);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12RuntimeErrorC1EiONSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_S7_"]
    pub fn frc_RuntimeError_RuntimeError(
        this: *mut frc_RuntimeError,
        code: i32,
        loc: *mut std_string,
        stack: *mut std_string,
        message: *mut std_string,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12RuntimeErrorC1EiPKciS2_ONSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES9_"]
    pub fn frc_RuntimeError_RuntimeError1(
        this: *mut frc_RuntimeError,
        code: i32,
        fileName: *const ::std::os::raw::c_char,
        lineNumber: ::std::os::raw::c_int,
        funcName: *const ::std::os::raw::c_char,
        stack: *mut std_string,
        message: *mut std_string,
    );
}
impl frc_RuntimeError {
    #[inline]
    pub unsafe fn Report(&self) {
        frc_RuntimeError_Report(self)
    }
    #[inline]
    pub unsafe fn new(
        code: i32,
        loc: *mut std_string,
        stack: *mut std_string,
        message: *mut std_string,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_RuntimeError_RuntimeError(__bindgen_tmp.as_mut_ptr(), code, loc, stack, message);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        code: i32,
        fileName: *const ::std::os::raw::c_char,
        lineNumber: ::std::os::raw::c_int,
        funcName: *const ::std::os::raw::c_char,
        stack: *mut std_string,
        message: *mut std_string,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_RuntimeError_RuntimeError1(
            __bindgen_tmp.as_mut_ptr(),
            code,
            fileName,
            lineNumber,
            funcName,
            stack,
            message,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Gets error message string for an error code."]
    #[link_name = "\u{1}_ZN3frc15GetErrorMessageEPi"]
    pub fn frc_GetErrorMessage(code: *mut i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Reports an error to the driver station (using HAL_SendError).\n Generally the FRC_ReportError wrapper macro should be used instead.\n\n @param[out] status error code\n @param[in]  fileName source file name\n @param[in]  lineNumber source line number\n @param[in]  funcName source function name\n @param[in]  format error message format\n @param[in]  args error message format args"]
    #[link_name = "\u{1}_ZN3frc12ReportErrorVEiPKciS1_N3fmt2v917basic_string_viewIcEENS3_17basic_format_argsINS3_20basic_format_contextINS3_8appenderEcEEEE"]
    pub fn frc_ReportErrorV(
        status: i32,
        fileName: *const ::std::os::raw::c_char,
        lineNumber: ::std::os::raw::c_int,
        funcName: *const ::std::os::raw::c_char,
        format: fmt_string_view,
        args: fmt_format_args,
    );
}
extern "C" {
    #[doc = " Makes a runtime error exception object. This object should be thrown\n by the caller. Generally the FRC_MakeError wrapper macro should be used\n instead.\n\n @param[out] status error code\n @param[in]  fileName source file name\n @param[in]  lineNumber source line number\n @param[in]  funcName source function name\n @param[in]  format error message format\n @param[in]  args error message format args\n @return runtime error object"]
    #[link_name = "\u{1}_ZN3frc10MakeErrorVEiPKciS1_N3fmt2v917basic_string_viewIcEENS3_17basic_format_argsINS3_20basic_format_contextINS3_8appenderEcEEEE"]
    pub fn frc_MakeErrorV(
        status: i32,
        fileName: *const ::std::os::raw::c_char,
        lineNumber: ::std::os::raw::c_int,
        funcName: *const ::std::os::raw::c_char,
        format: fmt_string_view,
        args: fmt_format_args,
    ) -> frc_RuntimeError;
}
extern "C" {
    #[doc = " Obtains the current working path that the program was launched with.\n This is analogous to the `pwd` command on unix.\n\n @return The result of the current working path lookup."]
    #[link_name = "\u{1}_ZN3frc10filesystem18GetLaunchDirectoryB5cxx11Ev"]
    pub fn frc_filesystem_GetLaunchDirectory() -> std_string;
}
extern "C" {
    #[doc = " Obtains the operating directory of the program. On the roboRIO, this\n is /home/lvuser. In simulation, it is where the simulation was launched\n from (`pwd`).\n\n @return The result of the operating directory lookup."]
    #[link_name = "\u{1}_ZN3frc10filesystem21GetOperatingDirectoryB5cxx11Ev"]
    pub fn frc_filesystem_GetOperatingDirectory() -> std_string;
}
extern "C" {
    #[doc = " Obtains the deploy directory of the program, which is the remote location\n src/main/deploy is deployed to by default. On the roboRIO, this is\n /home/lvuser/deploy. In simulation, it is where the simulation was launched\n from, in the subdirectory \"src/main/deploy\" (`pwd`/src/main/deploy).\n\n @return The result of the operating directory lookup"]
    #[link_name = "\u{1}_ZN3frc10filesystem18GetDeployDirectoryB5cxx11Ev"]
    pub fn frc_filesystem_GetDeployDirectory() -> std_string;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_BooleanEvent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_EventLoop {
    _unused: [u8; 0],
}
#[repr(C)]
pub struct frc_GenericHID__bindgen_vtable {}
#[doc = " Handle input from standard HID devices connected to the Driver Station.\n\n <p>This class handles standard input that comes from the Driver Station. Each\n time a value is requested the most recent value is returned. There is a\n single class instance for each device and the mapping of ports to hardware\n buttons depends on the code in the Driver Station."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_GenericHID {
    pub vtable_: *const frc_GenericHID__bindgen_vtable,
    pub m_port: ::std::os::raw::c_int,
    pub m_outputs: ::std::os::raw::c_int,
    pub m_leftRumble: u16,
    pub m_rightRumble: u16,
}
pub const frc_GenericHID_RumbleType_kLeftRumble: frc_GenericHID_RumbleType = 0;
pub const frc_GenericHID_RumbleType_kRightRumble: frc_GenericHID_RumbleType = 1;
pub const frc_GenericHID_RumbleType_kBothRumble: frc_GenericHID_RumbleType = 2;
pub type frc_GenericHID_RumbleType = ::std::os::raw::c_uint;
pub const frc_GenericHID_HIDType_kUnknown: frc_GenericHID_HIDType = -1;
pub const frc_GenericHID_HIDType_kXInputUnknown: frc_GenericHID_HIDType = 0;
pub const frc_GenericHID_HIDType_kXInputGamepad: frc_GenericHID_HIDType = 1;
pub const frc_GenericHID_HIDType_kXInputWheel: frc_GenericHID_HIDType = 2;
pub const frc_GenericHID_HIDType_kXInputArcadeStick: frc_GenericHID_HIDType = 3;
pub const frc_GenericHID_HIDType_kXInputFlightStick: frc_GenericHID_HIDType = 4;
pub const frc_GenericHID_HIDType_kXInputDancePad: frc_GenericHID_HIDType = 5;
pub const frc_GenericHID_HIDType_kXInputGuitar: frc_GenericHID_HIDType = 6;
pub const frc_GenericHID_HIDType_kXInputGuitar2: frc_GenericHID_HIDType = 7;
pub const frc_GenericHID_HIDType_kXInputDrumKit: frc_GenericHID_HIDType = 8;
pub const frc_GenericHID_HIDType_kXInputGuitar3: frc_GenericHID_HIDType = 11;
pub const frc_GenericHID_HIDType_kXInputArcadePad: frc_GenericHID_HIDType = 19;
pub const frc_GenericHID_HIDType_kHIDJoystick: frc_GenericHID_HIDType = 20;
pub const frc_GenericHID_HIDType_kHIDGamepad: frc_GenericHID_HIDType = 21;
pub const frc_GenericHID_HIDType_kHIDDriving: frc_GenericHID_HIDType = 22;
pub const frc_GenericHID_HIDType_kHIDFlight: frc_GenericHID_HIDType = 23;
pub const frc_GenericHID_HIDType_kHID1stPerson: frc_GenericHID_HIDType = 24;
pub type frc_GenericHID_HIDType = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_frc_GenericHID() {
    const UNINIT: ::std::mem::MaybeUninit<frc_GenericHID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_GenericHID>(),
        16usize,
        concat!("Size of: ", stringify!(frc_GenericHID))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_GenericHID>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_GenericHID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_port) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_GenericHID),
            "::",
            stringify!(m_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_outputs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_GenericHID),
            "::",
            stringify!(m_outputs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_leftRumble) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_GenericHID),
            "::",
            stringify!(m_leftRumble)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rightRumble) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_GenericHID),
            "::",
            stringify!(m_rightRumble)
        )
    );
}
extern "C" {
    #[doc = " Get the button value (starting at button 1).\n\n The buttons are returned in a single 16 bit value with one bit representing\n the state of each button. The appropriate button is returned as a boolean\n value.\n\n This method returns true if the button is being held down at the time\n that this method is being called.\n\n @param button The button number to be read (starting at 1)\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID12GetRawButtonEi"]
    pub fn frc_GenericHID_GetRawButton(
        this: *const frc_GenericHID,
        button: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Whether the button was pressed since the last check. %Button indexes begin\n at 1.\n\n This method returns true if the button went from not pressed to held down\n since the last time this method was called. This is useful if you only\n want to call a function once when you press the button.\n\n @param button The button index, beginning at 1.\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc10GenericHID19GetRawButtonPressedEi"]
    pub fn frc_GenericHID_GetRawButtonPressed(
        this: *mut frc_GenericHID,
        button: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Whether the button was released since the last check. %Button indexes begin\n at 1.\n\n This method returns true if the button went from held down to not pressed\n since the last time this method was called. This is useful if you only\n want to call a function once when you release the button.\n\n @param button The button index, beginning at 1.\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc10GenericHID20GetRawButtonReleasedEi"]
    pub fn frc_GenericHID_GetRawButtonReleased(
        this: *mut frc_GenericHID,
        button: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around this button's digital signal.\n\n @param button the button index\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the button's digital signal attached\n to the given loop."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID6ButtonEiPNS_9EventLoopE"]
    pub fn frc_GenericHID_Button(
        this: *const frc_GenericHID,
        button: ::std::os::raw::c_int,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Get the value of the axis.\n\n @param axis The axis to read, starting at 0.\n @return The value of the axis."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID10GetRawAxisEi"]
    pub fn frc_GenericHID_GetRawAxis(
        this: *const frc_GenericHID,
        axis: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " Get the angle in degrees of a POV on the HID.\n\n The POV angles start at 0 in the up direction, and increase clockwise\n (e.g. right is 90, upper-left is 315).\n\n @param pov The index of the POV to read (starting at 0)\n @return the angle of the POV in degrees, or -1 if the POV is not pressed."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID6GetPOVEi"]
    pub fn frc_GenericHID_GetPOV(
        this: *const frc_GenericHID,
        pov: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Constructs a BooleanEvent instance based around this angle of a POV on the\n HID.\n\n <p>The POV angles start at 0 in the up direction, and increase clockwise\n (eg right is 90, upper-left is 315).\n\n @param loop the event loop instance to attach the event to.\n @param angle POV angle in degrees, or -1 for the center / not pressed.\n @return a BooleanEvent instance based around this angle of a POV on the\n HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID3POVEiPNS_9EventLoopE"]
    pub fn frc_GenericHID_POV(
        this: *const frc_GenericHID,
        angle: ::std::os::raw::c_int,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs a BooleanEvent instance based around this angle of a POV on the\n HID.\n\n <p>The POV angles start at 0 in the up direction, and increase clockwise\n (eg right is 90, upper-left is 315).\n\n @param loop the event loop instance to attach the event to.\n @param pov   index of the POV to read (starting at 0). Defaults to 0.\n @param angle POV angle in degrees, or -1 for the center / not pressed.\n @return a BooleanEvent instance based around this angle of a POV on the\n HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID3POVEiiPNS_9EventLoopE"]
    pub fn frc_GenericHID_POV1(
        this: *const frc_GenericHID,
        pov: ::std::os::raw::c_int,
        angle: ::std::os::raw::c_int,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs a BooleanEvent instance based around the 0 degree angle (up) of\n the default (index 0) POV on the HID.\n\n @return a BooleanEvent instance based around the 0 degree angle of a POV on\n the HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID5POVUpEPNS_9EventLoopE"]
    pub fn frc_GenericHID_POVUp(
        this: *const frc_GenericHID,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs a BooleanEvent instance based around the 45 degree angle (right\n up) of the default (index 0) POV on the HID.\n\n @return a BooleanEvent instance based around the 45 degree angle of a POV\n on the HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID10POVUpRightEPNS_9EventLoopE"]
    pub fn frc_GenericHID_POVUpRight(
        this: *const frc_GenericHID,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs a BooleanEvent instance based around the 90 degree angle (right)\n of the default (index 0) POV on the HID.\n\n @return a BooleanEvent instance based around the 90 degree angle of a POV\n on the HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID8POVRightEPNS_9EventLoopE"]
    pub fn frc_GenericHID_POVRight(
        this: *const frc_GenericHID,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs a BooleanEvent instance based around the 135 degree angle (right\n down) of the default (index 0) POV on the HID.\n\n @return a BooleanEvent instance based around the 135 degree angle of a POV\n on the HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID12POVDownRightEPNS_9EventLoopE"]
    pub fn frc_GenericHID_POVDownRight(
        this: *const frc_GenericHID,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs a BooleanEvent instance based around the 180 degree angle (down)\n of the default (index 0) POV on the HID.\n\n @return a BooleanEvent instance based around the 180 degree angle of a POV\n on the HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID7POVDownEPNS_9EventLoopE"]
    pub fn frc_GenericHID_POVDown(
        this: *const frc_GenericHID,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs a BooleanEvent instance based around the 225 degree angle (down\n left) of the default (index 0) POV on the HID.\n\n @return a BooleanEvent instance based around the 225 degree angle of a POV\n on the HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID11POVDownLeftEPNS_9EventLoopE"]
    pub fn frc_GenericHID_POVDownLeft(
        this: *const frc_GenericHID,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs a BooleanEvent instance based around the 270 degree angle (left)\n of the default (index 0) POV on the HID.\n\n @return a BooleanEvent instance based around the 270 degree angle of a POV\n on the HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID7POVLeftEPNS_9EventLoopE"]
    pub fn frc_GenericHID_POVLeft(
        this: *const frc_GenericHID,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs a BooleanEvent instance based around the 315 degree angle (left\n up) of the default (index 0) POV on the HID.\n\n @return a BooleanEvent instance based around the 315 degree angle of a POV\n on the HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID9POVUpLeftEPNS_9EventLoopE"]
    pub fn frc_GenericHID_POVUpLeft(
        this: *const frc_GenericHID,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs a BooleanEvent instance based around the center (not pressed) of\n the default (index 0) POV on the HID.\n\n @return a BooleanEvent instance based around the center of a POV on the\n HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID9POVCenterEPNS_9EventLoopE"]
    pub fn frc_GenericHID_POVCenter(
        this: *const frc_GenericHID,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs an event instance that is true when the axis value is less than\n threshold\n\n @param axis The axis to read, starting at 0.\n @param threshold The value below which this trigger should return true.\n @param loop the event loop instance to attach the event to.\n @return an event instance that is true when the axis value is less than the\n provided threshold."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID12AxisLessThanEidPNS_9EventLoopE"]
    pub fn frc_GenericHID_AxisLessThan(
        this: *const frc_GenericHID,
        axis: ::std::os::raw::c_int,
        threshold: f64,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs an event instance that is true when the axis value is greater\n than threshold\n\n @param axis The axis to read, starting at 0.\n @param threshold The value above which this trigger should return true.\n @param loop the event loop instance to attach the event to.\n @return an event instance that is true when the axis value is greater than\n the provided threshold."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID15AxisGreaterThanEidPNS_9EventLoopE"]
    pub fn frc_GenericHID_AxisGreaterThan(
        this: *const frc_GenericHID,
        axis: ::std::os::raw::c_int,
        threshold: f64,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Get the number of axes for the HID.\n\n @return the number of axis for the current HID"]
    #[link_name = "\u{1}_ZNK3frc10GenericHID12GetAxisCountEv"]
    pub fn frc_GenericHID_GetAxisCount(this: *const frc_GenericHID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of POVs for the HID.\n\n @return the number of POVs for the current HID"]
    #[link_name = "\u{1}_ZNK3frc10GenericHID11GetPOVCountEv"]
    pub fn frc_GenericHID_GetPOVCount(this: *const frc_GenericHID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of buttons for the HID.\n\n @return the number of buttons on the current HID"]
    #[link_name = "\u{1}_ZNK3frc10GenericHID14GetButtonCountEv"]
    pub fn frc_GenericHID_GetButtonCount(this: *const frc_GenericHID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get if the HID is connected.\n\n @return true if the HID is connected"]
    #[link_name = "\u{1}_ZNK3frc10GenericHID11IsConnectedEv"]
    pub fn frc_GenericHID_IsConnected(this: *const frc_GenericHID) -> bool;
}
extern "C" {
    #[doc = " Get the type of the HID.\n\n @return the type of the HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID7GetTypeEv"]
    pub fn frc_GenericHID_GetType(this: *const frc_GenericHID) -> frc_GenericHID_HIDType;
}
extern "C" {
    #[doc = " Get the name of the HID.\n\n @return the name of the HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID7GetNameB5cxx11Ev"]
    pub fn frc_GenericHID_GetName(this: *const frc_GenericHID) -> std_string;
}
extern "C" {
    #[doc = " Get the axis type of a joystick axis.\n\n @return the axis type of a joystick axis."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID11GetAxisTypeEi"]
    pub fn frc_GenericHID_GetAxisType(
        this: *const frc_GenericHID,
        axis: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the port number of the HID.\n\n @return The port number of the HID."]
    #[link_name = "\u{1}_ZNK3frc10GenericHID7GetPortEv"]
    pub fn frc_GenericHID_GetPort(this: *const frc_GenericHID) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set a single HID output value for the HID.\n\n @param outputNumber The index of the output to set (1-32)\n @param value        The value to set the output to"]
    #[link_name = "\u{1}_ZN3frc10GenericHID9SetOutputEib"]
    pub fn frc_GenericHID_SetOutput(
        this: *mut frc_GenericHID,
        outputNumber: ::std::os::raw::c_int,
        value: bool,
    );
}
extern "C" {
    #[doc = " Set all output values for the HID.\n\n @param value The 32 bit output value (1 bit for each output)"]
    #[link_name = "\u{1}_ZN3frc10GenericHID10SetOutputsEi"]
    pub fn frc_GenericHID_SetOutputs(this: *mut frc_GenericHID, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the rumble output for the HID.\n\n The DS currently supports 2 rumble values, left rumble and right rumble.\n\n @param type  Which rumble value to set\n @param value The normalized value (0 to 1) to set the rumble to"]
    #[link_name = "\u{1}_ZN3frc10GenericHID9SetRumbleENS0_10RumbleTypeEd"]
    pub fn frc_GenericHID_SetRumble(
        this: *mut frc_GenericHID,
        type_: frc_GenericHID_RumbleType,
        value: f64,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10GenericHIDC1Ei"]
    pub fn frc_GenericHID_GenericHID(this: *mut frc_GenericHID, port: ::std::os::raw::c_int);
}
impl frc_GenericHID {
    #[inline]
    pub unsafe fn GetRawButton(&self, button: ::std::os::raw::c_int) -> bool {
        frc_GenericHID_GetRawButton(self, button)
    }
    #[inline]
    pub unsafe fn GetRawButtonPressed(&mut self, button: ::std::os::raw::c_int) -> bool {
        frc_GenericHID_GetRawButtonPressed(self, button)
    }
    #[inline]
    pub unsafe fn GetRawButtonReleased(&mut self, button: ::std::os::raw::c_int) -> bool {
        frc_GenericHID_GetRawButtonReleased(self, button)
    }
    #[inline]
    pub unsafe fn Button(
        &self,
        button: ::std::os::raw::c_int,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent {
        frc_GenericHID_Button(self, button, loop_)
    }
    #[inline]
    pub unsafe fn GetRawAxis(&self, axis: ::std::os::raw::c_int) -> f64 {
        frc_GenericHID_GetRawAxis(self, axis)
    }
    #[inline]
    pub unsafe fn GetPOV(&self, pov: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        frc_GenericHID_GetPOV(self, pov)
    }
    #[inline]
    pub unsafe fn POV(
        &self,
        angle: ::std::os::raw::c_int,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent {
        frc_GenericHID_POV(self, angle, loop_)
    }
    #[inline]
    pub unsafe fn POV1(
        &self,
        pov: ::std::os::raw::c_int,
        angle: ::std::os::raw::c_int,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent {
        frc_GenericHID_POV1(self, pov, angle, loop_)
    }
    #[inline]
    pub unsafe fn POVUp(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_GenericHID_POVUp(self, loop_)
    }
    #[inline]
    pub unsafe fn POVUpRight(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_GenericHID_POVUpRight(self, loop_)
    }
    #[inline]
    pub unsafe fn POVRight(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_GenericHID_POVRight(self, loop_)
    }
    #[inline]
    pub unsafe fn POVDownRight(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_GenericHID_POVDownRight(self, loop_)
    }
    #[inline]
    pub unsafe fn POVDown(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_GenericHID_POVDown(self, loop_)
    }
    #[inline]
    pub unsafe fn POVDownLeft(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_GenericHID_POVDownLeft(self, loop_)
    }
    #[inline]
    pub unsafe fn POVLeft(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_GenericHID_POVLeft(self, loop_)
    }
    #[inline]
    pub unsafe fn POVUpLeft(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_GenericHID_POVUpLeft(self, loop_)
    }
    #[inline]
    pub unsafe fn POVCenter(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_GenericHID_POVCenter(self, loop_)
    }
    #[inline]
    pub unsafe fn AxisLessThan(
        &self,
        axis: ::std::os::raw::c_int,
        threshold: f64,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent {
        frc_GenericHID_AxisLessThan(self, axis, threshold, loop_)
    }
    #[inline]
    pub unsafe fn AxisGreaterThan(
        &self,
        axis: ::std::os::raw::c_int,
        threshold: f64,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent {
        frc_GenericHID_AxisGreaterThan(self, axis, threshold, loop_)
    }
    #[inline]
    pub unsafe fn GetAxisCount(&self) -> ::std::os::raw::c_int {
        frc_GenericHID_GetAxisCount(self)
    }
    #[inline]
    pub unsafe fn GetPOVCount(&self) -> ::std::os::raw::c_int {
        frc_GenericHID_GetPOVCount(self)
    }
    #[inline]
    pub unsafe fn GetButtonCount(&self) -> ::std::os::raw::c_int {
        frc_GenericHID_GetButtonCount(self)
    }
    #[inline]
    pub unsafe fn IsConnected(&self) -> bool {
        frc_GenericHID_IsConnected(self)
    }
    #[inline]
    pub unsafe fn GetType(&self) -> frc_GenericHID_HIDType {
        frc_GenericHID_GetType(self)
    }
    #[inline]
    pub unsafe fn GetName(&self) -> std_string {
        frc_GenericHID_GetName(self)
    }
    #[inline]
    pub unsafe fn GetAxisType(&self, axis: ::std::os::raw::c_int) -> ::std::os::raw::c_int {
        frc_GenericHID_GetAxisType(self, axis)
    }
    #[inline]
    pub unsafe fn GetPort(&self) -> ::std::os::raw::c_int {
        frc_GenericHID_GetPort(self)
    }
    #[inline]
    pub unsafe fn SetOutput(&mut self, outputNumber: ::std::os::raw::c_int, value: bool) {
        frc_GenericHID_SetOutput(self, outputNumber, value)
    }
    #[inline]
    pub unsafe fn SetOutputs(&mut self, value: ::std::os::raw::c_int) {
        frc_GenericHID_SetOutputs(self, value)
    }
    #[inline]
    pub unsafe fn SetRumble(&mut self, type_: frc_GenericHID_RumbleType, value: f64) {
        frc_GenericHID_SetRumble(self, type_, value)
    }
    #[inline]
    pub unsafe fn new(port: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_GenericHID_GenericHID(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
}
pub const frc_RuntimeType_kRoboRIO: frc_RuntimeType = 0;
pub const frc_RuntimeType_kRoboRIO2: frc_RuntimeType = 1;
pub const frc_RuntimeType_kSimulation: frc_RuntimeType = 2;
pub type frc_RuntimeType = ::std::os::raw::c_uint;
extern "C" {
    #[link_name = "\u{1}_ZN3frc20RunHALInitializationEv"]
    pub fn frc_RunHALInitialization() -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc4impl16ResetMotorSafetyEv"]
    pub fn frc_impl_ResetMotorSafety();
}
#[repr(C)]
pub struct frc_RobotBase__bindgen_vtable {
    pub frc_RobotBase_StartCompetition: unsafe extern "C" fn(this: *mut frc_RobotBase),
    pub frc_RobotBase_EndCompetition: unsafe extern "C" fn(this: *mut frc_RobotBase),
}
#[doc = " Implement a Robot Program framework.\n\n The RobotBase class is intended to be subclassed by a user creating a robot\n program. Overridden Autonomous() and OperatorControl() methods are called at\n the appropriate time as the match proceeds. In the current implementation,\n the Autonomous code will run to completion before the OperatorControl code\n could start. In the future the Autonomous code might be spawned as a task,\n then killed at the end of the Autonomous period."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_RobotBase {
    pub vtable_: *const frc_RobotBase__bindgen_vtable,
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc9RobotBase10m_threadIdE"]
    pub static mut frc_RobotBase_m_threadId: std_thread_id;
}
#[test]
fn bindgen_test_layout_frc_RobotBase() {
    assert_eq!(
        ::std::mem::size_of::<frc_RobotBase>(),
        4usize,
        concat!("Size of: ", stringify!(frc_RobotBase))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_RobotBase>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_RobotBase))
    );
}
extern "C" {
    #[doc = " Determine if the Robot is currently enabled.\n\n @return True if the Robot is currently enabled by the field controls."]
    #[link_name = "\u{1}_ZNK3frc9RobotBase9IsEnabledEv"]
    pub fn frc_RobotBase_IsEnabled(this: *const frc_RobotBase) -> bool;
}
extern "C" {
    #[doc = " Determine if the Robot is currently disabled.\n\n @return True if the Robot is currently disabled by the field controls."]
    #[link_name = "\u{1}_ZNK3frc9RobotBase10IsDisabledEv"]
    pub fn frc_RobotBase_IsDisabled(this: *const frc_RobotBase) -> bool;
}
extern "C" {
    #[doc = " Determine if the robot is currently in Autonomous mode.\n\n @return True if the robot is currently operating Autonomously as determined\n         by the field controls."]
    #[link_name = "\u{1}_ZNK3frc9RobotBase12IsAutonomousEv"]
    pub fn frc_RobotBase_IsAutonomous(this: *const frc_RobotBase) -> bool;
}
extern "C" {
    #[doc = " Determine if the robot is currently in Autonomous mode and enabled.\n\n @return True if the robot us currently operating Autonomously while enabled\n as determined by the field controls."]
    #[link_name = "\u{1}_ZNK3frc9RobotBase19IsAutonomousEnabledEv"]
    pub fn frc_RobotBase_IsAutonomousEnabled(this: *const frc_RobotBase) -> bool;
}
extern "C" {
    #[doc = " Determine if the robot is currently in Operator Control mode.\n\n @return True if the robot is currently operating in Tele-Op mode as\n         determined by the field controls."]
    #[link_name = "\u{1}_ZNK3frc9RobotBase8IsTeleopEv"]
    pub fn frc_RobotBase_IsTeleop(this: *const frc_RobotBase) -> bool;
}
extern "C" {
    #[doc = " Determine if the robot is current in Operator Control mode and enabled.\n\n @return True if the robot is currently operating in Tele-Op mode while\n wnabled as determined by the field-controls."]
    #[link_name = "\u{1}_ZNK3frc9RobotBase15IsTeleopEnabledEv"]
    pub fn frc_RobotBase_IsTeleopEnabled(this: *const frc_RobotBase) -> bool;
}
extern "C" {
    #[doc = " Determine if the robot is currently in Test mode.\n\n @return True if the robot is currently running tests as determined by the\n         field controls."]
    #[link_name = "\u{1}_ZNK3frc9RobotBase6IsTestEv"]
    pub fn frc_RobotBase_IsTest(this: *const frc_RobotBase) -> bool;
}
extern "C" {
    #[doc = " Gets the ID of the main robot thread."]
    #[link_name = "\u{1}_ZN3frc9RobotBase11GetThreadIdEv"]
    pub fn frc_RobotBase_GetThreadId() -> std_thread_id;
}
extern "C" {
    #[doc = " Get the current runtime type.\n\n @return Current runtime type."]
    #[link_name = "\u{1}_ZN3frc9RobotBase14GetRuntimeTypeEv"]
    pub fn frc_RobotBase_GetRuntimeType() -> frc_RuntimeType;
}
extern "C" {
    #[doc = " Constructor for a generic robot program.\n\n User code should be placed in the constructor that runs before the\n Autonomous or Operator Control period starts. The constructor will run to\n completion before Autonomous is entered.\n\n This must be used to ensure that the communications code starts. In the\n future it would be nice to put this code into it's own task that loads on\n boot so ensure that it runs."]
    #[link_name = "\u{1}_ZN3frc9RobotBaseC2Ev"]
    pub fn frc_RobotBase_RobotBase(this: *mut frc_RobotBase);
}
impl frc_RobotBase {
    #[inline]
    pub unsafe fn IsEnabled(&self) -> bool {
        frc_RobotBase_IsEnabled(self)
    }
    #[inline]
    pub unsafe fn IsDisabled(&self) -> bool {
        frc_RobotBase_IsDisabled(self)
    }
    #[inline]
    pub unsafe fn IsAutonomous(&self) -> bool {
        frc_RobotBase_IsAutonomous(self)
    }
    #[inline]
    pub unsafe fn IsAutonomousEnabled(&self) -> bool {
        frc_RobotBase_IsAutonomousEnabled(self)
    }
    #[inline]
    pub unsafe fn IsTeleop(&self) -> bool {
        frc_RobotBase_IsTeleop(self)
    }
    #[inline]
    pub unsafe fn IsTeleopEnabled(&self) -> bool {
        frc_RobotBase_IsTeleopEnabled(self)
    }
    #[inline]
    pub unsafe fn IsTest(&self) -> bool {
        frc_RobotBase_IsTest(self)
    }
    #[inline]
    pub unsafe fn GetThreadId() -> std_thread_id {
        frc_RobotBase_GetThreadId()
    }
    #[inline]
    pub unsafe fn GetRuntimeType() -> frc_RuntimeType {
        frc_RobotBase_GetRuntimeType()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_RobotBase_RobotBase(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " A class for keeping track of how much time it takes for different parts of\n code to execute. This is done with epochs, that are added to calls to\n AddEpoch() and can be printed with a call to PrintEpochs().\n\n Epochs are a way to partition the time elapsed so that when overruns occur,\n one can determine which parts of an operation consumed the most time."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Tracer {
    pub m_startTime: hal_fpga_clock_time_point,
    pub m_lastEpochsPrintTime: hal_fpga_clock_time_point,
    pub m_epochs: wpi_StringMap<wpi_MallocAllocator>,
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6Tracer15kMinPrintPeriodE"]
    pub static frc_Tracer_kMinPrintPeriod: std_chrono_milliseconds;
}
#[test]
fn bindgen_test_layout_frc_Tracer() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Tracer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Tracer>(),
        40usize,
        concat!("Size of: ", stringify!(frc_Tracer))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Tracer>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_Tracer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_startTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Tracer),
            "::",
            stringify!(m_startTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_lastEpochsPrintTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Tracer),
            "::",
            stringify!(m_lastEpochsPrintTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_epochs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Tracer),
            "::",
            stringify!(m_epochs)
        )
    );
}
extern "C" {
    #[doc = " Restarts the epoch timer."]
    #[link_name = "\u{1}_ZN3frc6Tracer10ResetTimerEv"]
    pub fn frc_Tracer_ResetTimer(this: *mut frc_Tracer);
}
extern "C" {
    #[doc = " Clears all epochs."]
    #[link_name = "\u{1}_ZN3frc6Tracer11ClearEpochsEv"]
    pub fn frc_Tracer_ClearEpochs(this: *mut frc_Tracer);
}
extern "C" {
    #[doc = " Adds time since last epoch to the list printed by PrintEpochs().\n\n Epochs are a way to partition the time elapsed so that when overruns occur,\n one can determine which parts of an operation consumed the most time.\n\n @param epochName The name to associate with the epoch."]
    #[link_name = "\u{1}_ZN3frc6Tracer8AddEpochESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_Tracer_AddEpoch(this: *mut frc_Tracer, epochName: std_string_view);
}
extern "C" {
    #[doc = " Prints list of epochs added so far and their times to the DriverStation."]
    #[link_name = "\u{1}_ZN3frc6Tracer11PrintEpochsEv"]
    pub fn frc_Tracer_PrintEpochs(this: *mut frc_Tracer);
}
extern "C" {
    #[doc = " Prints list of epochs added so far and their times to a stream.\n\n @param os output stream"]
    #[link_name = "\u{1}_ZN3frc6Tracer11PrintEpochsERN3wpi11raw_ostreamE"]
    pub fn frc_Tracer_PrintEpochs1(this: *mut frc_Tracer, os: *mut wpi_raw_ostream);
}
extern "C" {
    #[doc = " Constructs a Tracer instance."]
    #[link_name = "\u{1}_ZN3frc6TracerC1Ev"]
    pub fn frc_Tracer_Tracer(this: *mut frc_Tracer);
}
impl frc_Tracer {
    #[inline]
    pub unsafe fn ResetTimer(&mut self) {
        frc_Tracer_ResetTimer(self)
    }
    #[inline]
    pub unsafe fn ClearEpochs(&mut self) {
        frc_Tracer_ClearEpochs(self)
    }
    #[inline]
    pub unsafe fn AddEpoch(&mut self, epochName: std_string_view) {
        frc_Tracer_AddEpoch(self, epochName)
    }
    #[inline]
    pub unsafe fn PrintEpochs(&mut self) {
        frc_Tracer_PrintEpochs(self)
    }
    #[inline]
    pub unsafe fn PrintEpochs1(&mut self, os: *mut wpi_raw_ostream) {
        frc_Tracer_PrintEpochs1(self, os)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Tracer_Tracer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[doc = " A class that's a wrapper around a watchdog timer.\n\n When the timer expires, a message is printed to the console and an optional\n user-provided callback is invoked.\n\n The watchdog is initialized disabled, so the user needs to call Enable()\n before use."]
#[repr(C)]
pub struct frc_Watchdog {
    pub m_startTime: units_time_second_t,
    pub m_timeout: units_time_second_t,
    pub m_expirationTime: units_time_second_t,
    pub m_callback: [u32; 4usize],
    pub m_lastTimeoutPrintTime: units_time_second_t,
    pub m_tracer: frc_Tracer,
    pub m_isExpired: bool,
    pub m_suppressTimeoutMessage: bool,
    pub m_impl: *mut frc_Watchdog_Impl,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_Watchdog_Impl {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc8Watchdog15kMinPrintPeriodE"]
    pub static frc_Watchdog_kMinPrintPeriod: units_time_second_t;
}
#[test]
fn bindgen_test_layout_frc_Watchdog() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Watchdog> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Watchdog>(),
        96usize,
        concat!("Size of: ", stringify!(frc_Watchdog))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Watchdog>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_Watchdog))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_startTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Watchdog),
            "::",
            stringify!(m_startTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_timeout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Watchdog),
            "::",
            stringify!(m_timeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_expirationTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Watchdog),
            "::",
            stringify!(m_expirationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_callback) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Watchdog),
            "::",
            stringify!(m_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_lastTimeoutPrintTime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Watchdog),
            "::",
            stringify!(m_lastTimeoutPrintTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tracer) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Watchdog),
            "::",
            stringify!(m_tracer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_isExpired) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Watchdog),
            "::",
            stringify!(m_isExpired)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_suppressTimeoutMessage) as usize - ptr as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Watchdog),
            "::",
            stringify!(m_suppressTimeoutMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_impl) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Watchdog),
            "::",
            stringify!(m_impl)
        )
    );
}
extern "C" {
    #[doc = " Returns the time since the watchdog was last fed."]
    #[link_name = "\u{1}_ZNK3frc8Watchdog7GetTimeEv"]
    pub fn frc_Watchdog_GetTime(this: *const frc_Watchdog) -> units_time_second_t;
}
extern "C" {
    #[doc = " Sets the watchdog's timeout.\n\n @param timeout The watchdog's timeout in seconds with microsecond\n                resolution."]
    #[link_name = "\u{1}_ZN3frc8Watchdog10SetTimeoutEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_Watchdog_SetTimeout(this: *mut frc_Watchdog, timeout: units_time_second_t);
}
extern "C" {
    #[doc = " Returns the watchdog's timeout."]
    #[link_name = "\u{1}_ZNK3frc8Watchdog10GetTimeoutEv"]
    pub fn frc_Watchdog_GetTimeout(this: *const frc_Watchdog) -> units_time_second_t;
}
extern "C" {
    #[doc = " Returns true if the watchdog timer has expired."]
    #[link_name = "\u{1}_ZNK3frc8Watchdog9IsExpiredEv"]
    pub fn frc_Watchdog_IsExpired(this: *const frc_Watchdog) -> bool;
}
extern "C" {
    #[doc = " Adds time since last epoch to the list printed by PrintEpochs().\n\n Epochs are a way to partition the time elapsed so that when overruns occur,\n one can determine which parts of an operation consumed the most time.\n\n @param epochName The name to associate with the epoch."]
    #[link_name = "\u{1}_ZN3frc8Watchdog8AddEpochESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_Watchdog_AddEpoch(this: *mut frc_Watchdog, epochName: std_string_view);
}
extern "C" {
    #[doc = " Prints list of epochs added so far and their times."]
    #[link_name = "\u{1}_ZN3frc8Watchdog11PrintEpochsEv"]
    pub fn frc_Watchdog_PrintEpochs(this: *mut frc_Watchdog);
}
extern "C" {
    #[doc = " Resets the watchdog timer.\n\n This also enables the timer if it was previously disabled."]
    #[link_name = "\u{1}_ZN3frc8Watchdog5ResetEv"]
    pub fn frc_Watchdog_Reset(this: *mut frc_Watchdog);
}
extern "C" {
    #[doc = " Enables the watchdog timer."]
    #[link_name = "\u{1}_ZN3frc8Watchdog6EnableEv"]
    pub fn frc_Watchdog_Enable(this: *mut frc_Watchdog);
}
extern "C" {
    #[doc = " Disables the watchdog timer."]
    #[link_name = "\u{1}_ZN3frc8Watchdog7DisableEv"]
    pub fn frc_Watchdog_Disable(this: *mut frc_Watchdog);
}
extern "C" {
    #[doc = " Enable or disable suppression of the generic timeout message.\n\n This may be desirable if the user-provided callback already prints a more\n specific message.\n\n @param suppress Whether to suppress generic timeout message."]
    #[link_name = "\u{1}_ZN3frc8Watchdog22SuppressTimeoutMessageEb"]
    pub fn frc_Watchdog_SuppressTimeoutMessage(this: *mut frc_Watchdog, suppress: bool);
}
extern "C" {
    #[doc = " Watchdog constructor.\n\n @param timeout  The watchdog's timeout in seconds with microsecond\n                 resolution.\n @param callback This function is called when the timeout expires."]
    #[link_name = "\u{1}_ZN3frc8WatchdogC1EN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEESt8functionIFvvEE"]
    pub fn frc_Watchdog_Watchdog(
        this: *mut frc_Watchdog,
        timeout: units_time_second_t,
        callback: [u32; 4usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc8WatchdogC1EOS0_"]
    pub fn frc_Watchdog_Watchdog1(this: *mut frc_Watchdog, rhs: *mut frc_Watchdog);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc8WatchdogD1Ev"]
    pub fn frc_Watchdog_Watchdog_destructor(this: *mut frc_Watchdog);
}
impl frc_Watchdog {
    #[inline]
    pub unsafe fn GetTime(&self) -> units_time_second_t {
        frc_Watchdog_GetTime(self)
    }
    #[inline]
    pub unsafe fn SetTimeout(&mut self, timeout: units_time_second_t) {
        frc_Watchdog_SetTimeout(self, timeout)
    }
    #[inline]
    pub unsafe fn GetTimeout(&self) -> units_time_second_t {
        frc_Watchdog_GetTimeout(self)
    }
    #[inline]
    pub unsafe fn IsExpired(&self) -> bool {
        frc_Watchdog_IsExpired(self)
    }
    #[inline]
    pub unsafe fn AddEpoch(&mut self, epochName: std_string_view) {
        frc_Watchdog_AddEpoch(self, epochName)
    }
    #[inline]
    pub unsafe fn PrintEpochs(&mut self) {
        frc_Watchdog_PrintEpochs(self)
    }
    #[inline]
    pub unsafe fn Reset(&mut self) {
        frc_Watchdog_Reset(self)
    }
    #[inline]
    pub unsafe fn Enable(&mut self) {
        frc_Watchdog_Enable(self)
    }
    #[inline]
    pub unsafe fn Disable(&mut self) {
        frc_Watchdog_Disable(self)
    }
    #[inline]
    pub unsafe fn SuppressTimeoutMessage(&mut self, suppress: bool) {
        frc_Watchdog_SuppressTimeoutMessage(self, suppress)
    }
    #[inline]
    pub unsafe fn new(timeout: units_time_second_t, callback: [u32; 4usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Watchdog_Watchdog(__bindgen_tmp.as_mut_ptr(), timeout, callback);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rhs: *mut frc_Watchdog) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Watchdog_Watchdog1(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        frc_Watchdog_Watchdog_destructor(self)
    }
}
#[doc = " IterativeRobotBase implements a specific type of robot program framework,\n extending the RobotBase class.\n\n The IterativeRobotBase class does not implement StartCompetition(), so it\n should not be used by teams directly.\n\n This class provides the following functions which are called by the main\n loop, StartCompetition(), at the appropriate times:\n\n RobotInit() -- provide for initialization at robot power-on\n\n Init() functions -- each of the following functions is called once when the\n appropriate mode is entered:\n\n \\li DisabledInit() -- called each and every time disabled is entered from\n   another mode\n \\li AutonomousInit() -- called each and every time autonomous is entered from\n   another mode\n \\li TeleopInit() -- called each and every time teleop is entered from another\n   mode\n \\li TestInit() -- called each and every time test is entered from another\n   mode\n\n Periodic() functions -- each of these functions is called on an interval:\n\n \\li RobotPeriodic()\n \\li DisabledPeriodic()\n \\li AutonomousPeriodic()\n \\li TeleopPeriodic()\n \\li TestPeriodic()\n\n Exit() functions -- each of the following functions is called once when the\n appropriate mode is exited:\n\n \\li DisabledExit() -- called each and every time disabled is exited\n \\li AutonomousExit() -- called each and every time autonomous is exited\n \\li TeleopExit() -- called each and every time teleop is exited\n \\li TestExit() -- called each and every time test is exited"]
#[repr(C)]
pub struct frc_IterativeRobotBase {
    pub _base: frc_RobotBase,
    pub m_lastMode: frc_IterativeRobotBase_Mode,
    pub m_period: units_time_second_t,
    pub m_watchdog: frc_Watchdog,
    pub m_ntFlushEnabled: bool,
    pub m_lwEnabledInTest: bool,
}
pub const frc_IterativeRobotBase_Mode_kNone: frc_IterativeRobotBase_Mode = 0;
pub const frc_IterativeRobotBase_Mode_kDisabled: frc_IterativeRobotBase_Mode = 1;
pub const frc_IterativeRobotBase_Mode_kAutonomous: frc_IterativeRobotBase_Mode = 2;
pub const frc_IterativeRobotBase_Mode_kTeleop: frc_IterativeRobotBase_Mode = 3;
pub const frc_IterativeRobotBase_Mode_kTest: frc_IterativeRobotBase_Mode = 4;
pub type frc_IterativeRobotBase_Mode = ::std::os::raw::c_int;
#[test]
fn bindgen_test_layout_frc_IterativeRobotBase() {
    const UNINIT: ::std::mem::MaybeUninit<frc_IterativeRobotBase> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_IterativeRobotBase>(),
        120usize,
        concat!("Size of: ", stringify!(frc_IterativeRobotBase))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_IterativeRobotBase>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_IterativeRobotBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_lastMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_IterativeRobotBase),
            "::",
            stringify!(m_lastMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_period) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_IterativeRobotBase),
            "::",
            stringify!(m_period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_watchdog) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_IterativeRobotBase),
            "::",
            stringify!(m_watchdog)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_ntFlushEnabled) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_IterativeRobotBase),
            "::",
            stringify!(m_ntFlushEnabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_lwEnabledInTest) as usize - ptr as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_IterativeRobotBase),
            "::",
            stringify!(m_lwEnabledInTest)
        )
    );
}
extern "C" {
    #[doc = " Enables or disables flushing NetworkTables every loop iteration.\n By default, this is enabled.\n\n @param enabled True to enable, false to disable"]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase28SetNetworkTablesFlushEnabledEb"]
    pub fn frc_IterativeRobotBase_SetNetworkTablesFlushEnabled(
        this: *mut frc_IterativeRobotBase,
        enabled: bool,
    );
}
extern "C" {
    #[doc = " Sets whether LiveWindow operation is enabled during test mode.\n\n @param testLW True to enable, false to disable. Defaults to true.\n @throws if called in test mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase22EnableLiveWindowInTestEb"]
    pub fn frc_IterativeRobotBase_EnableLiveWindowInTest(
        this: *mut frc_IterativeRobotBase,
        testLW: bool,
    );
}
extern "C" {
    #[doc = " Whether LiveWindow operation is enabled during test mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase25IsLiveWindowEnabledInTestEv"]
    pub fn frc_IterativeRobotBase_IsLiveWindowEnabledInTest(
        this: *mut frc_IterativeRobotBase,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets time period between calls to Periodic() functions."]
    #[link_name = "\u{1}_ZNK3frc18IterativeRobotBase9GetPeriodEv"]
    pub fn frc_IterativeRobotBase_GetPeriod(
        this: *const frc_IterativeRobotBase,
    ) -> units_time_second_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase8LoopFuncEv"]
    pub fn frc_IterativeRobotBase_LoopFunc(this: *mut frc_IterativeRobotBase);
}
extern "C" {
    #[doc = " Constructor for IterativeRobotBase.\n\n @param period Period."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBaseC2EN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_IterativeRobotBase_IterativeRobotBase(
        this: *mut frc_IterativeRobotBase,
        period: units_time_second_t,
    );
}
impl frc_IterativeRobotBase {
    #[inline]
    pub unsafe fn SetNetworkTablesFlushEnabled(&mut self, enabled: bool) {
        frc_IterativeRobotBase_SetNetworkTablesFlushEnabled(self, enabled)
    }
    #[inline]
    pub unsafe fn EnableLiveWindowInTest(&mut self, testLW: bool) {
        frc_IterativeRobotBase_EnableLiveWindowInTest(self, testLW)
    }
    #[inline]
    pub unsafe fn IsLiveWindowEnabledInTest(&mut self) -> bool {
        frc_IterativeRobotBase_IsLiveWindowEnabledInTest(self)
    }
    #[inline]
    pub unsafe fn GetPeriod(&self) -> units_time_second_t {
        frc_IterativeRobotBase_GetPeriod(self)
    }
    #[inline]
    pub unsafe fn LoopFunc(&mut self) {
        frc_IterativeRobotBase_LoopFunc(self)
    }
    #[inline]
    pub unsafe fn new(period: units_time_second_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_IterativeRobotBase_IterativeRobotBase(__bindgen_tmp.as_mut_ptr(), period);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Robot-wide initialization code should go here.\n\n Users should override this method for default Robot-wide initialization\n which will be called when the robot is first powered on. It will be called\n exactly one time.\n\n Warning: the Driver Station \"Robot Code\" light and FMS \"Robot Ready\"\n indicators will be off until RobotInit() exits. Code in RobotInit() that\n waits for enable will cause the robot to never indicate that the code is\n ready, causing the robot to be bypassed in a match."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase9RobotInitEv"]
    pub fn frc_IterativeRobotBase_RobotInit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Robot-wide simulation initialization code should go here.\n\n Users should override this method for default Robot-wide simulation\n related initialization which will be called when the robot is first\n started. It will be called exactly one time after RobotInit is called\n only when the robot is in simulation."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase14SimulationInitEv"]
    pub fn frc_IterativeRobotBase_SimulationInit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Initialization code for disabled mode should go here.\n\n Users should override this method for initialization code which will be\n called each time\n the robot enters disabled mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase12DisabledInitEv"]
    pub fn frc_IterativeRobotBase_DisabledInit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Initialization code for autonomous mode should go here.\n\n Users should override this method for initialization code which will be\n called each time the robot enters autonomous mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase14AutonomousInitEv"]
    pub fn frc_IterativeRobotBase_AutonomousInit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Initialization code for teleop mode should go here.\n\n Users should override this method for initialization code which will be\n called each time the robot enters teleop mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase10TeleopInitEv"]
    pub fn frc_IterativeRobotBase_TeleopInit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Initialization code for test mode should go here.\n\n Users should override this method for initialization code which will be\n called each time the robot enters test mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase8TestInitEv"]
    pub fn frc_IterativeRobotBase_TestInit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Periodic code for all modes should go here.\n\n This function is called each time a new packet is received from the driver\n station."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase13RobotPeriodicEv"]
    pub fn frc_IterativeRobotBase_RobotPeriodic(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Periodic simulation code should go here.\n\n This function is called in a simulated robot after user code executes."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase18SimulationPeriodicEv"]
    pub fn frc_IterativeRobotBase_SimulationPeriodic(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Periodic code for disabled mode should go here.\n\n Users should override this method for code which will be called each time a\n new packet is received from the driver station and the robot is in disabled\n mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase16DisabledPeriodicEv"]
    pub fn frc_IterativeRobotBase_DisabledPeriodic(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Periodic code for autonomous mode should go here.\n\n Users should override this method for code which will be called each time a\n new packet is received from the driver station and the robot is in\n autonomous mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase18AutonomousPeriodicEv"]
    pub fn frc_IterativeRobotBase_AutonomousPeriodic(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Periodic code for teleop mode should go here.\n\n Users should override this method for code which will be called each time a\n new packet is received from the driver station and the robot is in teleop\n mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase14TeleopPeriodicEv"]
    pub fn frc_IterativeRobotBase_TeleopPeriodic(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Periodic code for test mode should go here.\n\n Users should override this method for code which will be called each time a\n new packet is received from the driver station and the robot is in test\n mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase12TestPeriodicEv"]
    pub fn frc_IterativeRobotBase_TestPeriodic(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Exit code for disabled mode should go here.\n\n Users should override this method for code which will be called each time\n the robot exits disabled mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase12DisabledExitEv"]
    pub fn frc_IterativeRobotBase_DisabledExit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Exit code for autonomous mode should go here.\n\n Users should override this method for code which will be called each time\n the robot exits autonomous mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase14AutonomousExitEv"]
    pub fn frc_IterativeRobotBase_AutonomousExit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Exit code for teleop mode should go here.\n\n Users should override this method for code which will be called each time\n the robot exits teleop mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase10TeleopExitEv"]
    pub fn frc_IterativeRobotBase_TeleopExit(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Exit code for test mode should go here.\n\n Users should override this method for code which will be called each time\n the robot exits test mode."]
    #[link_name = "\u{1}_ZN3frc18IterativeRobotBase8TestExitEv"]
    pub fn frc_IterativeRobotBase_TestExit(this: *mut ::std::os::raw::c_void);
}
#[doc = " Handle input from standard Joysticks connected to the Driver Station.\n\n This class handles standard input that comes from the Driver Station. Each\n time a value is requested the most recent value is returned. There is a\n single class instance for each joystick and the mapping of ports to hardware\n buttons depends on the code in the Driver Station."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Joystick {
    pub _base: frc_GenericHID,
    pub m_axes: [u32; 5usize],
}
pub const frc_Joystick_AxisType_kXAxis: frc_Joystick_AxisType = 0;
pub const frc_Joystick_AxisType_kYAxis: frc_Joystick_AxisType = 1;
pub const frc_Joystick_AxisType_kZAxis: frc_Joystick_AxisType = 2;
pub const frc_Joystick_AxisType_kTwistAxis: frc_Joystick_AxisType = 3;
pub const frc_Joystick_AxisType_kThrottleAxis: frc_Joystick_AxisType = 4;
pub type frc_Joystick_AxisType = ::std::os::raw::c_uint;
pub const frc_Joystick_ButtonType_kTriggerButton: frc_Joystick_ButtonType = 0;
pub const frc_Joystick_ButtonType_kTopButton: frc_Joystick_ButtonType = 1;
pub type frc_Joystick_ButtonType = ::std::os::raw::c_uint;
pub const frc_Joystick_Axis_kX: frc_Joystick_Axis = 0;
pub const frc_Joystick_Axis_kY: frc_Joystick_Axis = 1;
pub const frc_Joystick_Axis_kZ: frc_Joystick_Axis = 2;
pub const frc_Joystick_Axis_kTwist: frc_Joystick_Axis = 3;
pub const frc_Joystick_Axis_kThrottle: frc_Joystick_Axis = 4;
pub const frc_Joystick_Axis_kNumAxes: frc_Joystick_Axis = 5;
pub type frc_Joystick_Axis = ::std::os::raw::c_uint;
pub const frc_Joystick_Button_kTrigger: frc_Joystick_Button = 1;
pub const frc_Joystick_Button_kTop: frc_Joystick_Button = 2;
pub type frc_Joystick_Button = ::std::os::raw::c_uint;
pub const frc_Joystick_kDefaultXChannel: ::std::os::raw::c_int = 0;
pub const frc_Joystick_kDefaultYChannel: ::std::os::raw::c_int = 1;
pub const frc_Joystick_kDefaultZChannel: ::std::os::raw::c_int = 2;
pub const frc_Joystick_kDefaultTwistChannel: ::std::os::raw::c_int = 2;
pub const frc_Joystick_kDefaultThrottleChannel: ::std::os::raw::c_int = 3;
#[test]
fn bindgen_test_layout_frc_Joystick() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Joystick> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Joystick>(),
        36usize,
        concat!("Size of: ", stringify!(frc_Joystick))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Joystick>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_Joystick))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_axes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Joystick),
            "::",
            stringify!(m_axes)
        )
    );
}
extern "C" {
    #[doc = " Set the channel associated with the X axis.\n\n @param channel The channel to set the axis to."]
    #[link_name = "\u{1}_ZN3frc8Joystick11SetXChannelEi"]
    pub fn frc_Joystick_SetXChannel(this: *mut frc_Joystick, channel: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the channel associated with the Y axis.\n\n @param channel The channel to set the axis to."]
    #[link_name = "\u{1}_ZN3frc8Joystick11SetYChannelEi"]
    pub fn frc_Joystick_SetYChannel(this: *mut frc_Joystick, channel: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the channel associated with the Z axis.\n\n @param channel The channel to set the axis to."]
    #[link_name = "\u{1}_ZN3frc8Joystick11SetZChannelEi"]
    pub fn frc_Joystick_SetZChannel(this: *mut frc_Joystick, channel: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the channel associated with the twist axis.\n\n @param channel The channel to set the axis to."]
    #[link_name = "\u{1}_ZN3frc8Joystick15SetTwistChannelEi"]
    pub fn frc_Joystick_SetTwistChannel(this: *mut frc_Joystick, channel: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Set the channel associated with the throttle axis.\n\n @param channel The channel to set the axis to."]
    #[link_name = "\u{1}_ZN3frc8Joystick18SetThrottleChannelEi"]
    pub fn frc_Joystick_SetThrottleChannel(this: *mut frc_Joystick, channel: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Get the channel currently associated with the X axis.\n\n @return The channel for the axis."]
    #[link_name = "\u{1}_ZNK3frc8Joystick11GetXChannelEv"]
    pub fn frc_Joystick_GetXChannel(this: *const frc_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the channel currently associated with the Y axis.\n\n @return The channel for the axis."]
    #[link_name = "\u{1}_ZNK3frc8Joystick11GetYChannelEv"]
    pub fn frc_Joystick_GetYChannel(this: *const frc_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the channel currently associated with the Z axis.\n\n @return The channel for the axis."]
    #[link_name = "\u{1}_ZNK3frc8Joystick11GetZChannelEv"]
    pub fn frc_Joystick_GetZChannel(this: *const frc_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the channel currently associated with the twist axis.\n\n @return The channel for the axis."]
    #[link_name = "\u{1}_ZNK3frc8Joystick15GetTwistChannelEv"]
    pub fn frc_Joystick_GetTwistChannel(this: *const frc_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the channel currently associated with the throttle axis.\n\n @return The channel for the axis."]
    #[link_name = "\u{1}_ZNK3frc8Joystick18GetThrottleChannelEv"]
    pub fn frc_Joystick_GetThrottleChannel(this: *const frc_Joystick) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the X value of the current joystick.\n\n This depends on the mapping of the joystick connected to the current port."]
    #[link_name = "\u{1}_ZNK3frc8Joystick4GetXEv"]
    pub fn frc_Joystick_GetX(this: *const frc_Joystick) -> f64;
}
extern "C" {
    #[doc = " Get the Y value of the current joystick.\n\n This depends on the mapping of the joystick connected to the current port."]
    #[link_name = "\u{1}_ZNK3frc8Joystick4GetYEv"]
    pub fn frc_Joystick_GetY(this: *const frc_Joystick) -> f64;
}
extern "C" {
    #[doc = " Get the Z value of the current joystick.\n\n This depends on the mapping of the joystick connected to the current port."]
    #[link_name = "\u{1}_ZNK3frc8Joystick4GetZEv"]
    pub fn frc_Joystick_GetZ(this: *const frc_Joystick) -> f64;
}
extern "C" {
    #[doc = " Get the twist value of the current joystick.\n\n This depends on the mapping of the joystick connected to the current port."]
    #[link_name = "\u{1}_ZNK3frc8Joystick8GetTwistEv"]
    pub fn frc_Joystick_GetTwist(this: *const frc_Joystick) -> f64;
}
extern "C" {
    #[doc = " Get the throttle value of the current joystick.\n\n This depends on the mapping of the joystick connected to the current port."]
    #[link_name = "\u{1}_ZNK3frc8Joystick11GetThrottleEv"]
    pub fn frc_Joystick_GetThrottle(this: *const frc_Joystick) -> f64;
}
extern "C" {
    #[doc = " Read the state of the trigger on the joystick.\n\n Look up which button has been assigned to the trigger and read its state.\n\n @return The state of the trigger."]
    #[link_name = "\u{1}_ZNK3frc8Joystick10GetTriggerEv"]
    pub fn frc_Joystick_GetTrigger(this: *const frc_Joystick) -> bool;
}
extern "C" {
    #[doc = " Whether the trigger was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc8Joystick17GetTriggerPressedEv"]
    pub fn frc_Joystick_GetTriggerPressed(this: *mut frc_Joystick) -> bool;
}
extern "C" {
    #[doc = " Whether the trigger was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc8Joystick18GetTriggerReleasedEv"]
    pub fn frc_Joystick_GetTriggerReleased(this: *mut frc_Joystick) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the trigger button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the trigger button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc8Joystick7TriggerEPNS_9EventLoopE"]
    pub fn frc_Joystick_Trigger(
        this: *const frc_Joystick,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the state of the top button on the joystick.\n\n Look up which button has been assigned to the top and read its state.\n\n @return The state of the top button."]
    #[link_name = "\u{1}_ZNK3frc8Joystick6GetTopEv"]
    pub fn frc_Joystick_GetTop(this: *const frc_Joystick) -> bool;
}
extern "C" {
    #[doc = " Whether the top button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc8Joystick13GetTopPressedEv"]
    pub fn frc_Joystick_GetTopPressed(this: *mut frc_Joystick) -> bool;
}
extern "C" {
    #[doc = " Whether the top button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc8Joystick14GetTopReleasedEv"]
    pub fn frc_Joystick_GetTopReleased(this: *mut frc_Joystick) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the top button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the top button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc8Joystick3TopEPNS_9EventLoopE"]
    pub fn frc_Joystick_Top(
        this: *const frc_Joystick,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Get the magnitude of the direction vector formed by the joystick's\n current position relative to its origin.\n\n @return The magnitude of the direction vector"]
    #[link_name = "\u{1}_ZNK3frc8Joystick12GetMagnitudeEv"]
    pub fn frc_Joystick_GetMagnitude(this: *const frc_Joystick) -> f64;
}
extern "C" {
    #[doc = " Get the direction of the vector formed by the joystick and its origin\n in radians.\n\n @return The direction of the vector in radians"]
    #[link_name = "\u{1}_ZNK3frc8Joystick19GetDirectionRadiansEv"]
    pub fn frc_Joystick_GetDirectionRadians(this: *const frc_Joystick) -> f64;
}
extern "C" {
    #[doc = " Get the direction of the vector formed by the joystick and its origin\n in degrees.\n\n @return The direction of the vector in degrees"]
    #[link_name = "\u{1}_ZNK3frc8Joystick19GetDirectionDegreesEv"]
    pub fn frc_Joystick_GetDirectionDegrees(this: *const frc_Joystick) -> f64;
}
extern "C" {
    #[doc = " Construct an instance of a joystick.\n\n The joystick index is the USB port on the Driver Station.\n\n @param port The port on the Driver Station that the joystick is plugged\n             into (0-5)."]
    #[link_name = "\u{1}_ZN3frc8JoystickC1Ei"]
    pub fn frc_Joystick_Joystick(this: *mut frc_Joystick, port: ::std::os::raw::c_int);
}
impl frc_Joystick {
    #[inline]
    pub unsafe fn SetXChannel(&mut self, channel: ::std::os::raw::c_int) {
        frc_Joystick_SetXChannel(self, channel)
    }
    #[inline]
    pub unsafe fn SetYChannel(&mut self, channel: ::std::os::raw::c_int) {
        frc_Joystick_SetYChannel(self, channel)
    }
    #[inline]
    pub unsafe fn SetZChannel(&mut self, channel: ::std::os::raw::c_int) {
        frc_Joystick_SetZChannel(self, channel)
    }
    #[inline]
    pub unsafe fn SetTwistChannel(&mut self, channel: ::std::os::raw::c_int) {
        frc_Joystick_SetTwistChannel(self, channel)
    }
    #[inline]
    pub unsafe fn SetThrottleChannel(&mut self, channel: ::std::os::raw::c_int) {
        frc_Joystick_SetThrottleChannel(self, channel)
    }
    #[inline]
    pub unsafe fn GetXChannel(&self) -> ::std::os::raw::c_int {
        frc_Joystick_GetXChannel(self)
    }
    #[inline]
    pub unsafe fn GetYChannel(&self) -> ::std::os::raw::c_int {
        frc_Joystick_GetYChannel(self)
    }
    #[inline]
    pub unsafe fn GetZChannel(&self) -> ::std::os::raw::c_int {
        frc_Joystick_GetZChannel(self)
    }
    #[inline]
    pub unsafe fn GetTwistChannel(&self) -> ::std::os::raw::c_int {
        frc_Joystick_GetTwistChannel(self)
    }
    #[inline]
    pub unsafe fn GetThrottleChannel(&self) -> ::std::os::raw::c_int {
        frc_Joystick_GetThrottleChannel(self)
    }
    #[inline]
    pub unsafe fn GetX(&self) -> f64 {
        frc_Joystick_GetX(self)
    }
    #[inline]
    pub unsafe fn GetY(&self) -> f64 {
        frc_Joystick_GetY(self)
    }
    #[inline]
    pub unsafe fn GetZ(&self) -> f64 {
        frc_Joystick_GetZ(self)
    }
    #[inline]
    pub unsafe fn GetTwist(&self) -> f64 {
        frc_Joystick_GetTwist(self)
    }
    #[inline]
    pub unsafe fn GetThrottle(&self) -> f64 {
        frc_Joystick_GetThrottle(self)
    }
    #[inline]
    pub unsafe fn GetTrigger(&self) -> bool {
        frc_Joystick_GetTrigger(self)
    }
    #[inline]
    pub unsafe fn GetTriggerPressed(&mut self) -> bool {
        frc_Joystick_GetTriggerPressed(self)
    }
    #[inline]
    pub unsafe fn GetTriggerReleased(&mut self) -> bool {
        frc_Joystick_GetTriggerReleased(self)
    }
    #[inline]
    pub unsafe fn Trigger(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_Joystick_Trigger(self, loop_)
    }
    #[inline]
    pub unsafe fn GetTop(&self) -> bool {
        frc_Joystick_GetTop(self)
    }
    #[inline]
    pub unsafe fn GetTopPressed(&mut self) -> bool {
        frc_Joystick_GetTopPressed(self)
    }
    #[inline]
    pub unsafe fn GetTopReleased(&mut self) -> bool {
        frc_Joystick_GetTopReleased(self)
    }
    #[inline]
    pub unsafe fn Top(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_Joystick_Top(self, loop_)
    }
    #[inline]
    pub unsafe fn GetMagnitude(&self) -> f64 {
        frc_Joystick_GetMagnitude(self)
    }
    #[inline]
    pub unsafe fn GetDirectionRadians(&self) -> f64 {
        frc_Joystick_GetDirectionRadians(self)
    }
    #[inline]
    pub unsafe fn GetDirectionDegrees(&self) -> f64 {
        frc_Joystick_GetDirectionDegrees(self)
    }
    #[inline]
    pub unsafe fn new(port: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Joystick_Joystick(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Pause the task for a specified time.\n\n Pause the execution of the program for a specified period of time given in\n seconds. Motors will continue to run at their last assigned values, and\n sensors will continue to update. Only the task containing the wait will pause\n until the wait time is expired.\n\n @param seconds Length of time to pause, in seconds."]
    #[link_name = "\u{1}_ZN3frc4WaitEN5units6unit_tINS0_4unitISt5ratioILx1ELx1EENS0_9base_unitIS3_ILx0ELx1EES6_S4_S6_S6_S6_S6_S6_S6_EES6_S6_EEdNS0_12linear_scaleEEE"]
    pub fn frc_Wait(seconds: units_time_second_t);
}
extern "C" {
    #[doc = " @brief  Gives real-time clock system time with nanosecond resolution\n @return The time, just in case you want the robot to start autonomous at 8pm\n         on Saturday."]
    #[link_name = "\u{1}_ZN3frc7GetTimeEv"]
    pub fn frc_GetTime() -> units_time_second_t;
}
#[repr(C)]
pub struct frc_Timer__bindgen_vtable {}
#[doc = " A timer class.\n\n Note that if the user calls frc::sim::RestartTiming(), they should also reset\n the timer so Get() won't return a negative duration."]
#[repr(C)]
pub struct frc_Timer {
    pub vtable_: *const frc_Timer__bindgen_vtable,
    pub m_startTime: units_time_second_t,
    pub m_accumulatedTime: units_time_second_t,
    pub m_running: bool,
}
#[test]
fn bindgen_test_layout_frc_Timer() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Timer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Timer>(),
        32usize,
        concat!("Size of: ", stringify!(frc_Timer))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Timer>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_Timer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_startTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Timer),
            "::",
            stringify!(m_startTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_accumulatedTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Timer),
            "::",
            stringify!(m_accumulatedTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_running) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Timer),
            "::",
            stringify!(m_running)
        )
    );
}
extern "C" {
    #[doc = " Get the current time from the timer. If the clock is running it is derived\n from the current system clock the start time stored in the timer class. If\n the clock is not running, then return the time when it was last stopped.\n\n @return Current time value for this timer in seconds"]
    #[link_name = "\u{1}_ZNK3frc5Timer3GetEv"]
    pub fn frc_Timer_Get(this: *const frc_Timer) -> units_time_second_t;
}
extern "C" {
    #[doc = " Reset the timer by setting the time to 0.\n\n Make the timer startTime the current time so new requests will be relative\n to now."]
    #[link_name = "\u{1}_ZN3frc5Timer5ResetEv"]
    pub fn frc_Timer_Reset(this: *mut frc_Timer);
}
extern "C" {
    #[doc = " Start the timer running.\n\n Just set the running flag to true indicating that all time requests should\n be relative to the system clock. Note that this method is a no-op if the\n timer is already running."]
    #[link_name = "\u{1}_ZN3frc5Timer5StartEv"]
    pub fn frc_Timer_Start(this: *mut frc_Timer);
}
extern "C" {
    #[doc = " Stop the timer.\n\n This computes the time as of now and clears the running flag, causing all\n subsequent time requests to be read from the accumulated time rather than\n looking at the system clock."]
    #[link_name = "\u{1}_ZN3frc5Timer4StopEv"]
    pub fn frc_Timer_Stop(this: *mut frc_Timer);
}
extern "C" {
    #[doc = " Check if the period specified has passed.\n\n @param period The period to check.\n @return       True if the period has passed."]
    #[link_name = "\u{1}_ZNK3frc5Timer10HasElapsedEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_Timer_HasElapsed(this: *const frc_Timer, period: units_time_second_t) -> bool;
}
extern "C" {
    #[doc = " Check if the period specified has passed and if it has, advance the start\n time by that period. This is useful to decide if it's time to do periodic\n work without drifting later by the time it took to get around to checking.\n\n @param period The period to check for.\n @return       True if the period has passed."]
    #[link_name = "\u{1}_ZN3frc5Timer16AdvanceIfElapsedEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_Timer_AdvanceIfElapsed(this: *mut frc_Timer, period: units_time_second_t) -> bool;
}
extern "C" {
    #[doc = " Return the FPGA system clock time in seconds.\n\n Return the time from the FPGA hardware clock in seconds since the FPGA\n started. Rolls over after 71 minutes.\n\n @returns Robot running time in seconds."]
    #[link_name = "\u{1}_ZN3frc5Timer16GetFPGATimestampEv"]
    pub fn frc_Timer_GetFPGATimestamp() -> units_time_second_t;
}
extern "C" {
    #[doc = " Return the approximate match time.\n\n The FMS does not send an official match time to the robots, but does send\n an approximate match time. The value will count down the time remaining in\n the current period (auto or teleop).\n\n Warning: This is not an official time (so it cannot be used to dispute ref\n calls or guarantee that a function will trigger before the match ends).\n\n The Practice Match function of the DS approximates the behavior seen on the\n field.\n\n @return Time remaining in current match period (auto or teleop)"]
    #[link_name = "\u{1}_ZN3frc5Timer12GetMatchTimeEv"]
    pub fn frc_Timer_GetMatchTime() -> units_time_second_t;
}
extern "C" {
    #[doc = " Create a new timer object.\n\n Create a new timer object and reset the time to zero. The timer is\n initially not running and must be started."]
    #[link_name = "\u{1}_ZN3frc5TimerC1Ev"]
    pub fn frc_Timer_Timer(this: *mut frc_Timer);
}
impl frc_Timer {
    #[inline]
    pub unsafe fn Get(&self) -> units_time_second_t {
        frc_Timer_Get(self)
    }
    #[inline]
    pub unsafe fn Reset(&mut self) {
        frc_Timer_Reset(self)
    }
    #[inline]
    pub unsafe fn Start(&mut self) {
        frc_Timer_Start(self)
    }
    #[inline]
    pub unsafe fn Stop(&mut self) {
        frc_Timer_Stop(self)
    }
    #[inline]
    pub unsafe fn HasElapsed(&self, period: units_time_second_t) -> bool {
        frc_Timer_HasElapsed(self, period)
    }
    #[inline]
    pub unsafe fn AdvanceIfElapsed(&mut self, period: units_time_second_t) -> bool {
        frc_Timer_AdvanceIfElapsed(self, period)
    }
    #[inline]
    pub unsafe fn GetFPGATimestamp() -> units_time_second_t {
        frc_Timer_GetFPGATimestamp()
    }
    #[inline]
    pub unsafe fn GetMatchTime() -> units_time_second_t {
        frc_Timer_GetMatchTime()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Timer_Timer(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
pub struct frc_MotorSafety__bindgen_vtable(::std::os::raw::c_void);
#[doc = " The Motor Safety feature acts as a watchdog timer for an individual motor. It\n operates by maintaining a timer that tracks how long it has been since the\n feed() method has been called for that actuator. Code in the Driver Station\n class initiates a comparison of these timers to the timeout values for any\n actuator with safety enabled every 5 received packets (100ms nominal).\n\n The subclass should call Feed() whenever the motor value is updated."]
#[repr(C)]
pub struct frc_MotorSafety {
    pub vtable_: *const frc_MotorSafety__bindgen_vtable,
    pub m_expiration: units_time_second_t,
    pub m_enabled: bool,
    pub m_stopTime: units_time_second_t,
    pub m_thisMutex: wpi_mutex,
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11MotorSafety24kDefaultSafetyExpirationE"]
    pub static frc_MotorSafety_kDefaultSafetyExpiration: units_time_millisecond_t;
}
#[test]
fn bindgen_test_layout_frc_MotorSafety() {
    const UNINIT: ::std::mem::MaybeUninit<frc_MotorSafety> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_MotorSafety>(),
        56usize,
        concat!("Size of: ", stringify!(frc_MotorSafety))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_MotorSafety>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_MotorSafety))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_expiration) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MotorSafety),
            "::",
            stringify!(m_expiration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_enabled) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MotorSafety),
            "::",
            stringify!(m_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_stopTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MotorSafety),
            "::",
            stringify!(m_stopTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_thisMutex) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MotorSafety),
            "::",
            stringify!(m_thisMutex)
        )
    );
}
extern "C" {
    #[doc = " Feed the motor safety object.\n\n Resets the timer on this object that is used to do the timeouts."]
    #[link_name = "\u{1}_ZN3frc11MotorSafety4FeedEv"]
    pub fn frc_MotorSafety_Feed(this: *mut frc_MotorSafety);
}
extern "C" {
    #[doc = " Set the expiration time for the corresponding motor safety object.\n\n @param expirationTime The timeout value."]
    #[link_name = "\u{1}_ZN3frc11MotorSafety13SetExpirationEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_MotorSafety_SetExpiration(
        this: *mut frc_MotorSafety,
        expirationTime: units_time_second_t,
    );
}
extern "C" {
    #[doc = " Retrieve the timeout value for the corresponding motor safety object.\n\n @return the timeout value."]
    #[link_name = "\u{1}_ZNK3frc11MotorSafety13GetExpirationEv"]
    pub fn frc_MotorSafety_GetExpiration(this: *const frc_MotorSafety) -> units_time_second_t;
}
extern "C" {
    #[doc = " Determine if the motor is still operating or has timed out.\n\n @return true if the motor is still operating normally and hasn't timed out."]
    #[link_name = "\u{1}_ZNK3frc11MotorSafety7IsAliveEv"]
    pub fn frc_MotorSafety_IsAlive(this: *const frc_MotorSafety) -> bool;
}
extern "C" {
    #[doc = " Enable/disable motor safety for this device.\n\n Turn on and off the motor safety option for this PWM object.\n\n @param enabled True if motor safety is enforced for this object."]
    #[link_name = "\u{1}_ZN3frc11MotorSafety16SetSafetyEnabledEb"]
    pub fn frc_MotorSafety_SetSafetyEnabled(this: *mut frc_MotorSafety, enabled: bool);
}
extern "C" {
    #[doc = " Return the state of the motor safety enabled flag.\n\n Return if the motor safety is currently enabled for this device.\n\n @return True if motor safety is enforced for this device."]
    #[link_name = "\u{1}_ZNK3frc11MotorSafety15IsSafetyEnabledEv"]
    pub fn frc_MotorSafety_IsSafetyEnabled(this: *const frc_MotorSafety) -> bool;
}
extern "C" {
    #[doc = " Check if this motor has exceeded its timeout.\n\n This method is called periodically to determine if this motor has exceeded\n its timeout value. If it has, the stop method is called, and the motor is\n shut down until its value is updated again."]
    #[link_name = "\u{1}_ZN3frc11MotorSafety5CheckEv"]
    pub fn frc_MotorSafety_Check(this: *mut frc_MotorSafety);
}
extern "C" {
    #[doc = " Check the motors to see if any have timed out.\n\n This static method is called periodically to poll all the motors and stop\n any that have timed out."]
    #[link_name = "\u{1}_ZN3frc11MotorSafety11CheckMotorsEv"]
    pub fn frc_MotorSafety_CheckMotors();
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11MotorSafetyC2Ev"]
    pub fn frc_MotorSafety_MotorSafety(this: *mut frc_MotorSafety);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11MotorSafetyC2EOS0_"]
    pub fn frc_MotorSafety_MotorSafety1(this: *mut frc_MotorSafety, rhs: *mut frc_MotorSafety);
}
impl frc_MotorSafety {
    #[inline]
    pub unsafe fn Feed(&mut self) {
        frc_MotorSafety_Feed(self)
    }
    #[inline]
    pub unsafe fn SetExpiration(&mut self, expirationTime: units_time_second_t) {
        frc_MotorSafety_SetExpiration(self, expirationTime)
    }
    #[inline]
    pub unsafe fn GetExpiration(&self) -> units_time_second_t {
        frc_MotorSafety_GetExpiration(self)
    }
    #[inline]
    pub unsafe fn IsAlive(&self) -> bool {
        frc_MotorSafety_IsAlive(self)
    }
    #[inline]
    pub unsafe fn SetSafetyEnabled(&mut self, enabled: bool) {
        frc_MotorSafety_SetSafetyEnabled(self, enabled)
    }
    #[inline]
    pub unsafe fn IsSafetyEnabled(&self) -> bool {
        frc_MotorSafety_IsSafetyEnabled(self)
    }
    #[inline]
    pub unsafe fn Check(&mut self) {
        frc_MotorSafety_Check(self)
    }
    #[inline]
    pub unsafe fn CheckMotors() {
        frc_MotorSafety_CheckMotors()
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_MotorSafety_MotorSafety(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rhs: *mut frc_MotorSafety) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_MotorSafety_MotorSafety1(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11MotorSafetyD1Ev"]
    pub fn frc_MotorSafety_MotorSafety_destructor(this: *mut frc_MotorSafety);
}
#[doc = " Notifiers run a callback function on a separate thread at a specified period.\n\n If StartSingle() is used, the callback will run once. If StartPeriodic() is\n used, the callback will run repeatedly with the given period until stop() is\n called."]
#[repr(C)]
pub struct frc_Notifier {
    pub m_thread: std_thread,
    pub m_processMutex: wpi_mutex,
    pub m_notifier: u32,
    pub m_handler: [u32; 4usize],
    pub m_expirationTime: units_time_second_t,
    pub m_period: units_time_second_t,
    pub m_periodic: bool,
}
#[test]
fn bindgen_test_layout_frc_Notifier() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Notifier> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Notifier>(),
        72usize,
        concat!("Size of: ", stringify!(frc_Notifier))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Notifier>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_Notifier))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_thread) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Notifier),
            "::",
            stringify!(m_thread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_processMutex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Notifier),
            "::",
            stringify!(m_processMutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_notifier) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Notifier),
            "::",
            stringify!(m_notifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handler) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Notifier),
            "::",
            stringify!(m_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_expirationTime) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Notifier),
            "::",
            stringify!(m_expirationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_period) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Notifier),
            "::",
            stringify!(m_period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_periodic) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Notifier),
            "::",
            stringify!(m_periodic)
        )
    );
}
extern "C" {
    #[doc = " Sets the name of the notifier.  Used for debugging purposes only.\n\n @param name Name"]
    #[link_name = "\u{1}_ZN3frc8Notifier7SetNameESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_Notifier_SetName(this: *mut frc_Notifier, name: std_string_view);
}
extern "C" {
    #[doc = " Change the handler function.\n\n @param handler Handler"]
    #[link_name = "\u{1}_ZN3frc8Notifier10SetHandlerESt8functionIFvvEE"]
    pub fn frc_Notifier_SetHandler(this: *mut frc_Notifier, handler: [u32; 4usize]);
}
extern "C" {
    #[doc = " Register for single event notification.\n\n A timer event is queued for a single event after the specified delay.\n\n @param delay Amount of time to wait before the handler is called."]
    #[link_name = "\u{1}_ZN3frc8Notifier11StartSingleEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_Notifier_StartSingle(this: *mut frc_Notifier, delay: units_time_second_t);
}
extern "C" {
    #[doc = " Register for periodic event notification.\n\n A timer event is queued for periodic event notification. Each time the\n interrupt occurs, the event will be immediately requeued for the same time\n interval.\n\n The user-provided callback should be written in a nonblocking manner so the\n callback can be recalled at the next periodic event notification.\n\n @param period Period to call the handler starting one period\n               after the call to this method."]
    #[link_name = "\u{1}_ZN3frc8Notifier13StartPeriodicEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_Notifier_StartPeriodic(this: *mut frc_Notifier, period: units_time_second_t);
}
extern "C" {
    #[doc = " Stop timer events from occurring.\n\n Stop any repeating timer events from occurring. This will also remove any\n single notification events from the queue.\n\n If a timer-based call to the registered handler is in progress, this\n function will block until the handler call is complete."]
    #[link_name = "\u{1}_ZN3frc8Notifier4StopEv"]
    pub fn frc_Notifier_Stop(this: *mut frc_Notifier);
}
extern "C" {
    #[doc = " Sets the HAL notifier thread priority.\n\n The HAL notifier thread is responsible for managing the FPGA's notifier\n interrupt and waking up user's Notifiers when it's their time to run.\n Giving the HAL notifier thread real-time priority helps ensure the user's\n real-time Notifiers, if any, are notified to run in a timely manner.\n\n @param realTime Set to true to set a real-time priority, false for standard\n                 priority.\n @param priority Priority to set the thread to. For real-time, this is 1-99\n                 with 99 being highest. For non-real-time, this is forced to\n                 0. See \"man 7 sched\" for more details.\n @return         True on success."]
    #[link_name = "\u{1}_ZN3frc8Notifier20SetHALThreadPriorityEbi"]
    pub fn frc_Notifier_SetHALThreadPriority(realTime: bool, priority: i32) -> bool;
}
extern "C" {
    #[doc = " Create a Notifier for timer event notification.\n\n @param handler The handler is called at the notification time which is set\n                using StartSingle or StartPeriodic."]
    #[link_name = "\u{1}_ZN3frc8NotifierC1ESt8functionIFvvEE"]
    pub fn frc_Notifier_Notifier(this: *mut frc_Notifier, handler: [u32; 4usize]);
}
extern "C" {
    #[doc = " Create a Notifier for timer event notification.\n\n This overload makes the underlying thread run with a real-time priority.\n This is useful for reducing scheduling jitter on processes which are\n sensitive to timing variance, like model-based control.\n\n @param priority The FIFO real-time scheduler priority ([1..99] where a\n                 higher number represents higher priority). See \"man 7\n                 sched\" for more details.\n @param handler  The handler is called at the notification time which is set\n                 using StartSingle or StartPeriodic."]
    #[link_name = "\u{1}_ZN3frc8NotifierC1EiSt8functionIFvvEE"]
    pub fn frc_Notifier_Notifier1(
        this: *mut frc_Notifier,
        priority: ::std::os::raw::c_int,
        handler: [u32; 4usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc8NotifierC1EOS0_"]
    pub fn frc_Notifier_Notifier2(this: *mut frc_Notifier, rhs: *mut frc_Notifier);
}
extern "C" {
    #[doc = " Free the resources for a timer event."]
    #[link_name = "\u{1}_ZN3frc8NotifierD1Ev"]
    pub fn frc_Notifier_Notifier_destructor(this: *mut frc_Notifier);
}
impl frc_Notifier {
    #[inline]
    pub unsafe fn SetName(&mut self, name: std_string_view) {
        frc_Notifier_SetName(self, name)
    }
    #[inline]
    pub unsafe fn SetHandler(&mut self, handler: [u32; 4usize]) {
        frc_Notifier_SetHandler(self, handler)
    }
    #[inline]
    pub unsafe fn StartSingle(&mut self, delay: units_time_second_t) {
        frc_Notifier_StartSingle(self, delay)
    }
    #[inline]
    pub unsafe fn StartPeriodic(&mut self, period: units_time_second_t) {
        frc_Notifier_StartPeriodic(self, period)
    }
    #[inline]
    pub unsafe fn Stop(&mut self) {
        frc_Notifier_Stop(self)
    }
    #[inline]
    pub unsafe fn SetHALThreadPriority(realTime: bool, priority: i32) -> bool {
        frc_Notifier_SetHALThreadPriority(realTime, priority)
    }
    #[inline]
    pub unsafe fn new(handler: [u32; 4usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Notifier_Notifier(__bindgen_tmp.as_mut_ptr(), handler);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(priority: ::std::os::raw::c_int, handler: [u32; 4usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Notifier_Notifier1(__bindgen_tmp.as_mut_ptr(), priority, handler);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(rhs: *mut frc_Notifier) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Notifier_Notifier2(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        frc_Notifier_Notifier_destructor(self)
    }
}
#[doc = " Module class for controlling a REV Robotics Pneumatic Hub."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_PneumaticHub {
    pub _base: frc_PneumaticsBase,
    pub m_dataStore: [u32; 2usize],
    pub m_handle: HAL_REVPHHandle,
    pub m_module: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_PneumaticHub_Version {
    pub FirmwareMajor: u32,
    pub FirmwareMinor: u32,
    pub FirmwareFix: u32,
    pub HardwareMinor: u32,
    pub HardwareMajor: u32,
    pub UniqueId: u32,
}
#[test]
fn bindgen_test_layout_frc_PneumaticHub_Version() {
    const UNINIT: ::std::mem::MaybeUninit<frc_PneumaticHub_Version> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_PneumaticHub_Version>(),
        24usize,
        concat!("Size of: ", stringify!(frc_PneumaticHub_Version))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PneumaticHub_Version>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_PneumaticHub_Version))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FirmwareMajor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PneumaticHub_Version),
            "::",
            stringify!(FirmwareMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FirmwareMinor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PneumaticHub_Version),
            "::",
            stringify!(FirmwareMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FirmwareFix) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PneumaticHub_Version),
            "::",
            stringify!(FirmwareFix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HardwareMinor) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PneumaticHub_Version),
            "::",
            stringify!(HardwareMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HardwareMajor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PneumaticHub_Version),
            "::",
            stringify!(HardwareMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UniqueId) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PneumaticHub_Version),
            "::",
            stringify!(UniqueId)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct frc_PneumaticHub_Faults {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_frc_PneumaticHub_Faults() {
    assert_eq!(
        ::std::mem::size_of::<frc_PneumaticHub_Faults>(),
        4usize,
        concat!("Size of: ", stringify!(frc_PneumaticHub_Faults))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PneumaticHub_Faults>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_PneumaticHub_Faults))
    );
}
impl frc_PneumaticHub_Faults {
    #[inline]
    pub fn Channel0Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel0Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel1Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel1Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel2Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel2Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel3Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel3Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel4Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel4Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel5Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel5Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel6Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel6Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel7Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel7Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel8Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel8Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel9Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel9Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel10Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel10Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel11Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel11Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel12Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel12Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel13Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel13Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel14Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel14Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel15Fault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel15Fault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CompressorOverCurrent(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompressorOverCurrent(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CompressorOpen(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompressorOpen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SolenoidOverCurrent(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SolenoidOverCurrent(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Brownout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Brownout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CanWarning(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CanWarning(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardwareFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardwareFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Channel0Fault: u32,
        Channel1Fault: u32,
        Channel2Fault: u32,
        Channel3Fault: u32,
        Channel4Fault: u32,
        Channel5Fault: u32,
        Channel6Fault: u32,
        Channel7Fault: u32,
        Channel8Fault: u32,
        Channel9Fault: u32,
        Channel10Fault: u32,
        Channel11Fault: u32,
        Channel12Fault: u32,
        Channel13Fault: u32,
        Channel14Fault: u32,
        Channel15Fault: u32,
        CompressorOverCurrent: u32,
        CompressorOpen: u32,
        SolenoidOverCurrent: u32,
        Brownout: u32,
        CanWarning: u32,
        HardwareFault: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Channel0Fault: u32 = unsafe { ::std::mem::transmute(Channel0Fault) };
            Channel0Fault as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Channel1Fault: u32 = unsafe { ::std::mem::transmute(Channel1Fault) };
            Channel1Fault as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Channel2Fault: u32 = unsafe { ::std::mem::transmute(Channel2Fault) };
            Channel2Fault as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Channel3Fault: u32 = unsafe { ::std::mem::transmute(Channel3Fault) };
            Channel3Fault as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Channel4Fault: u32 = unsafe { ::std::mem::transmute(Channel4Fault) };
            Channel4Fault as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Channel5Fault: u32 = unsafe { ::std::mem::transmute(Channel5Fault) };
            Channel5Fault as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Channel6Fault: u32 = unsafe { ::std::mem::transmute(Channel6Fault) };
            Channel6Fault as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Channel7Fault: u32 = unsafe { ::std::mem::transmute(Channel7Fault) };
            Channel7Fault as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Channel8Fault: u32 = unsafe { ::std::mem::transmute(Channel8Fault) };
            Channel8Fault as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Channel9Fault: u32 = unsafe { ::std::mem::transmute(Channel9Fault) };
            Channel9Fault as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Channel10Fault: u32 = unsafe { ::std::mem::transmute(Channel10Fault) };
            Channel10Fault as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Channel11Fault: u32 = unsafe { ::std::mem::transmute(Channel11Fault) };
            Channel11Fault as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let Channel12Fault: u32 = unsafe { ::std::mem::transmute(Channel12Fault) };
            Channel12Fault as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Channel13Fault: u32 = unsafe { ::std::mem::transmute(Channel13Fault) };
            Channel13Fault as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let Channel14Fault: u32 = unsafe { ::std::mem::transmute(Channel14Fault) };
            Channel14Fault as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Channel15Fault: u32 = unsafe { ::std::mem::transmute(Channel15Fault) };
            Channel15Fault as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let CompressorOverCurrent: u32 =
                unsafe { ::std::mem::transmute(CompressorOverCurrent) };
            CompressorOverCurrent as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let CompressorOpen: u32 = unsafe { ::std::mem::transmute(CompressorOpen) };
            CompressorOpen as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let SolenoidOverCurrent: u32 = unsafe { ::std::mem::transmute(SolenoidOverCurrent) };
            SolenoidOverCurrent as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Brownout: u32 = unsafe { ::std::mem::transmute(Brownout) };
            Brownout as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let CanWarning: u32 = unsafe { ::std::mem::transmute(CanWarning) };
            CanWarning as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let HardwareFault: u32 = unsafe { ::std::mem::transmute(HardwareFault) };
            HardwareFault as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct frc_PneumaticHub_StickyFaults {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_frc_PneumaticHub_StickyFaults() {
    assert_eq!(
        ::std::mem::size_of::<frc_PneumaticHub_StickyFaults>(),
        4usize,
        concat!("Size of: ", stringify!(frc_PneumaticHub_StickyFaults))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PneumaticHub_StickyFaults>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_PneumaticHub_StickyFaults))
    );
}
impl frc_PneumaticHub_StickyFaults {
    #[inline]
    pub fn CompressorOverCurrent(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompressorOverCurrent(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CompressorOpen(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompressorOpen(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SolenoidOverCurrent(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SolenoidOverCurrent(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Brownout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Brownout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CanWarning(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CanWarning(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CanBusOff(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CanBusOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasReset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasReset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CompressorOverCurrent: u32,
        CompressorOpen: u32,
        SolenoidOverCurrent: u32,
        Brownout: u32,
        CanWarning: u32,
        CanBusOff: u32,
        HasReset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CompressorOverCurrent: u32 =
                unsafe { ::std::mem::transmute(CompressorOverCurrent) };
            CompressorOverCurrent as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CompressorOpen: u32 = unsafe { ::std::mem::transmute(CompressorOpen) };
            CompressorOpen as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SolenoidOverCurrent: u32 = unsafe { ::std::mem::transmute(SolenoidOverCurrent) };
            SolenoidOverCurrent as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Brownout: u32 = unsafe { ::std::mem::transmute(Brownout) };
            Brownout as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CanWarning: u32 = unsafe { ::std::mem::transmute(CanWarning) };
            CanWarning as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let CanBusOff: u32 = unsafe { ::std::mem::transmute(CanBusOff) };
            CanBusOff as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let HasReset: u32 = unsafe { ::std::mem::transmute(HasReset) };
            HasReset as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_PneumaticHub_DataStore {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12PneumaticHub12m_handleLockE"]
    pub static mut frc_PneumaticHub_m_handleLock: wpi_mutex;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12PneumaticHub11m_handleMapE"]
    pub static mut frc_PneumaticHub_m_handleMap: u8;
}
#[test]
fn bindgen_test_layout_frc_PneumaticHub() {
    const UNINIT: ::std::mem::MaybeUninit<frc_PneumaticHub> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_PneumaticHub>(),
        20usize,
        concat!("Size of: ", stringify!(frc_PneumaticHub))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PneumaticHub>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_PneumaticHub))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dataStore) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PneumaticHub),
            "::",
            stringify!(m_dataStore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PneumaticHub),
            "::",
            stringify!(m_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_module) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PneumaticHub),
            "::",
            stringify!(m_module)
        )
    );
}
extern "C" {
    #[doc = " Returns the hardware and firmware versions of this device.\n\n @return The hardware and firmware versions."]
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub10GetVersionEv"]
    pub fn frc_PneumaticHub_GetVersion(this: *const frc_PneumaticHub) -> frc_PneumaticHub_Version;
}
extern "C" {
    #[doc = " Returns the faults currently active on this device.\n\n @return The faults."]
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub9GetFaultsEv"]
    pub fn frc_PneumaticHub_GetFaults(this: *const frc_PneumaticHub) -> frc_PneumaticHub_Faults;
}
extern "C" {
    #[doc = " Returns the sticky faults currently active on this device.\n\n @return The sticky faults."]
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub15GetStickyFaultsEv"]
    pub fn frc_PneumaticHub_GetStickyFaults(
        this: *const frc_PneumaticHub,
    ) -> frc_PneumaticHub_StickyFaults;
}
extern "C" {
    #[doc = " Clears the sticky faults."]
    #[link_name = "\u{1}_ZN3frc12PneumaticHub17ClearStickyFaultsEv"]
    pub fn frc_PneumaticHub_ClearStickyFaults(this: *mut frc_PneumaticHub);
}
extern "C" {
    #[doc = " Returns the current input voltage for this device.\n\n @return The input voltage."]
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub15GetInputVoltageEv"]
    pub fn frc_PneumaticHub_GetInputVoltage(this: *const frc_PneumaticHub) -> units_voltage_volt_t;
}
extern "C" {
    #[doc = " Returns the current voltage of the regulated 5v supply.\n\n @return The current voltage of the 5v supply."]
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub21Get5VRegulatedVoltageEv"]
    pub fn frc_PneumaticHub_Get5VRegulatedVoltage(
        this: *const frc_PneumaticHub,
    ) -> units_voltage_volt_t;
}
extern "C" {
    #[doc = " Returns the total current drawn by all solenoids.\n\n @return Total current drawn by all solenoids."]
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub24GetSolenoidsTotalCurrentEv"]
    pub fn frc_PneumaticHub_GetSolenoidsTotalCurrent(
        this: *const frc_PneumaticHub,
    ) -> units_current_ampere_t;
}
extern "C" {
    #[doc = " Returns the current voltage of the solenoid power supply.\n\n @return The current voltage of the solenoid power supply."]
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub19GetSolenoidsVoltageEv"]
    pub fn frc_PneumaticHub_GetSolenoidsVoltage(
        this: *const frc_PneumaticHub,
    ) -> units_voltage_volt_t;
}
extern "C" {
    #[doc = " Constructs a PneumaticHub with the default ID (1)."]
    #[link_name = "\u{1}_ZN3frc12PneumaticHubC1Ev"]
    pub fn frc_PneumaticHub_PneumaticHub(this: *mut frc_PneumaticHub);
}
extern "C" {
    #[doc = " Constructs a PneumaticHub.\n\n @param module module number to construct"]
    #[link_name = "\u{1}_ZN3frc12PneumaticHubC1Ei"]
    pub fn frc_PneumaticHub_PneumaticHub1(
        this: *mut frc_PneumaticHub,
        module: ::std::os::raw::c_int,
    );
}
impl frc_PneumaticHub {
    #[inline]
    pub unsafe fn GetVersion(&self) -> frc_PneumaticHub_Version {
        frc_PneumaticHub_GetVersion(self)
    }
    #[inline]
    pub unsafe fn GetFaults(&self) -> frc_PneumaticHub_Faults {
        frc_PneumaticHub_GetFaults(self)
    }
    #[inline]
    pub unsafe fn GetStickyFaults(&self) -> frc_PneumaticHub_StickyFaults {
        frc_PneumaticHub_GetStickyFaults(self)
    }
    #[inline]
    pub unsafe fn ClearStickyFaults(&mut self) {
        frc_PneumaticHub_ClearStickyFaults(self)
    }
    #[inline]
    pub unsafe fn GetInputVoltage(&self) -> units_voltage_volt_t {
        frc_PneumaticHub_GetInputVoltage(self)
    }
    #[inline]
    pub unsafe fn Get5VRegulatedVoltage(&self) -> units_voltage_volt_t {
        frc_PneumaticHub_Get5VRegulatedVoltage(self)
    }
    #[inline]
    pub unsafe fn GetSolenoidsTotalCurrent(&self) -> units_current_ampere_t {
        frc_PneumaticHub_GetSolenoidsTotalCurrent(self)
    }
    #[inline]
    pub unsafe fn GetSolenoidsVoltage(&self) -> units_voltage_volt_t {
        frc_PneumaticHub_GetSolenoidsVoltage(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_PneumaticHub_PneumaticHub(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(module: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_PneumaticHub_PneumaticHub1(__bindgen_tmp.as_mut_ptr(), module);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub13GetCompressorEv"]
    pub fn frc_PneumaticHub_GetCompressor(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Disables the compressor. The compressor will not turn on until\n EnableCompressorDigital(), EnableCompressorAnalog(), or\n EnableCompressorHybrid() are called."]
    #[link_name = "\u{1}_ZN3frc12PneumaticHub17DisableCompressorEv"]
    pub fn frc_PneumaticHub_DisableCompressor(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12PneumaticHub23EnableCompressorDigitalEv"]
    pub fn frc_PneumaticHub_EnableCompressorDigital(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Enables the compressor in analog mode. This mode uses an analog pressure\n sensor connected to analog channel 0 to cycle the compressor. The\n compressor will turn on when the pressure drops below {@code minPressure}\n and will turn off when the pressure reaches {@code maxPressure}.\n\n @param minPressure The minimum pressure. The compressor will turn on when\n the pressure drops below this value.\n @param maxPressure The maximum pressure. The compressor will turn off when\n the pressure reaches this value."]
    #[link_name = "\u{1}_ZN3frc12PneumaticHub22EnableCompressorAnalogEN5units6unit_tINS1_4unitISt5ratioILx437817087ELx63500EENS1_9base_unitIS4_ILxn1ELx1EES4_ILx1ELx1EES4_ILxn2ELx1EES4_ILx0ELx1EESA_SA_SA_SA_SA_EESA_SA_EEdNS1_12linear_scaleEEESE_"]
    pub fn frc_PneumaticHub_EnableCompressorAnalog(
        this: *mut ::std::os::raw::c_void,
        minPressure: units_pressure_pounds_per_square_inch_t,
        maxPressure: units_pressure_pounds_per_square_inch_t,
    );
}
extern "C" {
    #[doc = " Enables the compressor in hybrid mode. This mode uses both a digital\n pressure switch and an analog pressure sensor connected to analog channel 0\n to cycle the compressor.\n\n The compressor will turn on when \\a both:\n\n - The digital pressure switch indicates the system is not full AND\n - The analog pressure sensor indicates that the pressure in the system is\n below the specified minimum pressure.\n\n The compressor will turn off when \\a either:\n\n - The digital pressure switch is disconnected or indicates that the system\n is full OR\n - The pressure detected by the analog sensor is greater than the specified\n maximum pressure.\n\n @param minPressure The minimum pressure. The compressor will turn on when\n the pressure drops below this value and the pressure switch indicates that\n the system is not full.\n @param maxPressure The maximum pressure. The compressor will turn off when\n the pressure reaches this value or the pressure switch is disconnected or\n indicates that the system is full."]
    #[link_name = "\u{1}_ZN3frc12PneumaticHub22EnableCompressorHybridEN5units6unit_tINS1_4unitISt5ratioILx437817087ELx63500EENS1_9base_unitIS4_ILxn1ELx1EES4_ILx1ELx1EES4_ILxn2ELx1EES4_ILx0ELx1EESA_SA_SA_SA_SA_EESA_SA_EEdNS1_12linear_scaleEEESE_"]
    pub fn frc_PneumaticHub_EnableCompressorHybrid(
        this: *mut ::std::os::raw::c_void,
        minPressure: units_pressure_pounds_per_square_inch_t,
        maxPressure: units_pressure_pounds_per_square_inch_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub23GetCompressorConfigTypeEv"]
    pub fn frc_PneumaticHub_GetCompressorConfigType(
        this: *mut ::std::os::raw::c_void,
    ) -> frc_CompressorConfigType;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub17GetPressureSwitchEv"]
    pub fn frc_PneumaticHub_GetPressureSwitch(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub20GetCompressorCurrentEv"]
    pub fn frc_PneumaticHub_GetCompressorCurrent(
        this: *mut ::std::os::raw::c_void,
    ) -> units_current_ampere_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12PneumaticHub12SetSolenoidsEii"]
    pub fn frc_PneumaticHub_SetSolenoids(
        this: *mut ::std::os::raw::c_void,
        mask: ::std::os::raw::c_int,
        values: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub12GetSolenoidsEv"]
    pub fn frc_PneumaticHub_GetSolenoids(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub15GetModuleNumberEv"]
    pub fn frc_PneumaticHub_GetModuleNumber(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub23GetSolenoidDisabledListEv"]
    pub fn frc_PneumaticHub_GetSolenoidDisabledList(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12PneumaticHub11FireOneShotEi"]
    pub fn frc_PneumaticHub_FireOneShot(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12PneumaticHub18SetOneShotDurationEiN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_PneumaticHub_SetOneShotDuration(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        duration: units_time_second_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub20CheckSolenoidChannelEi"]
    pub fn frc_PneumaticHub_CheckSolenoidChannel(
        this: *mut ::std::os::raw::c_void,
        channel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12PneumaticHub24CheckAndReserveSolenoidsEi"]
    pub fn frc_PneumaticHub_CheckAndReserveSolenoids(
        this: *mut ::std::os::raw::c_void,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12PneumaticHub18UnreserveSolenoidsEi"]
    pub fn frc_PneumaticHub_UnreserveSolenoids(
        this: *mut ::std::os::raw::c_void,
        mask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12PneumaticHub17ReserveCompressorEv"]
    pub fn frc_PneumaticHub_ReserveCompressor(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12PneumaticHub19UnreserveCompressorEv"]
    pub fn frc_PneumaticHub_UnreserveCompressor(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12PneumaticHub12MakeSolenoidEi"]
    pub fn frc_PneumaticHub_MakeSolenoid(
        this: *mut ::std::os::raw::c_void,
        channel: ::std::os::raw::c_int,
    ) -> frc_Solenoid;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12PneumaticHub18MakeDoubleSolenoidEii"]
    pub fn frc_PneumaticHub_MakeDoubleSolenoid(
        this: *mut ::std::os::raw::c_void,
        forwardChannel: ::std::os::raw::c_int,
        reverseChannel: ::std::os::raw::c_int,
    ) -> frc_DoubleSolenoid;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12PneumaticHub14MakeCompressorEv"]
    pub fn frc_PneumaticHub_MakeCompressor(this: *mut ::std::os::raw::c_void) -> frc_Compressor;
}
extern "C" {
    #[doc = " Returns the raw voltage of the specified analog input channel.\n\n @param channel The analog input channel to read voltage from.\n @return The voltage of the specified analog input channel."]
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub16GetAnalogVoltageEi"]
    pub fn frc_PneumaticHub_GetAnalogVoltage(
        this: *mut ::std::os::raw::c_void,
        channel: ::std::os::raw::c_int,
    ) -> units_voltage_volt_t;
}
extern "C" {
    #[doc = " Returns the pressure read by an analog pressure sensor on the specified\n analog input channel.\n\n @param channel The analog input channel to read pressure from.\n @return The pressure read by an analog pressure sensor on the specified\n analog input channel."]
    #[link_name = "\u{1}_ZNK3frc12PneumaticHub11GetPressureEi"]
    pub fn frc_PneumaticHub_GetPressure(
        this: *mut ::std::os::raw::c_void,
        channel: ::std::os::raw::c_int,
    ) -> units_pressure_pounds_per_square_inch_t;
}
#[doc = " Module class for controlling a Cross The Road Electronics Pneumatics Control\n Module."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_PneumaticsControlModule {
    pub _base: frc_PneumaticsBase,
    pub m_dataStore: [u32; 2usize],
    pub m_handle: HAL_CTREPCMHandle,
    pub m_module: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_PneumaticsControlModule_DataStore {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule12m_handleLockE"]
    pub static mut frc_PneumaticsControlModule_m_handleLock: wpi_mutex;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule11m_handleMapE"]
    pub static mut frc_PneumaticsControlModule_m_handleMap: u8;
}
#[test]
fn bindgen_test_layout_frc_PneumaticsControlModule() {
    const UNINIT: ::std::mem::MaybeUninit<frc_PneumaticsControlModule> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_PneumaticsControlModule>(),
        20usize,
        concat!("Size of: ", stringify!(frc_PneumaticsControlModule))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PneumaticsControlModule>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_PneumaticsControlModule))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dataStore) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PneumaticsControlModule),
            "::",
            stringify!(m_dataStore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PneumaticsControlModule),
            "::",
            stringify!(m_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_module) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PneumaticsControlModule),
            "::",
            stringify!(m_module)
        )
    );
}
extern "C" {
    #[doc = " Return whether the compressor current is currently too high.\n\n @return True if the compressor current is too high, otherwise false.\n @see GetCompressorCurrentTooHighStickyFault()"]
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule32GetCompressorCurrentTooHighFaultEv"]
    pub fn frc_PneumaticsControlModule_GetCompressorCurrentTooHighFault(
        this: *const frc_PneumaticsControlModule,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns whether the compressor current has been too high since sticky\n faults were last cleared. This fault is persistent and can be cleared by\n ClearAllStickyFaults()\n\n @return True if the compressor current has been too high since sticky\n faults were last cleared.\n @see GetCompressorCurrentTooHighFault()"]
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule38GetCompressorCurrentTooHighStickyFaultEv"]
    pub fn frc_PneumaticsControlModule_GetCompressorCurrentTooHighStickyFault(
        this: *const frc_PneumaticsControlModule,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns whether the compressor is currently shorted.\n\n @return True if the compressor is currently shorted, otherwise false.\n @see GetCompressorShortedStickyFault()"]
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule25GetCompressorShortedFaultEv"]
    pub fn frc_PneumaticsControlModule_GetCompressorShortedFault(
        this: *const frc_PneumaticsControlModule,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns whether the compressor has been shorted since sticky faults were\n last cleared. This fault is persistent and can be cleared by\n ClearAllStickyFaults()\n\n @return True if the compressor has been shorted since sticky faults were\n last cleared, otherwise false.\n @see GetCompressorShortedFault()"]
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule31GetCompressorShortedStickyFaultEv"]
    pub fn frc_PneumaticsControlModule_GetCompressorShortedStickyFault(
        this: *const frc_PneumaticsControlModule,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns whether the compressor is currently disconnected.\n\n @return True if compressor is currently disconnected, otherwise false.\n @see GetCompressorNotConnectedStickyFault()"]
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule30GetCompressorNotConnectedFaultEv"]
    pub fn frc_PneumaticsControlModule_GetCompressorNotConnectedFault(
        this: *const frc_PneumaticsControlModule,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns whether the compressor has been disconnected since sticky faults\n were last cleared. This fault is persistent and can be cleared by\n ClearAllStickyFaults()}\n\n @return True if the compressor has been disconnected since sticky faults\n were last cleared, otherwise false.\n @see GetCompressorNotConnectedFault()"]
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule36GetCompressorNotConnectedStickyFaultEv"]
    pub fn frc_PneumaticsControlModule_GetCompressorNotConnectedStickyFault(
        this: *const frc_PneumaticsControlModule,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule23GetSolenoidVoltageFaultEv"]
    pub fn frc_PneumaticsControlModule_GetSolenoidVoltageFault(
        this: *const frc_PneumaticsControlModule,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule29GetSolenoidVoltageStickyFaultEv"]
    pub fn frc_PneumaticsControlModule_GetSolenoidVoltageStickyFault(
        this: *const frc_PneumaticsControlModule,
    ) -> bool;
}
extern "C" {
    #[doc = " Clears all sticky faults on this device."]
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule20ClearAllStickyFaultsEv"]
    pub fn frc_PneumaticsControlModule_ClearAllStickyFaults(this: *mut frc_PneumaticsControlModule);
}
extern "C" {
    #[doc = " Constructs a PneumaticsControlModule with the default ID (0)."]
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModuleC1Ev"]
    pub fn frc_PneumaticsControlModule_PneumaticsControlModule(
        this: *mut frc_PneumaticsControlModule,
    );
}
extern "C" {
    #[doc = " Constructs a PneumaticsControlModule.\n\n @param module module number to construct"]
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModuleC1Ei"]
    pub fn frc_PneumaticsControlModule_PneumaticsControlModule1(
        this: *mut frc_PneumaticsControlModule,
        module: ::std::os::raw::c_int,
    );
}
impl frc_PneumaticsControlModule {
    #[inline]
    pub unsafe fn GetCompressorCurrentTooHighFault(&self) -> bool {
        frc_PneumaticsControlModule_GetCompressorCurrentTooHighFault(self)
    }
    #[inline]
    pub unsafe fn GetCompressorCurrentTooHighStickyFault(&self) -> bool {
        frc_PneumaticsControlModule_GetCompressorCurrentTooHighStickyFault(self)
    }
    #[inline]
    pub unsafe fn GetCompressorShortedFault(&self) -> bool {
        frc_PneumaticsControlModule_GetCompressorShortedFault(self)
    }
    #[inline]
    pub unsafe fn GetCompressorShortedStickyFault(&self) -> bool {
        frc_PneumaticsControlModule_GetCompressorShortedStickyFault(self)
    }
    #[inline]
    pub unsafe fn GetCompressorNotConnectedFault(&self) -> bool {
        frc_PneumaticsControlModule_GetCompressorNotConnectedFault(self)
    }
    #[inline]
    pub unsafe fn GetCompressorNotConnectedStickyFault(&self) -> bool {
        frc_PneumaticsControlModule_GetCompressorNotConnectedStickyFault(self)
    }
    #[inline]
    pub unsafe fn GetSolenoidVoltageFault(&self) -> bool {
        frc_PneumaticsControlModule_GetSolenoidVoltageFault(self)
    }
    #[inline]
    pub unsafe fn GetSolenoidVoltageStickyFault(&self) -> bool {
        frc_PneumaticsControlModule_GetSolenoidVoltageStickyFault(self)
    }
    #[inline]
    pub unsafe fn ClearAllStickyFaults(&mut self) {
        frc_PneumaticsControlModule_ClearAllStickyFaults(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_PneumaticsControlModule_PneumaticsControlModule(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(module: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_PneumaticsControlModule_PneumaticsControlModule1(__bindgen_tmp.as_mut_ptr(), module);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule13GetCompressorEv"]
    pub fn frc_PneumaticsControlModule_GetCompressor(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Disables the compressor. The compressor will not turn on until\n EnableCompressorDigital() is called."]
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule17DisableCompressorEv"]
    pub fn frc_PneumaticsControlModule_DisableCompressor(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule23EnableCompressorDigitalEv"]
    pub fn frc_PneumaticsControlModule_EnableCompressorDigital(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Enables the compressor in digital mode. Analog mode is unsupported by the\n CTRE PCM.\n\n @param minPressure Unsupported.\n @param maxPressure Unsupported.\n @see EnableCompressorDigital()"]
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule22EnableCompressorAnalogEN5units6unit_tINS1_4unitISt5ratioILx437817087ELx63500EENS1_9base_unitIS4_ILxn1ELx1EES4_ILx1ELx1EES4_ILxn2ELx1EES4_ILx0ELx1EESA_SA_SA_SA_SA_EESA_SA_EEdNS1_12linear_scaleEEESE_"]
    pub fn frc_PneumaticsControlModule_EnableCompressorAnalog(
        this: *mut ::std::os::raw::c_void,
        minPressure: units_pressure_pounds_per_square_inch_t,
        maxPressure: units_pressure_pounds_per_square_inch_t,
    );
}
extern "C" {
    #[doc = " Enables the compressor in digital mode. Hybrid mode is unsupported by the\n CTRE PCM.\n\n @param minPressure Unsupported.\n @param maxPressure Unsupported.\n @see EnableCompressorDigital()"]
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule22EnableCompressorHybridEN5units6unit_tINS1_4unitISt5ratioILx437817087ELx63500EENS1_9base_unitIS4_ILxn1ELx1EES4_ILx1ELx1EES4_ILxn2ELx1EES4_ILx0ELx1EESA_SA_SA_SA_SA_EESA_SA_EEdNS1_12linear_scaleEEESE_"]
    pub fn frc_PneumaticsControlModule_EnableCompressorHybrid(
        this: *mut ::std::os::raw::c_void,
        minPressure: units_pressure_pounds_per_square_inch_t,
        maxPressure: units_pressure_pounds_per_square_inch_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule23GetCompressorConfigTypeEv"]
    pub fn frc_PneumaticsControlModule_GetCompressorConfigType(
        this: *mut ::std::os::raw::c_void,
    ) -> frc_CompressorConfigType;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule17GetPressureSwitchEv"]
    pub fn frc_PneumaticsControlModule_GetPressureSwitch(this: *mut ::std::os::raw::c_void)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule20GetCompressorCurrentEv"]
    pub fn frc_PneumaticsControlModule_GetCompressorCurrent(
        this: *mut ::std::os::raw::c_void,
    ) -> units_current_ampere_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule12SetSolenoidsEii"]
    pub fn frc_PneumaticsControlModule_SetSolenoids(
        this: *mut ::std::os::raw::c_void,
        mask: ::std::os::raw::c_int,
        values: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule12GetSolenoidsEv"]
    pub fn frc_PneumaticsControlModule_GetSolenoids(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule15GetModuleNumberEv"]
    pub fn frc_PneumaticsControlModule_GetModuleNumber(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule23GetSolenoidDisabledListEv"]
    pub fn frc_PneumaticsControlModule_GetSolenoidDisabledList(
        this: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule11FireOneShotEi"]
    pub fn frc_PneumaticsControlModule_FireOneShot(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule18SetOneShotDurationEiN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_PneumaticsControlModule_SetOneShotDuration(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
        duration: units_time_second_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule20CheckSolenoidChannelEi"]
    pub fn frc_PneumaticsControlModule_CheckSolenoidChannel(
        this: *mut ::std::os::raw::c_void,
        channel: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule24CheckAndReserveSolenoidsEi"]
    pub fn frc_PneumaticsControlModule_CheckAndReserveSolenoids(
        this: *mut ::std::os::raw::c_void,
        mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule18UnreserveSolenoidsEi"]
    pub fn frc_PneumaticsControlModule_UnreserveSolenoids(
        this: *mut ::std::os::raw::c_void,
        mask: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule17ReserveCompressorEv"]
    pub fn frc_PneumaticsControlModule_ReserveCompressor(this: *mut ::std::os::raw::c_void)
        -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule19UnreserveCompressorEv"]
    pub fn frc_PneumaticsControlModule_UnreserveCompressor(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Unsupported by the CTRE PCM.\n\n @param channel Unsupported.\n @return 0"]
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule16GetAnalogVoltageEi"]
    pub fn frc_PneumaticsControlModule_GetAnalogVoltage(
        this: *mut ::std::os::raw::c_void,
        channel: ::std::os::raw::c_int,
    ) -> units_voltage_volt_t;
}
extern "C" {
    #[doc = " Unsupported by the CTRE PCM.\n\n @param channel Unsupported.\n @return 0"]
    #[link_name = "\u{1}_ZNK3frc23PneumaticsControlModule11GetPressureEi"]
    pub fn frc_PneumaticsControlModule_GetPressure(
        this: *mut ::std::os::raw::c_void,
        channel: ::std::os::raw::c_int,
    ) -> units_pressure_pounds_per_square_inch_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule12MakeSolenoidEi"]
    pub fn frc_PneumaticsControlModule_MakeSolenoid(
        this: *mut ::std::os::raw::c_void,
        channel: ::std::os::raw::c_int,
    ) -> frc_Solenoid;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule18MakeDoubleSolenoidEii"]
    pub fn frc_PneumaticsControlModule_MakeDoubleSolenoid(
        this: *mut ::std::os::raw::c_void,
        forwardChannel: ::std::os::raw::c_int,
        reverseChannel: ::std::os::raw::c_int,
    ) -> frc_DoubleSolenoid;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc23PneumaticsControlModule14MakeCompressorEv"]
    pub fn frc_PneumaticsControlModule_MakeCompressor(
        this: *mut ::std::os::raw::c_void,
    ) -> frc_Compressor;
}
#[doc = " Class for getting voltage, current, temperature, power and energy from the\n CTRE Power Distribution Panel (PDP) or REV Power Distribution Hub (PDH)."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_PowerDistribution {
    pub _base: wpi_Sendable,
    pub m_handle: u32,
    pub m_module: ::std::os::raw::c_int,
}
pub const frc_PowerDistribution_ModuleType_kCTRE: frc_PowerDistribution_ModuleType = 1;
pub const frc_PowerDistribution_ModuleType_kRev: frc_PowerDistribution_ModuleType = 2;
pub type frc_PowerDistribution_ModuleType = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_PowerDistribution_Version {
    pub FirmwareMajor: u32,
    pub FirmwareMinor: u32,
    pub FirmwareFix: u32,
    pub HardwareMinor: u32,
    pub HardwareMajor: u32,
    pub UniqueId: u32,
}
#[test]
fn bindgen_test_layout_frc_PowerDistribution_Version() {
    const UNINIT: ::std::mem::MaybeUninit<frc_PowerDistribution_Version> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_PowerDistribution_Version>(),
        24usize,
        concat!("Size of: ", stringify!(frc_PowerDistribution_Version))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PowerDistribution_Version>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_PowerDistribution_Version))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FirmwareMajor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PowerDistribution_Version),
            "::",
            stringify!(FirmwareMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FirmwareMinor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PowerDistribution_Version),
            "::",
            stringify!(FirmwareMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FirmwareFix) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PowerDistribution_Version),
            "::",
            stringify!(FirmwareFix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HardwareMinor) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PowerDistribution_Version),
            "::",
            stringify!(HardwareMinor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HardwareMajor) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PowerDistribution_Version),
            "::",
            stringify!(HardwareMajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UniqueId) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PowerDistribution_Version),
            "::",
            stringify!(UniqueId)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct frc_PowerDistribution_Faults {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_frc_PowerDistribution_Faults() {
    assert_eq!(
        ::std::mem::size_of::<frc_PowerDistribution_Faults>(),
        4usize,
        concat!("Size of: ", stringify!(frc_PowerDistribution_Faults))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PowerDistribution_Faults>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_PowerDistribution_Faults))
    );
}
impl frc_PowerDistribution_Faults {
    #[inline]
    pub fn Channel0BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel0BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel1BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel1BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel2BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel2BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel3BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel3BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel4BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel4BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel5BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel5BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel6BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel6BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel7BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel7BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel8BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel8BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel9BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel9BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel10BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel10BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel11BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel11BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel12BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel12BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel13BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel13BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel14BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel14BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel15BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel15BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel16BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel16BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel17BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel17BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel18BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel18BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel19BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel19BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel20BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel20BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel21BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel21BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel22BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel22BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel23BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel23BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Brownout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Brownout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CanWarning(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CanWarning(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardwareFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardwareFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Channel0BreakerFault: u32,
        Channel1BreakerFault: u32,
        Channel2BreakerFault: u32,
        Channel3BreakerFault: u32,
        Channel4BreakerFault: u32,
        Channel5BreakerFault: u32,
        Channel6BreakerFault: u32,
        Channel7BreakerFault: u32,
        Channel8BreakerFault: u32,
        Channel9BreakerFault: u32,
        Channel10BreakerFault: u32,
        Channel11BreakerFault: u32,
        Channel12BreakerFault: u32,
        Channel13BreakerFault: u32,
        Channel14BreakerFault: u32,
        Channel15BreakerFault: u32,
        Channel16BreakerFault: u32,
        Channel17BreakerFault: u32,
        Channel18BreakerFault: u32,
        Channel19BreakerFault: u32,
        Channel20BreakerFault: u32,
        Channel21BreakerFault: u32,
        Channel22BreakerFault: u32,
        Channel23BreakerFault: u32,
        Brownout: u32,
        CanWarning: u32,
        HardwareFault: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Channel0BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel0BreakerFault) };
            Channel0BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Channel1BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel1BreakerFault) };
            Channel1BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Channel2BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel2BreakerFault) };
            Channel2BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Channel3BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel3BreakerFault) };
            Channel3BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Channel4BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel4BreakerFault) };
            Channel4BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Channel5BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel5BreakerFault) };
            Channel5BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Channel6BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel6BreakerFault) };
            Channel6BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Channel7BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel7BreakerFault) };
            Channel7BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Channel8BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel8BreakerFault) };
            Channel8BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Channel9BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel9BreakerFault) };
            Channel9BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Channel10BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel10BreakerFault) };
            Channel10BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Channel11BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel11BreakerFault) };
            Channel11BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let Channel12BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel12BreakerFault) };
            Channel12BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Channel13BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel13BreakerFault) };
            Channel13BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let Channel14BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel14BreakerFault) };
            Channel14BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Channel15BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel15BreakerFault) };
            Channel15BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let Channel16BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel16BreakerFault) };
            Channel16BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Channel17BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel17BreakerFault) };
            Channel17BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Channel18BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel18BreakerFault) };
            Channel18BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Channel19BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel19BreakerFault) };
            Channel19BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Channel20BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel20BreakerFault) };
            Channel20BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let Channel21BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel21BreakerFault) };
            Channel21BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let Channel22BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel22BreakerFault) };
            Channel22BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Channel23BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel23BreakerFault) };
            Channel23BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let Brownout: u32 = unsafe { ::std::mem::transmute(Brownout) };
            Brownout as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let CanWarning: u32 = unsafe { ::std::mem::transmute(CanWarning) };
            CanWarning as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let HardwareFault: u32 = unsafe { ::std::mem::transmute(HardwareFault) };
            HardwareFault as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct frc_PowerDistribution_StickyFaults {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_frc_PowerDistribution_StickyFaults() {
    assert_eq!(
        ::std::mem::size_of::<frc_PowerDistribution_StickyFaults>(),
        4usize,
        concat!("Size of: ", stringify!(frc_PowerDistribution_StickyFaults))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PowerDistribution_StickyFaults>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(frc_PowerDistribution_StickyFaults)
        )
    );
}
impl frc_PowerDistribution_StickyFaults {
    #[inline]
    pub fn Channel0BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel0BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel1BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel1BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel2BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel2BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel3BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel3BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel4BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel4BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel5BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel5BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel6BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel6BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel7BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel7BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel8BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel8BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel9BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel9BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel10BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel10BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel11BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel11BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel12BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel12BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel13BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel13BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel14BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel14BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel15BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel15BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel16BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel16BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel17BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel17BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel18BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel18BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel19BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel19BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel20BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel20BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel21BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel21BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel22BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel22BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Channel23BreakerFault(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Channel23BreakerFault(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Brownout(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Brownout(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CanWarning(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CanWarning(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CanBusOff(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CanBusOff(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasReset(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasReset(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Channel0BreakerFault: u32,
        Channel1BreakerFault: u32,
        Channel2BreakerFault: u32,
        Channel3BreakerFault: u32,
        Channel4BreakerFault: u32,
        Channel5BreakerFault: u32,
        Channel6BreakerFault: u32,
        Channel7BreakerFault: u32,
        Channel8BreakerFault: u32,
        Channel9BreakerFault: u32,
        Channel10BreakerFault: u32,
        Channel11BreakerFault: u32,
        Channel12BreakerFault: u32,
        Channel13BreakerFault: u32,
        Channel14BreakerFault: u32,
        Channel15BreakerFault: u32,
        Channel16BreakerFault: u32,
        Channel17BreakerFault: u32,
        Channel18BreakerFault: u32,
        Channel19BreakerFault: u32,
        Channel20BreakerFault: u32,
        Channel21BreakerFault: u32,
        Channel22BreakerFault: u32,
        Channel23BreakerFault: u32,
        Brownout: u32,
        CanWarning: u32,
        CanBusOff: u32,
        HasReset: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Channel0BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel0BreakerFault) };
            Channel0BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Channel1BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel1BreakerFault) };
            Channel1BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Channel2BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel2BreakerFault) };
            Channel2BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Channel3BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel3BreakerFault) };
            Channel3BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Channel4BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel4BreakerFault) };
            Channel4BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Channel5BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel5BreakerFault) };
            Channel5BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Channel6BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel6BreakerFault) };
            Channel6BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Channel7BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel7BreakerFault) };
            Channel7BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Channel8BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel8BreakerFault) };
            Channel8BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Channel9BreakerFault: u32 = unsafe { ::std::mem::transmute(Channel9BreakerFault) };
            Channel9BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Channel10BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel10BreakerFault) };
            Channel10BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let Channel11BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel11BreakerFault) };
            Channel11BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let Channel12BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel12BreakerFault) };
            Channel12BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Channel13BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel13BreakerFault) };
            Channel13BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let Channel14BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel14BreakerFault) };
            Channel14BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Channel15BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel15BreakerFault) };
            Channel15BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let Channel16BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel16BreakerFault) };
            Channel16BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Channel17BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel17BreakerFault) };
            Channel17BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Channel18BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel18BreakerFault) };
            Channel18BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Channel19BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel19BreakerFault) };
            Channel19BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Channel20BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel20BreakerFault) };
            Channel20BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let Channel21BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel21BreakerFault) };
            Channel21BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let Channel22BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel22BreakerFault) };
            Channel22BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Channel23BreakerFault: u32 =
                unsafe { ::std::mem::transmute(Channel23BreakerFault) };
            Channel23BreakerFault as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let Brownout: u32 = unsafe { ::std::mem::transmute(Brownout) };
            Brownout as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let CanWarning: u32 = unsafe { ::std::mem::transmute(CanWarning) };
            CanWarning as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let CanBusOff: u32 = unsafe { ::std::mem::transmute(CanBusOff) };
            CanBusOff as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let HasReset: u32 = unsafe { ::std::mem::transmute(HasReset) };
            HasReset as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const frc_PowerDistribution_kDefaultModule: ::std::os::raw::c_int = -1;
#[test]
fn bindgen_test_layout_frc_PowerDistribution() {
    const UNINIT: ::std::mem::MaybeUninit<frc_PowerDistribution> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_PowerDistribution>(),
        12usize,
        concat!("Size of: ", stringify!(frc_PowerDistribution))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PowerDistribution>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_PowerDistribution))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PowerDistribution),
            "::",
            stringify!(m_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_module) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PowerDistribution),
            "::",
            stringify!(m_module)
        )
    );
}
extern "C" {
    #[doc = " Query the input voltage of the PDP/PDH.\n\n @return The input voltage in volts"]
    #[link_name = "\u{1}_ZNK3frc17PowerDistribution10GetVoltageEv"]
    pub fn frc_PowerDistribution_GetVoltage(this: *const frc_PowerDistribution) -> f64;
}
extern "C" {
    #[doc = " Query the temperature of the PDP/PDH.\n\n @return The temperature in degrees Celsius"]
    #[link_name = "\u{1}_ZNK3frc17PowerDistribution14GetTemperatureEv"]
    pub fn frc_PowerDistribution_GetTemperature(this: *const frc_PowerDistribution) -> f64;
}
extern "C" {
    #[doc = " Query the current of a single channel of the PDP/PDH.\n\n @param channel the channel to query (0-15 for PDP, 0-23 for PDH)\n @return The current of the channel in Amperes"]
    #[link_name = "\u{1}_ZNK3frc17PowerDistribution10GetCurrentEi"]
    pub fn frc_PowerDistribution_GetCurrent(
        this: *const frc_PowerDistribution,
        channel: ::std::os::raw::c_int,
    ) -> f64;
}
extern "C" {
    #[doc = " Query the total current of all monitored PDP/PDH channels.\n\n @return The total current drawn from all channels in Amperes"]
    #[link_name = "\u{1}_ZNK3frc17PowerDistribution15GetTotalCurrentEv"]
    pub fn frc_PowerDistribution_GetTotalCurrent(this: *const frc_PowerDistribution) -> f64;
}
extern "C" {
    #[doc = " Query the total power drawn from all monitored PDP/PDH channels.\n\n @return The total power drawn in Watts"]
    #[link_name = "\u{1}_ZNK3frc17PowerDistribution13GetTotalPowerEv"]
    pub fn frc_PowerDistribution_GetTotalPower(this: *const frc_PowerDistribution) -> f64;
}
extern "C" {
    #[doc = " Query the total energy drawn from the monitored PDP/PDH channels.\n\n @return The total energy drawn in Joules"]
    #[link_name = "\u{1}_ZNK3frc17PowerDistribution14GetTotalEnergyEv"]
    pub fn frc_PowerDistribution_GetTotalEnergy(this: *const frc_PowerDistribution) -> f64;
}
extern "C" {
    #[doc = " Reset the total energy drawn from the PDP/PDH.\n\n @see PowerDistribution#GetTotalEnergy"]
    #[link_name = "\u{1}_ZN3frc17PowerDistribution16ResetTotalEnergyEv"]
    pub fn frc_PowerDistribution_ResetTotalEnergy(this: *mut frc_PowerDistribution);
}
extern "C" {
    #[doc = " Remove all of the fault flags on the PDP/PDH."]
    #[link_name = "\u{1}_ZN3frc17PowerDistribution17ClearStickyFaultsEv"]
    pub fn frc_PowerDistribution_ClearStickyFaults(this: *mut frc_PowerDistribution);
}
extern "C" {
    #[doc = " Gets module number (CAN ID)."]
    #[link_name = "\u{1}_ZNK3frc17PowerDistribution9GetModuleEv"]
    pub fn frc_PowerDistribution_GetModule(
        this: *const frc_PowerDistribution,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets module type."]
    #[link_name = "\u{1}_ZNK3frc17PowerDistribution7GetTypeEv"]
    pub fn frc_PowerDistribution_GetType(
        this: *const frc_PowerDistribution,
    ) -> frc_PowerDistribution_ModuleType;
}
extern "C" {
    #[doc = " Gets whether the PDH switchable channel is turned on or off. Returns false\n with the CTRE PDP.\n\n @return The output state of the PDH switchable channel"]
    #[link_name = "\u{1}_ZNK3frc17PowerDistribution20GetSwitchableChannelEv"]
    pub fn frc_PowerDistribution_GetSwitchableChannel(this: *const frc_PowerDistribution) -> bool;
}
extern "C" {
    #[doc = " Sets the PDH switchable channel on or off. Does nothing with the CTRE PDP.\n\n @param enabled Whether to turn the PDH switchable channel on or off"]
    #[link_name = "\u{1}_ZN3frc17PowerDistribution20SetSwitchableChannelEb"]
    pub fn frc_PowerDistribution_SetSwitchableChannel(
        this: *mut frc_PowerDistribution,
        enabled: bool,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc17PowerDistribution10GetVersionEv"]
    pub fn frc_PowerDistribution_GetVersion(
        this: *const frc_PowerDistribution,
    ) -> frc_PowerDistribution_Version;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc17PowerDistribution9GetFaultsEv"]
    pub fn frc_PowerDistribution_GetFaults(
        this: *const frc_PowerDistribution,
    ) -> frc_PowerDistribution_Faults;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc17PowerDistribution15GetStickyFaultsEv"]
    pub fn frc_PowerDistribution_GetStickyFaults(
        this: *const frc_PowerDistribution,
    ) -> frc_PowerDistribution_StickyFaults;
}
extern "C" {
    #[doc = " Constructs a PowerDistribution object.\n\n Detects the connected PDP/PDH using the default CAN ID (0 for CTRE and 1\n for REV)."]
    #[link_name = "\u{1}_ZN3frc17PowerDistributionC1Ev"]
    pub fn frc_PowerDistribution_PowerDistribution(this: *mut frc_PowerDistribution);
}
extern "C" {
    #[doc = " Constructs a PowerDistribution object.\n\n @param module The CAN ID of the PDP/PDH\n @param moduleType The type of module"]
    #[link_name = "\u{1}_ZN3frc17PowerDistributionC1EiNS0_10ModuleTypeE"]
    pub fn frc_PowerDistribution_PowerDistribution1(
        this: *mut frc_PowerDistribution,
        module: ::std::os::raw::c_int,
        moduleType: frc_PowerDistribution_ModuleType,
    );
}
impl frc_PowerDistribution {
    #[inline]
    pub unsafe fn GetVoltage(&self) -> f64 {
        frc_PowerDistribution_GetVoltage(self)
    }
    #[inline]
    pub unsafe fn GetTemperature(&self) -> f64 {
        frc_PowerDistribution_GetTemperature(self)
    }
    #[inline]
    pub unsafe fn GetCurrent(&self, channel: ::std::os::raw::c_int) -> f64 {
        frc_PowerDistribution_GetCurrent(self, channel)
    }
    #[inline]
    pub unsafe fn GetTotalCurrent(&self) -> f64 {
        frc_PowerDistribution_GetTotalCurrent(self)
    }
    #[inline]
    pub unsafe fn GetTotalPower(&self) -> f64 {
        frc_PowerDistribution_GetTotalPower(self)
    }
    #[inline]
    pub unsafe fn GetTotalEnergy(&self) -> f64 {
        frc_PowerDistribution_GetTotalEnergy(self)
    }
    #[inline]
    pub unsafe fn ResetTotalEnergy(&mut self) {
        frc_PowerDistribution_ResetTotalEnergy(self)
    }
    #[inline]
    pub unsafe fn ClearStickyFaults(&mut self) {
        frc_PowerDistribution_ClearStickyFaults(self)
    }
    #[inline]
    pub unsafe fn GetModule(&self) -> ::std::os::raw::c_int {
        frc_PowerDistribution_GetModule(self)
    }
    #[inline]
    pub unsafe fn GetType(&self) -> frc_PowerDistribution_ModuleType {
        frc_PowerDistribution_GetType(self)
    }
    #[inline]
    pub unsafe fn GetSwitchableChannel(&self) -> bool {
        frc_PowerDistribution_GetSwitchableChannel(self)
    }
    #[inline]
    pub unsafe fn SetSwitchableChannel(&mut self, enabled: bool) {
        frc_PowerDistribution_SetSwitchableChannel(self, enabled)
    }
    #[inline]
    pub unsafe fn GetVersion(&self) -> frc_PowerDistribution_Version {
        frc_PowerDistribution_GetVersion(self)
    }
    #[inline]
    pub unsafe fn GetFaults(&self) -> frc_PowerDistribution_Faults {
        frc_PowerDistribution_GetFaults(self)
    }
    #[inline]
    pub unsafe fn GetStickyFaults(&self) -> frc_PowerDistribution_StickyFaults {
        frc_PowerDistribution_GetStickyFaults(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_PowerDistribution_PowerDistribution(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        module: ::std::os::raw::c_int,
        moduleType: frc_PowerDistribution_ModuleType,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_PowerDistribution_PowerDistribution1(__bindgen_tmp.as_mut_ptr(), module, moduleType);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc17PowerDistributionD1Ev"]
    pub fn frc_PowerDistribution_PowerDistribution_destructor(this: *mut frc_PowerDistribution);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc17PowerDistribution12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_PowerDistribution_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " The preferences class provides a relatively simple way to save important\n values to the roboRIO to access the next time the roboRIO is booted.\n\n This class loads and saves from a file inside the roboRIO.  The user cannot\n access the file directly, but may modify values at specific fields which will\n then be automatically periodically saved to the file by the NetworkTable\n server.\n\n This class is thread safe.\n\n This will also interact with NetworkTable by creating a table called\n \"Preferences\" with all the key-value pairs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_Preferences {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_frc_Preferences() {
    assert_eq!(
        ::std::mem::size_of::<frc_Preferences>(),
        1usize,
        concat!("Size of: ", stringify!(frc_Preferences))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Preferences>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_Preferences))
    );
}
extern "C" {
    #[doc = " Returns a vector of all the keys.\n\n @return a vector of the keys"]
    #[link_name = "\u{1}_ZN3frc11Preferences7GetKeysB5cxx11Ev"]
    pub fn frc_Preferences_GetKeys() -> [u32; 3usize];
}
extern "C" {
    #[doc = " Returns the string at the given key.  If this table does not have a value\n for that position, then the given defaultValue will be returned.\n\n @param key          the key\n @param defaultValue the value to return if none exists in the table\n @return either the value in the table, or the defaultValue"]
    #[link_name = "\u{1}_ZN3frc11Preferences9GetStringB5cxx11ESt17basic_string_viewIcSt11char_traitsIcEES4_"]
    pub fn frc_Preferences_GetString(
        key: std_string_view,
        defaultValue: std_string_view,
    ) -> std_string;
}
extern "C" {
    #[doc = " Returns the int at the given key.  If this table does not have a value for\n that position, then the given defaultValue value will be returned.\n\n @param key          the key\n @param defaultValue the value to return if none exists in the table\n @return either the value in the table, or the defaultValue"]
    #[link_name = "\u{1}_ZN3frc11Preferences6GetIntESt17basic_string_viewIcSt11char_traitsIcEEi"]
    pub fn frc_Preferences_GetInt(
        key: std_string_view,
        defaultValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the double at the given key.  If this table does not have a value\n for that position, then the given defaultValue value will be returned.\n\n @param key          the key\n @param defaultValue the value to return if none exists in the table\n @return either the value in the table, or the defaultValue"]
    #[link_name = "\u{1}_ZN3frc11Preferences9GetDoubleESt17basic_string_viewIcSt11char_traitsIcEEd"]
    pub fn frc_Preferences_GetDouble(key: std_string_view, defaultValue: f64) -> f64;
}
extern "C" {
    #[doc = " Returns the float at the given key.  If this table does not have a value\n for that position, then the given defaultValue value will be returned.\n\n @param key          the key\n @param defaultValue the value to return if none exists in the table\n @return either the value in the table, or the defaultValue"]
    #[link_name = "\u{1}_ZN3frc11Preferences8GetFloatESt17basic_string_viewIcSt11char_traitsIcEEf"]
    pub fn frc_Preferences_GetFloat(key: std_string_view, defaultValue: f32) -> f32;
}
extern "C" {
    #[doc = " Returns the boolean at the given key.  If this table does not have a value\n for that position, then the given defaultValue value will be returned.\n\n @param key          the key\n @param defaultValue the value to return if none exists in the table\n @return either the value in the table, or the defaultValue"]
    #[link_name = "\u{1}_ZN3frc11Preferences10GetBooleanESt17basic_string_viewIcSt11char_traitsIcEEb"]
    pub fn frc_Preferences_GetBoolean(key: std_string_view, defaultValue: bool) -> bool;
}
extern "C" {
    #[doc = " Returns the long (int64_t) at the given key.  If this table does not have a\n value for that position, then the given defaultValue value will be\n returned.\n\n @param key          the key\n @param defaultValue the value to return if none exists in the table\n @return either the value in the table, or the defaultValue"]
    #[link_name = "\u{1}_ZN3frc11Preferences7GetLongESt17basic_string_viewIcSt11char_traitsIcEEx"]
    pub fn frc_Preferences_GetLong(key: std_string_view, defaultValue: i64) -> i64;
}
extern "C" {
    #[doc = " Puts the given string into the preferences table.\n\n The value may not have quotation marks, nor may the key have any whitespace\n nor an equals sign.\n\n @param key   the key\n @param value the value"]
    #[link_name = "\u{1}_ZN3frc11Preferences9SetStringESt17basic_string_viewIcSt11char_traitsIcEES4_"]
    pub fn frc_Preferences_SetString(key: std_string_view, value: std_string_view);
}
extern "C" {
    #[doc = " Puts the given string into the preferences table if it doesn't\n already exist."]
    #[link_name = "\u{1}_ZN3frc11Preferences10InitStringESt17basic_string_viewIcSt11char_traitsIcEES4_"]
    pub fn frc_Preferences_InitString(key: std_string_view, value: std_string_view);
}
extern "C" {
    #[doc = " Puts the given int into the preferences table.\n\n The key may not have any whitespace nor an equals sign.\n\n @param key   the key\n @param value the value"]
    #[link_name = "\u{1}_ZN3frc11Preferences6SetIntESt17basic_string_viewIcSt11char_traitsIcEEi"]
    pub fn frc_Preferences_SetInt(key: std_string_view, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Puts the given int into the preferences table if it doesn't\n already exist."]
    #[link_name = "\u{1}_ZN3frc11Preferences7InitIntESt17basic_string_viewIcSt11char_traitsIcEEi"]
    pub fn frc_Preferences_InitInt(key: std_string_view, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Puts the given double into the preferences table.\n\n The key may not have any whitespace nor an equals sign.\n\n @param key   the key\n @param value the value"]
    #[link_name = "\u{1}_ZN3frc11Preferences9SetDoubleESt17basic_string_viewIcSt11char_traitsIcEEd"]
    pub fn frc_Preferences_SetDouble(key: std_string_view, value: f64);
}
extern "C" {
    #[doc = " Puts the given double into the preferences table if it doesn't\n already exist."]
    #[link_name = "\u{1}_ZN3frc11Preferences10InitDoubleESt17basic_string_viewIcSt11char_traitsIcEEd"]
    pub fn frc_Preferences_InitDouble(key: std_string_view, value: f64);
}
extern "C" {
    #[doc = " Puts the given float into the preferences table.\n\n The key may not have any whitespace nor an equals sign.\n\n @param key   the key\n @param value the value"]
    #[link_name = "\u{1}_ZN3frc11Preferences8SetFloatESt17basic_string_viewIcSt11char_traitsIcEEf"]
    pub fn frc_Preferences_SetFloat(key: std_string_view, value: f32);
}
extern "C" {
    #[doc = " Puts the given float into the preferences table if it doesn't\n already exist."]
    #[link_name = "\u{1}_ZN3frc11Preferences9InitFloatESt17basic_string_viewIcSt11char_traitsIcEEf"]
    pub fn frc_Preferences_InitFloat(key: std_string_view, value: f32);
}
extern "C" {
    #[doc = " Puts the given boolean into the preferences table.\n\n The key may not have any whitespace nor an equals sign.\n\n @param key   the key\n @param value the value"]
    #[link_name = "\u{1}_ZN3frc11Preferences10SetBooleanESt17basic_string_viewIcSt11char_traitsIcEEb"]
    pub fn frc_Preferences_SetBoolean(key: std_string_view, value: bool);
}
extern "C" {
    #[doc = " Puts the given boolean into the preferences table if it doesn't\n already exist."]
    #[link_name = "\u{1}_ZN3frc11Preferences11InitBooleanESt17basic_string_viewIcSt11char_traitsIcEEb"]
    pub fn frc_Preferences_InitBoolean(key: std_string_view, value: bool);
}
extern "C" {
    #[doc = " Puts the given long (int64_t) into the preferences table.\n\n The key may not have any whitespace nor an equals sign.\n\n @param key   the key\n @param value the value"]
    #[link_name = "\u{1}_ZN3frc11Preferences7SetLongESt17basic_string_viewIcSt11char_traitsIcEEx"]
    pub fn frc_Preferences_SetLong(key: std_string_view, value: i64);
}
extern "C" {
    #[doc = " Puts the given long into the preferences table if it doesn't\n already exist."]
    #[link_name = "\u{1}_ZN3frc11Preferences8InitLongESt17basic_string_viewIcSt11char_traitsIcEEx"]
    pub fn frc_Preferences_InitLong(key: std_string_view, value: i64);
}
extern "C" {
    #[doc = " Returns whether or not there is a key with the given name.\n\n @param key the key\n @return if there is a value at the given key"]
    #[link_name = "\u{1}_ZN3frc11Preferences11ContainsKeyESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_Preferences_ContainsKey(key: std_string_view) -> bool;
}
extern "C" {
    #[doc = " Remove a preference.\n\n @param key the key"]
    #[link_name = "\u{1}_ZN3frc11Preferences6RemoveESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_Preferences_Remove(key: std_string_view);
}
extern "C" {
    #[doc = " Remove all preferences."]
    #[link_name = "\u{1}_ZN3frc11Preferences9RemoveAllEv"]
    pub fn frc_Preferences_RemoveAll();
}
impl frc_Preferences {
    #[inline]
    pub unsafe fn GetKeys() -> [u32; 3usize] {
        frc_Preferences_GetKeys()
    }
    #[inline]
    pub unsafe fn GetString(key: std_string_view, defaultValue: std_string_view) -> std_string {
        frc_Preferences_GetString(key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetInt(
        key: std_string_view,
        defaultValue: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        frc_Preferences_GetInt(key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetDouble(key: std_string_view, defaultValue: f64) -> f64 {
        frc_Preferences_GetDouble(key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetFloat(key: std_string_view, defaultValue: f32) -> f32 {
        frc_Preferences_GetFloat(key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetBoolean(key: std_string_view, defaultValue: bool) -> bool {
        frc_Preferences_GetBoolean(key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetLong(key: std_string_view, defaultValue: i64) -> i64 {
        frc_Preferences_GetLong(key, defaultValue)
    }
    #[inline]
    pub unsafe fn SetString(key: std_string_view, value: std_string_view) {
        frc_Preferences_SetString(key, value)
    }
    #[inline]
    pub unsafe fn InitString(key: std_string_view, value: std_string_view) {
        frc_Preferences_InitString(key, value)
    }
    #[inline]
    pub unsafe fn SetInt(key: std_string_view, value: ::std::os::raw::c_int) {
        frc_Preferences_SetInt(key, value)
    }
    #[inline]
    pub unsafe fn InitInt(key: std_string_view, value: ::std::os::raw::c_int) {
        frc_Preferences_InitInt(key, value)
    }
    #[inline]
    pub unsafe fn SetDouble(key: std_string_view, value: f64) {
        frc_Preferences_SetDouble(key, value)
    }
    #[inline]
    pub unsafe fn InitDouble(key: std_string_view, value: f64) {
        frc_Preferences_InitDouble(key, value)
    }
    #[inline]
    pub unsafe fn SetFloat(key: std_string_view, value: f32) {
        frc_Preferences_SetFloat(key, value)
    }
    #[inline]
    pub unsafe fn InitFloat(key: std_string_view, value: f32) {
        frc_Preferences_InitFloat(key, value)
    }
    #[inline]
    pub unsafe fn SetBoolean(key: std_string_view, value: bool) {
        frc_Preferences_SetBoolean(key, value)
    }
    #[inline]
    pub unsafe fn InitBoolean(key: std_string_view, value: bool) {
        frc_Preferences_InitBoolean(key, value)
    }
    #[inline]
    pub unsafe fn SetLong(key: std_string_view, value: i64) {
        frc_Preferences_SetLong(key, value)
    }
    #[inline]
    pub unsafe fn InitLong(key: std_string_view, value: i64) {
        frc_Preferences_InitLong(key, value)
    }
    #[inline]
    pub unsafe fn ContainsKey(key: std_string_view) -> bool {
        frc_Preferences_ContainsKey(key)
    }
    #[inline]
    pub unsafe fn Remove(key: std_string_view) {
        frc_Preferences_Remove(key)
    }
    #[inline]
    pub unsafe fn RemoveAll() {
        frc_Preferences_RemoveAll()
    }
}
#[doc = " Handle input from PS4 controllers connected to the Driver Station.\n\n <p>This class handles PS4 input that comes from the Driver Station. Each time\n a value is requested the most recent value is returned. There is a single\n class instance for each controller and the mapping of ports to hardware\n buttons depends on the code in the Driver Station."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_PS4Controller {
    pub _base: frc_GenericHID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_PS4Controller_Button {
    pub _address: u8,
}
pub const frc_PS4Controller_Button_kSquare: ::std::os::raw::c_int = 1;
pub const frc_PS4Controller_Button_kCross: ::std::os::raw::c_int = 2;
pub const frc_PS4Controller_Button_kCircle: ::std::os::raw::c_int = 3;
pub const frc_PS4Controller_Button_kTriangle: ::std::os::raw::c_int = 4;
pub const frc_PS4Controller_Button_kL1: ::std::os::raw::c_int = 5;
pub const frc_PS4Controller_Button_kR1: ::std::os::raw::c_int = 6;
pub const frc_PS4Controller_Button_kL2: ::std::os::raw::c_int = 7;
pub const frc_PS4Controller_Button_kR2: ::std::os::raw::c_int = 8;
pub const frc_PS4Controller_Button_kShare: ::std::os::raw::c_int = 9;
pub const frc_PS4Controller_Button_kOptions: ::std::os::raw::c_int = 10;
pub const frc_PS4Controller_Button_kL3: ::std::os::raw::c_int = 11;
pub const frc_PS4Controller_Button_kR3: ::std::os::raw::c_int = 12;
pub const frc_PS4Controller_Button_kPS: ::std::os::raw::c_int = 13;
pub const frc_PS4Controller_Button_kTouchpad: ::std::os::raw::c_int = 14;
#[test]
fn bindgen_test_layout_frc_PS4Controller_Button() {
    assert_eq!(
        ::std::mem::size_of::<frc_PS4Controller_Button>(),
        1usize,
        concat!("Size of: ", stringify!(frc_PS4Controller_Button))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PS4Controller_Button>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_PS4Controller_Button))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_PS4Controller_Axis {
    pub _address: u8,
}
pub const frc_PS4Controller_Axis_kLeftX: ::std::os::raw::c_int = 0;
pub const frc_PS4Controller_Axis_kLeftY: ::std::os::raw::c_int = 1;
pub const frc_PS4Controller_Axis_kRightX: ::std::os::raw::c_int = 2;
pub const frc_PS4Controller_Axis_kRightY: ::std::os::raw::c_int = 5;
pub const frc_PS4Controller_Axis_kL2: ::std::os::raw::c_int = 3;
pub const frc_PS4Controller_Axis_kR2: ::std::os::raw::c_int = 4;
#[test]
fn bindgen_test_layout_frc_PS4Controller_Axis() {
    assert_eq!(
        ::std::mem::size_of::<frc_PS4Controller_Axis>(),
        1usize,
        concat!("Size of: ", stringify!(frc_PS4Controller_Axis))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PS4Controller_Axis>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_PS4Controller_Axis))
    );
}
#[test]
fn bindgen_test_layout_frc_PS4Controller() {
    assert_eq!(
        ::std::mem::size_of::<frc_PS4Controller>(),
        16usize,
        concat!("Size of: ", stringify!(frc_PS4Controller))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PS4Controller>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_PS4Controller))
    );
}
extern "C" {
    #[doc = " Get the X axis value of left side of the controller.\n\n @return the axis value."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller8GetLeftXEv"]
    pub fn frc_PS4Controller_GetLeftX(this: *const frc_PS4Controller) -> f64;
}
extern "C" {
    #[doc = " Get the X axis value of right side of the controller.\n\n @return the axis value."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller9GetRightXEv"]
    pub fn frc_PS4Controller_GetRightX(this: *const frc_PS4Controller) -> f64;
}
extern "C" {
    #[doc = " Get the Y axis value of left side of the controller.\n\n @return the axis value."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller8GetLeftYEv"]
    pub fn frc_PS4Controller_GetLeftY(this: *const frc_PS4Controller) -> f64;
}
extern "C" {
    #[doc = " Get the Y axis value of right side of the controller.\n\n @return the axis value."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller9GetRightYEv"]
    pub fn frc_PS4Controller_GetRightY(this: *const frc_PS4Controller) -> f64;
}
extern "C" {
    #[doc = " Get the L2 axis value of the controller. Note that this axis is bound to\n the range of [0, 1] as opposed to the usual [-1, 1].\n\n @return the axis value."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller9GetL2AxisEv"]
    pub fn frc_PS4Controller_GetL2Axis(this: *const frc_PS4Controller) -> f64;
}
extern "C" {
    #[doc = " Get the R2 axis value of the controller. Note that this axis is bound to\n the range of [0, 1] as opposed to the usual [-1, 1].\n\n @return the axis value."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller9GetR2AxisEv"]
    pub fn frc_PS4Controller_GetR2Axis(this: *const frc_PS4Controller) -> f64;
}
extern "C" {
    #[doc = " Read the value of the Square button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller15GetSquareButtonEv"]
    pub fn frc_PS4Controller_GetSquareButton(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the Square button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller22GetSquareButtonPressedEv"]
    pub fn frc_PS4Controller_GetSquareButtonPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the Square button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller23GetSquareButtonReleasedEv"]
    pub fn frc_PS4Controller_GetSquareButtonReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the square button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the square button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller6SquareEPNS_9EventLoopE"]
    pub fn frc_PS4Controller_Square(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the Cross button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller14GetCrossButtonEv"]
    pub fn frc_PS4Controller_GetCrossButton(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the Cross button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller21GetCrossButtonPressedEv"]
    pub fn frc_PS4Controller_GetCrossButtonPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the Cross button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller22GetCrossButtonReleasedEv"]
    pub fn frc_PS4Controller_GetCrossButtonReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the cross button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the cross button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller5CrossEPNS_9EventLoopE"]
    pub fn frc_PS4Controller_Cross(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the Circle button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller15GetCircleButtonEv"]
    pub fn frc_PS4Controller_GetCircleButton(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the Circle button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller22GetCircleButtonPressedEv"]
    pub fn frc_PS4Controller_GetCircleButtonPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the Circle button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller23GetCircleButtonReleasedEv"]
    pub fn frc_PS4Controller_GetCircleButtonReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the circle button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the circle button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller6CircleEPNS_9EventLoopE"]
    pub fn frc_PS4Controller_Circle(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the Triangle button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller17GetTriangleButtonEv"]
    pub fn frc_PS4Controller_GetTriangleButton(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the Triangle button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller24GetTriangleButtonPressedEv"]
    pub fn frc_PS4Controller_GetTriangleButtonPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the Triangle button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller25GetTriangleButtonReleasedEv"]
    pub fn frc_PS4Controller_GetTriangleButtonReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the triangle button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the triangle button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller8TriangleEPNS_9EventLoopE"]
    pub fn frc_PS4Controller_Triangle(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the L1 button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller11GetL1ButtonEv"]
    pub fn frc_PS4Controller_GetL1Button(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the L1 button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller18GetL1ButtonPressedEv"]
    pub fn frc_PS4Controller_GetL1ButtonPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the L1 button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller19GetL1ButtonReleasedEv"]
    pub fn frc_PS4Controller_GetL1ButtonReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the L1 button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the L1 button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller2L1EPNS_9EventLoopE"]
    pub fn frc_PS4Controller_L1(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the R1 button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller11GetR1ButtonEv"]
    pub fn frc_PS4Controller_GetR1Button(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the R1 button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller18GetR1ButtonPressedEv"]
    pub fn frc_PS4Controller_GetR1ButtonPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the R1 button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller19GetR1ButtonReleasedEv"]
    pub fn frc_PS4Controller_GetR1ButtonReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the R1 button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the R1 button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller2R1EPNS_9EventLoopE"]
    pub fn frc_PS4Controller_R1(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the L2 button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller11GetL2ButtonEv"]
    pub fn frc_PS4Controller_GetL2Button(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the L2 button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller18GetL2ButtonPressedEv"]
    pub fn frc_PS4Controller_GetL2ButtonPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the L2 button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller19GetL2ButtonReleasedEv"]
    pub fn frc_PS4Controller_GetL2ButtonReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the L2 button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the L2 button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller2L2EPNS_9EventLoopE"]
    pub fn frc_PS4Controller_L2(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the R2 button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller11GetR2ButtonEv"]
    pub fn frc_PS4Controller_GetR2Button(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the R2 button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller18GetR2ButtonPressedEv"]
    pub fn frc_PS4Controller_GetR2ButtonPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the R2 button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller19GetR2ButtonReleasedEv"]
    pub fn frc_PS4Controller_GetR2ButtonReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the R2 button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the R2 button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller2R2EPNS_9EventLoopE"]
    pub fn frc_PS4Controller_R2(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the Share button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller14GetShareButtonEv"]
    pub fn frc_PS4Controller_GetShareButton(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the Share button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller21GetShareButtonPressedEv"]
    pub fn frc_PS4Controller_GetShareButtonPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the Share button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller22GetShareButtonReleasedEv"]
    pub fn frc_PS4Controller_GetShareButtonReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the share button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the share button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller5ShareEPNS_9EventLoopE"]
    pub fn frc_PS4Controller_Share(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the Options button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller16GetOptionsButtonEv"]
    pub fn frc_PS4Controller_GetOptionsButton(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the Options button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller23GetOptionsButtonPressedEv"]
    pub fn frc_PS4Controller_GetOptionsButtonPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the Options button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller24GetOptionsButtonReleasedEv"]
    pub fn frc_PS4Controller_GetOptionsButtonReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the options button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the options button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller7OptionsEPNS_9EventLoopE"]
    pub fn frc_PS4Controller_Options(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the L3 button (pressing the left analog stick) on the\n controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller11GetL3ButtonEv"]
    pub fn frc_PS4Controller_GetL3Button(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the L3 (left stick) button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller18GetL3ButtonPressedEv"]
    pub fn frc_PS4Controller_GetL3ButtonPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the L3 (left stick) button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller19GetL3ButtonReleasedEv"]
    pub fn frc_PS4Controller_GetL3ButtonReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the L3 button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the L3 button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller2L3EPNS_9EventLoopE"]
    pub fn frc_PS4Controller_L3(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the R3 button (pressing the right analog stick) on the\n controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller11GetR3ButtonEv"]
    pub fn frc_PS4Controller_GetR3Button(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the R3 (right stick) button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller18GetR3ButtonPressedEv"]
    pub fn frc_PS4Controller_GetR3ButtonPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the R3 (right stick) button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller19GetR3ButtonReleasedEv"]
    pub fn frc_PS4Controller_GetR3ButtonReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the R3 button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the R3 button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller2R3EPNS_9EventLoopE"]
    pub fn frc_PS4Controller_R3(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the PS button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller11GetPSButtonEv"]
    pub fn frc_PS4Controller_GetPSButton(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the PS button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller18GetPSButtonPressedEv"]
    pub fn frc_PS4Controller_GetPSButtonPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the PS button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller19GetPSButtonReleasedEv"]
    pub fn frc_PS4Controller_GetPSButtonReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the PS button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the PS button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller2PSEPNS_9EventLoopE"]
    pub fn frc_PS4Controller_PS(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the touchpad button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller11GetTouchpadEv"]
    pub fn frc_PS4Controller_GetTouchpad(this: *const frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the touchpad was pressed since the last check.\n\n @return Whether the touchpad was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller18GetTouchpadPressedEv"]
    pub fn frc_PS4Controller_GetTouchpadPressed(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Whether the touchpad was released since the last check.\n\n @return Whether the touchpad was released since the last check."]
    #[link_name = "\u{1}_ZN3frc13PS4Controller19GetTouchpadReleasedEv"]
    pub fn frc_PS4Controller_GetTouchpadReleased(this: *mut frc_PS4Controller) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the touchpad's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the touchpad's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc13PS4Controller8TouchpadEPNS_9EventLoopE"]
    pub fn frc_PS4Controller_Touchpad(
        this: *const frc_PS4Controller,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Construct an instance of an PS4 controller.\n\n The controller index is the USB port on the Driver Station.\n\n @param port The port on the Driver Station that the controller is plugged\n             into (0-5)."]
    #[link_name = "\u{1}_ZN3frc13PS4ControllerC1Ei"]
    pub fn frc_PS4Controller_PS4Controller(
        this: *mut frc_PS4Controller,
        port: ::std::os::raw::c_int,
    );
}
impl frc_PS4Controller {
    #[inline]
    pub unsafe fn GetLeftX(&self) -> f64 {
        frc_PS4Controller_GetLeftX(self)
    }
    #[inline]
    pub unsafe fn GetRightX(&self) -> f64 {
        frc_PS4Controller_GetRightX(self)
    }
    #[inline]
    pub unsafe fn GetLeftY(&self) -> f64 {
        frc_PS4Controller_GetLeftY(self)
    }
    #[inline]
    pub unsafe fn GetRightY(&self) -> f64 {
        frc_PS4Controller_GetRightY(self)
    }
    #[inline]
    pub unsafe fn GetL2Axis(&self) -> f64 {
        frc_PS4Controller_GetL2Axis(self)
    }
    #[inline]
    pub unsafe fn GetR2Axis(&self) -> f64 {
        frc_PS4Controller_GetR2Axis(self)
    }
    #[inline]
    pub unsafe fn GetSquareButton(&self) -> bool {
        frc_PS4Controller_GetSquareButton(self)
    }
    #[inline]
    pub unsafe fn GetSquareButtonPressed(&mut self) -> bool {
        frc_PS4Controller_GetSquareButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetSquareButtonReleased(&mut self) -> bool {
        frc_PS4Controller_GetSquareButtonReleased(self)
    }
    #[inline]
    pub unsafe fn Square(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_Square(self, loop_)
    }
    #[inline]
    pub unsafe fn GetCrossButton(&self) -> bool {
        frc_PS4Controller_GetCrossButton(self)
    }
    #[inline]
    pub unsafe fn GetCrossButtonPressed(&mut self) -> bool {
        frc_PS4Controller_GetCrossButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetCrossButtonReleased(&mut self) -> bool {
        frc_PS4Controller_GetCrossButtonReleased(self)
    }
    #[inline]
    pub unsafe fn Cross(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_Cross(self, loop_)
    }
    #[inline]
    pub unsafe fn GetCircleButton(&self) -> bool {
        frc_PS4Controller_GetCircleButton(self)
    }
    #[inline]
    pub unsafe fn GetCircleButtonPressed(&mut self) -> bool {
        frc_PS4Controller_GetCircleButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetCircleButtonReleased(&mut self) -> bool {
        frc_PS4Controller_GetCircleButtonReleased(self)
    }
    #[inline]
    pub unsafe fn Circle(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_Circle(self, loop_)
    }
    #[inline]
    pub unsafe fn GetTriangleButton(&self) -> bool {
        frc_PS4Controller_GetTriangleButton(self)
    }
    #[inline]
    pub unsafe fn GetTriangleButtonPressed(&mut self) -> bool {
        frc_PS4Controller_GetTriangleButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetTriangleButtonReleased(&mut self) -> bool {
        frc_PS4Controller_GetTriangleButtonReleased(self)
    }
    #[inline]
    pub unsafe fn Triangle(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_Triangle(self, loop_)
    }
    #[inline]
    pub unsafe fn GetL1Button(&self) -> bool {
        frc_PS4Controller_GetL1Button(self)
    }
    #[inline]
    pub unsafe fn GetL1ButtonPressed(&mut self) -> bool {
        frc_PS4Controller_GetL1ButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetL1ButtonReleased(&mut self) -> bool {
        frc_PS4Controller_GetL1ButtonReleased(self)
    }
    #[inline]
    pub unsafe fn L1(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_L1(self, loop_)
    }
    #[inline]
    pub unsafe fn GetR1Button(&self) -> bool {
        frc_PS4Controller_GetR1Button(self)
    }
    #[inline]
    pub unsafe fn GetR1ButtonPressed(&mut self) -> bool {
        frc_PS4Controller_GetR1ButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetR1ButtonReleased(&mut self) -> bool {
        frc_PS4Controller_GetR1ButtonReleased(self)
    }
    #[inline]
    pub unsafe fn R1(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_R1(self, loop_)
    }
    #[inline]
    pub unsafe fn GetL2Button(&self) -> bool {
        frc_PS4Controller_GetL2Button(self)
    }
    #[inline]
    pub unsafe fn GetL2ButtonPressed(&mut self) -> bool {
        frc_PS4Controller_GetL2ButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetL2ButtonReleased(&mut self) -> bool {
        frc_PS4Controller_GetL2ButtonReleased(self)
    }
    #[inline]
    pub unsafe fn L2(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_L2(self, loop_)
    }
    #[inline]
    pub unsafe fn GetR2Button(&self) -> bool {
        frc_PS4Controller_GetR2Button(self)
    }
    #[inline]
    pub unsafe fn GetR2ButtonPressed(&mut self) -> bool {
        frc_PS4Controller_GetR2ButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetR2ButtonReleased(&mut self) -> bool {
        frc_PS4Controller_GetR2ButtonReleased(self)
    }
    #[inline]
    pub unsafe fn R2(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_R2(self, loop_)
    }
    #[inline]
    pub unsafe fn GetShareButton(&self) -> bool {
        frc_PS4Controller_GetShareButton(self)
    }
    #[inline]
    pub unsafe fn GetShareButtonPressed(&mut self) -> bool {
        frc_PS4Controller_GetShareButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetShareButtonReleased(&mut self) -> bool {
        frc_PS4Controller_GetShareButtonReleased(self)
    }
    #[inline]
    pub unsafe fn Share(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_Share(self, loop_)
    }
    #[inline]
    pub unsafe fn GetOptionsButton(&self) -> bool {
        frc_PS4Controller_GetOptionsButton(self)
    }
    #[inline]
    pub unsafe fn GetOptionsButtonPressed(&mut self) -> bool {
        frc_PS4Controller_GetOptionsButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetOptionsButtonReleased(&mut self) -> bool {
        frc_PS4Controller_GetOptionsButtonReleased(self)
    }
    #[inline]
    pub unsafe fn Options(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_Options(self, loop_)
    }
    #[inline]
    pub unsafe fn GetL3Button(&self) -> bool {
        frc_PS4Controller_GetL3Button(self)
    }
    #[inline]
    pub unsafe fn GetL3ButtonPressed(&mut self) -> bool {
        frc_PS4Controller_GetL3ButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetL3ButtonReleased(&mut self) -> bool {
        frc_PS4Controller_GetL3ButtonReleased(self)
    }
    #[inline]
    pub unsafe fn L3(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_L3(self, loop_)
    }
    #[inline]
    pub unsafe fn GetR3Button(&self) -> bool {
        frc_PS4Controller_GetR3Button(self)
    }
    #[inline]
    pub unsafe fn GetR3ButtonPressed(&mut self) -> bool {
        frc_PS4Controller_GetR3ButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetR3ButtonReleased(&mut self) -> bool {
        frc_PS4Controller_GetR3ButtonReleased(self)
    }
    #[inline]
    pub unsafe fn R3(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_R3(self, loop_)
    }
    #[inline]
    pub unsafe fn GetPSButton(&self) -> bool {
        frc_PS4Controller_GetPSButton(self)
    }
    #[inline]
    pub unsafe fn GetPSButtonPressed(&mut self) -> bool {
        frc_PS4Controller_GetPSButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetPSButtonReleased(&mut self) -> bool {
        frc_PS4Controller_GetPSButtonReleased(self)
    }
    #[inline]
    pub unsafe fn PS(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_PS(self, loop_)
    }
    #[inline]
    pub unsafe fn GetTouchpad(&self) -> bool {
        frc_PS4Controller_GetTouchpad(self)
    }
    #[inline]
    pub unsafe fn GetTouchpadPressed(&mut self) -> bool {
        frc_PS4Controller_GetTouchpadPressed(self)
    }
    #[inline]
    pub unsafe fn GetTouchpadReleased(&mut self) -> bool {
        frc_PS4Controller_GetTouchpadReleased(self)
    }
    #[inline]
    pub unsafe fn Touchpad(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_PS4Controller_Touchpad(self, loop_)
    }
    #[inline]
    pub unsafe fn new(port: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_PS4Controller_PS4Controller(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Class implements the PWM generation in the FPGA.\n\n The values supplied as arguments for PWM outputs range from -1.0 to 1.0. They\n are mapped to the hardware dependent values, in this case 0-2000 for the\n FPGA. Changes are immediately sent to the FPGA, and the update occurs at the\n next FPGA cycle (5.005ms). There is no delay.\n\n As of revision 0.1.10 of the FPGA, the FPGA interprets the 0-2000 values as\n follows:\n   - 2000 = maximum pulse width\n   - 1999 to 1001 = linear scaling from \"full forward\" to \"center\"\n   - 1000 = center value\n   - 999 to 2 = linear scaling from \"center\" to \"full reverse\"\n   - 1 = minimum pulse width (currently 0.5ms)\n   - 0 = disabled (i.e. PWM output is held low)"]
#[repr(C)]
#[derive(Debug)]
pub struct frc_PWM {
    pub _base: wpi_Sendable,
    pub m_channel: ::std::os::raw::c_int,
    pub m_handle: u32,
}
#[doc = " Don't skip pulses. PWM pulses occur every 5.005 ms"]
pub const frc_PWM_PeriodMultiplier_kPeriodMultiplier_1X: frc_PWM_PeriodMultiplier = 1;
#[doc = " Skip every other pulse. PWM pulses occur every 10.010 ms"]
pub const frc_PWM_PeriodMultiplier_kPeriodMultiplier_2X: frc_PWM_PeriodMultiplier = 2;
#[doc = " Skip three out of four pulses. PWM pulses occur every 20.020 ms"]
pub const frc_PWM_PeriodMultiplier_kPeriodMultiplier_4X: frc_PWM_PeriodMultiplier = 4;
#[doc = " Represents the amount to multiply the minimum servo-pulse pwm period by."]
pub type frc_PWM_PeriodMultiplier = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_frc_PWM() {
    const UNINIT: ::std::mem::MaybeUninit<frc_PWM> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_PWM>(),
        12usize,
        concat!("Size of: ", stringify!(frc_PWM))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_PWM>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_PWM))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_channel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PWM),
            "::",
            stringify!(m_channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_PWM),
            "::",
            stringify!(m_handle)
        )
    );
}
extern "C" {
    #[doc = " Slow down the PWM signal for old devices.\n\n @param mult The period multiplier to apply to this channel"]
    #[link_name = "\u{1}_ZN3frc3PWM19SetPeriodMultiplierENS0_16PeriodMultiplierE"]
    pub fn frc_PWM_SetPeriodMultiplier(this: *mut frc_PWM, mult: frc_PWM_PeriodMultiplier);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3PWM12SetZeroLatchEv"]
    pub fn frc_PWM_SetZeroLatch(this: *mut frc_PWM);
}
extern "C" {
    #[doc = " Optionally eliminate the deadband from a motor controller.\n\n @param eliminateDeadband If true, set the motor curve on the motor\n                          controller to eliminate the deadband in the middle\n                          of the range. Otherwise, keep the full range\n                          without modifying any values."]
    #[link_name = "\u{1}_ZN3frc3PWM25EnableDeadbandEliminationEb"]
    pub fn frc_PWM_EnableDeadbandElimination(this: *mut frc_PWM, eliminateDeadband: bool);
}
extern "C" {
    #[doc = " Set the bounds on the PWM pulse widths.\n\n This sets the bounds on the PWM values for a particular type of controller.\n The values determine the upper and lower speeds as well as the deadband\n bracket.\n\n @param max         The max PWM pulse width in ms\n @param deadbandMax The high end of the deadband range pulse width in ms\n @param center      The center (off) pulse width in ms\n @param deadbandMin The low end of the deadband pulse width in ms\n @param min         The minimum pulse width in ms"]
    #[link_name = "\u{1}_ZN3frc3PWM9SetBoundsEddddd"]
    pub fn frc_PWM_SetBounds(
        this: *mut frc_PWM,
        max: f64,
        deadbandMax: f64,
        center: f64,
        deadbandMin: f64,
        min: f64,
    );
}
extern "C" {
    #[doc = " Set the bounds on the PWM values.\n\n This sets the bounds on the PWM values for a particular each type of\n controller. The values determine the upper and lower speeds as well as the\n deadband bracket.\n\n @param max         The Minimum pwm value\n @param deadbandMax The high end of the deadband range\n @param center      The center speed (off)\n @param deadbandMin The low end of the deadband range\n @param min         The minimum pwm value"]
    #[link_name = "\u{1}_ZN3frc3PWM12SetRawBoundsEiiiii"]
    pub fn frc_PWM_SetRawBounds(
        this: *mut frc_PWM,
        max: ::std::os::raw::c_int,
        deadbandMax: ::std::os::raw::c_int,
        center: ::std::os::raw::c_int,
        deadbandMin: ::std::os::raw::c_int,
        min: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Get the bounds on the PWM values.\n\n This Gets the bounds on the PWM values for a particular each type of\n controller. The values determine the upper and lower speeds as well as the\n deadband bracket.\n\n @param max         The Minimum pwm value\n @param deadbandMax The high end of the deadband range\n @param center      The center speed (off)\n @param deadbandMin The low end of the deadband range\n @param min         The minimum pwm value"]
    #[link_name = "\u{1}_ZN3frc3PWM12GetRawBoundsEPiS1_S1_S1_S1_"]
    pub fn frc_PWM_GetRawBounds(
        this: *mut frc_PWM,
        max: *mut i32,
        deadbandMax: *mut i32,
        center: *mut i32,
        deadbandMin: *mut i32,
        min: *mut i32,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc3PWM10GetChannelEv"]
    pub fn frc_PWM_GetChannel(this: *const frc_PWM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a PWM given a channel number.\n\n Checks channel value range and allocates the appropriate channel.\n The allocation is only done to help users ensure that they don't double\n assign channels.\n\n @param channel The PWM channel number. 0-9 are on-board, 10-19 are on the\n                MXP port\n @param registerSendable If true, adds this instance to SendableRegistry\n                         and LiveWindow"]
    #[link_name = "\u{1}_ZN3frc3PWMC1Eib"]
    pub fn frc_PWM_PWM(this: *mut frc_PWM, channel: ::std::os::raw::c_int, registerSendable: bool);
}
impl frc_PWM {
    #[inline]
    pub unsafe fn SetPeriodMultiplier(&mut self, mult: frc_PWM_PeriodMultiplier) {
        frc_PWM_SetPeriodMultiplier(self, mult)
    }
    #[inline]
    pub unsafe fn SetZeroLatch(&mut self) {
        frc_PWM_SetZeroLatch(self)
    }
    #[inline]
    pub unsafe fn EnableDeadbandElimination(&mut self, eliminateDeadband: bool) {
        frc_PWM_EnableDeadbandElimination(self, eliminateDeadband)
    }
    #[inline]
    pub unsafe fn SetBounds(
        &mut self,
        max: f64,
        deadbandMax: f64,
        center: f64,
        deadbandMin: f64,
        min: f64,
    ) {
        frc_PWM_SetBounds(self, max, deadbandMax, center, deadbandMin, min)
    }
    #[inline]
    pub unsafe fn SetRawBounds(
        &mut self,
        max: ::std::os::raw::c_int,
        deadbandMax: ::std::os::raw::c_int,
        center: ::std::os::raw::c_int,
        deadbandMin: ::std::os::raw::c_int,
        min: ::std::os::raw::c_int,
    ) {
        frc_PWM_SetRawBounds(self, max, deadbandMax, center, deadbandMin, min)
    }
    #[inline]
    pub unsafe fn GetRawBounds(
        &mut self,
        max: *mut i32,
        deadbandMax: *mut i32,
        center: *mut i32,
        deadbandMin: *mut i32,
        min: *mut i32,
    ) {
        frc_PWM_GetRawBounds(self, max, deadbandMax, center, deadbandMin, min)
    }
    #[inline]
    pub unsafe fn GetChannel(&self) -> ::std::os::raw::c_int {
        frc_PWM_GetChannel(self)
    }
    #[inline]
    pub unsafe fn new(channel: ::std::os::raw::c_int, registerSendable: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_PWM_PWM(__bindgen_tmp.as_mut_ptr(), channel, registerSendable);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Free the PWM channel.\n\n Free the resource associated with the PWM channel and set the value to 0."]
    #[link_name = "\u{1}_ZN3frc3PWMD1Ev"]
    pub fn frc_PWM_PWM_destructor(this: *mut frc_PWM);
}
extern "C" {
    #[doc = " Set the PWM value directly to the hardware.\n\n Write a raw value to a PWM channel.\n\n @param value Raw PWM value."]
    #[link_name = "\u{1}_ZN3frc3PWM6SetRawEt"]
    pub fn frc_PWM_SetRaw(this: *mut ::std::os::raw::c_void, value: u16);
}
extern "C" {
    #[doc = " Get the PWM value directly from the hardware.\n\n Read a raw value from a PWM channel.\n\n @return Raw PWM control value."]
    #[link_name = "\u{1}_ZNK3frc3PWM6GetRawEv"]
    pub fn frc_PWM_GetRaw(this: *mut ::std::os::raw::c_void) -> u16;
}
extern "C" {
    #[doc = " Set the PWM value based on a position.\n\n This is intended to be used by servos.\n\n @pre SetMaxPositivePwm() called.\n @pre SetMinNegativePwm() called.\n\n @param pos The position to set the servo between 0.0 and 1.0."]
    #[link_name = "\u{1}_ZN3frc3PWM11SetPositionEd"]
    pub fn frc_PWM_SetPosition(this: *mut ::std::os::raw::c_void, pos: f64);
}
extern "C" {
    #[doc = " Get the PWM value in terms of a position.\n\n This is intended to be used by servos.\n\n @pre SetMaxPositivePwm() called.\n @pre SetMinNegativePwm() called.\n\n @return The position the servo is set to between 0.0 and 1.0."]
    #[link_name = "\u{1}_ZNK3frc3PWM11GetPositionEv"]
    pub fn frc_PWM_GetPosition(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " Set the PWM value based on a speed.\n\n This is intended to be used by motor controllers.\n\n @pre SetMaxPositivePwm() called.\n @pre SetMinPositivePwm() called.\n @pre SetCenterPwm() called.\n @pre SetMaxNegativePwm() called.\n @pre SetMinNegativePwm() called.\n\n @param speed The speed to set the motor controller between -1.0 and 1.0."]
    #[link_name = "\u{1}_ZN3frc3PWM8SetSpeedEd"]
    pub fn frc_PWM_SetSpeed(this: *mut ::std::os::raw::c_void, speed: f64);
}
extern "C" {
    #[doc = " Get the PWM value in terms of speed.\n\n This is intended to be used by motor controllers.\n\n @pre SetMaxPositivePwm() called.\n @pre SetMinPositivePwm() called.\n @pre SetMaxNegativePwm() called.\n @pre SetMinNegativePwm() called.\n\n @return The most recently set speed between -1.0 and 1.0."]
    #[link_name = "\u{1}_ZNK3frc3PWM8GetSpeedEv"]
    pub fn frc_PWM_GetSpeed(this: *mut ::std::os::raw::c_void) -> f64;
}
extern "C" {
    #[doc = " Temporarily disables the PWM output. The next set call will reenable\n the output."]
    #[link_name = "\u{1}_ZN3frc3PWM11SetDisabledEv"]
    pub fn frc_PWM_SetDisabled(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc3PWM12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_PWM_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Class for Spike style relay outputs.\n\n Relays are intended to be connected to spikes or similar relays. The relay\n channels controls a pair of pins that are either both off, one on, the other\n on, or both on. This translates into two spike outputs at 0v, one at 12v and\n one at 0v, one at 0v and the other at 12v, or two spike outputs at 12V. This\n allows off, full forward, or full reverse control of motors without variable\n speed. It also allows the two channels (forward and reverse) to be used\n independently for something that does not care about voltage polarity (like\n a solenoid)."]
#[repr(C)]
pub struct frc_Relay {
    pub _base: frc_MotorSafety,
    pub _base_1: wpi_Sendable,
    pub m_channel: ::std::os::raw::c_int,
    pub m_direction: frc_Relay_Direction,
    pub m_forwardHandle: u32,
    pub m_reverseHandle: u32,
}
pub const frc_Relay_Value_kOff: frc_Relay_Value = 0;
pub const frc_Relay_Value_kOn: frc_Relay_Value = 1;
pub const frc_Relay_Value_kForward: frc_Relay_Value = 2;
pub const frc_Relay_Value_kReverse: frc_Relay_Value = 3;
pub type frc_Relay_Value = ::std::os::raw::c_uint;
pub const frc_Relay_Direction_kBothDirections: frc_Relay_Direction = 0;
pub const frc_Relay_Direction_kForwardOnly: frc_Relay_Direction = 1;
pub const frc_Relay_Direction_kReverseOnly: frc_Relay_Direction = 2;
pub type frc_Relay_Direction = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_frc_Relay() {
    assert_eq!(
        ::std::mem::size_of::<frc_Relay>(),
        80usize,
        concat!("Size of: ", stringify!(frc_Relay))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Relay>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_Relay))
    );
}
extern "C" {
    #[doc = " Set the relay state.\n\n Valid values depend on which directions of the relay are controlled by the\n object.\n\n When set to kBothDirections, the relay can be any of the four states:\n 0v-0v, 0v-12v, 12v-0v, 12v-12v\n\n When set to kForwardOnly or kReverseOnly, you can specify the constant for\n the direction or you can simply specify kOff and kOn.  Using only kOff and\n kOn is recommended.\n\n @param value The state to set the relay."]
    #[link_name = "\u{1}_ZN3frc5Relay3SetENS0_5ValueE"]
    pub fn frc_Relay_Set(this: *mut frc_Relay, value: frc_Relay_Value);
}
extern "C" {
    #[doc = " Get the Relay State\n\n Gets the current state of the relay.\n\n When set to kForwardOnly or kReverseOnly, value is returned as kOn/kOff not\n kForward/kReverse (per the recommendation in Set).\n\n @return The current state of the relay as a Relay::Value"]
    #[link_name = "\u{1}_ZNK3frc5Relay3GetEv"]
    pub fn frc_Relay_Get(this: *const frc_Relay) -> frc_Relay_Value;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc5Relay10GetChannelEv"]
    pub fn frc_Relay_GetChannel(this: *const frc_Relay) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Relay constructor given a channel.\n\n This code initializes the relay and reserves all resources that need to be\n locked. Initially the relay is set to both lines at 0v.\n\n @param channel   The channel number (0-3).\n @param direction The direction that the Relay object will control."]
    #[link_name = "\u{1}_ZN3frc5RelayC1EiNS0_9DirectionE"]
    pub fn frc_Relay_Relay(
        this: *mut frc_Relay,
        channel: ::std::os::raw::c_int,
        direction: frc_Relay_Direction,
    );
}
impl frc_Relay {
    #[inline]
    pub unsafe fn Set(&mut self, value: frc_Relay_Value) {
        frc_Relay_Set(self, value)
    }
    #[inline]
    pub unsafe fn Get(&self) -> frc_Relay_Value {
        frc_Relay_Get(self)
    }
    #[inline]
    pub unsafe fn GetChannel(&self) -> ::std::os::raw::c_int {
        frc_Relay_GetChannel(self)
    }
    #[inline]
    pub unsafe fn new(channel: ::std::os::raw::c_int, direction: frc_Relay_Direction) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Relay_Relay(__bindgen_tmp.as_mut_ptr(), channel, direction);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Free the resource associated with a relay.\n\n The relay channels are set to free and the relay output is turned off."]
    #[link_name = "\u{1}_ZN3frc5RelayD1Ev"]
    pub fn frc_Relay_Relay_destructor(this: *mut frc_Relay);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc5Relay9StopMotorEv"]
    pub fn frc_Relay_StopMotor(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc5Relay14GetDescriptionB5cxx11Ev"]
    pub fn frc_Relay_GetDescription(this: *mut ::std::os::raw::c_void) -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZThn56_N3frc5Relay12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_Relay_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[repr(C)]
pub struct frc_Resource__bindgen_vtable {}
#[doc = " The Resource class is a convenient way to track allocated resources.\n\n It tracks them as indicies in the range [0 .. elements - 1]. E.g. the library\n uses this to track hardware channel allocation.\n\n The Resource class does not allocate the hardware channels or other\n resources; it just tracks which indices were marked in use by Allocate and\n not yet freed by Free."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Resource {
    pub vtable_: *const frc_Resource__bindgen_vtable,
    pub m_isAllocated: [u32; 5usize],
    pub m_allocateMutex: wpi_mutex,
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc8Resource13m_createMutexE"]
    pub static mut frc_Resource_m_createMutex: wpi_mutex;
}
#[test]
fn bindgen_test_layout_frc_Resource() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Resource> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Resource>(),
        48usize,
        concat!("Size of: ", stringify!(frc_Resource))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Resource>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_Resource))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_isAllocated) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Resource),
            "::",
            stringify!(m_isAllocated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_allocateMutex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Resource),
            "::",
            stringify!(m_allocateMutex)
        )
    );
}
extern "C" {
    #[doc = " Factory method to create a Resource allocation-tracker *if* needed.\n\n @param r        address of the caller's Resource pointer. If *r == nullptr,\n                 this will construct a Resource and make *r point to it. If\n                 *r != nullptr, i.e. the caller already has a Resource\n                 instance, this won't do anything.\n @param elements the number of elements for this Resource allocator to\n                 track, that is, it will allocate resource numbers in the\n                 range [0 .. elements - 1]."]
    #[link_name = "\u{1}_ZN3frc8Resource20CreateResourceObjectERSt10unique_ptrIS0_St14default_deleteIS0_EEj"]
    pub fn frc_Resource_CreateResourceObject(r: *mut u8, elements: u32);
}
extern "C" {
    #[doc = " Allocate a resource.\n\n When a resource is requested, mark it allocated. In this case, a free\n resource value within the range is located and returned after it is marked\n allocated."]
    #[link_name = "\u{1}_ZN3frc8Resource8AllocateERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn frc_Resource_Allocate(this: *mut frc_Resource, resourceDesc: *const std_string) -> u32;
}
extern "C" {
    #[doc = " Allocate a specific resource value.\n\n The user requests a specific resource value, i.e. channel number and it is\n verified unallocated, then returned."]
    #[link_name = "\u{1}_ZN3frc8Resource8AllocateEjRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
    pub fn frc_Resource_Allocate1(
        this: *mut frc_Resource,
        index: u32,
        resourceDesc: *const std_string,
    ) -> u32;
}
extern "C" {
    #[doc = " Free an allocated resource.\n\n After a resource is no longer needed, for example a destructor is called\n for a channel assignment class, Free will release the resource value so it\n can be reused somewhere else in the program."]
    #[link_name = "\u{1}_ZN3frc8Resource4FreeEj"]
    pub fn frc_Resource_Free(this: *mut frc_Resource, index: u32);
}
extern "C" {
    #[doc = " Allocate storage for a new instance of Resource.\n\n Allocate a bool array of values that will get initialized to indicate that\n no resources have been allocated yet. The indicies of the resources are\n [0 .. elements - 1]."]
    #[link_name = "\u{1}_ZN3frc8ResourceC1Ej"]
    pub fn frc_Resource_Resource(this: *mut frc_Resource, size: u32);
}
impl frc_Resource {
    #[inline]
    pub unsafe fn CreateResourceObject(r: *mut u8, elements: u32) {
        frc_Resource_CreateResourceObject(r, elements)
    }
    #[inline]
    pub unsafe fn Allocate(&mut self, resourceDesc: *const std_string) -> u32 {
        frc_Resource_Allocate(self, resourceDesc)
    }
    #[inline]
    pub unsafe fn Allocate1(&mut self, index: u32, resourceDesc: *const std_string) -> u32 {
        frc_Resource_Allocate1(self, index, resourceDesc)
    }
    #[inline]
    pub unsafe fn Free(&mut self, index: u32) {
        frc_Resource_Free(self, index)
    }
    #[inline]
    pub unsafe fn new(size: u32) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Resource_Resource(__bindgen_tmp.as_mut_ptr(), size);
        __bindgen_tmp.assume_init()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_CANStatus {
    pub percentBusUtilization: f32,
    pub busOffCount: ::std::os::raw::c_int,
    pub txFullCount: ::std::os::raw::c_int,
    pub receiveErrorCount: ::std::os::raw::c_int,
    pub transmitErrorCount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_frc_CANStatus() {
    const UNINIT: ::std::mem::MaybeUninit<frc_CANStatus> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_CANStatus>(),
        20usize,
        concat!("Size of: ", stringify!(frc_CANStatus))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_CANStatus>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_CANStatus))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).percentBusUtilization) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_CANStatus),
            "::",
            stringify!(percentBusUtilization)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).busOffCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_CANStatus),
            "::",
            stringify!(busOffCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).txFullCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_CANStatus),
            "::",
            stringify!(txFullCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).receiveErrorCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_CANStatus),
            "::",
            stringify!(receiveErrorCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).transmitErrorCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_CANStatus),
            "::",
            stringify!(transmitErrorCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_RobotController {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_frc_RobotController() {
    assert_eq!(
        ::std::mem::size_of::<frc_RobotController>(),
        1usize,
        concat!("Size of: ", stringify!(frc_RobotController))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_RobotController>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_RobotController))
    );
}
extern "C" {
    #[doc = " Return the FPGA Version number.\n\n For now, expect this to be competition year.\n\n @return FPGA Version number."]
    #[link_name = "\u{1}_ZN3frc15RobotController14GetFPGAVersionEv"]
    pub fn frc_RobotController_GetFPGAVersion() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the FPGA Revision number.\n\n The format of the revision is 3 numbers. The 12 most significant bits are\n the Major Revision. The next 8 bits are the Minor Revision. The 12 least\n significant bits are the Build Number.\n\n @return FPGA Revision number."]
    #[link_name = "\u{1}_ZN3frc15RobotController15GetFPGARevisionEv"]
    pub fn frc_RobotController_GetFPGARevision() -> i64;
}
extern "C" {
    #[doc = " Return the serial number of the roboRIO.\n\n @return The serial number of the roboRIO."]
    #[link_name = "\u{1}_ZN3frc15RobotController15GetSerialNumberB5cxx11Ev"]
    pub fn frc_RobotController_GetSerialNumber() -> std_string;
}
extern "C" {
    #[doc = " Return the comments from the roboRIO web interface.\n\n The comments string is cached after the first call to this function on the\n RoboRIO - restart the robot code to reload the comments string after\n changing it in the web interface.\n\n @return The comments from the roboRIO web interface."]
    #[link_name = "\u{1}_ZN3frc15RobotController11GetCommentsB5cxx11Ev"]
    pub fn frc_RobotController_GetComments() -> std_string;
}
extern "C" {
    #[doc = " Read the microsecond-resolution timer on the FPGA.\n\n @return The current time in microseconds according to the FPGA (since FPGA\n         reset)."]
    #[link_name = "\u{1}_ZN3frc15RobotController11GetFPGATimeEv"]
    pub fn frc_RobotController_GetFPGATime() -> u64;
}
extern "C" {
    #[doc = " Get the state of the \"USER\" button on the roboRIO.\n\n @return True if the button is currently pressed down"]
    #[link_name = "\u{1}_ZN3frc15RobotController13GetUserButtonEv"]
    pub fn frc_RobotController_GetUserButton() -> bool;
}
extern "C" {
    #[doc = " Read the battery voltage.\n\n @return The battery voltage in Volts."]
    #[link_name = "\u{1}_ZN3frc15RobotController17GetBatteryVoltageEv"]
    pub fn frc_RobotController_GetBatteryVoltage() -> units_voltage_volt_t;
}
extern "C" {
    #[doc = " Check if the FPGA outputs are enabled.\n\n The outputs may be disabled if the robot is disabled or e-stopped, the\n watchdog has expired, or if the roboRIO browns out.\n\n @return True if the FPGA outputs are enabled."]
    #[link_name = "\u{1}_ZN3frc15RobotController11IsSysActiveEv"]
    pub fn frc_RobotController_IsSysActive() -> bool;
}
extern "C" {
    #[doc = " Check if the system is browned out.\n\n @return True if the system is browned out"]
    #[link_name = "\u{1}_ZN3frc15RobotController12IsBrownedOutEv"]
    pub fn frc_RobotController_IsBrownedOut() -> bool;
}
extern "C" {
    #[doc = " Get the input voltage to the robot controller.\n\n @return The controller input voltage value in Volts"]
    #[link_name = "\u{1}_ZN3frc15RobotController15GetInputVoltageEv"]
    pub fn frc_RobotController_GetInputVoltage() -> f64;
}
extern "C" {
    #[doc = " Get the input current to the robot controller.\n\n @return The controller input current value in Amps"]
    #[link_name = "\u{1}_ZN3frc15RobotController15GetInputCurrentEv"]
    pub fn frc_RobotController_GetInputCurrent() -> f64;
}
extern "C" {
    #[doc = " Get the voltage of the 3.3V rail.\n\n @return The controller 3.3V rail voltage value in Volts"]
    #[link_name = "\u{1}_ZN3frc15RobotController13GetVoltage3V3Ev"]
    pub fn frc_RobotController_GetVoltage3V3() -> f64;
}
extern "C" {
    #[doc = " Get the current output of the 3.3V rail.\n\n @return The controller 3.3V rail output current value in Amps"]
    #[link_name = "\u{1}_ZN3frc15RobotController13GetCurrent3V3Ev"]
    pub fn frc_RobotController_GetCurrent3V3() -> f64;
}
extern "C" {
    #[doc = " Get the enabled state of the 3.3V rail. The rail may be disabled due to a\n controller brownout, a short circuit on the rail, or controller\n over-voltage.\n\n @return The controller 3.3V rail enabled value. True for enabled."]
    #[link_name = "\u{1}_ZN3frc15RobotController13GetEnabled3V3Ev"]
    pub fn frc_RobotController_GetEnabled3V3() -> bool;
}
extern "C" {
    #[doc = " Get the count of the total current faults on the 3.3V rail since the\n controller has booted.\n\n @return The number of faults"]
    #[link_name = "\u{1}_ZN3frc15RobotController16GetFaultCount3V3Ev"]
    pub fn frc_RobotController_GetFaultCount3V3() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the voltage of the 5V rail.\n\n @return The controller 5V rail voltage value in Volts"]
    #[link_name = "\u{1}_ZN3frc15RobotController12GetVoltage5VEv"]
    pub fn frc_RobotController_GetVoltage5V() -> f64;
}
extern "C" {
    #[doc = " Get the current output of the 5V rail.\n\n @return The controller 5V rail output current value in Amps"]
    #[link_name = "\u{1}_ZN3frc15RobotController12GetCurrent5VEv"]
    pub fn frc_RobotController_GetCurrent5V() -> f64;
}
extern "C" {
    #[doc = " Get the enabled state of the 5V rail. The rail may be disabled due to a\n controller brownout, a short circuit on the rail, or controller\n over-voltage.\n\n @return The controller 5V rail enabled value. True for enabled."]
    #[link_name = "\u{1}_ZN3frc15RobotController12GetEnabled5VEv"]
    pub fn frc_RobotController_GetEnabled5V() -> bool;
}
extern "C" {
    #[doc = " Get the count of the total current faults on the 5V rail since the\n controller has booted.\n\n @return The number of faults"]
    #[link_name = "\u{1}_ZN3frc15RobotController15GetFaultCount5VEv"]
    pub fn frc_RobotController_GetFaultCount5V() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the voltage of the 6V rail.\n\n @return The controller 6V rail voltage value in Volts"]
    #[link_name = "\u{1}_ZN3frc15RobotController12GetVoltage6VEv"]
    pub fn frc_RobotController_GetVoltage6V() -> f64;
}
extern "C" {
    #[doc = " Get the current output of the 6V rail.\n\n @return The controller 6V rail output current value in Amps"]
    #[link_name = "\u{1}_ZN3frc15RobotController12GetCurrent6VEv"]
    pub fn frc_RobotController_GetCurrent6V() -> f64;
}
extern "C" {
    #[doc = " Get the enabled state of the 6V rail. The rail may be disabled due to a\n controller brownout, a short circuit on the rail, or controller\n over-voltage.\n\n @return The controller 6V rail enabled value. True for enabled."]
    #[link_name = "\u{1}_ZN3frc15RobotController12GetEnabled6VEv"]
    pub fn frc_RobotController_GetEnabled6V() -> bool;
}
extern "C" {
    #[doc = " Get the count of the total current faults on the 6V rail since the\n controller has booted.\n\n @return The number of faults."]
    #[link_name = "\u{1}_ZN3frc15RobotController15GetFaultCount6VEv"]
    pub fn frc_RobotController_GetFaultCount6V() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the current brownout voltage setting.\n\n @return The brownout voltage"]
    #[link_name = "\u{1}_ZN3frc15RobotController18GetBrownoutVoltageEv"]
    pub fn frc_RobotController_GetBrownoutVoltage() -> units_voltage_volt_t;
}
extern "C" {
    #[doc = " Set the voltage the roboRIO will brownout and disable all outputs.\n\n Note that this only does anything on the roboRIO 2.\n On the roboRIO it is a no-op.\n\n @param brownoutVoltage The brownout voltage"]
    #[link_name = "\u{1}_ZN3frc15RobotController18SetBrownoutVoltageEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx2ELx1EES5_S4_ILxn3ELx1EES4_ILx0ELx1EES4_ILxn1ELx1EES9_S9_S9_S9_EES9_S9_EEdNS1_12linear_scaleEEE"]
    pub fn frc_RobotController_SetBrownoutVoltage(brownoutVoltage: units_voltage_volt_t);
}
extern "C" {
    #[doc = " Get the current status of the CAN bus.\n\n @return The status of the CAN bus"]
    #[link_name = "\u{1}_ZN3frc15RobotController12GetCANStatusEv"]
    pub fn frc_RobotController_GetCANStatus() -> frc_CANStatus;
}
impl frc_RobotController {
    #[inline]
    pub unsafe fn GetFPGAVersion() -> ::std::os::raw::c_int {
        frc_RobotController_GetFPGAVersion()
    }
    #[inline]
    pub unsafe fn GetFPGARevision() -> i64 {
        frc_RobotController_GetFPGARevision()
    }
    #[inline]
    pub unsafe fn GetSerialNumber() -> std_string {
        frc_RobotController_GetSerialNumber()
    }
    #[inline]
    pub unsafe fn GetComments() -> std_string {
        frc_RobotController_GetComments()
    }
    #[inline]
    pub unsafe fn GetFPGATime() -> u64 {
        frc_RobotController_GetFPGATime()
    }
    #[inline]
    pub unsafe fn GetUserButton() -> bool {
        frc_RobotController_GetUserButton()
    }
    #[inline]
    pub unsafe fn GetBatteryVoltage() -> units_voltage_volt_t {
        frc_RobotController_GetBatteryVoltage()
    }
    #[inline]
    pub unsafe fn IsSysActive() -> bool {
        frc_RobotController_IsSysActive()
    }
    #[inline]
    pub unsafe fn IsBrownedOut() -> bool {
        frc_RobotController_IsBrownedOut()
    }
    #[inline]
    pub unsafe fn GetInputVoltage() -> f64 {
        frc_RobotController_GetInputVoltage()
    }
    #[inline]
    pub unsafe fn GetInputCurrent() -> f64 {
        frc_RobotController_GetInputCurrent()
    }
    #[inline]
    pub unsafe fn GetVoltage3V3() -> f64 {
        frc_RobotController_GetVoltage3V3()
    }
    #[inline]
    pub unsafe fn GetCurrent3V3() -> f64 {
        frc_RobotController_GetCurrent3V3()
    }
    #[inline]
    pub unsafe fn GetEnabled3V3() -> bool {
        frc_RobotController_GetEnabled3V3()
    }
    #[inline]
    pub unsafe fn GetFaultCount3V3() -> ::std::os::raw::c_int {
        frc_RobotController_GetFaultCount3V3()
    }
    #[inline]
    pub unsafe fn GetVoltage5V() -> f64 {
        frc_RobotController_GetVoltage5V()
    }
    #[inline]
    pub unsafe fn GetCurrent5V() -> f64 {
        frc_RobotController_GetCurrent5V()
    }
    #[inline]
    pub unsafe fn GetEnabled5V() -> bool {
        frc_RobotController_GetEnabled5V()
    }
    #[inline]
    pub unsafe fn GetFaultCount5V() -> ::std::os::raw::c_int {
        frc_RobotController_GetFaultCount5V()
    }
    #[inline]
    pub unsafe fn GetVoltage6V() -> f64 {
        frc_RobotController_GetVoltage6V()
    }
    #[inline]
    pub unsafe fn GetCurrent6V() -> f64 {
        frc_RobotController_GetCurrent6V()
    }
    #[inline]
    pub unsafe fn GetEnabled6V() -> bool {
        frc_RobotController_GetEnabled6V()
    }
    #[inline]
    pub unsafe fn GetFaultCount6V() -> ::std::os::raw::c_int {
        frc_RobotController_GetFaultCount6V()
    }
    #[inline]
    pub unsafe fn GetBrownoutVoltage() -> units_voltage_volt_t {
        frc_RobotController_GetBrownoutVoltage()
    }
    #[inline]
    pub unsafe fn SetBrownoutVoltage(brownoutVoltage: units_voltage_volt_t) {
        frc_RobotController_SetBrownoutVoltage(brownoutVoltage)
    }
    #[inline]
    pub unsafe fn GetCANStatus() -> frc_CANStatus {
        frc_RobotController_GetCANStatus()
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_RobotState {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_frc_RobotState() {
    assert_eq!(
        ::std::mem::size_of::<frc_RobotState>(),
        1usize,
        concat!("Size of: ", stringify!(frc_RobotState))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_RobotState>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_RobotState))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10RobotState10IsDisabledEv"]
    pub fn frc_RobotState_IsDisabled() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10RobotState9IsEnabledEv"]
    pub fn frc_RobotState_IsEnabled() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10RobotState10IsEStoppedEv"]
    pub fn frc_RobotState_IsEStopped() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10RobotState8IsTeleopEv"]
    pub fn frc_RobotState_IsTeleop() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10RobotState12IsAutonomousEv"]
    pub fn frc_RobotState_IsAutonomous() -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10RobotState6IsTestEv"]
    pub fn frc_RobotState_IsTest() -> bool;
}
impl frc_RobotState {
    #[inline]
    pub unsafe fn IsDisabled() -> bool {
        frc_RobotState_IsDisabled()
    }
    #[inline]
    pub unsafe fn IsEnabled() -> bool {
        frc_RobotState_IsEnabled()
    }
    #[inline]
    pub unsafe fn IsEStopped() -> bool {
        frc_RobotState_IsEStopped()
    }
    #[inline]
    pub unsafe fn IsTeleop() -> bool {
        frc_RobotState_IsTeleop()
    }
    #[inline]
    pub unsafe fn IsAutonomous() -> bool {
        frc_RobotState_IsAutonomous()
    }
    #[inline]
    pub unsafe fn IsTest() -> bool {
        frc_RobotState_IsTest()
    }
}
#[doc = " A class for keeping track of how much time it takes for different\n parts of code to execute. This class uses RAII, meaning you simply\n need to create an instance at the top of the block you are timing. After the\n block finishes execution (i.e. when the ScopedTracer instance gets\n destroyed), the epoch is printed to the provided raw_ostream."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_ScopedTracer {
    pub m_tracer: frc_Tracer,
    pub m_name: std_string,
    pub m_os: *mut wpi_raw_ostream,
}
#[test]
fn bindgen_test_layout_frc_ScopedTracer() {
    const UNINIT: ::std::mem::MaybeUninit<frc_ScopedTracer> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_ScopedTracer>(),
        72usize,
        concat!("Size of: ", stringify!(frc_ScopedTracer))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ScopedTracer>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_ScopedTracer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tracer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ScopedTracer),
            "::",
            stringify!(m_tracer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_name) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ScopedTracer),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_os) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ScopedTracer),
            "::",
            stringify!(m_os)
        )
    );
}
extern "C" {
    #[doc = " Constructs a ScopedTracer instance.\n\n @param name The name of the epoch.\n @param os A reference to the raw_ostream to print data to."]
    #[link_name = "\u{1}_ZN3frc12ScopedTracerC1ESt17basic_string_viewIcSt11char_traitsIcEERN3wpi11raw_ostreamE"]
    pub fn frc_ScopedTracer_ScopedTracer(
        this: *mut frc_ScopedTracer,
        name: std_string_view,
        os: *mut wpi_raw_ostream,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12ScopedTracerD1Ev"]
    pub fn frc_ScopedTracer_ScopedTracer_destructor(this: *mut frc_ScopedTracer);
}
impl frc_ScopedTracer {
    #[inline]
    pub unsafe fn new(name: std_string_view, os: *mut wpi_raw_ostream) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_ScopedTracer_ScopedTracer(__bindgen_tmp.as_mut_ptr(), name, os);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        frc_ScopedTracer_ScopedTracer_destructor(self)
    }
}
#[doc = " Driver for the RS-232 serial port on the roboRIO.\n\n The current implementation uses the VISA formatted I/O mode.  This means that\n all traffic goes through the fomatted buffers.  This allows the intermingled\n use of Printf(), Scanf(), and the raw buffer accessors Read() and Write().\n\n More information can be found in the NI-VISA User Manual here:\n   http://www.ni.com/pdf/manuals/370423a.pdf\n and the NI-VISA Programmer's Reference Manual here:\n   http://www.ni.com/pdf/manuals/370132c.pdf"]
#[repr(C)]
#[derive(Debug)]
pub struct frc_SerialPort {
    pub m_portHandle: u32,
}
pub const frc_SerialPort_Parity_kParity_None: frc_SerialPort_Parity = 0;
pub const frc_SerialPort_Parity_kParity_Odd: frc_SerialPort_Parity = 1;
pub const frc_SerialPort_Parity_kParity_Even: frc_SerialPort_Parity = 2;
pub const frc_SerialPort_Parity_kParity_Mark: frc_SerialPort_Parity = 3;
pub const frc_SerialPort_Parity_kParity_Space: frc_SerialPort_Parity = 4;
pub type frc_SerialPort_Parity = ::std::os::raw::c_uint;
pub const frc_SerialPort_StopBits_kStopBits_One: frc_SerialPort_StopBits = 10;
pub const frc_SerialPort_StopBits_kStopBits_OnePointFive: frc_SerialPort_StopBits = 15;
pub const frc_SerialPort_StopBits_kStopBits_Two: frc_SerialPort_StopBits = 20;
pub type frc_SerialPort_StopBits = ::std::os::raw::c_uint;
pub const frc_SerialPort_FlowControl_kFlowControl_None: frc_SerialPort_FlowControl = 0;
pub const frc_SerialPort_FlowControl_kFlowControl_XonXoff: frc_SerialPort_FlowControl = 1;
pub const frc_SerialPort_FlowControl_kFlowControl_RtsCts: frc_SerialPort_FlowControl = 2;
pub const frc_SerialPort_FlowControl_kFlowControl_DtrDsr: frc_SerialPort_FlowControl = 4;
pub type frc_SerialPort_FlowControl = ::std::os::raw::c_uint;
pub const frc_SerialPort_WriteBufferMode_kFlushOnAccess: frc_SerialPort_WriteBufferMode = 1;
pub const frc_SerialPort_WriteBufferMode_kFlushWhenFull: frc_SerialPort_WriteBufferMode = 2;
pub type frc_SerialPort_WriteBufferMode = ::std::os::raw::c_uint;
pub const frc_SerialPort_Port_kOnboard: frc_SerialPort_Port = 0;
pub const frc_SerialPort_Port_kMXP: frc_SerialPort_Port = 1;
pub const frc_SerialPort_Port_kUSB: frc_SerialPort_Port = 2;
pub const frc_SerialPort_Port_kUSB1: frc_SerialPort_Port = 2;
pub const frc_SerialPort_Port_kUSB2: frc_SerialPort_Port = 3;
pub type frc_SerialPort_Port = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_frc_SerialPort() {
    const UNINIT: ::std::mem::MaybeUninit<frc_SerialPort> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_SerialPort>(),
        4usize,
        concat!("Size of: ", stringify!(frc_SerialPort))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_SerialPort>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_SerialPort))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_portHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SerialPort),
            "::",
            stringify!(m_portHandle)
        )
    );
}
extern "C" {
    #[doc = " Set the type of flow control to enable on this port.\n\n By default, flow control is disabled."]
    #[link_name = "\u{1}_ZN3frc10SerialPort14SetFlowControlENS0_11FlowControlE"]
    pub fn frc_SerialPort_SetFlowControl(
        this: *mut frc_SerialPort,
        flowControl: frc_SerialPort_FlowControl,
    );
}
extern "C" {
    #[doc = " Enable termination and specify the termination character.\n\n Termination is currently only implemented for receive.\n When the the terminator is received, the Read() or Scanf() will return\n fewer bytes than requested, stopping after the terminator.\n\n @param terminator The character to use for termination."]
    #[link_name = "\u{1}_ZN3frc10SerialPort17EnableTerminationEc"]
    pub fn frc_SerialPort_EnableTermination(
        this: *mut frc_SerialPort,
        terminator: ::std::os::raw::c_char,
    );
}
extern "C" {
    #[doc = " Disable termination behavior."]
    #[link_name = "\u{1}_ZN3frc10SerialPort18DisableTerminationEv"]
    pub fn frc_SerialPort_DisableTermination(this: *mut frc_SerialPort);
}
extern "C" {
    #[doc = " Get the number of bytes currently available to read from the serial port.\n\n @return The number of bytes available to read"]
    #[link_name = "\u{1}_ZN3frc10SerialPort16GetBytesReceivedEv"]
    pub fn frc_SerialPort_GetBytesReceived(this: *mut frc_SerialPort) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Read raw bytes out of the buffer.\n\n @param buffer Pointer to the buffer to store the bytes in.\n @param count  The maximum number of bytes to read.\n @return The number of bytes actually read into the buffer."]
    #[link_name = "\u{1}_ZN3frc10SerialPort4ReadEPci"]
    pub fn frc_SerialPort_Read(
        this: *mut frc_SerialPort,
        buffer: *mut ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write raw bytes to the buffer.\n\n @param buffer Pointer to the buffer to read the bytes from.\n @param count  The maximum number of bytes to write.\n @return The number of bytes actually written into the port."]
    #[link_name = "\u{1}_ZN3frc10SerialPort5WriteEPKci"]
    pub fn frc_SerialPort_Write(
        this: *mut frc_SerialPort,
        buffer: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write raw bytes to the buffer.\n\n Use Write({data, len}) to get a buffer that is shorter than the length of\n the string.\n\n @param buffer the buffer to read the bytes from.\n @return The number of bytes actually written into the port."]
    #[link_name = "\u{1}_ZN3frc10SerialPort5WriteESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_SerialPort_Write1(
        this: *mut frc_SerialPort,
        buffer: std_string_view,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configure the timeout of the serial port.\n\n This defines the timeout for transactions with the hardware.\n It will affect reads and very large writes.\n\n @param timeout The time to wait for I/O."]
    #[link_name = "\u{1}_ZN3frc10SerialPort10SetTimeoutEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_SerialPort_SetTimeout(this: *mut frc_SerialPort, timeout: units_time_second_t);
}
extern "C" {
    #[doc = " Specify the size of the input buffer.\n\n Specify the amount of data that can be stored before data\n from the device is returned to Read or Scanf.  If you want\n data that is received to be returned immediately, set this to 1.\n\n It the buffer is not filled before the read timeout expires, all\n data that has been received so far will be returned.\n\n @param size The read buffer size."]
    #[link_name = "\u{1}_ZN3frc10SerialPort17SetReadBufferSizeEi"]
    pub fn frc_SerialPort_SetReadBufferSize(this: *mut frc_SerialPort, size: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Specify the size of the output buffer.\n\n Specify the amount of data that can be stored before being\n transmitted to the device.\n\n @param size The write buffer size."]
    #[link_name = "\u{1}_ZN3frc10SerialPort18SetWriteBufferSizeEi"]
    pub fn frc_SerialPort_SetWriteBufferSize(
        this: *mut frc_SerialPort,
        size: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Specify the flushing behavior of the output buffer.\n\n When set to kFlushOnAccess, data is synchronously written to the serial\n port after each call to either Printf() or Write().\n\n When set to kFlushWhenFull, data will only be written to the serial port\n when the buffer is full or when Flush() is called.\n\n @param mode The write buffer mode."]
    #[link_name = "\u{1}_ZN3frc10SerialPort18SetWriteBufferModeENS0_15WriteBufferModeE"]
    pub fn frc_SerialPort_SetWriteBufferMode(
        this: *mut frc_SerialPort,
        mode: frc_SerialPort_WriteBufferMode,
    );
}
extern "C" {
    #[doc = " Force the output buffer to be written to the port.\n\n This is used when SetWriteBufferMode() is set to kFlushWhenFull to force a\n flush before the buffer is full."]
    #[link_name = "\u{1}_ZN3frc10SerialPort5FlushEv"]
    pub fn frc_SerialPort_Flush(this: *mut frc_SerialPort);
}
extern "C" {
    #[doc = " Reset the serial port driver to a known state.\n\n Empty the transmit and receive buffers in the device and formatted I/O."]
    #[link_name = "\u{1}_ZN3frc10SerialPort5ResetEv"]
    pub fn frc_SerialPort_Reset(this: *mut frc_SerialPort);
}
extern "C" {
    #[doc = " Create an instance of a Serial Port class.\n\n @param baudRate The baud rate to configure the serial port.\n @param port     The physical port to use\n @param dataBits The number of data bits per transfer.  Valid values are\n                 between 5 and 8 bits.\n @param parity   Select the type of parity checking to use.\n @param stopBits The number of stop bits to use as defined by the enum\n                 StopBits."]
    #[link_name = "\u{1}_ZN3frc10SerialPortC1EiNS0_4PortEiNS0_6ParityENS0_8StopBitsE"]
    pub fn frc_SerialPort_SerialPort(
        this: *mut frc_SerialPort,
        baudRate: ::std::os::raw::c_int,
        port: frc_SerialPort_Port,
        dataBits: ::std::os::raw::c_int,
        parity: frc_SerialPort_Parity,
        stopBits: frc_SerialPort_StopBits,
    );
}
extern "C" {
    #[doc = " Create an instance of a Serial Port class.\n\n Prefer to use the constructor that doesn't take a port name, but in some\n cases the automatic detection might not work correctly.\n\n @param baudRate The baud rate to configure the serial port.\n @param port     The physical port to use\n @param portName The direct port name to use\n @param dataBits The number of data bits per transfer.  Valid values are\n                 between 5 and 8 bits.\n @param parity   Select the type of parity checking to use.\n @param stopBits The number of stop bits to use as defined by the enum\n                 StopBits."]
    #[link_name = "\u{1}_ZN3frc10SerialPortC1EiSt17basic_string_viewIcSt11char_traitsIcEENS0_4PortEiNS0_6ParityENS0_8StopBitsE"]
    pub fn frc_SerialPort_SerialPort1(
        this: *mut frc_SerialPort,
        baudRate: ::std::os::raw::c_int,
        portName: std_string_view,
        port: frc_SerialPort_Port,
        dataBits: ::std::os::raw::c_int,
        parity: frc_SerialPort_Parity,
        stopBits: frc_SerialPort_StopBits,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10SerialPortD1Ev"]
    pub fn frc_SerialPort_SerialPort_destructor(this: *mut frc_SerialPort);
}
impl frc_SerialPort {
    #[inline]
    pub unsafe fn SetFlowControl(&mut self, flowControl: frc_SerialPort_FlowControl) {
        frc_SerialPort_SetFlowControl(self, flowControl)
    }
    #[inline]
    pub unsafe fn EnableTermination(&mut self, terminator: ::std::os::raw::c_char) {
        frc_SerialPort_EnableTermination(self, terminator)
    }
    #[inline]
    pub unsafe fn DisableTermination(&mut self) {
        frc_SerialPort_DisableTermination(self)
    }
    #[inline]
    pub unsafe fn GetBytesReceived(&mut self) -> ::std::os::raw::c_int {
        frc_SerialPort_GetBytesReceived(self)
    }
    #[inline]
    pub unsafe fn Read(
        &mut self,
        buffer: *mut ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        frc_SerialPort_Read(self, buffer, count)
    }
    #[inline]
    pub unsafe fn Write(
        &mut self,
        buffer: *const ::std::os::raw::c_char,
        count: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        frc_SerialPort_Write(self, buffer, count)
    }
    #[inline]
    pub unsafe fn Write1(&mut self, buffer: std_string_view) -> ::std::os::raw::c_int {
        frc_SerialPort_Write1(self, buffer)
    }
    #[inline]
    pub unsafe fn SetTimeout(&mut self, timeout: units_time_second_t) {
        frc_SerialPort_SetTimeout(self, timeout)
    }
    #[inline]
    pub unsafe fn SetReadBufferSize(&mut self, size: ::std::os::raw::c_int) {
        frc_SerialPort_SetReadBufferSize(self, size)
    }
    #[inline]
    pub unsafe fn SetWriteBufferSize(&mut self, size: ::std::os::raw::c_int) {
        frc_SerialPort_SetWriteBufferSize(self, size)
    }
    #[inline]
    pub unsafe fn SetWriteBufferMode(&mut self, mode: frc_SerialPort_WriteBufferMode) {
        frc_SerialPort_SetWriteBufferMode(self, mode)
    }
    #[inline]
    pub unsafe fn Flush(&mut self) {
        frc_SerialPort_Flush(self)
    }
    #[inline]
    pub unsafe fn Reset(&mut self) {
        frc_SerialPort_Reset(self)
    }
    #[inline]
    pub unsafe fn new(
        baudRate: ::std::os::raw::c_int,
        port: frc_SerialPort_Port,
        dataBits: ::std::os::raw::c_int,
        parity: frc_SerialPort_Parity,
        stopBits: frc_SerialPort_StopBits,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_SerialPort_SerialPort(
            __bindgen_tmp.as_mut_ptr(),
            baudRate,
            port,
            dataBits,
            parity,
            stopBits,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        baudRate: ::std::os::raw::c_int,
        portName: std_string_view,
        port: frc_SerialPort_Port,
        dataBits: ::std::os::raw::c_int,
        parity: frc_SerialPort_Parity,
        stopBits: frc_SerialPort_StopBits,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_SerialPort_SerialPort1(
            __bindgen_tmp.as_mut_ptr(),
            baudRate,
            portName,
            port,
            dataBits,
            parity,
            stopBits,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        frc_SerialPort_SerialPort_destructor(self)
    }
}
#[doc = " Standard hobby style servo.\n\n The range parameters default to the appropriate values for the Hitec HS-322HD\n servo provided in the FIRST Kit of Parts in 2008."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Servo {
    pub _base: frc_PWM,
}
pub const frc_Servo_kMaxServoAngle: f64 = 180.0;
pub const frc_Servo_kMinServoAngle: f64 = 0.0;
pub const frc_Servo_kDefaultMaxServoPWM: f64 = 2.4;
pub const frc_Servo_kDefaultMinServoPWM: f64 = 0.6;
#[test]
fn bindgen_test_layout_frc_Servo() {
    assert_eq!(
        ::std::mem::size_of::<frc_Servo>(),
        12usize,
        concat!("Size of: ", stringify!(frc_Servo))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Servo>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_Servo))
    );
}
extern "C" {
    #[doc = " Set the servo position.\n\n Servo values range from 0.0 to 1.0 corresponding to the range of full left\n to full right.\n\n @param value Position from 0.0 to 1.0."]
    #[link_name = "\u{1}_ZN3frc5Servo3SetEd"]
    pub fn frc_Servo_Set(this: *mut frc_Servo, value: f64);
}
extern "C" {
    #[doc = " Set the servo to offline.\n\n Set the servo raw value to 0 (undriven)"]
    #[link_name = "\u{1}_ZN3frc5Servo10SetOfflineEv"]
    pub fn frc_Servo_SetOffline(this: *mut frc_Servo);
}
extern "C" {
    #[doc = " Get the servo position.\n\n Servo values range from 0.0 to 1.0 corresponding to the range of full left\n to full right. This returns the commanded position, not the position that\n the servo is actually at, as the servo does not report its own position.\n\n @return Position from 0.0 to 1.0."]
    #[link_name = "\u{1}_ZNK3frc5Servo3GetEv"]
    pub fn frc_Servo_Get(this: *const frc_Servo) -> f64;
}
extern "C" {
    #[doc = " Set the servo angle.\n\n The angles are based on the HS-322HD Servo, and have a range of 0 to 180\n degrees.\n\n Servo angles that are out of the supported range of the servo simply\n \"saturate\" in that direction. In other words, if the servo has a range of\n (X degrees to Y degrees) than angles of less than X result in an angle of\n X being set and angles of more than Y degrees result in an angle of Y being\n set.\n\n @param angle The angle in degrees to set the servo."]
    #[link_name = "\u{1}_ZN3frc5Servo8SetAngleEd"]
    pub fn frc_Servo_SetAngle(this: *mut frc_Servo, angle: f64);
}
extern "C" {
    #[doc = " Get the servo angle.\n\n This returns the commanded angle, not the angle that the servo is actually\n at, as the servo does not report its own angle.\n\n @return The angle in degrees to which the servo is set."]
    #[link_name = "\u{1}_ZNK3frc5Servo8GetAngleEv"]
    pub fn frc_Servo_GetAngle(this: *const frc_Servo) -> f64;
}
extern "C" {
    #[doc = " Get the maximum angle of the servo.\n\n @return The maximum angle of the servo in degrees."]
    #[link_name = "\u{1}_ZNK3frc5Servo11GetMaxAngleEv"]
    pub fn frc_Servo_GetMaxAngle(this: *const frc_Servo) -> f64;
}
extern "C" {
    #[doc = " Get the minimum angle of the servo.\n\n @return The minimum angle of the servo in degrees."]
    #[link_name = "\u{1}_ZNK3frc5Servo11GetMinAngleEv"]
    pub fn frc_Servo_GetMinAngle(this: *const frc_Servo) -> f64;
}
extern "C" {
    #[doc = " @param channel The PWM channel to which the servo is attached. 0-9 are\n                on-board, 10-19 are on the MXP port"]
    #[link_name = "\u{1}_ZN3frc5ServoC1Ei"]
    pub fn frc_Servo_Servo(this: *mut frc_Servo, channel: ::std::os::raw::c_int);
}
impl frc_Servo {
    #[inline]
    pub unsafe fn Set(&mut self, value: f64) {
        frc_Servo_Set(self, value)
    }
    #[inline]
    pub unsafe fn SetOffline(&mut self) {
        frc_Servo_SetOffline(self)
    }
    #[inline]
    pub unsafe fn Get(&self) -> f64 {
        frc_Servo_Get(self)
    }
    #[inline]
    pub unsafe fn SetAngle(&mut self, angle: f64) {
        frc_Servo_SetAngle(self, angle)
    }
    #[inline]
    pub unsafe fn GetAngle(&self) -> f64 {
        frc_Servo_GetAngle(self)
    }
    #[inline]
    pub unsafe fn GetMaxAngle(&self) -> f64 {
        frc_Servo_GetMaxAngle(self)
    }
    #[inline]
    pub unsafe fn GetMinAngle(&self) -> f64 {
        frc_Servo_GetMinAngle(self)
    }
    #[inline]
    pub unsafe fn new(channel: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Servo_Servo(__bindgen_tmp.as_mut_ptr(), channel);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc5Servo12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_Servo_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Solenoid class for running high voltage Digital Output on a pneumatics\n module.\n\n The Solenoid class is typically used for pneumatics solenoids, but could be\n used for any device within the current spec of the module."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Solenoid {
    pub _base: wpi_Sendable,
    pub m_module: [u32; 2usize],
    pub m_mask: ::std::os::raw::c_int,
    pub m_channel: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_frc_Solenoid() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Solenoid> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Solenoid>(),
        20usize,
        concat!("Size of: ", stringify!(frc_Solenoid))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Solenoid>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_Solenoid))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_module) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Solenoid),
            "::",
            stringify!(m_module)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Solenoid),
            "::",
            stringify!(m_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_channel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Solenoid),
            "::",
            stringify!(m_channel)
        )
    );
}
extern "C" {
    #[doc = " Toggle the value of the solenoid.\n\n If the solenoid is set to on, it'll be turned off. If the solenoid is set\n to off, it'll be turned on."]
    #[link_name = "\u{1}_ZN3frc8Solenoid6ToggleEv"]
    pub fn frc_Solenoid_Toggle(this: *mut frc_Solenoid);
}
extern "C" {
    #[doc = " Get the channel this solenoid is connected to."]
    #[link_name = "\u{1}_ZNK3frc8Solenoid10GetChannelEv"]
    pub fn frc_Solenoid_GetChannel(this: *const frc_Solenoid) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if solenoid is Disabled.\n\n If a solenoid is shorted, it is added to the DisabledList and\n disabled until power cycle, or until faults are cleared.\n\n @see ClearAllPCMStickyFaults()\n\n @return If solenoid is disabled due to short."]
    #[link_name = "\u{1}_ZNK3frc8Solenoid10IsDisabledEv"]
    pub fn frc_Solenoid_IsDisabled(this: *const frc_Solenoid) -> bool;
}
extern "C" {
    #[doc = " Set the pulse duration in the PCM. This is used in conjunction with\n the startPulse method to allow the PCM to control the timing of a pulse.\n The timing can be controlled in 0.01 second increments.\n\n @param duration The duration of the pulse, from 0.01 to 2.55 seconds.\n\n @see startPulse()"]
    #[link_name = "\u{1}_ZN3frc8Solenoid16SetPulseDurationEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_Solenoid_SetPulseDuration(this: *mut frc_Solenoid, duration: units_time_second_t);
}
extern "C" {
    #[doc = " %Trigger the PCM to generate a pulse of the duration set in\n setPulseDuration.\n\n @see setPulseDuration()"]
    #[link_name = "\u{1}_ZN3frc8Solenoid10StartPulseEv"]
    pub fn frc_Solenoid_StartPulse(this: *mut frc_Solenoid);
}
extern "C" {
    #[doc = " Constructs a solenoid for a specified module and type.\n\n @param module The module ID to use.\n @param moduleType The module type to use.\n @param channel The channel the solenoid is on."]
    #[link_name = "\u{1}_ZN3frc8SolenoidC1EiNS_20PneumaticsModuleTypeEi"]
    pub fn frc_Solenoid_Solenoid(
        this: *mut frc_Solenoid,
        module: ::std::os::raw::c_int,
        moduleType: frc_PneumaticsModuleType,
        channel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Constructs a solenoid for a default module and specified type.\n\n @param moduleType The module type to use.\n @param channel The channel the solenoid is on."]
    #[link_name = "\u{1}_ZN3frc8SolenoidC1ENS_20PneumaticsModuleTypeEi"]
    pub fn frc_Solenoid_Solenoid1(
        this: *mut frc_Solenoid,
        moduleType: frc_PneumaticsModuleType,
        channel: ::std::os::raw::c_int,
    );
}
impl frc_Solenoid {
    #[inline]
    pub unsafe fn Toggle(&mut self) {
        frc_Solenoid_Toggle(self)
    }
    #[inline]
    pub unsafe fn GetChannel(&self) -> ::std::os::raw::c_int {
        frc_Solenoid_GetChannel(self)
    }
    #[inline]
    pub unsafe fn IsDisabled(&self) -> bool {
        frc_Solenoid_IsDisabled(self)
    }
    #[inline]
    pub unsafe fn SetPulseDuration(&mut self, duration: units_time_second_t) {
        frc_Solenoid_SetPulseDuration(self, duration)
    }
    #[inline]
    pub unsafe fn StartPulse(&mut self) {
        frc_Solenoid_StartPulse(self)
    }
    #[inline]
    pub unsafe fn new(
        module: ::std::os::raw::c_int,
        moduleType: frc_PneumaticsModuleType,
        channel: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Solenoid_Solenoid(__bindgen_tmp.as_mut_ptr(), module, moduleType, channel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        moduleType: frc_PneumaticsModuleType,
        channel: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Solenoid_Solenoid1(__bindgen_tmp.as_mut_ptr(), moduleType, channel);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc8SolenoidD1Ev"]
    pub fn frc_Solenoid_Solenoid_destructor(this: *mut frc_Solenoid);
}
extern "C" {
    #[doc = " Set the value of a solenoid.\n\n @param on Turn the solenoid output off or on."]
    #[link_name = "\u{1}_ZN3frc8Solenoid3SetEb"]
    pub fn frc_Solenoid_Set(this: *mut ::std::os::raw::c_void, on: bool);
}
extern "C" {
    #[doc = " Read the current value of the solenoid.\n\n @return The current value of the solenoid."]
    #[link_name = "\u{1}_ZNK3frc8Solenoid3GetEv"]
    pub fn frc_Solenoid_Get(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc8Solenoid12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_Solenoid_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
extern "C" {
    #[doc = " Get the thread priority for the specified thread.\n\n @param thread     Reference to the thread to get the priority for.\n @param isRealTime Set to true if thread is real-time, otherwise false.\n @return           The current thread priority. For real-time, this is 1-99\n                   with 99 being highest. For non-real-time, this is 0. See\n                   \"man 7 sched\" for details."]
    #[link_name = "\u{1}_ZN3frc17GetThreadPriorityERSt6threadPb"]
    pub fn frc_GetThreadPriority(
        thread: *mut std_thread,
        isRealTime: *mut bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the thread priority for the current thread.\n\n @param isRealTime Set to true if thread is real-time, otherwise false.\n @return           The current thread priority. For real-time, this is 1-99\n                   with 99 being highest. For non-real-time, this is 0. See\n                   \"man 7 sched\" for details."]
    #[link_name = "\u{1}_ZN3frc24GetCurrentThreadPriorityEPb"]
    pub fn frc_GetCurrentThreadPriority(isRealTime: *mut bool) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Sets the thread priority for the specified thread.\n\n @param thread   Reference to the thread to set the priority of.\n @param realTime Set to true to set a real-time priority, false for standard\n                 priority.\n @param priority Priority to set the thread to. For real-time, this is 1-99\n                 with 99 being highest. For non-real-time, this is forced to\n                 0. See \"man 7 sched\" for more details.\n @return         True on success."]
    #[link_name = "\u{1}_ZN3frc17SetThreadPriorityERSt6threadbi"]
    pub fn frc_SetThreadPriority(
        thread: *mut std_thread,
        realTime: bool,
        priority: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Sets the thread priority for the current thread.\n\n @param realTime Set to true to set a real-time priority, false for standard\n                 priority.\n @param priority Priority to set the thread to. For real-time, this is 1-99\n                 with 99 being highest. For non-real-time, this is forced to\n                 0. See \"man 7 sched\" for more details.\n @return         True on success."]
    #[link_name = "\u{1}_ZN3frc24SetCurrentThreadPriorityEbi"]
    pub fn frc_SetCurrentThreadPriority(realTime: bool, priority: ::std::os::raw::c_int) -> bool;
}
#[doc = " TimedRobot implements the IterativeRobotBase robot program framework.\n\n The TimedRobot class is intended to be subclassed by a user creating a\n robot program.\n\n Periodic() functions from the base class are called on an interval by a\n Notifier instance."]
#[repr(C)]
pub struct frc_TimedRobot {
    pub _base: frc_IterativeRobotBase,
    pub m_notifier: u32,
    pub m_startTime: units_time_second_t,
    pub m_callbacks: [u32; 4usize],
}
#[repr(C)]
pub struct frc_TimedRobot_Callback {
    pub func: [u32; 4usize],
    pub period: units_time_second_t,
    pub expirationTime: units_time_second_t,
}
#[test]
fn bindgen_test_layout_frc_TimedRobot_Callback() {
    const UNINIT: ::std::mem::MaybeUninit<frc_TimedRobot_Callback> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_TimedRobot_Callback>(),
        32usize,
        concat!("Size of: ", stringify!(frc_TimedRobot_Callback))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_TimedRobot_Callback>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_TimedRobot_Callback))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_TimedRobot_Callback),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_TimedRobot_Callback),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expirationTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_TimedRobot_Callback),
            "::",
            stringify!(expirationTime)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10TimedRobot14kDefaultPeriodE"]
    pub static frc_TimedRobot_kDefaultPeriod: units_time_millisecond_t;
}
#[test]
fn bindgen_test_layout_frc_TimedRobot() {
    const UNINIT: ::std::mem::MaybeUninit<frc_TimedRobot> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_TimedRobot>(),
        144usize,
        concat!("Size of: ", stringify!(frc_TimedRobot))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_TimedRobot>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_TimedRobot))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_notifier) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_TimedRobot),
            "::",
            stringify!(m_notifier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_startTime) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_TimedRobot),
            "::",
            stringify!(m_startTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_callbacks) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_TimedRobot),
            "::",
            stringify!(m_callbacks)
        )
    );
}
extern "C" {
    #[doc = " Add a callback to run at a specific period with a starting time offset.\n\n This is scheduled on TimedRobot's Notifier, so TimedRobot and the callback\n run synchronously. Interactions between them are thread-safe.\n\n @param callback The callback to run.\n @param period   The period at which to run the callback.\n @param offset   The offset from the common starting time. This is useful\n                 for scheduling a callback in a different timeslot relative\n                 to TimedRobot."]
    #[link_name = "\u{1}_ZN3frc10TimedRobot11AddPeriodicESt8functionIFvvEEN5units6unit_tINS4_4unitISt5ratioILx1ELx1EENS4_9base_unitIS7_ILx0ELx1EESA_S8_SA_SA_SA_SA_SA_SA_EESA_SA_EEdNS4_12linear_scaleEEESE_"]
    pub fn frc_TimedRobot_AddPeriodic(
        this: *mut frc_TimedRobot,
        callback: [u32; 4usize],
        period: units_time_second_t,
        offset: units_time_second_t,
    );
}
extern "C" {
    #[doc = " Constructor for TimedRobot.\n\n @param period Period."]
    #[link_name = "\u{1}_ZN3frc10TimedRobotC1EN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEE"]
    pub fn frc_TimedRobot_TimedRobot(this: *mut frc_TimedRobot, period: units_time_second_t);
}
impl frc_TimedRobot {
    #[inline]
    pub unsafe fn AddPeriodic(
        &mut self,
        callback: [u32; 4usize],
        period: units_time_second_t,
        offset: units_time_second_t,
    ) {
        frc_TimedRobot_AddPeriodic(self, callback, period, offset)
    }
    #[inline]
    pub unsafe fn new(period: units_time_second_t) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_TimedRobot_TimedRobot(__bindgen_tmp.as_mut_ptr(), period);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[doc = " Provide an alternate \"main loop\" via StartCompetition()."]
    #[link_name = "\u{1}_ZN3frc10TimedRobot16StartCompetitionEv"]
    pub fn frc_TimedRobot_StartCompetition(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Ends the main loop in StartCompetition()."]
    #[link_name = "\u{1}_ZN3frc10TimedRobot14EndCompetitionEv"]
    pub fn frc_TimedRobot_EndCompetition(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10TimedRobotD1Ev"]
    pub fn frc_TimedRobot_TimedRobot_destructor(this: *mut frc_TimedRobot);
}
#[doc = " TimesliceRobot extends the TimedRobot robot program framework to provide\n timeslice scheduling of periodic functions.\n\n The TimesliceRobot class is intended to be subclassed by a user creating a\n robot program.\n\n This class schedules robot operations serially in a timeslice format.\n TimedRobot's periodic functions are the first in the timeslice table with 0\n ms offset and 20 ms period. You can schedule additional controller periodic\n functions at a shorter period (5 ms by default). You give each one a\n timeslice duration, then they're run sequentially. The main benefit of this\n approach is consistent starting times for each controller periodic, which can\n make odometry and estimators more accurate and controller outputs change more\n consistently.\n\n Here's an example of measured subsystem durations and their timeslice\n allocations:\n\n <table>\n   <tr>\n     <td><b>Subsystem</b></td>\n     <td><b>Duration (ms)</b></td>\n     <td><b>Allocation (ms)</b></td>\n   </tr>\n   <tr>\n     <td><b>Total</b></td>\n     <td>5.0</td>\n     <td>5.0</td>\n   </tr>\n   <tr>\n     <td>TimedRobot</td>\n     <td>?</td>\n     <td>2.0</td>\n   </tr>\n   <tr>\n     <td>Drivetrain</td>\n     <td>1.32</td>\n     <td>1.5</td>\n   </tr>\n   <tr>\n     <td>Flywheel</td>\n     <td>0.6</td>\n     <td>0.7</td>\n   </tr>\n   <tr>\n     <td>Turret</td>\n     <td>0.6</td>\n     <td>0.8</td>\n   </tr>\n   <tr>\n     <td><b>Free</b></td>\n     <td>0.0</td>\n     <td>N/A</td>\n   </tr>\n </table>\n\n Since TimedRobot periodic functions only run every 20ms, that leaves a 2 ms\n empty spot in the allocation table for three of the four 5 ms cycles\n comprising 20 ms. That's OK because the OS needs time to do other things.\n\n If the robot periodic functions and the controller periodic functions have a\n lot of scheduling jitter that cause them to occasionally overlap with later\n timeslices, consider giving the main robot thread a real-time priority using\n frc::SetCurrentThreadPriority(). An RT priority of 15 is a reasonable choice.\n\n If you do enable RT though, <i>make sure your periodic functions do not\n block</i>. If they do, the operating system will lock up, and you'll have to\n boot the roboRIO into safe mode and delete the robot program to recover."]
#[repr(C)]
pub struct frc_TimesliceRobot {
    pub _base: frc_TimedRobot,
    pub m_nextOffset: units_time_second_t,
    pub m_controllerPeriod: units_time_second_t,
}
#[test]
fn bindgen_test_layout_frc_TimesliceRobot() {
    const UNINIT: ::std::mem::MaybeUninit<frc_TimesliceRobot> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_TimesliceRobot>(),
        160usize,
        concat!("Size of: ", stringify!(frc_TimesliceRobot))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_TimesliceRobot>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_TimesliceRobot))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_nextOffset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_TimesliceRobot),
            "::",
            stringify!(m_nextOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_controllerPeriod) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_TimesliceRobot),
            "::",
            stringify!(m_controllerPeriod)
        )
    );
}
extern "C" {
    #[doc = " Schedule a periodic function with the constructor's controller period and\n the given allocation. The function's runtime allocation will be placed\n after the end of the previous one's.\n\n If a call to this function makes the allocations exceed the controller\n period, an exception will be thrown since that means the TimesliceRobot\n periodic functions and the given function will have conflicting\n timeslices.\n\n @param func       Function to schedule.\n @param allocation The function's runtime allocation out of the controller\n                   period."]
    #[link_name = "\u{1}_ZN3frc14TimesliceRobot8ScheduleESt8functionIFvvEEN5units6unit_tINS4_4unitISt5ratioILx1ELx1EENS4_9base_unitIS7_ILx0ELx1EESA_S8_SA_SA_SA_SA_SA_SA_EESA_SA_EEdNS4_12linear_scaleEEE"]
    pub fn frc_TimesliceRobot_Schedule(
        this: *mut frc_TimesliceRobot,
        func: [u32; 4usize],
        allocation: units_time_second_t,
    );
}
extern "C" {
    #[doc = " Constructor for TimesliceRobot.\n\n @param robotPeriodicAllocation The allocation to give the TimesliceRobot\n                                periodic functions.\n @param controllerPeriod The controller period. The sum of all scheduler\n                         allocations should be less than or equal to this\n                         value."]
    #[link_name = "\u{1}_ZN3frc14TimesliceRobotC1EN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES7_S5_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEESB_"]
    pub fn frc_TimesliceRobot_TimesliceRobot(
        this: *mut frc_TimesliceRobot,
        robotPeriodicAllocation: units_time_second_t,
        controllerPeriod: units_time_second_t,
    );
}
impl frc_TimesliceRobot {
    #[inline]
    pub unsafe fn Schedule(&mut self, func: [u32; 4usize], allocation: units_time_second_t) {
        frc_TimesliceRobot_Schedule(self, func, allocation)
    }
    #[inline]
    pub unsafe fn new(
        robotPeriodicAllocation: units_time_second_t,
        controllerPeriod: units_time_second_t,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_TimesliceRobot_TimesliceRobot(
            __bindgen_tmp.as_mut_ptr(),
            robotPeriodicAllocation,
            controllerPeriod,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Ultrasonic rangefinder class.\n\n The Ultrasonic rangefinder measures absolute distance based on the round-trip\n time of a ping generated by the controller. These sensors use two\n transducers, a speaker and a microphone both tuned to the ultrasonic range. A\n common ultrasonic sensor, the Daventech SRF04 requires a short pulse to be\n generated on a digital channel. This causes the chirp to be emitted. A second\n line becomes high as the ping is transmitted and goes low when the echo is\n received. The time that the line is high determines the round trip distance\n (time of flight)."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Ultrasonic {
    pub _base: wpi_Sendable,
    pub m_pingChannel: [u32; 2usize],
    pub m_echoChannel: [u32; 2usize],
    pub m_enabled: bool,
    pub m_counter: frc_Counter,
    pub m_simDevice: hal_SimDevice,
    pub m_simRangeValid: hal_SimBoolean,
    pub m_simRange: hal_SimDouble,
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10Ultrasonic9kPingTimeE"]
    pub static frc_Ultrasonic_kPingTime: units_time_microsecond_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10Ultrasonic18kMaxUltrasonicTimeE"]
    pub static frc_Ultrasonic_kMaxUltrasonicTime: units_time_second_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10Ultrasonic13kSpeedOfSoundE"]
    pub static frc_Ultrasonic_kSpeedOfSound: units_velocity_feet_per_second_t;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10Ultrasonic8m_threadE"]
    pub static mut frc_Ultrasonic_m_thread: std_thread;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10Ultrasonic9m_sensorsE"]
    pub static mut frc_Ultrasonic_m_sensors: u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10Ultrasonic18m_automaticEnabledE"]
    pub static mut frc_Ultrasonic_m_automaticEnabled: u8;
}
#[test]
fn bindgen_test_layout_frc_Ultrasonic() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Ultrasonic> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Ultrasonic>(),
        68usize,
        concat!("Size of: ", stringify!(frc_Ultrasonic))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Ultrasonic>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_Ultrasonic))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pingChannel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Ultrasonic),
            "::",
            stringify!(m_pingChannel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_echoChannel) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Ultrasonic),
            "::",
            stringify!(m_echoChannel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_enabled) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Ultrasonic),
            "::",
            stringify!(m_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_counter) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Ultrasonic),
            "::",
            stringify!(m_counter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_simDevice) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Ultrasonic),
            "::",
            stringify!(m_simDevice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_simRangeValid) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Ultrasonic),
            "::",
            stringify!(m_simRangeValid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_simRange) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Ultrasonic),
            "::",
            stringify!(m_simRange)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc10Ultrasonic14GetEchoChannelEv"]
    pub fn frc_Ultrasonic_GetEchoChannel(this: *const frc_Ultrasonic) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Single ping to ultrasonic sensor.\n\n Send out a single ping to the ultrasonic sensor. This only works if\n automatic (round robin) mode is disabled. A single ping is sent out, and\n the counter should count the semi-period when it comes in. The counter is\n reset to make the current value invalid."]
    #[link_name = "\u{1}_ZN3frc10Ultrasonic4PingEv"]
    pub fn frc_Ultrasonic_Ping(this: *mut frc_Ultrasonic);
}
extern "C" {
    #[doc = " Check if there is a valid range measurement.\n\n The ranges are accumulated in a counter that will increment on each edge of\n the echo (return) signal. If the count is not at least 2, then the range\n has not yet been measured, and is invalid."]
    #[link_name = "\u{1}_ZNK3frc10Ultrasonic12IsRangeValidEv"]
    pub fn frc_Ultrasonic_IsRangeValid(this: *const frc_Ultrasonic) -> bool;
}
extern "C" {
    #[doc = " Turn Automatic mode on/off.\n\n When in Automatic mode, all sensors will fire in round robin, waiting a set\n time between each sensor.\n\n @param enabling Set to true if round robin scheduling should start for all\n                 the ultrasonic sensors. This scheduling method assures that\n                 the sensors are non-interfering because no two sensors fire\n                 at the same time. If another scheduling algorithm is\n                 preferred, it can be implemented by pinging the sensors\n                 manually and waiting for the results to come back."]
    #[link_name = "\u{1}_ZN3frc10Ultrasonic16SetAutomaticModeEb"]
    pub fn frc_Ultrasonic_SetAutomaticMode(enabling: bool);
}
extern "C" {
    #[doc = " Get the range from the ultrasonic sensor.\n\n @return Range of the target returned from the ultrasonic sensor. If there\n         is no valid value yet, i.e. at least one measurement hasn't\n         completed, then return 0."]
    #[link_name = "\u{1}_ZNK3frc10Ultrasonic8GetRangeEv"]
    pub fn frc_Ultrasonic_GetRange(this: *const frc_Ultrasonic) -> units_length_meter_t;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc10Ultrasonic9IsEnabledEv"]
    pub fn frc_Ultrasonic_IsEnabled(this: *const frc_Ultrasonic) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10Ultrasonic10SetEnabledEb"]
    pub fn frc_Ultrasonic_SetEnabled(this: *mut frc_Ultrasonic, enable: bool);
}
extern "C" {
    #[doc = " Create an instance of the Ultrasonic Sensor.\n\n This is designed to support the Daventech SRF04 and Vex ultrasonic sensors.\n\n @param pingChannel The digital output channel that sends the pulse to\n                    initiate the sensor sending the ping.\n @param echoChannel The digital input channel that receives the echo. The\n                    length of time that the echo is high represents the\n                    round trip time of the ping, and the distance."]
    #[link_name = "\u{1}_ZN3frc10UltrasonicC1Eii"]
    pub fn frc_Ultrasonic_Ultrasonic(
        this: *mut frc_Ultrasonic,
        pingChannel: ::std::os::raw::c_int,
        echoChannel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Create an instance of an Ultrasonic Sensor from a DigitalInput for the echo\n channel and a DigitalOutput for the ping channel.\n\n @param pingChannel The digital output object that starts the sensor doing a\n                    ping. Requires a 10uS pulse to start.\n @param echoChannel The digital input object that times the return pulse to\n                    determine the range."]
    #[link_name = "\u{1}_ZN3frc10UltrasonicC1EPNS_13DigitalOutputEPNS_12DigitalInputE"]
    pub fn frc_Ultrasonic_Ultrasonic1(
        this: *mut frc_Ultrasonic,
        pingChannel: *mut frc_DigitalOutput,
        echoChannel: *mut frc_DigitalInput,
    );
}
extern "C" {
    #[doc = " Create an instance of an Ultrasonic Sensor from a DigitalInput for the echo\n channel and a DigitalOutput for the ping channel.\n\n @param pingChannel The digital output object that starts the sensor doing a\n                    ping. Requires a 10uS pulse to start.\n @param echoChannel The digital input object that times the return pulse to\n                    determine the range."]
    #[link_name = "\u{1}_ZN3frc10UltrasonicC1ERNS_13DigitalOutputERNS_12DigitalInputE"]
    pub fn frc_Ultrasonic_Ultrasonic2(
        this: *mut frc_Ultrasonic,
        pingChannel: *mut frc_DigitalOutput,
        echoChannel: *mut frc_DigitalInput,
    );
}
extern "C" {
    #[doc = " Create an instance of an Ultrasonic Sensor from a DigitalInput for the echo\n channel and a DigitalOutput for the ping channel.\n\n @param pingChannel The digital output object that starts the sensor doing a\n                    ping. Requires a 10uS pulse to start.\n @param echoChannel The digital input object that times the return pulse to\n                    determine the range."]
    #[link_name = "\u{1}_ZN3frc10UltrasonicC1ESt10shared_ptrINS_13DigitalOutputEES1_INS_12DigitalInputEE"]
    pub fn frc_Ultrasonic_Ultrasonic3(
        this: *mut frc_Ultrasonic,
        pingChannel: [u32; 2usize],
        echoChannel: [u32; 2usize],
    );
}
impl frc_Ultrasonic {
    #[inline]
    pub unsafe fn GetEchoChannel(&self) -> ::std::os::raw::c_int {
        frc_Ultrasonic_GetEchoChannel(self)
    }
    #[inline]
    pub unsafe fn Ping(&mut self) {
        frc_Ultrasonic_Ping(self)
    }
    #[inline]
    pub unsafe fn IsRangeValid(&self) -> bool {
        frc_Ultrasonic_IsRangeValid(self)
    }
    #[inline]
    pub unsafe fn SetAutomaticMode(enabling: bool) {
        frc_Ultrasonic_SetAutomaticMode(enabling)
    }
    #[inline]
    pub unsafe fn GetRange(&self) -> units_length_meter_t {
        frc_Ultrasonic_GetRange(self)
    }
    #[inline]
    pub unsafe fn IsEnabled(&self) -> bool {
        frc_Ultrasonic_IsEnabled(self)
    }
    #[inline]
    pub unsafe fn SetEnabled(&mut self, enable: bool) {
        frc_Ultrasonic_SetEnabled(self, enable)
    }
    #[inline]
    pub unsafe fn new(
        pingChannel: ::std::os::raw::c_int,
        echoChannel: ::std::os::raw::c_int,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Ultrasonic_Ultrasonic(__bindgen_tmp.as_mut_ptr(), pingChannel, echoChannel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        pingChannel: *mut frc_DigitalOutput,
        echoChannel: *mut frc_DigitalInput,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Ultrasonic_Ultrasonic1(__bindgen_tmp.as_mut_ptr(), pingChannel, echoChannel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        pingChannel: *mut frc_DigitalOutput,
        echoChannel: *mut frc_DigitalInput,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Ultrasonic_Ultrasonic2(__bindgen_tmp.as_mut_ptr(), pingChannel, echoChannel);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(pingChannel: [u32; 2usize], echoChannel: [u32; 2usize]) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Ultrasonic_Ultrasonic3(__bindgen_tmp.as_mut_ptr(), pingChannel, echoChannel);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10UltrasonicD1Ev"]
    pub fn frc_Ultrasonic_Ultrasonic_destructor(this: *mut frc_Ultrasonic);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10Ultrasonic12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_Ultrasonic_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Handle input from Xbox 360 or Xbox One controllers connected to the Driver\n Station.\n\n This class handles Xbox input that comes from the Driver Station. Each time a\n value is requested the most recent value is returned. There is a single class\n instance for each controller and the mapping of ports to hardware buttons\n depends on the code in the Driver Station."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_XboxController {
    pub _base: frc_GenericHID,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_XboxController_Button {
    pub _address: u8,
}
pub const frc_XboxController_Button_kLeftBumper: ::std::os::raw::c_int = 5;
pub const frc_XboxController_Button_kRightBumper: ::std::os::raw::c_int = 6;
pub const frc_XboxController_Button_kLeftStick: ::std::os::raw::c_int = 9;
pub const frc_XboxController_Button_kRightStick: ::std::os::raw::c_int = 10;
pub const frc_XboxController_Button_kA: ::std::os::raw::c_int = 1;
pub const frc_XboxController_Button_kB: ::std::os::raw::c_int = 2;
pub const frc_XboxController_Button_kX: ::std::os::raw::c_int = 3;
pub const frc_XboxController_Button_kY: ::std::os::raw::c_int = 4;
pub const frc_XboxController_Button_kBack: ::std::os::raw::c_int = 7;
pub const frc_XboxController_Button_kStart: ::std::os::raw::c_int = 8;
#[test]
fn bindgen_test_layout_frc_XboxController_Button() {
    assert_eq!(
        ::std::mem::size_of::<frc_XboxController_Button>(),
        1usize,
        concat!("Size of: ", stringify!(frc_XboxController_Button))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_XboxController_Button>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_XboxController_Button))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_XboxController_Axis {
    pub _address: u8,
}
pub const frc_XboxController_Axis_kLeftX: ::std::os::raw::c_int = 0;
pub const frc_XboxController_Axis_kRightX: ::std::os::raw::c_int = 4;
pub const frc_XboxController_Axis_kLeftY: ::std::os::raw::c_int = 1;
pub const frc_XboxController_Axis_kRightY: ::std::os::raw::c_int = 5;
pub const frc_XboxController_Axis_kLeftTrigger: ::std::os::raw::c_int = 2;
pub const frc_XboxController_Axis_kRightTrigger: ::std::os::raw::c_int = 3;
#[test]
fn bindgen_test_layout_frc_XboxController_Axis() {
    assert_eq!(
        ::std::mem::size_of::<frc_XboxController_Axis>(),
        1usize,
        concat!("Size of: ", stringify!(frc_XboxController_Axis))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_XboxController_Axis>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_XboxController_Axis))
    );
}
#[test]
fn bindgen_test_layout_frc_XboxController() {
    assert_eq!(
        ::std::mem::size_of::<frc_XboxController>(),
        16usize,
        concat!("Size of: ", stringify!(frc_XboxController))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_XboxController>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_XboxController))
    );
}
extern "C" {
    #[doc = " Get the X axis value of left side of the controller."]
    #[link_name = "\u{1}_ZNK3frc14XboxController8GetLeftXEv"]
    pub fn frc_XboxController_GetLeftX(this: *const frc_XboxController) -> f64;
}
extern "C" {
    #[doc = " Get the X axis value of right side of the controller."]
    #[link_name = "\u{1}_ZNK3frc14XboxController9GetRightXEv"]
    pub fn frc_XboxController_GetRightX(this: *const frc_XboxController) -> f64;
}
extern "C" {
    #[doc = " Get the Y axis value of left side of the controller."]
    #[link_name = "\u{1}_ZNK3frc14XboxController8GetLeftYEv"]
    pub fn frc_XboxController_GetLeftY(this: *const frc_XboxController) -> f64;
}
extern "C" {
    #[doc = " Get the Y axis value of right side of the controller."]
    #[link_name = "\u{1}_ZNK3frc14XboxController9GetRightYEv"]
    pub fn frc_XboxController_GetRightY(this: *const frc_XboxController) -> f64;
}
extern "C" {
    #[doc = " Get the left trigger (LT) axis value of the controller. Note that this axis\n is bound to the range of [0, 1] as opposed to the usual [-1, 1]."]
    #[link_name = "\u{1}_ZNK3frc14XboxController18GetLeftTriggerAxisEv"]
    pub fn frc_XboxController_GetLeftTriggerAxis(this: *const frc_XboxController) -> f64;
}
extern "C" {
    #[doc = " Get the right trigger (RT) axis value of the controller. Note that this\n axis is bound to the range of [0, 1] as opposed to the usual [-1, 1]."]
    #[link_name = "\u{1}_ZNK3frc14XboxController19GetRightTriggerAxisEv"]
    pub fn frc_XboxController_GetRightTriggerAxis(this: *const frc_XboxController) -> f64;
}
extern "C" {
    #[doc = " Read the value of the left bumper (LB) button on the controller."]
    #[link_name = "\u{1}_ZNK3frc14XboxController13GetLeftBumperEv"]
    pub fn frc_XboxController_GetLeftBumper(this: *const frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Read the value of the right bumper (RB) button on the controller."]
    #[link_name = "\u{1}_ZNK3frc14XboxController14GetRightBumperEv"]
    pub fn frc_XboxController_GetRightBumper(this: *const frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the left bumper (LB) was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController20GetLeftBumperPressedEv"]
    pub fn frc_XboxController_GetLeftBumperPressed(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the right bumper (RB) was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController21GetRightBumperPressedEv"]
    pub fn frc_XboxController_GetRightBumperPressed(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the left bumper (LB) was released since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController21GetLeftBumperReleasedEv"]
    pub fn frc_XboxController_GetLeftBumperReleased(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the right bumper (RB) was released since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController22GetRightBumperReleasedEv"]
    pub fn frc_XboxController_GetRightBumperReleased(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the left bumper's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the left bumper's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc14XboxController10LeftBumperEPNS_9EventLoopE"]
    pub fn frc_XboxController_LeftBumper(
        this: *const frc_XboxController,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs an event instance around the right bumper's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the right bumper's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc14XboxController11RightBumperEPNS_9EventLoopE"]
    pub fn frc_XboxController_RightBumper(
        this: *const frc_XboxController,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the left stick button (LSB) on the controller."]
    #[link_name = "\u{1}_ZNK3frc14XboxController18GetLeftStickButtonEv"]
    pub fn frc_XboxController_GetLeftStickButton(this: *const frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Read the value of the right stick button (RSB) on the controller."]
    #[link_name = "\u{1}_ZNK3frc14XboxController19GetRightStickButtonEv"]
    pub fn frc_XboxController_GetRightStickButton(this: *const frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the left stick button (LSB) was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController25GetLeftStickButtonPressedEv"]
    pub fn frc_XboxController_GetLeftStickButtonPressed(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the right stick button (RSB) was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController26GetRightStickButtonPressedEv"]
    pub fn frc_XboxController_GetRightStickButtonPressed(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the left stick button (LSB) was released since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController26GetLeftStickButtonReleasedEv"]
    pub fn frc_XboxController_GetLeftStickButtonReleased(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the right stick button (RSB) was released since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController27GetRightStickButtonReleasedEv"]
    pub fn frc_XboxController_GetRightStickButtonReleased(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the left stick's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the left stick's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc14XboxController9LeftStickEPNS_9EventLoopE"]
    pub fn frc_XboxController_LeftStick(
        this: *const frc_XboxController,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs an event instance around the right stick's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the right stick's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc14XboxController10RightStickEPNS_9EventLoopE"]
    pub fn frc_XboxController_RightStick(
        this: *const frc_XboxController,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the A button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc14XboxController10GetAButtonEv"]
    pub fn frc_XboxController_GetAButton(this: *const frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the A button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController17GetAButtonPressedEv"]
    pub fn frc_XboxController_GetAButtonPressed(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the A button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController18GetAButtonReleasedEv"]
    pub fn frc_XboxController_GetAButtonReleased(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the A button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the A button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc14XboxController1AEPNS_9EventLoopE"]
    pub fn frc_XboxController_A(
        this: *const frc_XboxController,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the B button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc14XboxController10GetBButtonEv"]
    pub fn frc_XboxController_GetBButton(this: *const frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the B button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController17GetBButtonPressedEv"]
    pub fn frc_XboxController_GetBButtonPressed(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the B button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController18GetBButtonReleasedEv"]
    pub fn frc_XboxController_GetBButtonReleased(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the B button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the B button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc14XboxController1BEPNS_9EventLoopE"]
    pub fn frc_XboxController_B(
        this: *const frc_XboxController,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the X button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc14XboxController10GetXButtonEv"]
    pub fn frc_XboxController_GetXButton(this: *const frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the X button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController17GetXButtonPressedEv"]
    pub fn frc_XboxController_GetXButtonPressed(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the X button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController18GetXButtonReleasedEv"]
    pub fn frc_XboxController_GetXButtonReleased(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the X button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the X button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc14XboxController1XEPNS_9EventLoopE"]
    pub fn frc_XboxController_X(
        this: *const frc_XboxController,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the Y button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc14XboxController10GetYButtonEv"]
    pub fn frc_XboxController_GetYButton(this: *const frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the Y button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController17GetYButtonPressedEv"]
    pub fn frc_XboxController_GetYButtonPressed(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the Y button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController18GetYButtonReleasedEv"]
    pub fn frc_XboxController_GetYButtonReleased(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the Y button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the Y button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc14XboxController1YEPNS_9EventLoopE"]
    pub fn frc_XboxController_Y(
        this: *const frc_XboxController,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Whether the Y button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZNK3frc14XboxController13GetBackButtonEv"]
    pub fn frc_XboxController_GetBackButton(this: *const frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the back button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController20GetBackButtonPressedEv"]
    pub fn frc_XboxController_GetBackButtonPressed(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the back button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController21GetBackButtonReleasedEv"]
    pub fn frc_XboxController_GetBackButtonReleased(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the back button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the back button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc14XboxController4BackEPNS_9EventLoopE"]
    pub fn frc_XboxController_Back(
        this: *const frc_XboxController,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Read the value of the start button on the controller.\n\n @return The state of the button."]
    #[link_name = "\u{1}_ZNK3frc14XboxController14GetStartButtonEv"]
    pub fn frc_XboxController_GetStartButton(this: *const frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the start button was pressed since the last check.\n\n @return Whether the button was pressed since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController21GetStartButtonPressedEv"]
    pub fn frc_XboxController_GetStartButtonPressed(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Whether the start button was released since the last check.\n\n @return Whether the button was released since the last check."]
    #[link_name = "\u{1}_ZN3frc14XboxController22GetStartButtonReleasedEv"]
    pub fn frc_XboxController_GetStartButtonReleased(this: *mut frc_XboxController) -> bool;
}
extern "C" {
    #[doc = " Constructs an event instance around the start button's digital signal.\n\n @param loop the event loop instance to attach the event to.\n @return an event instance representing the start button's digital signal\n attached to the given loop."]
    #[link_name = "\u{1}_ZNK3frc14XboxController5StartEPNS_9EventLoopE"]
    pub fn frc_XboxController_Start(
        this: *const frc_XboxController,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs an event instance around the axis value of the left trigger. The\n returned trigger will be true when the axis value is greater than {@code\n threshold}.\n @param threshold the minimum axis value for the returned event to be true.\n This value should be in the range [0, 1] where 0 is the unpressed state of\n the axis.\n @param loop the event loop instance to attach the event to.\n @return an event instance that is true when the left trigger's axis exceeds\n the provided threshold, attached to the given event loop"]
    #[link_name = "\u{1}_ZNK3frc14XboxController11LeftTriggerEdPNS_9EventLoopE"]
    pub fn frc_XboxController_LeftTrigger(
        this: *const frc_XboxController,
        threshold: f64,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs an event instance around the axis value of the left trigger.\n The returned trigger will be true when the axis value is greater than 0.5.\n @param loop the event loop instance to attach the event to.\n @return an event instance that is true when the right trigger's axis\n exceeds 0.5, attached to the given event loop"]
    #[link_name = "\u{1}_ZNK3frc14XboxController11LeftTriggerEPNS_9EventLoopE"]
    pub fn frc_XboxController_LeftTrigger1(
        this: *const frc_XboxController,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs an event instance around the axis value of the right trigger.\n The returned trigger will be true when the axis value is greater than\n {@code threshold}.\n @param threshold the minimum axis value for the returned event to be true.\n This value should be in the range [0, 1] where 0 is the unpressed state of\n the axis.\n @param loop the event loop instance to attach the event to.\n @return an event instance that is true when the right trigger's axis\n exceeds the provided threshold, attached to the given event loop"]
    #[link_name = "\u{1}_ZNK3frc14XboxController12RightTriggerEdPNS_9EventLoopE"]
    pub fn frc_XboxController_RightTrigger(
        this: *const frc_XboxController,
        threshold: f64,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Constructs an event instance around the axis value of the right trigger.\n The returned trigger will be true when the axis value is greater than 0.5.\n @param loop the event loop instance to attach the event to.\n @return an event instance that is true when the right trigger's axis\n exceeds 0.5, attached to the given event loop"]
    #[link_name = "\u{1}_ZNK3frc14XboxController12RightTriggerEPNS_9EventLoopE"]
    pub fn frc_XboxController_RightTrigger1(
        this: *const frc_XboxController,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent;
}
extern "C" {
    #[doc = " Construct an instance of an Xbox controller.\n\n The controller index is the USB port on the Driver Station.\n\n @param port The port on the Driver Station that the controller is plugged\n             into (0-5)."]
    #[link_name = "\u{1}_ZN3frc14XboxControllerC1Ei"]
    pub fn frc_XboxController_XboxController(
        this: *mut frc_XboxController,
        port: ::std::os::raw::c_int,
    );
}
impl frc_XboxController {
    #[inline]
    pub unsafe fn GetLeftX(&self) -> f64 {
        frc_XboxController_GetLeftX(self)
    }
    #[inline]
    pub unsafe fn GetRightX(&self) -> f64 {
        frc_XboxController_GetRightX(self)
    }
    #[inline]
    pub unsafe fn GetLeftY(&self) -> f64 {
        frc_XboxController_GetLeftY(self)
    }
    #[inline]
    pub unsafe fn GetRightY(&self) -> f64 {
        frc_XboxController_GetRightY(self)
    }
    #[inline]
    pub unsafe fn GetLeftTriggerAxis(&self) -> f64 {
        frc_XboxController_GetLeftTriggerAxis(self)
    }
    #[inline]
    pub unsafe fn GetRightTriggerAxis(&self) -> f64 {
        frc_XboxController_GetRightTriggerAxis(self)
    }
    #[inline]
    pub unsafe fn GetLeftBumper(&self) -> bool {
        frc_XboxController_GetLeftBumper(self)
    }
    #[inline]
    pub unsafe fn GetRightBumper(&self) -> bool {
        frc_XboxController_GetRightBumper(self)
    }
    #[inline]
    pub unsafe fn GetLeftBumperPressed(&mut self) -> bool {
        frc_XboxController_GetLeftBumperPressed(self)
    }
    #[inline]
    pub unsafe fn GetRightBumperPressed(&mut self) -> bool {
        frc_XboxController_GetRightBumperPressed(self)
    }
    #[inline]
    pub unsafe fn GetLeftBumperReleased(&mut self) -> bool {
        frc_XboxController_GetLeftBumperReleased(self)
    }
    #[inline]
    pub unsafe fn GetRightBumperReleased(&mut self) -> bool {
        frc_XboxController_GetRightBumperReleased(self)
    }
    #[inline]
    pub unsafe fn LeftBumper(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_XboxController_LeftBumper(self, loop_)
    }
    #[inline]
    pub unsafe fn RightBumper(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_XboxController_RightBumper(self, loop_)
    }
    #[inline]
    pub unsafe fn GetLeftStickButton(&self) -> bool {
        frc_XboxController_GetLeftStickButton(self)
    }
    #[inline]
    pub unsafe fn GetRightStickButton(&self) -> bool {
        frc_XboxController_GetRightStickButton(self)
    }
    #[inline]
    pub unsafe fn GetLeftStickButtonPressed(&mut self) -> bool {
        frc_XboxController_GetLeftStickButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetRightStickButtonPressed(&mut self) -> bool {
        frc_XboxController_GetRightStickButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetLeftStickButtonReleased(&mut self) -> bool {
        frc_XboxController_GetLeftStickButtonReleased(self)
    }
    #[inline]
    pub unsafe fn GetRightStickButtonReleased(&mut self) -> bool {
        frc_XboxController_GetRightStickButtonReleased(self)
    }
    #[inline]
    pub unsafe fn LeftStick(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_XboxController_LeftStick(self, loop_)
    }
    #[inline]
    pub unsafe fn RightStick(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_XboxController_RightStick(self, loop_)
    }
    #[inline]
    pub unsafe fn GetAButton(&self) -> bool {
        frc_XboxController_GetAButton(self)
    }
    #[inline]
    pub unsafe fn GetAButtonPressed(&mut self) -> bool {
        frc_XboxController_GetAButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetAButtonReleased(&mut self) -> bool {
        frc_XboxController_GetAButtonReleased(self)
    }
    #[inline]
    pub unsafe fn A(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_XboxController_A(self, loop_)
    }
    #[inline]
    pub unsafe fn GetBButton(&self) -> bool {
        frc_XboxController_GetBButton(self)
    }
    #[inline]
    pub unsafe fn GetBButtonPressed(&mut self) -> bool {
        frc_XboxController_GetBButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetBButtonReleased(&mut self) -> bool {
        frc_XboxController_GetBButtonReleased(self)
    }
    #[inline]
    pub unsafe fn B(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_XboxController_B(self, loop_)
    }
    #[inline]
    pub unsafe fn GetXButton(&self) -> bool {
        frc_XboxController_GetXButton(self)
    }
    #[inline]
    pub unsafe fn GetXButtonPressed(&mut self) -> bool {
        frc_XboxController_GetXButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetXButtonReleased(&mut self) -> bool {
        frc_XboxController_GetXButtonReleased(self)
    }
    #[inline]
    pub unsafe fn X(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_XboxController_X(self, loop_)
    }
    #[inline]
    pub unsafe fn GetYButton(&self) -> bool {
        frc_XboxController_GetYButton(self)
    }
    #[inline]
    pub unsafe fn GetYButtonPressed(&mut self) -> bool {
        frc_XboxController_GetYButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetYButtonReleased(&mut self) -> bool {
        frc_XboxController_GetYButtonReleased(self)
    }
    #[inline]
    pub unsafe fn Y(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_XboxController_Y(self, loop_)
    }
    #[inline]
    pub unsafe fn GetBackButton(&self) -> bool {
        frc_XboxController_GetBackButton(self)
    }
    #[inline]
    pub unsafe fn GetBackButtonPressed(&mut self) -> bool {
        frc_XboxController_GetBackButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetBackButtonReleased(&mut self) -> bool {
        frc_XboxController_GetBackButtonReleased(self)
    }
    #[inline]
    pub unsafe fn Back(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_XboxController_Back(self, loop_)
    }
    #[inline]
    pub unsafe fn GetStartButton(&self) -> bool {
        frc_XboxController_GetStartButton(self)
    }
    #[inline]
    pub unsafe fn GetStartButtonPressed(&mut self) -> bool {
        frc_XboxController_GetStartButtonPressed(self)
    }
    #[inline]
    pub unsafe fn GetStartButtonReleased(&mut self) -> bool {
        frc_XboxController_GetStartButtonReleased(self)
    }
    #[inline]
    pub unsafe fn Start(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_XboxController_Start(self, loop_)
    }
    #[inline]
    pub unsafe fn LeftTrigger(
        &self,
        threshold: f64,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent {
        frc_XboxController_LeftTrigger(self, threshold, loop_)
    }
    #[inline]
    pub unsafe fn LeftTrigger1(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_XboxController_LeftTrigger1(self, loop_)
    }
    #[inline]
    pub unsafe fn RightTrigger(
        &self,
        threshold: f64,
        loop_: *mut frc_EventLoop,
    ) -> frc_BooleanEvent {
        frc_XboxController_RightTrigger(self, threshold, loop_)
    }
    #[inline]
    pub unsafe fn RightTrigger1(&self, loop_: *mut frc_EventLoop) -> frc_BooleanEvent {
        frc_XboxController_RightTrigger1(self, loop_)
    }
    #[inline]
    pub unsafe fn new(port: ::std::os::raw::c_int) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_XboxController_XboxController(__bindgen_tmp.as_mut_ptr(), port);
        __bindgen_tmp.assume_init()
    }
}
pub type frc_Vectord = Eigen_Vector;
pub type frc_Matrixd = u8;
#[doc = " Represents a translation in 2D space.\n This object can be used to represent a point or a vector.\n\n This assumes that you are using conventional mathematical axes.\n When the robot is at the origin facing in the positive X direction, forward\n is positive X and left is positive Y."]
#[repr(C)]
pub struct frc_Translation2d {
    pub m_x: units_length_meter_t,
    pub m_y: units_length_meter_t,
}
#[test]
fn bindgen_test_layout_frc_Translation2d() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Translation2d> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Translation2d>(),
        16usize,
        concat!("Size of: ", stringify!(frc_Translation2d))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Translation2d>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_Translation2d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Translation2d),
            "::",
            stringify!(m_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Translation2d),
            "::",
            stringify!(m_y)
        )
    );
}
extern "C" {
    #[doc = " Calculates the distance between two translations in 2D space.\n\n The distance between translations is defined as ((xx)+(yy)).\n\n @param other The translation to compute the distance to.\n\n @return The distance between the two translations."]
    #[link_name = "\u{1}_ZNK3frc13Translation2d8DistanceERKS0_"]
    pub fn frc_Translation2d_Distance(
        this: *const frc_Translation2d,
        other: *const frc_Translation2d,
    ) -> units_length_meter_t;
}
extern "C" {
    #[doc = " Returns the norm, or distance from the origin to the translation.\n\n @return The norm of the translation."]
    #[link_name = "\u{1}_ZNK3frc13Translation2d4NormEv"]
    pub fn frc_Translation2d_Norm(this: *const frc_Translation2d) -> units_length_meter_t;
}
impl frc_Translation2d {
    #[inline]
    pub unsafe fn Distance(&self, other: *const frc_Translation2d) -> units_length_meter_t {
        frc_Translation2d_Distance(self, other)
    }
    #[inline]
    pub unsafe fn Norm(&self) -> units_length_meter_t {
        frc_Translation2d_Norm(self)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7to_jsonERN3wpi4jsonERKNS_13Translation2dE"]
    pub fn frc_to_json1(json: *mut wpi_json, state: *const frc_Translation2d);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc9from_jsonERKN3wpi4jsonERNS_13Translation2dE"]
    pub fn frc_from_json1(json: *const wpi_json, state: *mut frc_Translation2d);
}
#[doc = " Represents a transformation for a Pose2d."]
#[repr(C)]
pub struct frc_Transform2d {
    pub m_translation: frc_Translation2d,
    pub m_rotation: frc_Rotation2d,
}
#[test]
fn bindgen_test_layout_frc_Transform2d() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Transform2d> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Transform2d>(),
        40usize,
        concat!("Size of: ", stringify!(frc_Transform2d))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Transform2d>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_Transform2d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_translation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Transform2d),
            "::",
            stringify!(m_translation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rotation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Transform2d),
            "::",
            stringify!(m_rotation)
        )
    );
}
extern "C" {
    #[doc = " Constructs the transform that maps the initial pose to the final pose.\n\n @param initial The initial pose for the transformation.\n @param final The final pose for the transformation."]
    #[link_name = "\u{1}_ZN3frc11Transform2dC1ENS_6Pose2dES1_"]
    pub fn frc_Transform2d_Transform2d(
        this: *mut frc_Transform2d,
        initial: frc_Pose2d,
        final_: frc_Pose2d,
    );
}
impl frc_Transform2d {
    #[inline]
    pub unsafe fn new(initial: frc_Pose2d, final_: frc_Pose2d) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Transform2d_Transform2d(__bindgen_tmp.as_mut_ptr(), initial, final_);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " A change in distance along a 2D arc since the last pose update. We can use\n ideas from differential calculus to create new Pose2ds from a Twist2d and\n vise versa.\n\n A Twist can be used to represent a difference between two poses."]
#[repr(C)]
pub struct frc_Twist2d {
    #[doc = " Linear \"dx\" component"]
    pub dx: units_length_meter_t,
    #[doc = " Linear \"dy\" component"]
    pub dy: units_length_meter_t,
    #[doc = " Angular \"dtheta\" component (radians)"]
    pub dtheta: units_angle_radian_t,
}
#[test]
fn bindgen_test_layout_frc_Twist2d() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Twist2d> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Twist2d>(),
        24usize,
        concat!("Size of: ", stringify!(frc_Twist2d))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Twist2d>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_Twist2d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Twist2d),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Twist2d),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dtheta) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Twist2d),
            "::",
            stringify!(dtheta)
        )
    );
}
#[doc = " Represents a 2D pose containing translational and rotational elements."]
#[repr(C)]
pub struct frc_Pose2d {
    pub m_translation: frc_Translation2d,
    pub m_rotation: frc_Rotation2d,
}
#[test]
fn bindgen_test_layout_frc_Pose2d() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Pose2d> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Pose2d>(),
        40usize,
        concat!("Size of: ", stringify!(frc_Pose2d))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Pose2d>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_Pose2d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_translation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Pose2d),
            "::",
            stringify!(m_translation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_rotation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Pose2d),
            "::",
            stringify!(m_rotation)
        )
    );
}
extern "C" {
    #[doc = " Returns the current pose relative to the given pose.\n\n This function can often be used for trajectory tracking or pose\n stabilization algorithms to get the error between the reference and the\n current pose.\n\n @param other The pose that is the origin of the new coordinate frame that\n the current pose will be converted into.\n\n @return The current pose relative to the new origin pose."]
    #[link_name = "\u{1}_ZNK3frc6Pose2d10RelativeToERKS0_"]
    pub fn frc_Pose2d_RelativeTo(this: *const frc_Pose2d, other: *const frc_Pose2d) -> frc_Pose2d;
}
extern "C" {
    #[doc = " Obtain a new Pose2d from a (constant curvature) velocity.\n\n See https://file.tavsys.net/control/controls-engineering-in-frc.pdf section\n 10.2 \"Pose exponential\" for a derivation.\n\n The twist is a change in pose in the robot's coordinate frame since the\n previous pose update. When the user runs exp() on the previous known\n field-relative pose with the argument being the twist, the user will\n receive the new field-relative pose.\n\n \"Exp\" represents the pose exponential, which is solving a differential\n equation moving the pose forward in time.\n\n @param twist The change in pose in the robot's coordinate frame since the\n previous pose update. For example, if a non-holonomic robot moves forward\n 0.01 meters and changes angle by 0.5 degrees since the previous pose\n update, the twist would be Twist2d{0.01_m, 0_m, 0.5_deg}.\n\n @return The new pose of the robot."]
    #[link_name = "\u{1}_ZNK3frc6Pose2d3ExpERKNS_7Twist2dE"]
    pub fn frc_Pose2d_Exp(this: *const frc_Pose2d, twist: *const frc_Twist2d) -> frc_Pose2d;
}
extern "C" {
    #[doc = " Returns a Twist2d that maps this pose to the end pose. If c is the output\n of a.Log(b), then a.Exp(c) would yield b.\n\n @param end The end pose for the transformation.\n\n @return The twist that maps this to end."]
    #[link_name = "\u{1}_ZNK3frc6Pose2d3LogERKS0_"]
    pub fn frc_Pose2d_Log(this: *const frc_Pose2d, end: *const frc_Pose2d) -> frc_Twist2d;
}
impl frc_Pose2d {
    #[inline]
    pub unsafe fn RelativeTo(&self, other: *const frc_Pose2d) -> frc_Pose2d {
        frc_Pose2d_RelativeTo(self, other)
    }
    #[inline]
    pub unsafe fn Exp(&self, twist: *const frc_Twist2d) -> frc_Pose2d {
        frc_Pose2d_Exp(self, twist)
    }
    #[inline]
    pub unsafe fn Log(&self, end: *const frc_Pose2d) -> frc_Twist2d {
        frc_Pose2d_Log(self, end)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7to_jsonERN3wpi4jsonERKNS_6Pose2dE"]
    pub fn frc_to_json2(json: *mut wpi_json, pose: *const frc_Pose2d);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc9from_jsonERKN3wpi4jsonERNS_6Pose2dE"]
    pub fn frc_from_json2(json: *const wpi_json, pose: *mut frc_Pose2d);
}
#[doc = " An executor for running listener tasks posted by Sendable listeners\n synchronously from the main application thread.\n\n @see Sendable"]
#[repr(C)]
#[derive(Debug)]
pub struct frc_detail_ListenerExecutor {
    pub m_tasks: [u32; 3usize],
    pub m_runningTasks: [u32; 3usize],
    pub m_lock: wpi_mutex,
}
#[test]
fn bindgen_test_layout_frc_detail_ListenerExecutor() {
    const UNINIT: ::std::mem::MaybeUninit<frc_detail_ListenerExecutor> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_detail_ListenerExecutor>(),
        48usize,
        concat!("Size of: ", stringify!(frc_detail_ListenerExecutor))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_detail_ListenerExecutor>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_detail_ListenerExecutor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_tasks) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_detail_ListenerExecutor),
            "::",
            stringify!(m_tasks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_runningTasks) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_detail_ListenerExecutor),
            "::",
            stringify!(m_runningTasks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_lock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_detail_ListenerExecutor),
            "::",
            stringify!(m_lock)
        )
    );
}
extern "C" {
    #[doc = " Posts a task to the executor to be run synchronously from the main thread.\n\n @param task The task to run synchronously from the main thread."]
    #[link_name = "\u{1}_ZN3frc6detail16ListenerExecutor7ExecuteESt8functionIFvvEE"]
    pub fn frc_detail_ListenerExecutor_Execute(
        this: *mut frc_detail_ListenerExecutor,
        task: [u32; 4usize],
    );
}
extern "C" {
    #[doc = " Runs all posted tasks.  Called periodically from main thread."]
    #[link_name = "\u{1}_ZN3frc6detail16ListenerExecutor16RunListenerTasksEv"]
    pub fn frc_detail_ListenerExecutor_RunListenerTasks(this: *mut frc_detail_ListenerExecutor);
}
impl frc_detail_ListenerExecutor {
    #[inline]
    pub unsafe fn Execute(&mut self, task: [u32; 4usize]) {
        frc_detail_ListenerExecutor_Execute(self, task)
    }
    #[inline]
    pub unsafe fn RunListenerTasks(&mut self) {
        frc_detail_ListenerExecutor_RunListenerTasks(self)
    }
}
#[repr(C)]
pub struct frc_detail_RecordingController__bindgen_vtable {}
#[repr(C)]
#[derive(Debug)]
pub struct frc_detail_RecordingController {
    pub vtable_: *const frc_detail_RecordingController__bindgen_vtable,
    pub m_recordingControlEntry: nt_BooleanPublisher,
    pub m_recordingFileNameFormatEntry: nt_StringPublisher,
    pub m_eventsTable: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_frc_detail_RecordingController() {
    const UNINIT: ::std::mem::MaybeUninit<frc_detail_RecordingController> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_detail_RecordingController>(),
        28usize,
        concat!("Size of: ", stringify!(frc_detail_RecordingController))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_detail_RecordingController>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_detail_RecordingController))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_recordingControlEntry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_detail_RecordingController),
            "::",
            stringify!(m_recordingControlEntry)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).m_recordingFileNameFormatEntry) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_detail_RecordingController),
            "::",
            stringify!(m_recordingFileNameFormatEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_eventsTable) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_detail_RecordingController),
            "::",
            stringify!(m_eventsTable)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail19RecordingController14StartRecordingEv"]
    pub fn frc_detail_RecordingController_StartRecording(this: *mut frc_detail_RecordingController);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail19RecordingController13StopRecordingEv"]
    pub fn frc_detail_RecordingController_StopRecording(this: *mut frc_detail_RecordingController);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail19RecordingController26SetRecordingFileNameFormatESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_detail_RecordingController_SetRecordingFileNameFormat(
        this: *mut frc_detail_RecordingController,
        format: std_string_view,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail19RecordingController28ClearRecordingFileNameFormatEv"]
    pub fn frc_detail_RecordingController_ClearRecordingFileNameFormat(
        this: *mut frc_detail_RecordingController,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail19RecordingController14AddEventMarkerESt17basic_string_viewIcSt11char_traitsIcEES5_NS_27ShuffleboardEventImportanceE"]
    pub fn frc_detail_RecordingController_AddEventMarker(
        this: *mut frc_detail_RecordingController,
        name: std_string_view,
        description: std_string_view,
        importance: frc_ShuffleboardEventImportance,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail19RecordingControllerC1EN2nt20NetworkTableInstanceE"]
    pub fn frc_detail_RecordingController_RecordingController(
        this: *mut frc_detail_RecordingController,
        ntInstance: nt_NetworkTableInstance,
    );
}
impl frc_detail_RecordingController {
    #[inline]
    pub unsafe fn StartRecording(&mut self) {
        frc_detail_RecordingController_StartRecording(self)
    }
    #[inline]
    pub unsafe fn StopRecording(&mut self) {
        frc_detail_RecordingController_StopRecording(self)
    }
    #[inline]
    pub unsafe fn SetRecordingFileNameFormat(&mut self, format: std_string_view) {
        frc_detail_RecordingController_SetRecordingFileNameFormat(self, format)
    }
    #[inline]
    pub unsafe fn ClearRecordingFileNameFormat(&mut self) {
        frc_detail_RecordingController_ClearRecordingFileNameFormat(self)
    }
    #[inline]
    pub unsafe fn AddEventMarker(
        &mut self,
        name: std_string_view,
        description: std_string_view,
        importance: frc_ShuffleboardEventImportance,
    ) {
        frc_detail_RecordingController_AddEventMarker(self, name, description, importance)
    }
    #[inline]
    pub unsafe fn new(ntInstance: nt_NetworkTableInstance) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_detail_RecordingController_RecordingController(__bindgen_tmp.as_mut_ptr(), ntInstance);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail22GetStringForWidgetTypeENS_14BuiltInWidgetsE"]
    pub fn frc_detail_GetStringForWidgetType(
        type_: frc_BuiltInWidgets,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail24GetSendableCameraWrapperESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_detail_GetSendableCameraWrapper(cameraName: std_string_view) -> *mut [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail21AddToSendableRegistryEPN3wpi8SendableESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_detail_AddToSendableRegistry(sendable: *mut wpi_Sendable, name: std_string_view);
}
#[repr(C)]
#[derive(Debug)]
pub struct frc_detail_ShuffleboardInstance {
    pub _base: frc_ShuffleboardRoot,
    pub m_impl: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_detail_ShuffleboardInstance_Impl {
    _unused: [u8; 0],
}
#[test]
fn bindgen_test_layout_frc_detail_ShuffleboardInstance() {
    const UNINIT: ::std::mem::MaybeUninit<frc_detail_ShuffleboardInstance> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_detail_ShuffleboardInstance>(),
        8usize,
        concat!("Size of: ", stringify!(frc_detail_ShuffleboardInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_detail_ShuffleboardInstance>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_detail_ShuffleboardInstance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_impl) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_detail_ShuffleboardInstance),
            "::",
            stringify!(m_impl)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail20ShuffleboardInstanceC1EN2nt20NetworkTableInstanceE"]
    pub fn frc_detail_ShuffleboardInstance_ShuffleboardInstance(
        this: *mut frc_detail_ShuffleboardInstance,
        ntInstance: nt_NetworkTableInstance,
    );
}
impl frc_detail_ShuffleboardInstance {
    #[inline]
    pub unsafe fn new(ntInstance: nt_NetworkTableInstance) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_detail_ShuffleboardInstance_ShuffleboardInstance(
            __bindgen_tmp.as_mut_ptr(),
            ntInstance,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail20ShuffleboardInstanceD1Ev"]
    pub fn frc_detail_ShuffleboardInstance_ShuffleboardInstance_destructor(
        this: *mut frc_detail_ShuffleboardInstance,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail20ShuffleboardInstance6GetTabESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_detail_ShuffleboardInstance_GetTab(
        this: *mut ::std::os::raw::c_void,
        title: std_string_view,
    ) -> *mut frc_ShuffleboardTab;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail20ShuffleboardInstance6UpdateEv"]
    pub fn frc_detail_ShuffleboardInstance_Update(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail20ShuffleboardInstance21EnableActuatorWidgetsEv"]
    pub fn frc_detail_ShuffleboardInstance_EnableActuatorWidgets(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail20ShuffleboardInstance22DisableActuatorWidgetsEv"]
    pub fn frc_detail_ShuffleboardInstance_DisableActuatorWidgets(
        this: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail20ShuffleboardInstance9SelectTabEi"]
    pub fn frc_detail_ShuffleboardInstance_SelectTab(
        this: *mut ::std::os::raw::c_void,
        index: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc6detail20ShuffleboardInstance9SelectTabESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_detail_ShuffleboardInstance_SelectTab1(
        this: *mut ::std::os::raw::c_void,
        arg1: std_string_view,
    );
}
extern "C" {
    #[doc = " Converts a Pose2d into a vector of [x, y, theta].\n\n @param pose The pose that is being represented.\n\n @return The vector."]
    #[link_name = "\u{1}_ZN3frc14PoseTo3dVectorERKNS_6Pose2dE"]
    pub fn frc_PoseTo3dVector(pose: *const frc_Pose2d) -> [u64; 3usize];
}
extern "C" {
    #[doc = " Converts a Pose2d into a vector of [x, y, std::cos(theta), std::sin(theta)].\n\n @param pose The pose that is being represented.\n\n @return The vector."]
    #[link_name = "\u{1}_ZN3frc14PoseTo4dVectorERKNS_6Pose2dE"]
    pub fn frc_PoseTo4dVector(pose: *const frc_Pose2d) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc14IsStabilizableILi1ELi1EEEbRKN5Eigen6MatrixIdXT_EXT_EXorLNS1_14StorageOptionsE0EquaaeqT_Li1EneT_Li1ELS3_1EquaaeqT_Li1EneT_Li1ELS3_0ELS3_0EEXT_EXT_EEERKNS2_IdXT_EXT0_EXorLS3_0EquaaeqT_Li1EneT0_Li1ELS3_1EquaaeqT0_Li1EneT_Li1ELS3_0ELS3_0EEXT_EXT0_EEE"]
    pub fn frc_IsStabilizable(A: *const u64, B: *const u64) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc14IsStabilizableILi2ELi1EEEbRKN5Eigen6MatrixIdXT_EXT_EXorLNS1_14StorageOptionsE0EquaaeqT_Li1EneT_Li1ELS3_1EquaaeqT_Li1EneT_Li1ELS3_0ELS3_0EEXT_EXT_EEERKNS2_IdXT_EXT0_EXorLS3_0EquaaeqT_Li1EneT0_Li1ELS3_1EquaaeqT0_Li1EneT_Li1ELS3_0ELS3_0EEXT_EXT0_EEE"]
    pub fn frc_IsStabilizable1(A: *const [u128; 2usize], B: *const u128) -> bool;
}
extern "C" {
    #[doc = " Converts a Pose2d into a vector of [x, y, theta].\n\n @param pose The pose that is being represented.\n\n @return The vector."]
    #[link_name = "\u{1}_ZN3frc12PoseToVectorERKNS_6Pose2dE"]
    pub fn frc_PoseToVector(pose: *const frc_Pose2d) -> [u64; 3usize];
}
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type frc_LinearSystem_StateVector = frc_Vectord;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type frc_LinearSystem_InputVector = frc_Vectord;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type frc_LinearSystem_OutputVector = frc_Vectord;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type frc_LinearPlantInversionFeedforward_StateVector = frc_Vectord;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type frc_LinearPlantInversionFeedforward_InputVector = frc_Vectord;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type frc_LinearQuadraticRegulator_StateVector = frc_Vectord;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type frc_LinearQuadraticRegulator_InputVector = frc_Vectord;
#[doc = " This class is a wrapper around std::array that does compile time size\n checking.\n\n std::array's implicit constructor can result in uninitialized elements if the\n number of arguments doesn't match the std::array size."]
pub type frc_LinearQuadraticRegulator_StateArray = u8;
#[doc = " This class is a wrapper around std::array that does compile time size\n checking.\n\n std::array's implicit constructor can result in uninitialized elements if the\n number of arguments doesn't match the std::array size."]
pub type frc_LinearQuadraticRegulator_InputArray = u8;
extern "C" {
    #[doc = " Returns the next output of the controller.\n\n @param x The current state x."]
    #[link_name = "\u{1}Calculate"]
    pub fn frc_LinearQuadraticRegulator_Calculate(
        this: *mut u8,
        x: *const frc_LinearQuadraticRegulator_StateVector,
    ) -> frc_LinearQuadraticRegulator_InputVector;
}
extern "C" {
    #[doc = " Returns the next output of the controller.\n\n @param x     The current state x.\n @param nextR The next reference vector r."]
    #[link_name = "\u{1}Calculate"]
    pub fn frc_LinearQuadraticRegulator_Calculate1(
        this: *mut u8,
        x: *const frc_LinearQuadraticRegulator_StateVector,
        nextR: *const frc_LinearQuadraticRegulator_StateVector,
    ) -> frc_LinearQuadraticRegulator_InputVector;
}
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type frc_KalmanFilter_StateVector = frc_Vectord;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type frc_KalmanFilter_InputVector = frc_Vectord;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type frc_KalmanFilter_OutputVector = frc_Vectord;
#[doc = " This class is a wrapper around std::array that does compile time size\n checking.\n\n std::array's implicit constructor can result in uninitialized elements if the\n number of arguments doesn't match the std::array size."]
pub type frc_KalmanFilter_StateArray = u8;
#[doc = " This class is a wrapper around std::array that does compile time size\n checking.\n\n std::array's implicit constructor can result in uninitialized elements if the\n number of arguments doesn't match the std::array size."]
pub type frc_KalmanFilter_OutputArray = u8;
extern "C" {
    #[doc = " Project the model into the future with a new control input u.\n\n @param u  New control input from controller.\n @param dt Timestep for prediction."]
    #[link_name = "\u{1}Predict"]
    pub fn frc_KalmanFilter_Predict(
        this: *mut u8,
        u: *const frc_KalmanFilter_InputVector,
        dt: units_time_second_t,
    );
}
extern "C" {
    #[doc = " Correct the state estimate x-hat using the measurements in y.\n\n @param u Same control input used in the last predict step.\n @param y Measurement vector."]
    #[link_name = "\u{1}Correct"]
    pub fn frc_KalmanFilter_Correct(
        this: *mut u8,
        u: *const frc_KalmanFilter_InputVector,
        y: *const frc_KalmanFilter_OutputVector,
    );
}
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type frc_LinearSystemLoop_StateVector = frc_Vectord;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type frc_LinearSystemLoop_InputVector = frc_Vectord;
#[doc = " \\class Matrix\n \\ingroup Core_Module\n\n \\brief The matrix class, also used for vectors and row-vectors\n\n The %Matrix class is the work-horse for all \\em dense (\\ref dense \"note\") matrices and vectors within Eigen.\n Vectors are matrices with one column, and row-vectors are matrices with one row.\n\n The %Matrix class encompasses \\em both fixed-size and dynamic-size objects (\\ref fixedsize \"note\").\n\n The first three template parameters are required:\n \\tparam _Scalar Numeric type, e.g. float, double, int or std::complex<float>.\n                 User defined scalar types are supported as well (see \\ref user_defined_scalars \"here\").\n \\tparam _Rows Number of rows, or \\b Dynamic\n \\tparam _Cols Number of columns, or \\b Dynamic\n\n The remaining template parameters are optional -- in most cases you don't have to worry about them.\n \\tparam _Options A combination of either \\b #RowMajor or \\b #ColMajor, and of either\n                 \\b #AutoAlign or \\b #DontAlign.\n                 The former controls \\ref TopicStorageOrders \"storage order\", and defaults to column-major. The latter controls alignment, which is required\n                 for vectorization. It defaults to aligning matrices except for fixed sizes that aren't a multiple of the packet size.\n \\tparam _MaxRows Maximum number of rows. Defaults to \\a _Rows (\\ref maxrows \"note\").\n \\tparam _MaxCols Maximum number of columns. Defaults to \\a _Cols (\\ref maxrows \"note\").\n\n Eigen provides a number of typedefs covering the usual cases. Here are some examples:\n\n \\li \\c Matrix2d is a 2x2 square matrix of doubles (\\c Matrix<double, 2, 2>)\n \\li \\c Vector4f is a vector of 4 floats (\\c Matrix<float, 4, 1>)\n \\li \\c RowVector3i is a row-vector of 3 ints (\\c Matrix<int, 1, 3>)\n\n \\li \\c MatrixXf is a dynamic-size matrix of floats (\\c Matrix<float, Dynamic, Dynamic>)\n \\li \\c VectorXf is a dynamic-size vector of floats (\\c Matrix<float, Dynamic, 1>)\n\n \\li \\c Matrix2Xf is a partially fixed-size (dynamic-size) matrix of floats (\\c Matrix<float, 2, Dynamic>)\n \\li \\c MatrixX3d is a partially dynamic-size (fixed-size) matrix of double (\\c Matrix<double, Dynamic, 3>)\n\n See \\link matrixtypedefs this page \\endlink for a complete list of predefined \\em %Matrix and \\em Vector typedefs.\n\n You can access elements of vectors and matrices using normal subscripting:\n\n \\code\n Eigen::VectorXd v(10);\n v[0] = 0.1;\n v[1] = 0.2;\n v(0) = 0.3;\n v(1) = 0.4;\n\n Eigen::MatrixXi m(10, 10);\n m(0, 1) = 1;\n m(0, 2) = 2;\n m(0, 3) = 3;\n \\endcode\n\n This class can be extended with the help of the plugin mechanism described on the page\n \\ref TopicCustomizing_Plugins by defining the preprocessor symbol \\c EIGEN_MATRIX_PLUGIN.\n\n <i><b>Some notes:</b></i>\n\n <dl>\n <dt><b>\\anchor dense Dense versus sparse:</b></dt>\n <dd>This %Matrix class handles dense, not sparse matrices and vectors. For sparse matrices and vectors, see the Sparse module.\n\n Dense matrices and vectors are plain usual arrays of coefficients. All the coefficients are stored, in an ordinary contiguous array.\n This is unlike Sparse matrices and vectors where the coefficients are stored as a list of nonzero coefficients.</dd>\n\n <dt><b>\\anchor fixedsize Fixed-size versus dynamic-size:</b></dt>\n <dd>Fixed-size means that the numbers of rows and columns are known are compile-time. In this case, Eigen allocates the array\n of coefficients as a fixed-size array, as a class member. This makes sense for very small matrices, typically up to 4x4, sometimes up\n to 16x16. Larger matrices should be declared as dynamic-size even if one happens to know their size at compile-time.\n\n Dynamic-size means that the numbers of rows or columns are not necessarily known at compile-time. In this case they are runtime\n variables, and the array of coefficients is allocated dynamically on the heap.\n\n Note that \\em dense matrices, be they Fixed-size or Dynamic-size, <em>do not</em> expand dynamically in the sense of a std::map.\n If you want this behavior, see the Sparse module.</dd>\n\n <dt><b>\\anchor maxrows _MaxRows and _MaxCols:</b></dt>\n <dd>In most cases, one just leaves these parameters to the default values.\n These parameters mean the maximum size of rows and columns that the matrix may have. They are useful in cases\n when the exact numbers of rows and columns are not known are compile-time, but it is known at compile-time that they cannot\n exceed a certain value. This happens when taking dynamic-size blocks inside fixed-size matrices: in this case _MaxRows and _MaxCols\n are the dimensions of the original matrix, while _Rows and _Cols are Dynamic.</dd>\n </dl>\n\n <i><b>ABI and storage layout</b></i>\n\n The table below summarizes the ABI of some possible Matrix instances which is fixed thorough the lifetime of Eigen 3.\n <table  class=\"manual\">\n <tr><th>Matrix type</th><th>Equivalent C structure</th></tr>\n <tr><td>\\code Matrix<T,Dynamic,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code\n Matrix<T,Dynamic,1>\n Matrix<T,1,Dynamic> \\endcode</td><td>\\code\n struct {\n   T *data;                  // with (size_t(data)%EIGEN_MAX_ALIGN_BYTES)==0\n   Eigen::Index size;\n  };\n \\endcode</td></tr>\n <tr><td>\\code Matrix<T,Rows,Cols> \\endcode</td><td>\\code\n struct {\n   T data[Rows*Cols];        // with (size_t(data)%A(Rows*Cols*sizeof(T)))==0\n  };\n \\endcode</td></tr>\n <tr class=\"alt\"><td>\\code Matrix<T,Dynamic,Dynamic,0,MaxRows,MaxCols> \\endcode</td><td>\\code\n struct {\n   T data[MaxRows*MaxCols];  // with (size_t(data)%A(MaxRows*MaxCols*sizeof(T)))==0\n   Eigen::Index rows, cols;\n  };\n \\endcode</td></tr>\n </table>\n Note that in this table Rows, Cols, MaxRows and MaxCols are all positive integers. A(S) is defined to the largest possible power-of-two\n smaller to EIGEN_MAX_STATIC_ALIGN_BYTES.\n\n \\see MatrixBase for the majority of the API methods for matrices, \\ref TopicClassHierarchy,\n \\ref TopicStorageOrders"]
pub type frc_LinearSystemLoop_OutputVector = frc_Vectord;
extern "C" {
    #[link_name = "\u{1}kStates"]
    pub static frc_LinearSystemLoop_kStates: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}kInputs"]
    pub static frc_LinearSystemLoop_kInputs: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}kOutputs"]
    pub static frc_LinearSystemLoop_kOutputs: ::std::os::raw::c_int;
}
#[doc = " Holds the constants for a DC motor."]
#[repr(C)]
pub struct frc_DCMotor {
    pub nominalVoltage: units_voltage_volt_t,
    pub stallTorque: units_torque_newton_meter_t,
    pub stallCurrent: units_current_ampere_t,
    pub freeCurrent: units_current_ampere_t,
    pub freeSpeed: units_angular_velocity_radians_per_second_t,
    pub R: units_impedance_ohm_t,
    pub Kv: frc_DCMotor_radians_per_second_per_volt_t,
    pub Kt: frc_DCMotor_newton_meters_per_ampere_t,
}
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type frc_DCMotor_radians_per_second_per_volt_t = units_unit_t;
#[doc = " @ingroup\t\tUnitContainers\n @brief\t\tContainer for values which represent quantities of a given unit.\n @details\t\tStores a value which represents a quantity in the given units. Unit containers\n\t\t\t\t(except scalar values) are *not* convertible to built-in c++ types, in order to\n\t\t\t\tprovide type safety in dimensional analysis. Unit containers *are* implicitly\n\t\t\t\tconvertible to other compatible unit container types. Unit containers support\n\t\t\t\tvarious types of arithmetic operations, depending on their scale type.\n\n\t\t\t\tThe value of a `unit_t` can only be changed on construction, or by assignment\n\t\t\t\tfrom another `unit_t` type. If necessary, the underlying value can be accessed\n\t\t\t\tusing `operator()`: @code\n\t\t\t\tmeter_t m(5.0);\n\t\t\t\tdouble val = m(); // val == 5.0\t@endcode.\n @tparam\t\tUnits unit tag for which type of units the `unit_t` represents (e.g. meters)\n @tparam\t\tT underlying type of the storage. Defaults to double.\n @tparam\t\tNonLinearScale optional scale class for the units. Defaults to linear (i.e. does\n\t\t\t\tnot scale the unit value). Examples of non-linear scales could be logarithmic,\n\t\t\t\tdecibel, or richter scales. Non-linear scales must adhere to the non-linear-scale\n\t\t\t\tconcept, i.e. `is_nonlinear_scale<...>::value` must be `true`.\n @sa\n\t\t\t\t- \\ref lengthContainers \"length unit containers\"\n\t\t\t\t- \\ref massContainers \"mass unit containers\"\n\t\t\t\t- \\ref timeContainers \"time unit containers\"\n\t\t\t\t- \\ref angleContainers \"angle unit containers\"\n\t\t\t\t- \\ref currentContainers \"current unit containers\"\n\t\t\t\t- \\ref temperatureContainers \"temperature unit containers\"\n\t\t\t\t- \\ref substanceContainers \"substance unit containers\"\n\t\t\t\t- \\ref luminousIntensityContainers \"luminous intensity unit containers\"\n\t\t\t\t- \\ref solidAngleContainers \"solid angle unit containers\"\n\t\t\t\t- \\ref frequencyContainers \"frequency unit containers\"\n\t\t\t\t- \\ref velocityContainers \"velocity unit containers\"\n\t\t\t\t- \\ref angularVelocityContainers \"angular velocity unit containers\"\n\t\t\t\t- \\ref accelerationContainers \"acceleration unit containers\"\n\t\t\t\t- \\ref forceContainers \"force unit containers\"\n\t\t\t\t- \\ref pressureContainers \"pressure unit containers\"\n\t\t\t\t- \\ref chargeContainers \"charge unit containers\"\n\t\t\t\t- \\ref energyContainers \"energy unit containers\"\n\t\t\t\t- \\ref powerContainers \"power unit containers\"\n\t\t\t\t- \\ref voltageContainers \"voltage unit containers\"\n\t\t\t\t- \\ref capacitanceContainers \"capacitance unit containers\"\n\t\t\t\t- \\ref impedanceContainers \"impedance unit containers\"\n\t\t\t\t- \\ref magneticFluxContainers \"magnetic flux unit containers\"\n\t\t\t\t- \\ref magneticFieldStrengthContainers \"magnetic field strength unit containers\"\n\t\t\t\t- \\ref inductanceContainers \"inductance unit containers\"\n\t\t\t\t- \\ref luminousFluxContainers \"luminous flux unit containers\"\n\t\t\t\t- \\ref illuminanceContainers \"illuminance unit containers\"\n\t\t\t\t- \\ref radiationContainers \"radiation unit containers\"\n\t\t\t\t- \\ref torqueContainers \"torque unit containers\"\n\t\t\t\t- \\ref areaContainers \"area unit containers\"\n\t\t\t\t- \\ref volumeContainers \"volume unit containers\"\n\t\t\t\t- \\ref densityContainers \"density unit containers\"\n\t\t\t\t- \\ref concentrationContainers \"concentration unit containers\"\n\t\t\t\t- \\ref constantContainers \"constant unit containers\""]
pub type frc_DCMotor_newton_meters_per_ampere_t = units_unit_t;
#[test]
fn bindgen_test_layout_frc_DCMotor() {
    const UNINIT: ::std::mem::MaybeUninit<frc_DCMotor> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_DCMotor>(),
        64usize,
        concat!("Size of: ", stringify!(frc_DCMotor))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_DCMotor>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_DCMotor))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nominalVoltage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DCMotor),
            "::",
            stringify!(nominalVoltage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stallTorque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DCMotor),
            "::",
            stringify!(stallTorque)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stallCurrent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DCMotor),
            "::",
            stringify!(stallCurrent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freeCurrent) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DCMotor),
            "::",
            stringify!(freeCurrent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freeSpeed) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DCMotor),
            "::",
            stringify!(freeSpeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DCMotor),
            "::",
            stringify!(R)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Kv) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DCMotor),
            "::",
            stringify!(Kv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Kt) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_DCMotor),
            "::",
            stringify!(Kt)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_LinearSystemId {
    pub _address: u8,
}
pub type frc_LinearSystemId_Velocity_t = units_unit_t;
pub type frc_LinearSystemId_Acceleration_t = units_unit_t;
#[test]
fn bindgen_test_layout_frc_LinearSystemId() {
    assert_eq!(
        ::std::mem::size_of::<frc_LinearSystemId>(),
        1usize,
        concat!("Size of: ", stringify!(frc_LinearSystemId))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_LinearSystemId>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_LinearSystemId))
    );
}
extern "C" {
    #[doc = " Create a state-space model of the elevator system. The states of the system\n are [position, velocity], inputs are [voltage], and outputs are [position].\n\n @param motor The motor (or gearbox) attached to the carriage.\n @param mass The mass of the elevator carriage, in kilograms.\n @param radius The radius of the elevator's driving drum, in meters.\n @param G Gear ratio from motor to carriage.\n @throws std::domain_error if mass <= 0, radius <= 0, or G <= 0."]
    #[link_name = "\u{1}_ZN3frc14LinearSystemId14ElevatorSystemENS_7DCMotorEN5units6unit_tINS2_4unitISt5ratioILx1000ELx1EENS4_IS5_ILx1ELx1000EENS2_9base_unitIS5_ILx0ELx1EES5_ILx1ELx1EES9_S9_S9_S9_S9_S9_S9_EES9_S9_EES9_S9_EEdNS2_12linear_scaleEEENS3_INS4_ISA_NS8_ISA_S9_S9_S9_S9_S9_S9_S9_S9_EES9_S9_EEdSE_EEd"]
    pub fn frc_LinearSystemId_ElevatorSystem(
        motor: frc_DCMotor,
        mass: units_mass_kilogram_t,
        radius: units_length_meter_t,
        G: f64,
    ) -> [u128; 5usize];
}
extern "C" {
    #[doc = " Create a state-space model of a single-jointed arm system.The states of the\n system are [angle, angular velocity], inputs are [voltage], and outputs are\n [angle].\n\n @param motor The motor (or gearbox) attached to the arm.\n @param J The moment of inertia J of the arm.\n @param G Gear ratio from motor to arm.\n @throws std::domain_error if J <= 0 or G <= 0."]
    #[link_name = "\u{1}_ZN3frc14LinearSystemId22SingleJointedArmSystemENS_7DCMotorEN5units6unit_tINS2_4unitISt5ratioILx1ELx1EENS2_9base_unitIS5_ILx2ELx1EES6_S5_ILx0ELx1EES9_S9_S9_S9_S9_S9_EES9_S9_EEdNS2_12linear_scaleEEEd"]
    pub fn frc_LinearSystemId_SingleJointedArmSystem(
        motor: frc_DCMotor,
        J: units_moment_of_inertia_kilogram_square_meter_t,
        G: f64,
    ) -> [u128; 5usize];
}
extern "C" {
    #[doc = " Identify a differential drive drivetrain given the drivetrain's kV and kA\n in both linear {(volts/(meter/sec), (volts/(meter/sec))} and angular\n {(volts/(radian/sec), (volts/(radian/sec))} cases. These constants can be\n found using SysId.\n\n States: [[left velocity], [right velocity]]<br>\n Inputs: [[left voltage], [right voltage]]<br>\n Outputs: [[left velocity], [right velocity]]\n\n @param kVLinear  The linear velocity gain in volts per (meters per second).\n @param kALinear  The linear acceleration gain in volts per (meters per\n                  second squared).\n @param kVAngular The angular velocity gain in volts per (meters per\n                  second).\n @param kAAngular The angular acceleration gain in volts per (meters per\n                  second squared).\n @throws domain_error if kVLinear <= 0, kALinear <= 0, kVAngular <= 0,\n         or kAAngular <= 0."]
    #[link_name = "\u{1}_ZN3frc14LinearSystemId24IdentifyDrivetrainSystemEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS5_S5_S4_ILxn2ELx1EES4_ILx0ELx1EES4_ILxn1ELx1EES8_S8_S8_S8_EES8_S8_EEdNS1_12linear_scaleEEENS2_INS3_IS5_NS6_IS5_S5_S9_S8_S9_S8_S8_S8_S8_EES8_S8_EEdSC_EESD_SG_"]
    pub fn frc_LinearSystemId_IdentifyDrivetrainSystem(
        kVLinear: u8,
        kALinear: u8,
        kVAngular: u8,
        kAAngular: u8,
    ) -> u8;
}
extern "C" {
    #[doc = " Identify a differential drive drivetrain given the drivetrain's kV and kA\n in both linear {(volts/(meter/sec)), (volts/(meter/sec))} and angular\n {(volts/(radian/sec)), (volts/(radian/sec))} cases. This can be found\n using SysId.\n\n States: [[left velocity], [right velocity]]<br>\n Inputs: [[left voltage], [right voltage]]<br>\n Outputs: [[left velocity], [right velocity]]\n\n @param kVLinear   The linear velocity gain in volts per (meters per\n second).\n @param kALinear   The linear acceleration gain in volts per (meters per\n                   second squared).\n @param kVAngular  The angular velocity gain in volts per (radians per\n                   second).\n @param kAAngular  The angular acceleration gain in volts per (radians per\n                   second squared).\n @param trackwidth The distance between the differential drive's left and\n                   right wheels, in meters.\n @throws domain_error if kVLinear <= 0, kALinear <= 0, kVAngular <= 0,\n         kAAngular <= 0, or trackwidth <= 0."]
    #[link_name = "\u{1}_ZN3frc14LinearSystemId24IdentifyDrivetrainSystemEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS5_S5_S4_ILxn2ELx1EES4_ILx0ELx1EES4_ILxn1ELx1EES8_S8_S8_S8_EES8_S8_EEdNS1_12linear_scaleEEENS2_INS3_IS5_NS6_IS5_S5_S9_S8_S9_S8_S8_S8_S8_EES8_S8_EEdSC_EENS2_INS3_IS5_NS6_IS4_ILx2ELx1EES5_S7_S9_S9_S8_S8_S8_S8_EES8_S8_EEdSC_EENS2_INS3_IS5_NS6_ISH_S5_S9_S9_S9_S8_S8_S8_S8_EES8_S8_EEdSC_EENS2_INS3_IS5_NS6_IS5_S8_S8_S8_S8_S8_S8_S8_S8_EES8_S8_EEdSC_EE"]
    pub fn frc_LinearSystemId_IdentifyDrivetrainSystem1(
        kVLinear: u8,
        kALinear: u8,
        kVAngular: u64,
        kAAngular: u8,
        trackwidth: units_length_meter_t,
    ) -> u8;
}
extern "C" {
    #[doc = " Create a state-space model of a flywheel system, the states of the system\n are [angular velocity], inputs are [voltage], and outputs are [angular\n velocity].\n\n @param motor The motor (or gearbox) attached to the flywheel.\n @param J The moment of inertia J of the flywheel.\n @param G Gear ratio from motor to flywheel.\n @throws std::domain_error if J <= 0 or G <= 0."]
    #[link_name = "\u{1}_ZN3frc14LinearSystemId14FlywheelSystemENS_7DCMotorEN5units6unit_tINS2_4unitISt5ratioILx1ELx1EENS2_9base_unitIS5_ILx2ELx1EES6_S5_ILx0ELx1EES9_S9_S9_S9_S9_S9_EES9_S9_EEdNS2_12linear_scaleEEEd"]
    pub fn frc_LinearSystemId_FlywheelSystem(
        motor: frc_DCMotor,
        J: units_moment_of_inertia_kilogram_square_meter_t,
        G: f64,
    ) -> [u64; 4usize];
}
extern "C" {
    #[doc = " Create a state-space model of a DC motor system. The states of the system\n are [angular position, angular velocity], inputs are [voltage], and outputs\n are [angular position, angular velocity].\n\n @param motor The motor (or gearbox) attached to the system.\n @param J the moment of inertia J of the DC motor.\n @param G Gear ratio from motor to output.\n @throws std::domain_error if J <= 0 or G <= 0."]
    #[link_name = "\u{1}_ZN3frc14LinearSystemId13DCMotorSystemENS_7DCMotorEN5units6unit_tINS2_4unitISt5ratioILx1ELx1EENS2_9base_unitIS5_ILx2ELx1EES6_S5_ILx0ELx1EES9_S9_S9_S9_S9_S9_EES9_S9_EEdNS2_12linear_scaleEEEd"]
    pub fn frc_LinearSystemId_DCMotorSystem(
        motor: frc_DCMotor,
        J: units_moment_of_inertia_kilogram_square_meter_t,
        G: f64,
    ) -> u8;
}
extern "C" {
    #[doc = " Create a state-space model of differential drive drivetrain. In this model,\n the states are [left velocity, right velocity], the inputs are [left\n voltage, right voltage], and the outputs are [left velocity, right\n velocity]\n\n @param motor The motor (or gearbox) driving the drivetrain.\n @param mass The mass of the robot in kilograms.\n @param r The radius of the wheels in meters.\n @param rb The radius of the base (half of the track width), in meters.\n @param J The moment of inertia of the robot.\n @param G Gear ratio from motor to wheel.\n @throws std::domain_error if mass <= 0, r <= 0, rb <= 0, J <= 0, or\n         G <= 0."]
    #[link_name = "\u{1}_ZN3frc14LinearSystemId24DrivetrainVelocitySystemERKNS_7DCMotorEN5units6unit_tINS4_4unitISt5ratioILx1000ELx1EENS6_IS7_ILx1ELx1000EENS4_9base_unitIS7_ILx0ELx1EES7_ILx1ELx1EESB_SB_SB_SB_SB_SB_SB_EESB_SB_EESB_SB_EEdNS4_12linear_scaleEEENS5_INS6_ISC_NSA_ISC_SB_SB_SB_SB_SB_SB_SB_SB_EESB_SB_EEdSG_EESK_NS5_INS6_ISC_NSA_IS7_ILx2ELx1EESC_SB_SB_SB_SB_SB_SB_SB_EESB_SB_EEdSG_EEd"]
    pub fn frc_LinearSystemId_DrivetrainVelocitySystem(
        motor: *const frc_DCMotor,
        mass: units_mass_kilogram_t,
        r: units_length_meter_t,
        rb: units_length_meter_t,
        J: units_moment_of_inertia_kilogram_square_meter_t,
        G: f64,
    ) -> u8;
}
impl frc_LinearSystemId {
    #[inline]
    pub unsafe fn ElevatorSystem(
        motor: frc_DCMotor,
        mass: units_mass_kilogram_t,
        radius: units_length_meter_t,
        G: f64,
    ) -> [u128; 5usize] {
        frc_LinearSystemId_ElevatorSystem(motor, mass, radius, G)
    }
    #[inline]
    pub unsafe fn SingleJointedArmSystem(
        motor: frc_DCMotor,
        J: units_moment_of_inertia_kilogram_square_meter_t,
        G: f64,
    ) -> [u128; 5usize] {
        frc_LinearSystemId_SingleJointedArmSystem(motor, J, G)
    }
    #[inline]
    pub unsafe fn IdentifyDrivetrainSystem(
        kVLinear: u8,
        kALinear: u8,
        kVAngular: u8,
        kAAngular: u8,
    ) -> u8 {
        frc_LinearSystemId_IdentifyDrivetrainSystem(kVLinear, kALinear, kVAngular, kAAngular)
    }
    #[inline]
    pub unsafe fn IdentifyDrivetrainSystem1(
        kVLinear: u8,
        kALinear: u8,
        kVAngular: u64,
        kAAngular: u8,
        trackwidth: units_length_meter_t,
    ) -> u8 {
        frc_LinearSystemId_IdentifyDrivetrainSystem1(
            kVLinear, kALinear, kVAngular, kAAngular, trackwidth,
        )
    }
    #[inline]
    pub unsafe fn FlywheelSystem(
        motor: frc_DCMotor,
        J: units_moment_of_inertia_kilogram_square_meter_t,
        G: f64,
    ) -> [u64; 4usize] {
        frc_LinearSystemId_FlywheelSystem(motor, J, G)
    }
    #[inline]
    pub unsafe fn DCMotorSystem(
        motor: frc_DCMotor,
        J: units_moment_of_inertia_kilogram_square_meter_t,
        G: f64,
    ) -> u8 {
        frc_LinearSystemId_DCMotorSystem(motor, J, G)
    }
    #[inline]
    pub unsafe fn DrivetrainVelocitySystem(
        motor: *const frc_DCMotor,
        mass: units_mass_kilogram_t,
        r: units_length_meter_t,
        rb: units_length_meter_t,
        J: units_moment_of_inertia_kilogram_square_meter_t,
        G: f64,
    ) -> u8 {
        frc_LinearSystemId_DrivetrainVelocitySystem(motor, mass, r, rb, J, G)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_Trajectory {
    _unused: [u8; 0],
}
#[doc = " Game field object on a Field2d."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_FieldObject2d {
    pub m_mutex: wpi_mutex,
    pub m_name: std_string,
    pub m_entry: nt_DoubleArrayEntry,
    pub m_poses: [u64; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_FieldObject2d_private_init {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_frc_FieldObject2d_private_init() {
    assert_eq!(
        ::std::mem::size_of::<frc_FieldObject2d_private_init>(),
        1usize,
        concat!("Size of: ", stringify!(frc_FieldObject2d_private_init))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_FieldObject2d_private_init>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_FieldObject2d_private_init))
    );
}
#[test]
fn bindgen_test_layout_frc_FieldObject2d() {
    const UNINIT: ::std::mem::MaybeUninit<frc_FieldObject2d> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_FieldObject2d>(),
        136usize,
        concat!("Size of: ", stringify!(frc_FieldObject2d))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_FieldObject2d>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_FieldObject2d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mutex) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_FieldObject2d),
            "::",
            stringify!(m_mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_FieldObject2d),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_entry) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_FieldObject2d),
            "::",
            stringify!(m_entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_poses) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_FieldObject2d),
            "::",
            stringify!(m_poses)
        )
    );
}
extern "C" {
    #[doc = " Set the pose from a Pose object.\n\n @param pose 2D pose"]
    #[link_name = "\u{1}_ZN3frc13FieldObject2d7SetPoseERKNS_6Pose2dE"]
    pub fn frc_FieldObject2d_SetPose(this: *mut frc_FieldObject2d, pose: *const frc_Pose2d);
}
extern "C" {
    #[doc = " Set the pose from x, y, and rotation.\n\n @param x X location\n @param y Y location\n @param rotation rotation"]
    #[link_name = "\u{1}_ZN3frc13FieldObject2d7SetPoseEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS5_S4_ILx0ELx1EES7_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEESB_NS_10Rotation2dE"]
    pub fn frc_FieldObject2d_SetPose1(
        this: *mut frc_FieldObject2d,
        x: units_length_meter_t,
        y: units_length_meter_t,
        rotation: frc_Rotation2d,
    );
}
extern "C" {
    #[doc = " Get the pose.\n\n @return 2D pose, or 0,0,0 if unknown / does not exist"]
    #[link_name = "\u{1}_ZNK3frc13FieldObject2d7GetPoseEv"]
    pub fn frc_FieldObject2d_GetPose(this: *const frc_FieldObject2d) -> frc_Pose2d;
}
extern "C" {
    #[doc = " Set multiple poses from an array of Pose objects.\n The total number of poses is limited to 85.\n\n @param poses array of 2D poses"]
    #[link_name = "\u{1}_ZN3frc13FieldObject2d8SetPosesESt4spanIKNS_6Pose2dELj4294967295EE"]
    pub fn frc_FieldObject2d_SetPoses(this: *mut frc_FieldObject2d, poses: u8);
}
extern "C" {
    #[doc = " Set multiple poses from an array of Pose objects.\n The total number of poses is limited to 85.\n\n @param poses array of 2D poses"]
    #[link_name = "\u{1}_ZN3frc13FieldObject2d8SetPosesESt16initializer_listINS_6Pose2dEE"]
    pub fn frc_FieldObject2d_SetPoses1(this: *mut frc_FieldObject2d, poses: u8);
}
extern "C" {
    #[doc = " Sets poses from a trajectory.\n\n @param trajectory The trajectory from which poses should be added."]
    #[link_name = "\u{1}_ZN3frc13FieldObject2d13SetTrajectoryERKNS_10TrajectoryE"]
    pub fn frc_FieldObject2d_SetTrajectory(
        this: *mut frc_FieldObject2d,
        trajectory: *const frc_Trajectory,
    );
}
extern "C" {
    #[doc = " Get multiple poses.\n\n @param obj Object entry\n @return vector of 2D poses"]
    #[link_name = "\u{1}_ZNK3frc13FieldObject2d8GetPosesEv"]
    pub fn frc_FieldObject2d_GetPoses(this: *const frc_FieldObject2d) -> u8;
}
extern "C" {
    #[doc = " Get multiple poses.\n\n @param out output SmallVector to hold 2D poses\n @return span referring to output SmallVector"]
    #[link_name = "\u{1}_ZNK3frc13FieldObject2d8GetPosesERN3wpi15SmallVectorImplINS_6Pose2dEEE"]
    pub fn frc_FieldObject2d_GetPoses1(
        this: *const frc_FieldObject2d,
        out: *mut wpi_SmallVectorImpl,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc13FieldObject2dC1EOS0_"]
    pub fn frc_FieldObject2d_FieldObject2d(
        this: *mut frc_FieldObject2d,
        rhs: *mut frc_FieldObject2d,
    );
}
impl frc_FieldObject2d {
    #[inline]
    pub unsafe fn SetPose(&mut self, pose: *const frc_Pose2d) {
        frc_FieldObject2d_SetPose(self, pose)
    }
    #[inline]
    pub unsafe fn SetPose1(
        &mut self,
        x: units_length_meter_t,
        y: units_length_meter_t,
        rotation: frc_Rotation2d,
    ) {
        frc_FieldObject2d_SetPose1(self, x, y, rotation)
    }
    #[inline]
    pub unsafe fn GetPose(&self) -> frc_Pose2d {
        frc_FieldObject2d_GetPose(self)
    }
    #[inline]
    pub unsafe fn SetPoses(&mut self, poses: u8) {
        frc_FieldObject2d_SetPoses(self, poses)
    }
    #[inline]
    pub unsafe fn SetPoses1(&mut self, poses: u8) {
        frc_FieldObject2d_SetPoses1(self, poses)
    }
    #[inline]
    pub unsafe fn SetTrajectory(&mut self, trajectory: *const frc_Trajectory) {
        frc_FieldObject2d_SetTrajectory(self, trajectory)
    }
    #[inline]
    pub unsafe fn GetPoses(&self) -> u8 {
        frc_FieldObject2d_GetPoses(self)
    }
    #[inline]
    pub unsafe fn GetPoses1(&self, out: *mut wpi_SmallVectorImpl) -> u8 {
        frc_FieldObject2d_GetPoses1(self, out)
    }
    #[inline]
    pub unsafe fn new(rhs: *mut frc_FieldObject2d) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_FieldObject2d_FieldObject2d(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " 2D representation of game field for dashboards.\n\n An object's pose is the location shown on the dashboard view.  Note that\n for the robot, this may or may not match the internal odometry.  For example,\n if the robot is shown at a particular starting location, the pose in this\n class would represent the actual location on the field, but the robot's\n internal state might have a 0,0,0 pose (unless it's initialized to\n something different).\n\n As the user is able to edit the pose, code performing updates should get\n the robot pose, transform it as appropriate (e.g. based on wheel odometry),\n and set the new pose.\n\n This class provides methods to set the robot pose, but other objects can\n also be shown by using the GetObject() function.  Other objects can\n also have multiple poses (which will show the object at multiple locations)."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Field2d {
    pub _base: nt_NTSendable,
    pub m_table: [u32; 2usize],
    pub m_mutex: wpi_mutex,
    pub m_objects: [u32; 3usize],
}
pub type frc_Field2d_Entry = usize;
#[test]
fn bindgen_test_layout_frc_Field2d() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Field2d> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Field2d>(),
        48usize,
        concat!("Size of: ", stringify!(frc_Field2d))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Field2d>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_Field2d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_table) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Field2d),
            "::",
            stringify!(m_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mutex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Field2d),
            "::",
            stringify!(m_mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_objects) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Field2d),
            "::",
            stringify!(m_objects)
        )
    );
}
extern "C" {
    #[doc = " Set the robot pose from a Pose object.\n\n @param pose 2D pose"]
    #[link_name = "\u{1}_ZN3frc7Field2d12SetRobotPoseERKNS_6Pose2dE"]
    pub fn frc_Field2d_SetRobotPose(this: *mut frc_Field2d, pose: *const frc_Pose2d);
}
extern "C" {
    #[doc = " Set the robot pose from x, y, and rotation.\n\n @param x X location\n @param y Y location\n @param rotation rotation"]
    #[link_name = "\u{1}_ZN3frc7Field2d12SetRobotPoseEN5units6unit_tINS1_4unitISt5ratioILx1ELx1EENS1_9base_unitIS5_S4_ILx0ELx1EES7_S7_S7_S7_S7_S7_S7_EES7_S7_EEdNS1_12linear_scaleEEESB_NS_10Rotation2dE"]
    pub fn frc_Field2d_SetRobotPose1(
        this: *mut frc_Field2d,
        x: units_length_meter_t,
        y: units_length_meter_t,
        rotation: frc_Rotation2d,
    );
}
extern "C" {
    #[doc = " Get the robot pose.\n\n @return 2D pose"]
    #[link_name = "\u{1}_ZNK3frc7Field2d12GetRobotPoseEv"]
    pub fn frc_Field2d_GetRobotPose(this: *const frc_Field2d) -> frc_Pose2d;
}
extern "C" {
    #[doc = " Get or create a field object.\n\n @return Field object"]
    #[link_name = "\u{1}_ZN3frc7Field2d9GetObjectESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_Field2d_GetObject(
        this: *mut frc_Field2d,
        name: std_string_view,
    ) -> *mut frc_FieldObject2d;
}
extern "C" {
    #[doc = " Get the robot object.\n\n @return Field object for robot"]
    #[link_name = "\u{1}_ZN3frc7Field2d14GetRobotObjectEv"]
    pub fn frc_Field2d_GetRobotObject(this: *mut frc_Field2d) -> *mut frc_FieldObject2d;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7Field2dC1Ev"]
    pub fn frc_Field2d_Field2d(this: *mut frc_Field2d);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7Field2dC1EOS0_"]
    pub fn frc_Field2d_Field2d1(this: *mut frc_Field2d, rhs: *mut frc_Field2d);
}
impl frc_Field2d {
    #[inline]
    pub unsafe fn SetRobotPose(&mut self, pose: *const frc_Pose2d) {
        frc_Field2d_SetRobotPose(self, pose)
    }
    #[inline]
    pub unsafe fn SetRobotPose1(
        &mut self,
        x: units_length_meter_t,
        y: units_length_meter_t,
        rotation: frc_Rotation2d,
    ) {
        frc_Field2d_SetRobotPose1(self, x, y, rotation)
    }
    #[inline]
    pub unsafe fn GetRobotPose(&self) -> frc_Pose2d {
        frc_Field2d_GetRobotPose(self)
    }
    #[inline]
    pub unsafe fn GetObject(&mut self, name: std_string_view) -> *mut frc_FieldObject2d {
        frc_Field2d_GetObject(self, name)
    }
    #[inline]
    pub unsafe fn GetRobotObject(&mut self) -> *mut frc_FieldObject2d {
        frc_Field2d_GetRobotObject(self)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Field2d_Field2d(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(rhs: *mut frc_Field2d) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Field2d_Field2d1(__bindgen_tmp.as_mut_ptr(), rhs);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc7Field2d12InitSendableERN2nt17NTSendableBuilderE"]
    pub fn frc_Field2d_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut nt_NTSendableBuilder,
    );
}
#[repr(C)]
pub struct frc_MechanismObject2d__bindgen_vtable {
    pub frc_MechanismObject2d_UpdateEntries:
        unsafe extern "C" fn(this: *mut frc_MechanismObject2d, table: [u32; 2usize]),
}
#[doc = " Common base class for all Mechanism2d node types.\n\n To append another node, call Append with the type of node and its\n construction parameters. None of the node types are designed to be\n constructed directly, and are owned by their parent node/container - obtain\n pointers from the Append function or similar factory methods.\n\n @see Mechanism2d."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_MechanismObject2d {
    pub vtable_: *const frc_MechanismObject2d__bindgen_vtable,
    pub m_mutex: wpi_mutex,
    pub m_name: std_string,
    pub m_objects: wpi_StringMap<wpi_MallocAllocator>,
    pub m_table: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_frc_MechanismObject2d() {
    const UNINIT: ::std::mem::MaybeUninit<frc_MechanismObject2d> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_MechanismObject2d>(),
        84usize,
        concat!("Size of: ", stringify!(frc_MechanismObject2d))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_MechanismObject2d>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_MechanismObject2d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mutex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismObject2d),
            "::",
            stringify!(m_mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_name) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismObject2d),
            "::",
            stringify!(m_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_objects) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismObject2d),
            "::",
            stringify!(m_objects)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_table) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismObject2d),
            "::",
            stringify!(m_table)
        )
    );
}
extern "C" {
    #[doc = " Retrieve the object's name.\n\n @return the object's name relative to its parent."]
    #[link_name = "\u{1}_ZNK3frc17MechanismObject2d7GetNameB5cxx11Ev"]
    pub fn frc_MechanismObject2d_GetName(this: *const frc_MechanismObject2d) -> *const std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc17MechanismObject2dC2ESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_MechanismObject2d_MechanismObject2d(
        this: *mut frc_MechanismObject2d,
        name: std_string_view,
    );
}
impl frc_MechanismObject2d {
    #[inline]
    pub unsafe fn GetName(&self) -> *const std_string {
        frc_MechanismObject2d_GetName(self)
    }
    #[inline]
    pub unsafe fn new(name: std_string_view) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_MechanismObject2d_MechanismObject2d(__bindgen_tmp.as_mut_ptr(), name);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Root Mechanism2d node.\n\n A root is the anchor point of other nodes (such as ligaments).\n\n Do not create objects of this class directly! Obtain pointers from the\n Mechanism2d.GetRoot() factory method.\n\n <p>Append other nodes by using Append()."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_MechanismRoot2d {
    pub _base: frc_MechanismObject2d,
    pub m_x: f64,
    pub m_y: f64,
    pub m_xPub: nt_DoublePublisher,
    pub m_yPub: nt_DoublePublisher,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_MechanismRoot2d_private_init {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_frc_MechanismRoot2d_private_init() {
    assert_eq!(
        ::std::mem::size_of::<frc_MechanismRoot2d_private_init>(),
        1usize,
        concat!("Size of: ", stringify!(frc_MechanismRoot2d_private_init))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_MechanismRoot2d_private_init>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(frc_MechanismRoot2d_private_init)
        )
    );
}
#[test]
fn bindgen_test_layout_frc_MechanismRoot2d() {
    const UNINIT: ::std::mem::MaybeUninit<frc_MechanismRoot2d> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_MechanismRoot2d>(),
        120usize,
        concat!("Size of: ", stringify!(frc_MechanismRoot2d))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_MechanismRoot2d>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_MechanismRoot2d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_x) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismRoot2d),
            "::",
            stringify!(m_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_y) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismRoot2d),
            "::",
            stringify!(m_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_xPub) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismRoot2d),
            "::",
            stringify!(m_xPub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_yPub) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismRoot2d),
            "::",
            stringify!(m_yPub)
        )
    );
}
extern "C" {
    #[doc = " Set the root's position.\n\n @param x new x coordinate\n @param y new y coordinate"]
    #[link_name = "\u{1}_ZN3frc15MechanismRoot2d11SetPositionEdd"]
    pub fn frc_MechanismRoot2d_SetPosition(this: *mut frc_MechanismRoot2d, x: f64, y: f64);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc15MechanismRoot2dC1ESt17basic_string_viewIcSt11char_traitsIcEEddRKNS0_12private_initE"]
    pub fn frc_MechanismRoot2d_MechanismRoot2d(
        this: *mut frc_MechanismRoot2d,
        name: std_string_view,
        x: f64,
        y: f64,
        arg1: *const frc_MechanismRoot2d_private_init,
    );
}
impl frc_MechanismRoot2d {
    #[inline]
    pub unsafe fn SetPosition(&mut self, x: f64, y: f64) {
        frc_MechanismRoot2d_SetPosition(self, x, y)
    }
    #[inline]
    pub unsafe fn new(
        name: std_string_view,
        x: f64,
        y: f64,
        arg1: *const frc_MechanismRoot2d_private_init,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_MechanismRoot2d_MechanismRoot2d(__bindgen_tmp.as_mut_ptr(), name, x, y, arg1);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " Visual 2D representation of arms, elevators, and general mechanisms through\n a node-based API.\n\n A Mechanism2d object is published and contains at least one root node. A root\n is the anchor point of other nodes (such as ligaments). Other nodes are\n recursively appended based on other nodes.\n\n Except for the Mechanism2d container object, none of the objects should be\n passed or interacted with by value! Obtain pointers from factory methods such\n as Mechanism2d.GetRoot() and MechanismObject2d.Append<>(). The Mechanism2d\n container object owns the root nodes, and each node internally owns the nodes\n based on it. Beware not to let the Mechanism2d object out of scope - all\n nodes will be recursively destructed!\n\n @see MechanismObject2d\n @see MechanismLigament2d\n @see MechanismRoot2d"]
#[repr(C)]
#[derive(Debug)]
pub struct frc_Mechanism2d {
    pub _base: nt_NTSendable,
    pub m_width: f64,
    pub m_height: f64,
    pub m_color: std_string,
    pub m_mutex: wpi_mutex,
    pub m_table: [u32; 2usize],
    pub m_roots: wpi_StringMap<wpi_MallocAllocator>,
    pub m_dimsPub: nt_DoubleArrayPublisher,
    pub m_colorPub: nt_StringPublisher,
}
#[test]
fn bindgen_test_layout_frc_Mechanism2d() {
    const UNINIT: ::std::mem::MaybeUninit<frc_Mechanism2d> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_Mechanism2d>(),
        120usize,
        concat!("Size of: ", stringify!(frc_Mechanism2d))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Mechanism2d>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_Mechanism2d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Mechanism2d),
            "::",
            stringify!(m_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_height) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Mechanism2d),
            "::",
            stringify!(m_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_color) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Mechanism2d),
            "::",
            stringify!(m_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mutex) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Mechanism2d),
            "::",
            stringify!(m_mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_table) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Mechanism2d),
            "::",
            stringify!(m_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_roots) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Mechanism2d),
            "::",
            stringify!(m_roots)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_dimsPub) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Mechanism2d),
            "::",
            stringify!(m_dimsPub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_colorPub) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_Mechanism2d),
            "::",
            stringify!(m_colorPub)
        )
    );
}
extern "C" {
    #[doc = " Get or create a root in this Mechanism2d with the given name and\n position.\n\n <p>If a root with the given name already exists, the given x and y\n coordinates are not used.\n\n @param name the root name\n @param x the root x coordinate\n @param y the root y coordinate\n @return a new root object, or the existing one with the given name."]
    #[link_name = "\u{1}_ZN3frc11Mechanism2d7GetRootESt17basic_string_viewIcSt11char_traitsIcEEdd"]
    pub fn frc_Mechanism2d_GetRoot(
        this: *mut frc_Mechanism2d,
        name: std_string_view,
        x: f64,
        y: f64,
    ) -> *mut frc_MechanismRoot2d;
}
extern "C" {
    #[doc = " Set the Mechanism2d background color.\n\n @param color the new background color"]
    #[link_name = "\u{1}_ZN3frc11Mechanism2d18SetBackgroundColorERKNS_9Color8BitE"]
    pub fn frc_Mechanism2d_SetBackgroundColor(
        this: *mut frc_Mechanism2d,
        color: *const frc_Color8Bit,
    );
}
extern "C" {
    #[doc = " Create a new Mechanism2d with the given dimensions and background color.\n\n The dimensions represent the canvas that all the nodes are drawn on. The\n default color is dark blue.\n\n @param width the width\n @param height the height\n @param backgroundColor the background color"]
    #[link_name = "\u{1}_ZN3frc11Mechanism2dC1EddRKNS_9Color8BitE"]
    pub fn frc_Mechanism2d_Mechanism2d(
        this: *mut frc_Mechanism2d,
        width: f64,
        height: f64,
        backgroundColor: *const frc_Color8Bit,
    );
}
impl frc_Mechanism2d {
    #[inline]
    pub unsafe fn GetRoot(
        &mut self,
        name: std_string_view,
        x: f64,
        y: f64,
    ) -> *mut frc_MechanismRoot2d {
        frc_Mechanism2d_GetRoot(self, name, x, y)
    }
    #[inline]
    pub unsafe fn SetBackgroundColor(&mut self, color: *const frc_Color8Bit) {
        frc_Mechanism2d_SetBackgroundColor(self, color)
    }
    #[inline]
    pub unsafe fn new(width: f64, height: f64, backgroundColor: *const frc_Color8Bit) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_Mechanism2d_Mechanism2d(__bindgen_tmp.as_mut_ptr(), width, height, backgroundColor);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc11Mechanism2d12InitSendableERN2nt17NTSendableBuilderE"]
    pub fn frc_Mechanism2d_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut nt_NTSendableBuilder,
    );
}
#[doc = " Ligament node on a Mechanism2d.\n\n A ligament can have its length changed (like an elevator) or angle changed,\n like an arm.\n\n @see Mechanism2d"]
#[repr(C)]
#[derive(Debug)]
pub struct frc_MechanismLigament2d {
    pub _base: frc_MechanismObject2d,
    pub m_typePub: nt_StringPublisher,
    pub m_length: f64,
    pub m_lengthEntry: nt_DoubleEntry,
    pub m_angle: f64,
    pub m_angleEntry: nt_DoubleEntry,
    pub m_weight: f64,
    pub m_weightEntry: nt_DoubleEntry,
    pub m_color: [::std::os::raw::c_char; 10usize],
    pub m_colorEntry: nt_StringEntry,
}
#[test]
fn bindgen_test_layout_frc_MechanismLigament2d() {
    const UNINIT: ::std::mem::MaybeUninit<frc_MechanismLigament2d> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_MechanismLigament2d>(),
        248usize,
        concat!("Size of: ", stringify!(frc_MechanismLigament2d))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_MechanismLigament2d>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_MechanismLigament2d))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_typePub) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismLigament2d),
            "::",
            stringify!(m_typePub)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_length) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismLigament2d),
            "::",
            stringify!(m_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_lengthEntry) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismLigament2d),
            "::",
            stringify!(m_lengthEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_angle) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismLigament2d),
            "::",
            stringify!(m_angle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_angleEntry) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismLigament2d),
            "::",
            stringify!(m_angleEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_weight) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismLigament2d),
            "::",
            stringify!(m_weight)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_weightEntry) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismLigament2d),
            "::",
            stringify!(m_weightEntry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_color) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismLigament2d),
            "::",
            stringify!(m_color)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_colorEntry) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_MechanismLigament2d),
            "::",
            stringify!(m_colorEntry)
        )
    );
}
extern "C" {
    #[doc = " Set the ligament color.\n\n @param color the color of the line"]
    #[link_name = "\u{1}_ZN3frc19MechanismLigament2d8SetColorERKNS_9Color8BitE"]
    pub fn frc_MechanismLigament2d_SetColor(
        this: *mut frc_MechanismLigament2d,
        color: *const frc_Color8Bit,
    );
}
extern "C" {
    #[doc = " Get the ligament color.\n\n @return the color of the line"]
    #[link_name = "\u{1}_ZN3frc19MechanismLigament2d8GetColorEv"]
    pub fn frc_MechanismLigament2d_GetColor(this: *mut frc_MechanismLigament2d) -> frc_Color8Bit;
}
extern "C" {
    #[doc = " Set the ligament's length.\n\n @param length the line length"]
    #[link_name = "\u{1}_ZN3frc19MechanismLigament2d9SetLengthEd"]
    pub fn frc_MechanismLigament2d_SetLength(this: *mut frc_MechanismLigament2d, length: f64);
}
extern "C" {
    #[doc = " Get the ligament length.\n\n @return the line length"]
    #[link_name = "\u{1}_ZN3frc19MechanismLigament2d9GetLengthEv"]
    pub fn frc_MechanismLigament2d_GetLength(this: *mut frc_MechanismLigament2d) -> f64;
}
extern "C" {
    #[doc = " Set the ligament's angle relative to its parent.\n\n @param angle the angle"]
    #[link_name = "\u{1}_ZN3frc19MechanismLigament2d8SetAngleEN5units6unit_tINS1_4unitISt5ratioILx1ELx180EENS3_IS4_ILx1ELx1EENS1_9base_unitIS4_ILx0ELx1EES8_S8_S6_S8_S8_S8_S8_S8_EES8_S8_EES6_S8_EEdNS1_12linear_scaleEEE"]
    pub fn frc_MechanismLigament2d_SetAngle(
        this: *mut frc_MechanismLigament2d,
        angle: units_angle_degree_t,
    );
}
extern "C" {
    #[doc = " Get the ligament's angle relative to its parent.\n\n @return the angle"]
    #[link_name = "\u{1}_ZN3frc19MechanismLigament2d8GetAngleEv"]
    pub fn frc_MechanismLigament2d_GetAngle(this: *mut frc_MechanismLigament2d) -> f64;
}
extern "C" {
    #[doc = " Set the line thickness.\n\n @param lineWidth the line thickness"]
    #[link_name = "\u{1}_ZN3frc19MechanismLigament2d13SetLineWeightEd"]
    pub fn frc_MechanismLigament2d_SetLineWeight(
        this: *mut frc_MechanismLigament2d,
        lineWidth: f64,
    );
}
extern "C" {
    #[doc = " Get the line thickness.\n\n @return the line thickness"]
    #[link_name = "\u{1}_ZN3frc19MechanismLigament2d13GetLineWeightEv"]
    pub fn frc_MechanismLigament2d_GetLineWeight(this: *mut frc_MechanismLigament2d) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19MechanismLigament2dC1ESt17basic_string_viewIcSt11char_traitsIcEEdN5units6unit_tINS5_4unitISt5ratioILx1ELx180EENS7_IS8_ILx1ELx1EENS5_9base_unitIS8_ILx0ELx1EESC_SC_SA_SC_SC_SC_SC_SC_EESC_SC_EESA_SC_EEdNS5_12linear_scaleEEEdRKNS_9Color8BitE"]
    pub fn frc_MechanismLigament2d_MechanismLigament2d(
        this: *mut frc_MechanismLigament2d,
        name: std_string_view,
        length: f64,
        angle: units_angle_degree_t,
        lineWidth: f64,
        color: *const frc_Color8Bit,
    );
}
impl frc_MechanismLigament2d {
    #[inline]
    pub unsafe fn SetColor(&mut self, color: *const frc_Color8Bit) {
        frc_MechanismLigament2d_SetColor(self, color)
    }
    #[inline]
    pub unsafe fn GetColor(&mut self) -> frc_Color8Bit {
        frc_MechanismLigament2d_GetColor(self)
    }
    #[inline]
    pub unsafe fn SetLength(&mut self, length: f64) {
        frc_MechanismLigament2d_SetLength(self, length)
    }
    #[inline]
    pub unsafe fn GetLength(&mut self) -> f64 {
        frc_MechanismLigament2d_GetLength(self)
    }
    #[inline]
    pub unsafe fn SetAngle(&mut self, angle: units_angle_degree_t) {
        frc_MechanismLigament2d_SetAngle(self, angle)
    }
    #[inline]
    pub unsafe fn GetAngle(&mut self) -> f64 {
        frc_MechanismLigament2d_GetAngle(self)
    }
    #[inline]
    pub unsafe fn SetLineWeight(&mut self, lineWidth: f64) {
        frc_MechanismLigament2d_SetLineWeight(self, lineWidth)
    }
    #[inline]
    pub unsafe fn GetLineWeight(&mut self) -> f64 {
        frc_MechanismLigament2d_GetLineWeight(self)
    }
    #[inline]
    pub unsafe fn new(
        name: std_string_view,
        length: f64,
        angle: units_angle_degree_t,
        lineWidth: f64,
        color: *const frc_Color8Bit,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_MechanismLigament2d_MechanismLigament2d(
            __bindgen_tmp.as_mut_ptr(),
            name,
            length,
            angle,
            lineWidth,
            color,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19MechanismLigament2d13UpdateEntriesESt10shared_ptrIN2nt12NetworkTableEE"]
    pub fn frc_MechanismLigament2d_UpdateEntries(
        this: *mut ::std::os::raw::c_void,
        table: [u32; 2usize],
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct frc_SendableBuilderImpl {
    pub _base: nt_NTSendableBuilder,
    pub m_properties: [u32; 3usize],
    pub m_safeState: [u32; 4usize],
    pub m_updateTables: [u32; 3usize],
    pub m_table: [u32; 2usize],
    pub m_controllable: bool,
    pub m_actuator: bool,
    pub m_controllablePublisher: nt_BooleanPublisher,
    pub m_typePublisher: nt_StringPublisher,
    pub m_actuatorPublisher: nt_BooleanPublisher,
}
#[repr(C)]
pub struct frc_SendableBuilderImpl_Property__bindgen_vtable {
    pub frc_SendableBuilderImpl_Property_Update: unsafe extern "C" fn(
        this: *mut frc_SendableBuilderImpl_Property,
        controllable: bool,
        time: i64,
    ),
}
#[repr(C)]
#[derive(Debug)]
pub struct frc_SendableBuilderImpl_Property {
    pub vtable_: *const frc_SendableBuilderImpl_Property__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_frc_SendableBuilderImpl_Property() {
    assert_eq!(
        ::std::mem::size_of::<frc_SendableBuilderImpl_Property>(),
        4usize,
        concat!("Size of: ", stringify!(frc_SendableBuilderImpl_Property))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_SendableBuilderImpl_Property>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(frc_SendableBuilderImpl_Property)
        )
    );
}
#[repr(C)]
pub struct frc_SendableBuilderImpl_PropertyImpl {
    pub _base: frc_SendableBuilderImpl_Property,
    pub pub_: frc_SendableBuilderImpl_PropertyImpl_Publisher,
    pub sub: frc_SendableBuilderImpl_PropertyImpl_Subscriber,
    pub updateNetwork: u8,
    pub updateLocal: u8,
}
pub type frc_SendableBuilderImpl_PropertyImpl_Publisher = [u8; 0usize];
pub type frc_SendableBuilderImpl_PropertyImpl_Subscriber = [u8; 0usize];
#[test]
fn bindgen_test_layout_frc_SendableBuilderImpl() {
    const UNINIT: ::std::mem::MaybeUninit<frc_SendableBuilderImpl> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_SendableBuilderImpl>(),
        80usize,
        concat!("Size of: ", stringify!(frc_SendableBuilderImpl))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_SendableBuilderImpl>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_SendableBuilderImpl))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_properties) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableBuilderImpl),
            "::",
            stringify!(m_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_safeState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableBuilderImpl),
            "::",
            stringify!(m_safeState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_updateTables) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableBuilderImpl),
            "::",
            stringify!(m_updateTables)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_table) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableBuilderImpl),
            "::",
            stringify!(m_table)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_controllable) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableBuilderImpl),
            "::",
            stringify!(m_controllable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_actuator) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableBuilderImpl),
            "::",
            stringify!(m_actuator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_controllablePublisher) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableBuilderImpl),
            "::",
            stringify!(m_controllablePublisher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_typePublisher) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableBuilderImpl),
            "::",
            stringify!(m_typePublisher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_actuatorPublisher) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableBuilderImpl),
            "::",
            stringify!(m_actuatorPublisher)
        )
    );
}
extern "C" {
    #[doc = " Set the network table.  Must be called prior to any Add* functions being\n called.\n @param table Network table"]
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl8SetTableESt10shared_ptrIN2nt12NetworkTableEE"]
    pub fn frc_SendableBuilderImpl_SetTable(
        this: *mut frc_SendableBuilderImpl,
        table: [u32; 2usize],
    );
}
extern "C" {
    #[doc = " Return whether this sendable should be treated as an actuator.\n @return True if actuator, false if not."]
    #[link_name = "\u{1}_ZNK3frc19SendableBuilderImpl10IsActuatorEv"]
    pub fn frc_SendableBuilderImpl_IsActuator(this: *const frc_SendableBuilderImpl) -> bool;
}
extern "C" {
    #[doc = " Hook setters for all properties."]
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl14StartListenersEv"]
    pub fn frc_SendableBuilderImpl_StartListeners(this: *mut frc_SendableBuilderImpl);
}
extern "C" {
    #[doc = " Unhook setters for all properties."]
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl13StopListenersEv"]
    pub fn frc_SendableBuilderImpl_StopListeners(this: *mut frc_SendableBuilderImpl);
}
extern "C" {
    #[doc = " Start LiveWindow mode by hooking the setters for all properties.  Also\n calls the SafeState function if one was provided."]
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl19StartLiveWindowModeEv"]
    pub fn frc_SendableBuilderImpl_StartLiveWindowMode(this: *mut frc_SendableBuilderImpl);
}
extern "C" {
    #[doc = " Stop LiveWindow mode by unhooking the setters for all properties.  Also\n calls the SafeState function if one was provided."]
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl18StopLiveWindowModeEv"]
    pub fn frc_SendableBuilderImpl_StopLiveWindowMode(this: *mut frc_SendableBuilderImpl);
}
impl frc_SendableBuilderImpl {
    #[inline]
    pub unsafe fn SetTable(&mut self, table: [u32; 2usize]) {
        frc_SendableBuilderImpl_SetTable(self, table)
    }
    #[inline]
    pub unsafe fn IsActuator(&self) -> bool {
        frc_SendableBuilderImpl_IsActuator(self)
    }
    #[inline]
    pub unsafe fn StartListeners(&mut self) {
        frc_SendableBuilderImpl_StartListeners(self)
    }
    #[inline]
    pub unsafe fn StopListeners(&mut self) {
        frc_SendableBuilderImpl_StopListeners(self)
    }
    #[inline]
    pub unsafe fn StartLiveWindowMode(&mut self) {
        frc_SendableBuilderImpl_StartLiveWindowMode(self)
    }
    #[inline]
    pub unsafe fn StopLiveWindowMode(&mut self) {
        frc_SendableBuilderImpl_StopLiveWindowMode(self)
    }
}
extern "C" {
    #[doc = " Get the network table.\n @return The network table"]
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl8GetTableEv"]
    pub fn frc_SendableBuilderImpl_GetTable(this: *mut ::std::os::raw::c_void) -> [u32; 2usize];
}
extern "C" {
    #[doc = " Return whether this sendable has an associated table.\n @return True if it has a table, false if not."]
    #[link_name = "\u{1}_ZNK3frc19SendableBuilderImpl11IsPublishedEv"]
    pub fn frc_SendableBuilderImpl_IsPublished(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " Synchronize with network table values by calling the getters for all\n properties and setters when the network table value has changed."]
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl6UpdateEv"]
    pub fn frc_SendableBuilderImpl_Update(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Clear properties."]
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl15ClearPropertiesEv"]
    pub fn frc_SendableBuilderImpl_ClearProperties(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl21SetSmartDashboardTypeESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_SendableBuilderImpl_SetSmartDashboardType(
        this: *mut ::std::os::raw::c_void,
        type_: std_string_view,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl11SetActuatorEb"]
    pub fn frc_SendableBuilderImpl_SetActuator(this: *mut ::std::os::raw::c_void, value: bool);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl12SetSafeStateESt8functionIFvvEE"]
    pub fn frc_SendableBuilderImpl_SetSafeState(
        this: *mut ::std::os::raw::c_void,
        func: [u32; 4usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl14SetUpdateTableEN3wpi15unique_functionIFvvEEE"]
    pub fn frc_SendableBuilderImpl_SetUpdateTable(
        this: *mut ::std::os::raw::c_void,
        func: wpi_unique_function,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl8GetTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_SendableBuilderImpl_GetTopic(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
    ) -> nt_Topic;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl18AddBooleanPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFbvEES5_IFvbEE"]
    pub fn frc_SendableBuilderImpl_AddBooleanProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl18AddIntegerPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFxvEES5_IFvxEE"]
    pub fn frc_SendableBuilderImpl_AddIntegerProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl16AddFloatPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFfvEES5_IFvfEE"]
    pub fn frc_SendableBuilderImpl_AddFloatProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl17AddDoublePropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFdvEES5_IFvdEE"]
    pub fn frc_SendableBuilderImpl_AddDoubleProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl17AddStringPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFNSt7__cxx1112basic_stringIcS3_SaIcEEEvEES5_IFvS4_EE"]
    pub fn frc_SendableBuilderImpl_AddStringProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl23AddBooleanArrayPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt6vectorIiSaIiEEvEES5_IFvSt4spanIKiLj4294967295EEEE"]
    pub fn frc_SendableBuilderImpl_AddBooleanArrayProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl23AddIntegerArrayPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt6vectorIxSaIxEEvEES5_IFvSt4spanIKxLj4294967295EEEE"]
    pub fn frc_SendableBuilderImpl_AddIntegerArrayProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl21AddFloatArrayPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt6vectorIfSaIfEEvEES5_IFvSt4spanIKfLj4294967295EEEE"]
    pub fn frc_SendableBuilderImpl_AddFloatArrayProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl22AddDoubleArrayPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt6vectorIdSaIdEEvEES5_IFvSt4spanIKdLj4294967295EEEE"]
    pub fn frc_SendableBuilderImpl_AddDoubleArrayProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl22AddStringArrayPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt6vectorINSt7__cxx1112basic_stringIcS3_SaIcEEESaISA_EEvEES5_IFvSt4spanIKSA_Lj4294967295EEEE"]
    pub fn frc_SendableBuilderImpl_AddStringArrayProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl14AddRawPropertyESt17basic_string_viewIcSt11char_traitsIcEES4_St8functionIFSt6vectorIhSaIhEEvEES5_IFvSt4spanIKhLj4294967295EEEE"]
    pub fn frc_SendableBuilderImpl_AddRawProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        typeString: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl22AddSmallStringPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFS4_RN3wpi15SmallVectorImplIcEEEES5_IFvS4_EE"]
    pub fn frc_SendableBuilderImpl_AddSmallStringProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl28AddSmallBooleanArrayPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt4spanIKiLj4294967295EERN3wpi15SmallVectorImplIiEEEES5_IFvS8_EE"]
    pub fn frc_SendableBuilderImpl_AddSmallBooleanArrayProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl28AddSmallIntegerArrayPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt4spanIKxLj4294967295EERN3wpi15SmallVectorImplIxEEEES5_IFvS8_EE"]
    pub fn frc_SendableBuilderImpl_AddSmallIntegerArrayProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl26AddSmallFloatArrayPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt4spanIKfLj4294967295EERN3wpi15SmallVectorImplIfEEEES5_IFvS8_EE"]
    pub fn frc_SendableBuilderImpl_AddSmallFloatArrayProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl27AddSmallDoubleArrayPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt4spanIKdLj4294967295EERN3wpi15SmallVectorImplIdEEEES5_IFvS8_EE"]
    pub fn frc_SendableBuilderImpl_AddSmallDoubleArrayProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl27AddSmallStringArrayPropertyESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt4spanIKNSt7__cxx1112basic_stringIcS3_SaIcEEELj4294967295EERN3wpi15SmallVectorImplISA_EEEES5_IFvSC_EE"]
    pub fn frc_SendableBuilderImpl_AddSmallStringArrayProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        getter: u8,
        setter: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableBuilderImpl19AddSmallRawPropertyESt17basic_string_viewIcSt11char_traitsIcEES4_St8functionIFSt4spanIhLj4294967295EERN3wpi15SmallVectorImplIhEEEES5_IFvS6_IKhLj4294967295EEEE"]
    pub fn frc_SendableBuilderImpl_AddSmallRawProperty(
        this: *mut ::std::os::raw::c_void,
        key: std_string_view,
        typeString: std_string_view,
        getter: u8,
        setter: u8,
    );
}
#[doc = " This class is a non-template base class for SendableChooser.\n\n It contains static, non-templated variables to avoid their duplication in the\n template class."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_SendableChooserBase {
    pub _base: nt_NTSendable,
    pub m_defaultChoice: std_string,
    pub m_selected: std_string,
    pub m_haveSelected: bool,
    pub m_instancePubs: [u32; 7usize],
    pub m_activePubs: [u32; 7usize],
    pub m_mutex: wpi_mutex,
    pub m_instance: ::std::os::raw::c_int,
}
pub const frc_SendableChooserBase_kDefault: &[u8; 8usize] = b"default\0";
pub const frc_SendableChooserBase_kOptions: &[u8; 8usize] = b"options\0";
pub const frc_SendableChooserBase_kSelected: &[u8; 9usize] = b"selected\0";
pub const frc_SendableChooserBase_kActive: &[u8; 7usize] = b"active\0";
pub const frc_SendableChooserBase_kInstance: &[u8; 10usize] = b".instance\0";
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableChooserBase11s_instancesE"]
    pub static mut frc_SendableChooserBase_s_instances: std_atomic_int;
}
#[test]
fn bindgen_test_layout_frc_SendableChooserBase() {
    const UNINIT: ::std::mem::MaybeUninit<frc_SendableChooserBase> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_SendableChooserBase>(),
        140usize,
        concat!("Size of: ", stringify!(frc_SendableChooserBase))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_SendableChooserBase>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_SendableChooserBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultChoice) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableChooserBase),
            "::",
            stringify!(m_defaultChoice)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_selected) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableChooserBase),
            "::",
            stringify!(m_selected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_haveSelected) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableChooserBase),
            "::",
            stringify!(m_haveSelected)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_instancePubs) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableChooserBase),
            "::",
            stringify!(m_instancePubs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_activePubs) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableChooserBase),
            "::",
            stringify!(m_activePubs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mutex) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableChooserBase),
            "::",
            stringify!(m_mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_instance) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableChooserBase),
            "::",
            stringify!(m_instance)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableChooserBaseC2Ev"]
    pub fn frc_SendableChooserBase_SendableChooserBase(this: *mut frc_SendableChooserBase);
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc19SendableChooserBaseC2EOS0_"]
    pub fn frc_SendableChooserBase_SendableChooserBase1(
        this: *mut frc_SendableChooserBase,
        oth: *mut frc_SendableChooserBase,
    );
}
impl frc_SendableChooserBase {
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_SendableChooserBase_SendableChooserBase(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(oth: *mut frc_SendableChooserBase) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_SendableChooserBase_SendableChooserBase1(__bindgen_tmp.as_mut_ptr(), oth);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " The SendableChooser class is a useful tool for presenting a selection of\n options to the SmartDashboard.\n\n For instance, you may wish to be able to select between multiple autonomous\n modes. You can do this by putting every possible Command you want to run as\n an autonomous into a SendableChooser and then put it into the SmartDashboard\n to have a list of options appear on the laptop. Once autonomous starts,\n simply ask the SendableChooser what the selected value is.\n\n @tparam T The type of values to be stored\n @see SmartDashboard"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_SendableChooser {}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_SmartDashboard {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_frc_SmartDashboard() {
    assert_eq!(
        ::std::mem::size_of::<frc_SmartDashboard>(),
        1usize,
        concat!("Size of: ", stringify!(frc_SmartDashboard))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_SmartDashboard>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_SmartDashboard))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc14SmartDashboard4initEv"]
    pub fn frc_SmartDashboard_init();
}
extern "C" {
    #[doc = " Determines whether the given key is in this table.\n\n @param key the key to search for\n @return true if the table as a value assigned to the given key"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard11ContainsKeyESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_SmartDashboard_ContainsKey(key: std_string_view) -> bool;
}
extern "C" {
    #[doc = " @param types bitmask of types; 0 is treated as a \"don't care\".\n @return keys currently in the table"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard7GetKeysB5cxx11Ei"]
    pub fn frc_SmartDashboard_GetKeys(types: ::std::os::raw::c_int) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Makes a key's value persistent through program restarts.\n\n @param key the key to make persistent"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard13SetPersistentESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_SmartDashboard_SetPersistent(key: std_string_view);
}
extern "C" {
    #[doc = " Stop making a key's value persistent through program restarts.\n The key cannot be null.\n\n @param key the key name"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard15ClearPersistentESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_SmartDashboard_ClearPersistent(key: std_string_view);
}
extern "C" {
    #[doc = " Returns whether the value is persistent through program restarts.\n The key cannot be null.\n\n @param key the key name"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard12IsPersistentESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_SmartDashboard_IsPersistent(key: std_string_view) -> bool;
}
extern "C" {
    #[doc = " Returns an NT Entry mapping to the specified key\n\n This is useful if an entry is used often, or is read and then modified.\n\n @param key the key\n @return    the entry for the key"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard8GetEntryESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_SmartDashboard_GetEntry(key: std_string_view) -> nt_NetworkTableEntry;
}
extern "C" {
    #[doc = " Maps the specified key to the specified value in this table.\n\n The value can be retrieved by calling the get method with a key that is\n equal to the original key.\n\n In order for the value to appear in the dashboard, it must be registered\n with SendableRegistry.  WPILib components do this automatically.\n\n @param key  the key\n @param data the value"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard7PutDataESt17basic_string_viewIcSt11char_traitsIcEEPN3wpi8SendableE"]
    pub fn frc_SmartDashboard_PutData(key: std_string_view, data: *mut wpi_Sendable);
}
extern "C" {
    #[doc = " Maps the specified key (where the key is the name of the Sendable)\n to the specified value in this table.\n\n The value can be retrieved by calling the get method with a key that is\n equal to the original key.\n\n In order for the value to appear in the dashboard, it must be registered\n with SendableRegistry.  WPILib components do this automatically.\n\n @param value the value"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard7PutDataEPN3wpi8SendableE"]
    pub fn frc_SmartDashboard_PutData1(value: *mut wpi_Sendable);
}
extern "C" {
    #[doc = " Returns the value at the specified key.\n\n @param keyName the key\n @return the value"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard7GetDataESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_SmartDashboard_GetData(keyName: std_string_view) -> *mut wpi_Sendable;
}
extern "C" {
    #[doc = " Maps the specified key to the specified value in this table.\n\n The value can be retrieved by calling the get method with a key that is\n equal to the original key.\n\n @param keyName the key\n @param value   the value\n @return        False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard10PutBooleanESt17basic_string_viewIcSt11char_traitsIcEEb"]
    pub fn frc_SmartDashboard_PutBoolean(keyName: std_string_view, value: bool) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n @param key the key\n @param defaultValue the default value to set if key doesn't exist.\n @returns False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard17SetDefaultBooleanESt17basic_string_viewIcSt11char_traitsIcEEb"]
    pub fn frc_SmartDashboard_SetDefaultBoolean(key: std_string_view, defaultValue: bool) -> bool;
}
extern "C" {
    #[doc = " Returns the value at the specified key.\n\n If the key is not found, returns the default value.\n\n @param keyName the key\n @param defaultValue the default value to set if key doesn't exist\n @return the value"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard10GetBooleanESt17basic_string_viewIcSt11char_traitsIcEEb"]
    pub fn frc_SmartDashboard_GetBoolean(keyName: std_string_view, defaultValue: bool) -> bool;
}
extern "C" {
    #[doc = " Maps the specified key to the specified value in this table.\n\n The value can be retrieved by calling the get method with a key that is\n equal to the original key.\n\n @param keyName the key\n @param value   the value\n @return        False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard9PutNumberESt17basic_string_viewIcSt11char_traitsIcEEd"]
    pub fn frc_SmartDashboard_PutNumber(keyName: std_string_view, value: f64) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key          The key.\n @param defaultValue The default value to set if key doesn't exist.\n @returns False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard16SetDefaultNumberESt17basic_string_viewIcSt11char_traitsIcEEd"]
    pub fn frc_SmartDashboard_SetDefaultNumber(key: std_string_view, defaultValue: f64) -> bool;
}
extern "C" {
    #[doc = " Returns the value at the specified key.\n\n If the key is not found, returns the default value.\n\n @param keyName the key\n @param defaultValue the default value to set if the key doesn't exist\n @return the value"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard9GetNumberESt17basic_string_viewIcSt11char_traitsIcEEd"]
    pub fn frc_SmartDashboard_GetNumber(keyName: std_string_view, defaultValue: f64) -> f64;
}
extern "C" {
    #[doc = " Maps the specified key to the specified value in this table.\n\n The value can be retrieved by calling the get method with a key that is\n equal to the original key.\n\n @param keyName the key\n @param value   the value\n @return        False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard9PutStringESt17basic_string_viewIcSt11char_traitsIcEES4_"]
    pub fn frc_SmartDashboard_PutString(keyName: std_string_view, value: std_string_view) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key the key\n @param defaultValue the default value to set if key doesn't exist.\n @returns False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard16SetDefaultStringESt17basic_string_viewIcSt11char_traitsIcEES4_"]
    pub fn frc_SmartDashboard_SetDefaultString(
        key: std_string_view,
        defaultValue: std_string_view,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the value at the specified key.\n\n If the key is not found, returns the default value.\n\n @param keyName the key\n @param defaultValue the default value to set if the key doesn't exist\n @return the value"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard9GetStringB5cxx11ESt17basic_string_viewIcSt11char_traitsIcEES4_"]
    pub fn frc_SmartDashboard_GetString(
        keyName: std_string_view,
        defaultValue: std_string_view,
    ) -> std_string;
}
extern "C" {
    #[doc = " Put a boolean array in the table.\n\n @param key the key to be assigned to\n @param value the value that will be assigned\n @return False if the table key already exists with a different type\n\n @note The array must be of int's rather than of bool's because\n       std::vector<bool> is special-cased in C++. 0 is false, any\n       non-zero value is true."]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard15PutBooleanArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKiLj4294967295EE"]
    pub fn frc_SmartDashboard_PutBooleanArray(key: std_string_view, value: [u32; 2usize]) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key the key\n @param defaultValue the default value to set if key doesn't exist.\n @returns False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard22SetDefaultBooleanArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKiLj4294967295EE"]
    pub fn frc_SmartDashboard_SetDefaultBooleanArray(
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the boolean array the key maps to.\n\n If the key does not exist or is of different type, it will return the\n default value.\n\n @param key          The key to look up.\n @param defaultValue The value to be returned if no value is found.\n @return the value associated with the given key or the given default value\n         if there is no value associated with the key\n\n @note This makes a copy of the array. If the overhead of this is a concern,\n       use GetValue() instead.\n\n @note The returned array is std::vector<int> instead of std::vector<bool>\n       because std::vector<bool> is special-cased in C++. 0 is false, any\n       non-zero value is true."]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard15GetBooleanArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKiLj4294967295EE"]
    pub fn frc_SmartDashboard_GetBooleanArray(
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Put a number array in the table.\n\n @param key   The key to be assigned to.\n @param value The value that will be assigned.\n @return False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard14PutNumberArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKdLj4294967295EE"]
    pub fn frc_SmartDashboard_PutNumberArray(key: std_string_view, value: [u32; 2usize]) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key          The key.\n @param defaultValue The default value to set if key doesn't exist.\n @returns False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard21SetDefaultNumberArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKdLj4294967295EE"]
    pub fn frc_SmartDashboard_SetDefaultNumberArray(
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the number array the key maps to.\n\n If the key does not exist or is of different type, it will return the\n default value.\n\n @param key The key to look up.\n @param defaultValue The value to be returned if no value is found.\n @return the value associated with the given key or the given default value\n if there is no value associated with the key\n\n @note This makes a copy of the array. If the overhead of this is a concern,\n       use GetValue() instead."]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard14GetNumberArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKdLj4294967295EE"]
    pub fn frc_SmartDashboard_GetNumberArray(
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Put a string array in the table.\n\n @param key   The key to be assigned to.\n @param value The value that will be assigned.\n @return False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard14PutStringArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKNSt7__cxx1112basic_stringIcS3_SaIcEEELj4294967295EE"]
    pub fn frc_SmartDashboard_PutStringArray(key: std_string_view, value: [u32; 2usize]) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key          The key.\n @param defaultValue The default value to set if key doesn't exist.\n @returns False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard21SetDefaultStringArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKNSt7__cxx1112basic_stringIcS3_SaIcEEELj4294967295EE"]
    pub fn frc_SmartDashboard_SetDefaultStringArray(
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the string array the key maps to.\n\n If the key does not exist or is of different type, it will return the\n default value.\n\n @param key          The key to look up.\n @param defaultValue The value to be returned if no value is found.\n @return the value associated with the given key or the given default value\n if there is no value associated with the key\n\n @note This makes a copy of the array. If the overhead of this is a concern,\n       use GetValue() instead."]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard14GetStringArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKNSt7__cxx1112basic_stringIcS3_SaIcEEELj4294967295EE"]
    pub fn frc_SmartDashboard_GetStringArray(
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Put a raw value (byte array) in the table.\n\n @param key   The key to be assigned to.\n @param value The value that will be assigned.\n @return False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard6PutRawESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKhLj4294967295EE"]
    pub fn frc_SmartDashboard_PutRaw(key: std_string_view, value: [u32; 2usize]) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key          The key.\n @param defaultValue The default value to set if key doesn't exist.\n @returns False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard13SetDefaultRawESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKhLj4294967295EE"]
    pub fn frc_SmartDashboard_SetDefaultRaw(
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the raw value (byte array) the key maps to.\n\n If the key does not exist or is of different type, it will return the\n default value.\n\n @param key          The key to look up.\n @param defaultValue The value to be returned if no value is found.\n @return the value associated with the given key or the given default value\n         if there is no value associated with the key\n\n @note This makes a copy of the raw contents. If the overhead of this is a\n       concern, use GetValue() instead."]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard6GetRawESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKhLj4294967295EE"]
    pub fn frc_SmartDashboard_GetRaw(
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Maps the specified key to the specified complex value (such as an array) in\n this table.\n\n The value can be retrieved by calling the RetrieveValue method with a key\n that is equal to the original key.\n\n @param keyName the key\n @param value   the value\n @return        False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard8PutValueESt17basic_string_viewIcSt11char_traitsIcEERKN2nt5ValueE"]
    pub fn frc_SmartDashboard_PutValue(keyName: std_string_view, value: *const nt_Value) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key the key\n @param defaultValue The default value to set if key doesn't exist.\n @returns False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard15SetDefaultValueESt17basic_string_viewIcSt11char_traitsIcEERKN2nt5ValueE"]
    pub fn frc_SmartDashboard_SetDefaultValue(
        key: std_string_view,
        defaultValue: *const nt_Value,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieves the complex value (such as an array) in this table into the\n complex data object.\n\n @param keyName the key"]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard8GetValueESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_SmartDashboard_GetValue(keyName: std_string_view) -> nt_Value;
}
extern "C" {
    #[doc = " Posts a task from a listener to the ListenerExecutor, so that it can be run\n synchronously from the main loop on the next call to updateValues().\n\n @param task The task to run synchronously from the main thread."]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard16PostListenerTaskESt8functionIFvvEE"]
    pub fn frc_SmartDashboard_PostListenerTask(task: [u32; 4usize]);
}
extern "C" {
    #[doc = " Puts all sendable data to the dashboard."]
    #[link_name = "\u{1}_ZN3frc14SmartDashboard12UpdateValuesEv"]
    pub fn frc_SmartDashboard_UpdateValues();
}
impl frc_SmartDashboard {
    #[inline]
    pub unsafe fn init() {
        frc_SmartDashboard_init()
    }
    #[inline]
    pub unsafe fn ContainsKey(key: std_string_view) -> bool {
        frc_SmartDashboard_ContainsKey(key)
    }
    #[inline]
    pub unsafe fn GetKeys(types: ::std::os::raw::c_int) -> [u32; 3usize] {
        frc_SmartDashboard_GetKeys(types)
    }
    #[inline]
    pub unsafe fn SetPersistent(key: std_string_view) {
        frc_SmartDashboard_SetPersistent(key)
    }
    #[inline]
    pub unsafe fn ClearPersistent(key: std_string_view) {
        frc_SmartDashboard_ClearPersistent(key)
    }
    #[inline]
    pub unsafe fn IsPersistent(key: std_string_view) -> bool {
        frc_SmartDashboard_IsPersistent(key)
    }
    #[inline]
    pub unsafe fn GetEntry(key: std_string_view) -> nt_NetworkTableEntry {
        frc_SmartDashboard_GetEntry(key)
    }
    #[inline]
    pub unsafe fn PutData(key: std_string_view, data: *mut wpi_Sendable) {
        frc_SmartDashboard_PutData(key, data)
    }
    #[inline]
    pub unsafe fn PutData1(value: *mut wpi_Sendable) {
        frc_SmartDashboard_PutData1(value)
    }
    #[inline]
    pub unsafe fn GetData(keyName: std_string_view) -> *mut wpi_Sendable {
        frc_SmartDashboard_GetData(keyName)
    }
    #[inline]
    pub unsafe fn PutBoolean(keyName: std_string_view, value: bool) -> bool {
        frc_SmartDashboard_PutBoolean(keyName, value)
    }
    #[inline]
    pub unsafe fn SetDefaultBoolean(key: std_string_view, defaultValue: bool) -> bool {
        frc_SmartDashboard_SetDefaultBoolean(key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetBoolean(keyName: std_string_view, defaultValue: bool) -> bool {
        frc_SmartDashboard_GetBoolean(keyName, defaultValue)
    }
    #[inline]
    pub unsafe fn PutNumber(keyName: std_string_view, value: f64) -> bool {
        frc_SmartDashboard_PutNumber(keyName, value)
    }
    #[inline]
    pub unsafe fn SetDefaultNumber(key: std_string_view, defaultValue: f64) -> bool {
        frc_SmartDashboard_SetDefaultNumber(key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetNumber(keyName: std_string_view, defaultValue: f64) -> f64 {
        frc_SmartDashboard_GetNumber(keyName, defaultValue)
    }
    #[inline]
    pub unsafe fn PutString(keyName: std_string_view, value: std_string_view) -> bool {
        frc_SmartDashboard_PutString(keyName, value)
    }
    #[inline]
    pub unsafe fn SetDefaultString(key: std_string_view, defaultValue: std_string_view) -> bool {
        frc_SmartDashboard_SetDefaultString(key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetString(keyName: std_string_view, defaultValue: std_string_view) -> std_string {
        frc_SmartDashboard_GetString(keyName, defaultValue)
    }
    #[inline]
    pub unsafe fn PutBooleanArray(key: std_string_view, value: [u32; 2usize]) -> bool {
        frc_SmartDashboard_PutBooleanArray(key, value)
    }
    #[inline]
    pub unsafe fn SetDefaultBooleanArray(
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> bool {
        frc_SmartDashboard_SetDefaultBooleanArray(key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetBooleanArray(
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize] {
        frc_SmartDashboard_GetBooleanArray(key, defaultValue)
    }
    #[inline]
    pub unsafe fn PutNumberArray(key: std_string_view, value: [u32; 2usize]) -> bool {
        frc_SmartDashboard_PutNumberArray(key, value)
    }
    #[inline]
    pub unsafe fn SetDefaultNumberArray(key: std_string_view, defaultValue: [u32; 2usize]) -> bool {
        frc_SmartDashboard_SetDefaultNumberArray(key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetNumberArray(
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize] {
        frc_SmartDashboard_GetNumberArray(key, defaultValue)
    }
    #[inline]
    pub unsafe fn PutStringArray(key: std_string_view, value: [u32; 2usize]) -> bool {
        frc_SmartDashboard_PutStringArray(key, value)
    }
    #[inline]
    pub unsafe fn SetDefaultStringArray(key: std_string_view, defaultValue: [u32; 2usize]) -> bool {
        frc_SmartDashboard_SetDefaultStringArray(key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetStringArray(
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize] {
        frc_SmartDashboard_GetStringArray(key, defaultValue)
    }
    #[inline]
    pub unsafe fn PutRaw(key: std_string_view, value: [u32; 2usize]) -> bool {
        frc_SmartDashboard_PutRaw(key, value)
    }
    #[inline]
    pub unsafe fn SetDefaultRaw(key: std_string_view, defaultValue: [u32; 2usize]) -> bool {
        frc_SmartDashboard_SetDefaultRaw(key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetRaw(key: std_string_view, defaultValue: [u32; 2usize]) -> [u32; 3usize] {
        frc_SmartDashboard_GetRaw(key, defaultValue)
    }
    #[inline]
    pub unsafe fn PutValue(keyName: std_string_view, value: *const nt_Value) -> bool {
        frc_SmartDashboard_PutValue(keyName, value)
    }
    #[inline]
    pub unsafe fn SetDefaultValue(key: std_string_view, defaultValue: *const nt_Value) -> bool {
        frc_SmartDashboard_SetDefaultValue(key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetValue(keyName: std_string_view) -> nt_Value {
        frc_SmartDashboard_GetValue(keyName)
    }
    #[inline]
    pub unsafe fn PostListenerTask(task: [u32; 4usize]) {
        frc_SmartDashboard_PostListenerTask(task)
    }
    #[inline]
    pub unsafe fn UpdateValues() {
        frc_SmartDashboard_UpdateValues()
    }
}
#[doc = " The LiveWindow class is the public interface for putting sensors and\n actuators on the LiveWindow."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_LiveWindow {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_frc_LiveWindow() {
    assert_eq!(
        ::std::mem::size_of::<frc_LiveWindow>(),
        1usize,
        concat!("Size of: ", stringify!(frc_LiveWindow))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_LiveWindow>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_LiveWindow))
    );
}
extern "C" {
    #[doc = " Set function to be called when LiveWindow is enabled.\n\n @param func function (or nullptr for none)"]
    #[link_name = "\u{1}_ZN3frc10LiveWindow18SetEnabledCallbackESt8functionIFvvEE"]
    pub fn frc_LiveWindow_SetEnabledCallback(func: [u32; 4usize]);
}
extern "C" {
    #[doc = " Set function to be called when LiveWindow is disabled.\n\n @param func function (or nullptr for none)"]
    #[link_name = "\u{1}_ZN3frc10LiveWindow19SetDisabledCallbackESt8functionIFvvEE"]
    pub fn frc_LiveWindow_SetDisabledCallback(func: [u32; 4usize]);
}
extern "C" {
    #[doc = " Enable telemetry for a single component.\n\n @param component sendable"]
    #[link_name = "\u{1}_ZN3frc10LiveWindow15EnableTelemetryEPN3wpi8SendableE"]
    pub fn frc_LiveWindow_EnableTelemetry(component: *mut wpi_Sendable);
}
extern "C" {
    #[doc = " Disable telemetry for a single component.\n\n @param component sendable"]
    #[link_name = "\u{1}_ZN3frc10LiveWindow16DisableTelemetryEPN3wpi8SendableE"]
    pub fn frc_LiveWindow_DisableTelemetry(component: *mut wpi_Sendable);
}
extern "C" {
    #[doc = " Disable ALL telemetry."]
    #[link_name = "\u{1}_ZN3frc10LiveWindow19DisableAllTelemetryEv"]
    pub fn frc_LiveWindow_DisableAllTelemetry();
}
extern "C" {
    #[doc = " Enable ALL telemetry."]
    #[link_name = "\u{1}_ZN3frc10LiveWindow18EnableAllTelemetryEv"]
    pub fn frc_LiveWindow_EnableAllTelemetry();
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc10LiveWindow9IsEnabledEv"]
    pub fn frc_LiveWindow_IsEnabled() -> bool;
}
extern "C" {
    #[doc = " Change the enabled status of LiveWindow.\n\n If it changes to enabled, start livewindow running otherwise stop it"]
    #[link_name = "\u{1}_ZN3frc10LiveWindow10SetEnabledEb"]
    pub fn frc_LiveWindow_SetEnabled(enabled: bool);
}
extern "C" {
    #[doc = " Tell all the sensors to update (send) their values.\n\n Actuators are handled through callbacks on their value changing from the\n SmartDashboard widgets."]
    #[link_name = "\u{1}_ZN3frc10LiveWindow12UpdateValuesEv"]
    pub fn frc_LiveWindow_UpdateValues();
}
impl frc_LiveWindow {
    #[inline]
    pub unsafe fn SetEnabledCallback(func: [u32; 4usize]) {
        frc_LiveWindow_SetEnabledCallback(func)
    }
    #[inline]
    pub unsafe fn SetDisabledCallback(func: [u32; 4usize]) {
        frc_LiveWindow_SetDisabledCallback(func)
    }
    #[inline]
    pub unsafe fn EnableTelemetry(component: *mut wpi_Sendable) {
        frc_LiveWindow_EnableTelemetry(component)
    }
    #[inline]
    pub unsafe fn DisableTelemetry(component: *mut wpi_Sendable) {
        frc_LiveWindow_DisableTelemetry(component)
    }
    #[inline]
    pub unsafe fn DisableAllTelemetry() {
        frc_LiveWindow_DisableAllTelemetry()
    }
    #[inline]
    pub unsafe fn EnableAllTelemetry() {
        frc_LiveWindow_EnableAllTelemetry()
    }
    #[inline]
    pub unsafe fn IsEnabled() -> bool {
        frc_LiveWindow_IsEnabled()
    }
    #[inline]
    pub unsafe fn SetEnabled(enabled: bool) {
        frc_LiveWindow_SetEnabled(enabled)
    }
    #[inline]
    pub unsafe fn UpdateValues() {
        frc_LiveWindow_UpdateValues()
    }
}
pub const frc_ShuffleboardEventImportance_kTrivial: frc_ShuffleboardEventImportance = 0;
pub const frc_ShuffleboardEventImportance_kLow: frc_ShuffleboardEventImportance = 1;
pub const frc_ShuffleboardEventImportance_kNormal: frc_ShuffleboardEventImportance = 2;
pub const frc_ShuffleboardEventImportance_kHigh: frc_ShuffleboardEventImportance = 3;
pub const frc_ShuffleboardEventImportance_kCritical: frc_ShuffleboardEventImportance = 4;
pub type frc_ShuffleboardEventImportance = ::std::os::raw::c_uint;
#[repr(C)]
pub struct frc_ShuffleboardRoot__bindgen_vtable {
    pub frc_ShuffleboardRoot_GetTab: unsafe extern "C" fn(
        this: *mut frc_ShuffleboardRoot,
        title: std_string_view,
    ) -> *mut frc_ShuffleboardTab,
    pub frc_ShuffleboardRoot_Update: unsafe extern "C" fn(this: *mut frc_ShuffleboardRoot),
    pub frc_ShuffleboardRoot_EnableActuatorWidgets:
        unsafe extern "C" fn(this: *mut frc_ShuffleboardRoot),
    pub frc_ShuffleboardRoot_DisableActuatorWidgets:
        unsafe extern "C" fn(this: *mut frc_ShuffleboardRoot),
    pub frc_ShuffleboardRoot_SelectTab:
        unsafe extern "C" fn(this: *mut frc_ShuffleboardRoot, index: ::std::os::raw::c_int),
    pub frc_ShuffleboardRoot_SelectTab1:
        unsafe extern "C" fn(this: *mut frc_ShuffleboardRoot, title: std_string_view),
}
#[doc = " The root of the data placed in Shuffleboard. It contains the tabs, but no\n data is placed directly in the root.\n\n This class is package-private to minimize API surface area."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_ShuffleboardRoot {
    pub vtable_: *const frc_ShuffleboardRoot__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_frc_ShuffleboardRoot() {
    assert_eq!(
        ::std::mem::size_of::<frc_ShuffleboardRoot>(),
        4usize,
        concat!("Size of: ", stringify!(frc_ShuffleboardRoot))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ShuffleboardRoot>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_ShuffleboardRoot))
    );
}
#[doc = " Represents the type of a layout in Shuffleboard. Using this is preferred over\n specifying raw strings, to avoid typos and having to know or look up the\n exact string name for a desired layout.\n\n @see BuiltInLayouts the built-in layout types"]
#[repr(C)]
#[derive(Debug)]
pub struct frc_LayoutType {
    pub m_layoutName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_frc_LayoutType() {
    const UNINIT: ::std::mem::MaybeUninit<frc_LayoutType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_LayoutType>(),
        4usize,
        concat!("Size of: ", stringify!(frc_LayoutType))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_LayoutType>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_LayoutType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_layoutName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_LayoutType),
            "::",
            stringify!(m_layoutName)
        )
    );
}
extern "C" {
    #[doc = " Gets the string type of the layout as defined by that layout in\n Shuffleboard."]
    #[link_name = "\u{1}_ZNK3frc10LayoutType13GetLayoutNameEv"]
    pub fn frc_LayoutType_GetLayoutName(this: *const frc_LayoutType) -> std_string_view;
}
impl frc_LayoutType {
    #[inline]
    pub unsafe fn GetLayoutName(&self) -> std_string_view {
        frc_LayoutType_GetLayoutName(self)
    }
}
#[doc = " Groups components in a vertical list. New widgets added to the layout will\n be placed at the bottom of the list. <br>Custom properties: <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Label position</td><td>String</td><td>\"BOTTOM\"</td>\n <td>The position of component labels inside the grid. One of\n {@code [\"TOP\", \"LEFT\", \"BOTTOM\", \"RIGHT\", \"HIDDEN\"}</td></tr>\n </table>"]
pub const frc_BuiltInLayouts_kList: frc_BuiltInLayouts = 0;
#[doc = " Groups components in an <i>n</i> x <i>m</i> grid. Grid layouts default to\n 3x3. <br>Custom properties: <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Number of columns</td><td>Number</td><td>3</td><td>Must be in the\n range [1,15]</td>\n </tr>\n <tr><td>Number of rows</td><td>Number</td><td>3</td><td>Must be in the\n range [1,15]</td></tr> <tr> <td>Label position</td> <td>String</td>\n <td>\"BOTTOM\"</td>\n <td>The position of component labels inside the grid.\n One of {@code [\"TOP\", \"LEFT\", \"BOTTOM\", \"RIGHT\", \"HIDDEN\"}</td>\n </tr>\n </table>"]
pub const frc_BuiltInLayouts_kGrid: frc_BuiltInLayouts = 1;
#[doc = " The types of layouts bundled with Shuffleboard.\n\n <pre>{@code\n ShuffleboardLayout myList = Shuffleboard::GetTab(\"My Tab\")\n   .GetLayout(BuiltinLayouts::kList, \"My List\");\n }</pre>"]
pub type frc_BuiltInLayouts = ::std::os::raw::c_int;
#[repr(C)]
pub struct frc_ShuffleboardValue__bindgen_vtable {
    pub frc_ShuffleboardValue_BuildInto: unsafe extern "C" fn(
        this: *mut frc_ShuffleboardValue,
        parentTable: [u32; 2usize],
        metaTable: [u32; 2usize],
    ),
}
#[repr(C)]
#[derive(Debug)]
pub struct frc_ShuffleboardValue {
    pub vtable_: *const frc_ShuffleboardValue__bindgen_vtable,
    pub m_title: std_string,
}
#[test]
fn bindgen_test_layout_frc_ShuffleboardValue() {
    const UNINIT: ::std::mem::MaybeUninit<frc_ShuffleboardValue> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_ShuffleboardValue>(),
        28usize,
        concat!("Size of: ", stringify!(frc_ShuffleboardValue))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ShuffleboardValue>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_ShuffleboardValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_title) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardValue),
            "::",
            stringify!(m_title)
        )
    );
}
#[doc = " A shim class to allow storing ShuffleboardComponents in arrays."]
#[repr(C)]
pub struct frc_ShuffleboardComponentBase {
    pub __bindgen_padding_0: u32,
    pub m_properties: wpi_StringMap<wpi_MallocAllocator>,
    pub m_metadataDirty: bool,
    pub m_column: ::std::os::raw::c_int,
    pub m_row: ::std::os::raw::c_int,
    pub m_width: ::std::os::raw::c_int,
    pub m_height: ::std::os::raw::c_int,
    pub m_parent: *mut frc_ShuffleboardContainer,
    pub m_type: std_string,
    pub __bindgen_padding_1: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_frc_ShuffleboardComponentBase() {
    const UNINIT: ::std::mem::MaybeUninit<frc_ShuffleboardComponentBase> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_ShuffleboardComponentBase>(),
        104usize,
        concat!("Size of: ", stringify!(frc_ShuffleboardComponentBase))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ShuffleboardComponentBase>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_ShuffleboardComponentBase))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_properties) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardComponentBase),
            "::",
            stringify!(m_properties)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_metadataDirty) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardComponentBase),
            "::",
            stringify!(m_metadataDirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_column) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardComponentBase),
            "::",
            stringify!(m_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_row) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardComponentBase),
            "::",
            stringify!(m_row)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_width) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardComponentBase),
            "::",
            stringify!(m_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_height) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardComponentBase),
            "::",
            stringify!(m_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_parent) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardComponentBase),
            "::",
            stringify!(m_parent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_type) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardComponentBase),
            "::",
            stringify!(m_type)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc25ShuffleboardComponentBase7SetTypeESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_ShuffleboardComponentBase_SetType(
        this: *mut frc_ShuffleboardComponentBase,
        type_: std_string_view,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc25ShuffleboardComponentBase13BuildMetadataESt10shared_ptrIN2nt12NetworkTableEE"]
    pub fn frc_ShuffleboardComponentBase_BuildMetadata(
        this: *mut frc_ShuffleboardComponentBase,
        metaTable: [u32; 2usize],
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc25ShuffleboardComponentBase9GetParentEv"]
    pub fn frc_ShuffleboardComponentBase_GetParent(
        this: *mut frc_ShuffleboardComponentBase,
    ) -> *mut frc_ShuffleboardContainer;
}
extern "C" {
    #[link_name = "\u{1}_ZNK3frc25ShuffleboardComponentBase7GetTypeB5cxx11Ev"]
    pub fn frc_ShuffleboardComponentBase_GetType(
        this: *const frc_ShuffleboardComponentBase,
    ) -> *const std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc25ShuffleboardComponentBaseC2ERNS_21ShuffleboardContainerESt17basic_string_viewIcSt11char_traitsIcEES6_"]
    pub fn frc_ShuffleboardComponentBase_ShuffleboardComponentBase(
        this: *mut frc_ShuffleboardComponentBase,
        parent: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        type_: std_string_view,
    );
}
impl frc_ShuffleboardComponentBase {
    #[inline]
    pub unsafe fn SetType(&mut self, type_: std_string_view) {
        frc_ShuffleboardComponentBase_SetType(self, type_)
    }
    #[inline]
    pub unsafe fn BuildMetadata(&mut self, metaTable: [u32; 2usize]) {
        frc_ShuffleboardComponentBase_BuildMetadata(self, metaTable)
    }
    #[inline]
    pub unsafe fn GetParent(&mut self) -> *mut frc_ShuffleboardContainer {
        frc_ShuffleboardComponentBase_GetParent(self)
    }
    #[inline]
    pub unsafe fn GetType(&self) -> *const std_string {
        frc_ShuffleboardComponentBase_GetType(self)
    }
    #[inline]
    pub unsafe fn new(
        parent: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        type_: std_string_view,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_ShuffleboardComponentBase_ShuffleboardComponentBase(
            __bindgen_tmp.as_mut_ptr(),
            parent,
            title,
            type_,
        );
        __bindgen_tmp.assume_init()
    }
}
#[doc = " A generic component in Shuffleboard.\n\n @tparam Derived the self type"]
#[repr(C)]
pub struct frc_ShuffleboardComponent {
    pub _base: frc_ShuffleboardComponentBase,
}
#[doc = " Represents the type of a widget in Shuffleboard. Using this is preferred over\n specifying raw strings, to avoid typos and having to know or look up the\n exact string name for a desired widget.\n\n @see BuiltInWidgets the built-in widget types"]
#[repr(C)]
#[derive(Debug)]
pub struct frc_WidgetType {
    pub m_widgetName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_frc_WidgetType() {
    const UNINIT: ::std::mem::MaybeUninit<frc_WidgetType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_WidgetType>(),
        4usize,
        concat!("Size of: ", stringify!(frc_WidgetType))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_WidgetType>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_WidgetType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_widgetName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_WidgetType),
            "::",
            stringify!(m_widgetName)
        )
    );
}
extern "C" {
    #[doc = " Gets the string type of the widget as defined by that widget in\n Shuffleboard."]
    #[link_name = "\u{1}_ZNK3frc10WidgetType13GetWidgetNameEv"]
    pub fn frc_WidgetType_GetWidgetName(this: *const frc_WidgetType) -> std_string_view;
}
impl frc_WidgetType {
    #[inline]
    pub unsafe fn GetWidgetName(&self) -> std_string_view {
        frc_WidgetType_GetWidgetName(self)
    }
}
#[doc = " Displays a value with a simple text field.\n <br>Supported types:\n <ul>\n <li>String</li>\n <li>Number</li>\n <li>Boolean</li>\n </ul>\n <br>This widget has no custom properties."]
pub const frc_BuiltInWidgets_kTextView: frc_BuiltInWidgets = 0;
#[doc = " Displays a number with a controllable slider.\n <br>Supported types:\n <ul>\n <li>Number</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Min</td><td>Number</td><td>-1.0</td><td>The minimum value of the\n slider</td></tr> <tr><td>Max</td><td>Number</td><td>1.0</td><td>The maximum\n value of the slider</td></tr> <tr><td>Block\n increment</td><td>Number</td><td>0.0625</td> <td>How much to move the\n slider by with the arrow keys</td></tr>\n </table>"]
pub const frc_BuiltInWidgets_kNumberSlider: frc_BuiltInWidgets = 1;
#[doc = " Displays a number with a view-only bar.\n <br>Supported types:\n <ul>\n <li>Number</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Min</td><td>Number</td><td>-1.0</td><td>The minimum value of the\n bar</td></tr> <tr><td>Max</td><td>Number</td><td>1.0</td><td>The maximum\n value of the bar</td></tr>\n <tr><td>Center</td><td>Number</td><td>0</td><td>The center (\"zero\") value\n of the bar</td></tr>\n </table>"]
pub const frc_BuiltInWidgets_kNumberBar: frc_BuiltInWidgets = 2;
#[doc = " Displays a number with a view-only dial. Displayed values are rounded to\n the nearest integer. <br>Supported types: <ul> <li>Number</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Min</td><td>Number</td><td>0</td><td>The minimum value of the\n dial</td></tr> <tr><td>Max</td><td>Number</td><td>100</td><td>The maximum\n value of the dial</td></tr> <tr><td>Show\n value</td><td>Boolean</td><td>true</td> <td>Whether or not to show the\n value as text</td></tr>\n </table>"]
pub const frc_BuiltInWidgets_kDial: frc_BuiltInWidgets = 3;
#[doc = " Displays a number with a graph. <strong>NOTE:</strong> graphs can be taxing\n on the computer running the dashboard. Keep the number of visible data\n points to a minimum. Making the widget smaller also helps with performance,\n but may cause the graph to become difficult to read. <br>Supported types:\n <ul>\n <li>Number</li>\n <li>Number array</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Visible time</td><td>Number</td><td>30</td>\n <td>How long, in seconds, should past data be visible for</td></tr>\n </table>"]
pub const frc_BuiltInWidgets_kGraph: frc_BuiltInWidgets = 4;
#[doc = " Displays a boolean value as a large colored box.\n <br>Supported types:\n <ul>\n <li>Boolean</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Color when true</td><td>Color</td><td>\"green\"</td>\n <td>Can be specified as a string ({@code \"#00FF00\"}) or a rgba integer\n ({@code 0x00FF0000})\n </td></tr>\n <tr><td>Color when false</td><td>Color</td><td>\"red\"</td>\n <td>Can be specified as a string or a number</td></tr>\n </table>"]
pub const frc_BuiltInWidgets_kBooleanBox: frc_BuiltInWidgets = 5;
#[doc = " Displays a boolean with a large interactive toggle button.\n <br>Supported types:\n <ul>\n <li>Boolean</li>\n </ul>\n <br>This widget has no custom properties."]
pub const frc_BuiltInWidgets_kToggleButton: frc_BuiltInWidgets = 6;
#[doc = " Displays a boolean with a fixed-size toggle switch.\n <br>Supported types:\n <ul>\n <li>Boolean</li>\n </ul>\n <br>This widget has no custom properties."]
pub const frc_BuiltInWidgets_kToggleSwitch: frc_BuiltInWidgets = 7;
#[doc = " Displays an analog input or a raw number with a number bar.\n <br>Supported types:\n <ul>\n <li>Number</li>\n <li>AnalogInput</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Min</td><td>Number</td><td>0</td><td>The minimum value of the\n bar</td></tr> <tr><td>Max</td><td>Number</td><td>5</td><td>The maximum\n value of the bar</td></tr>\n <tr><td>Center</td><td>Number</td><td>0</td><td>The center (\"zero\") value\n of the bar</td></tr>\n <tr><td>Orientation</td><td>String</td><td>\"HORIZONTAL\"</td>\n <td>The orientation of the bar. One of {@code [\"HORIZONTAL\",\n \"VERTICAL\"]}</td></tr> <tr><td>Number of tick\n marks</td><td>Number</td><td>5</td> <td>The number of discrete ticks on the\n bar</td></tr>\n </table>"]
pub const frc_BuiltInWidgets_kVoltageView: frc_BuiltInWidgets = 8;
#[doc = " Displays a PowerDistribution. <br>Supported types: <ul> <li>\n PowerDistribution</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Show voltage and current values</td><td>Boolean</td><td>true</td>\n <td>Whether or not to display the voltage and current draw</td></tr>\n </table>"]
pub const frc_BuiltInWidgets_kPowerDistribution: frc_BuiltInWidgets = 9;
#[doc = " Displays a SendableChooser with a dropdown combo box with a list of\n options.\n <br>Supported types:\n <ul>\n <li>SendableChooser</li>\n </ul>\n <br>This widget has no custom properties."]
pub const frc_BuiltInWidgets_kComboBoxChooser: frc_BuiltInWidgets = 10;
#[doc = " Displays a SendableChooserwith a toggle button for each available option.\n <br>Supported types:\n <ul>\n <li>SendableChooser</li>\n </ul>\n <br>This widget has no custom properties."]
pub const frc_BuiltInWidgets_kSplitButtonChooser: frc_BuiltInWidgets = 11;
#[doc = " Displays an Encoder displaying its speed,\n total traveled distance, and its distance per tick. <br>Supported types:\n <ul>\n <li>Encoder</li>\n </ul>\n <br>This widget has no custom properties."]
pub const frc_BuiltInWidgets_kEncoder: frc_BuiltInWidgets = 12;
#[doc = " Displays a MotorController.\n The motor controller will be controllable from the dashboard when test mode\n is enabled, but will otherwise be view-only. <br>Supported types: <ul>\n <li>PWMMotorController</li>\n <li>DMC60</li>\n <li>Jaguar</li>\n <li>PWMTalonSRX</li>\n <li>PWMVictorSPX</li>\n <li>SD540</li>\n <li>Spark</li>\n <li>Talon</li>\n <li>Victor</li>\n <li>VictorSP</li>\n <li>MotorControllerGroup</li>\n <li>Any custom subclass of {@code SpeedContorller}</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Orientation</td><td>String</td><td>\"HORIZONTAL\"</td>\n <td>One of {@code [\"HORIZONTAL\", \"VERTICAL\"]}</td></tr>\n </table>"]
pub const frc_BuiltInWidgets_kMotorController: frc_BuiltInWidgets = 13;
#[doc = " Displays a command with a toggle button. Pressing the button will start the\n command, and the button will automatically release when the command\n completes. <br>Supported types: <ul> <li>Command</li> <li>CommandGroup</li>\n <li>Any custom subclass of {@code Command} or {@code CommandGroup}</li>\n </ul>\n <br>This widget has no custom properties."]
pub const frc_BuiltInWidgets_kCommand: frc_BuiltInWidgets = 14;
#[doc = " Displays a PID command with a checkbox and an editor for the PIDF\n constants. Selecting the checkbox will start the command, and the checkbox\n will automatically deselect when the command completes. <br>Supported\n types: <ul> <li>PIDCommand</li>\n <li>Any custom subclass of {@code PIDCommand}</li>\n </ul>\n <br>This widget has no custom properties."]
pub const frc_BuiltInWidgets_kPIDCommand: frc_BuiltInWidgets = 15;
#[doc = " Displays a PID controller with an editor for the PIDF constants and a\n toggle switch for enabling and disabling the controller. <br>Supported\n types: <ul> <li>PIDController</li>\n </ul>\n <br>This widget has no custom properties."]
pub const frc_BuiltInWidgets_kPIDController: frc_BuiltInWidgets = 16;
#[doc = " Displays an accelerometer with a number bar displaying the magnitude of the\n acceleration and text displaying the exact value. <br>Supported types: <ul>\n <li>AnalogAccelerometer</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Min</td><td>Number</td><td>-1</td>\n <td>The minimum acceleration value to display</td></tr>\n <tr><td>Max</td><td>Number</td><td>1</td>\n <td>The maximum acceleration value to display</td></tr>\n <tr><td>Show text</td><td>Boolean</td><td>true</td>\n <td>Show or hide the acceleration values</td></tr>\n <tr><td>Precision</td><td>Number</td><td>2</td>\n <td>How many numbers to display after the decimal point</td></tr>\n <tr><td>Show tick marks</td><td>Boolean</td><td>false</td>\n <td>Show or hide the tick marks on the number bars</td></tr>\n </table>"]
pub const frc_BuiltInWidgets_kAccelerometer: frc_BuiltInWidgets = 17;
#[doc = " Displays a 3-axis accelerometer with a number bar for each axis'\n acceleration. <br>Supported types: <ul> <li>ADXL345_I2C</li> <li>\n ADXL345_SPI</li> <li>ADXL362</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Range</td><td>Range</td><td>k16G</td><td>The accelerometer\n range</td></tr> <tr><td>Show value</td><td>Boolean</td><td>true</td>\n <td>Show or hide the acceleration values</td></tr>\n <tr><td>Precision</td><td>Number</td><td>2</td>\n <td>How many numbers to display after the decimal point</td></tr>\n <tr><td>Show tick marks</td><td>Boolean</td><td>false</td>\n <td>Show or hide the tick marks on the number bars</td></tr>\n </table>"]
pub const frc_BuiltInWidgets_k3AxisAccelerometer: frc_BuiltInWidgets = 18;
#[doc = " Displays a gyro with a dial from 0 to 360 degrees.\n <br>Supported types:\n <ul>\n <li>ADXRS450_Gyro</li>\n <li>AnalogGyro</li>\n <li>Any custom subclass of {@code GyroBase} (such as a MXP gyro)</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Major tick\n spacing</td><td>Number</td><td>45</td><td>Degrees</td></tr>\n <tr><td>Starting angle</td><td>Number</td><td>180</td>\n <td>How far to rotate the entire dial, in degrees</td></tr>\n <tr><td>Show tick mark ring</td><td>Boolean</td><td>true</td></tr>\n </table>"]
pub const frc_BuiltInWidgets_kGyro: frc_BuiltInWidgets = 19;
#[doc = " Displays a relay with toggle buttons for each supported mode (off, on,\n forward, reverse). <br>Supported types: <ul> <li>Relay</li>\n </ul>\n <br>This widget has no custom properties."]
pub const frc_BuiltInWidgets_kRelay: frc_BuiltInWidgets = 20;
#[doc = " Displays a differential drive with a widget that displays the speed of each\n side of the drivebase and a vector for the direction and rotation of the\n drivebase. The widget will be controllable if the robot is in test mode.\n <br>Supported types:\n <ul>\n <li>DifferentialDrive</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Number of wheels</td><td>Number</td><td>4</td><td>Must be a\n positive even integer\n </td></tr>\n <tr><td>Wheel diameter</td><td>Number</td><td>80</td><td>Pixels</td></tr>\n <tr><td>Show velocity vectors</td><td>Boolean</td><td>true</td></tr>\n </table>"]
pub const frc_BuiltInWidgets_kDifferentialDrive: frc_BuiltInWidgets = 21;
#[doc = " Displays a mecanum drive with a widget that displays the speed of each\n wheel, and vectors for the direction and rotation of the drivebase. The\n widget will be controllable if the robot is in test mode. <br>Supported\n types: <ul> <li>MecanumDrive</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Show velocity vectors</td><td>Boolean</td><td>true</td></tr>\n </table>"]
pub const frc_BuiltInWidgets_kMecanumDrive: frc_BuiltInWidgets = 22;
#[doc = " Displays a camera stream.\n <br>Supported types:\n <ul>\n <li>VideoSource (as long as it is streaming on an MJPEG server)</li>\n </ul>\n <br>Custom properties:\n <table>\n <tr><th>Name</th><th>Type</th><th>Default Value</th><th>Notes</th></tr>\n <tr><td>Show crosshair</td><td>Boolean</td><td>true</td>\n <td>Show or hide a crosshair on the image</td></tr>\n <tr><td>Crosshair color</td><td>Color</td><td>\"white\"</td>\n <td>Can be a string or a rgba integer</td></tr>\n <tr><td>Show controls</td><td>Boolean</td><td>true</td><td>Show or hide the\n stream controls\n </td></tr>\n <tr><td>Rotation</td><td>String</td><td>\"NONE\"</td>\n <td>Rotates the displayed image. One of {@code [\"NONE\", \"QUARTER_CW\",\n \"QUARTER_CCW\", \"HALF\"]}\n </td></tr>\n </table>"]
pub const frc_BuiltInWidgets_kCameraStream: frc_BuiltInWidgets = 23;
#[doc = " Displays a field2d object.<br>\n Supported types:\n\n <ul>\n   <li>Field2d\n </ul>"]
pub const frc_BuiltInWidgets_kField: frc_BuiltInWidgets = 24;
#[doc = " The types of the widgets bundled with Shuffleboard.\n\n <p>For example, setting a number to be displayed with a slider:\n <pre>{@code\n NetworkTableEntry example = Shuffleboard.getTab(\"My Tab\")\n   .add(\"My Number\", 0)\n   .withWidget(BuiltInWidgets.kNumberSlider)\n   .getEntry();\n }</pre>\n\n <p>Each value in this enum goes into detail on what data types that widget\n can support, as well as the custom properties that widget uses."]
pub type frc_BuiltInWidgets = ::std::os::raw::c_int;
#[doc = " Abstract superclass for widgets.\n\n <p>This class is package-private to minimize API surface area.\n\n @tparam Derived the self type"]
#[repr(C)]
pub struct frc_ShuffleboardWidget {
    pub _base: frc_ShuffleboardComponent,
}
#[repr(C)]
pub struct frc_SuppliedValueWidget {
    pub _base: frc_ShuffleboardWidget,
    pub m_typeString: std_string,
    pub m_supplier: u8,
    pub m_setter: u8,
    pub m_controllablePub: nt_BooleanPublisher,
    pub m_entry: nt_GenericPublisher,
}
#[doc = " Common interface for objects that can contain shuffleboard components."]
#[repr(C)]
pub struct frc_ShuffleboardContainer {
    pub __bindgen_padding_0: [u8; 4usize],
    pub m_isLayout: bool,
    pub m_usedTitles: [u32; 201usize],
    pub m_components: [u32; 3usize],
    pub m_layouts: wpi_StringMap<wpi_MallocAllocator>,
    pub __bindgen_padding_1: [u32; 7usize],
}
#[test]
fn bindgen_test_layout_frc_ShuffleboardContainer() {
    const UNINIT: ::std::mem::MaybeUninit<frc_ShuffleboardContainer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_ShuffleboardContainer>(),
        876usize,
        concat!("Size of: ", stringify!(frc_ShuffleboardContainer))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ShuffleboardContainer>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_ShuffleboardContainer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_isLayout) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardContainer),
            "::",
            stringify!(m_isLayout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_usedTitles) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardContainer),
            "::",
            stringify!(m_usedTitles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_components) as usize - ptr as usize },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardContainer),
            "::",
            stringify!(m_components)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_layouts) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardContainer),
            "::",
            stringify!(m_layouts)
        )
    );
}
extern "C" {
    #[doc = " Gets the components that are direct children of this container."]
    #[link_name = "\u{1}_ZNK3frc21ShuffleboardContainer13GetComponentsEv"]
    pub fn frc_ShuffleboardContainer_GetComponents(
        this: *const frc_ShuffleboardContainer,
    ) -> *const [u32; 3usize];
}
extern "C" {
    #[doc = " Gets the layout with the given type and title, creating it if it does not\n already exist at the time this method is called.\n\n @param title the title of the layout\n @param type  the type of the layout, eg \"List\" or \"Grid\"\n @return the layout"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer9GetLayoutESt17basic_string_viewIcSt11char_traitsIcEENS_14BuiltInLayoutsE"]
    pub fn frc_ShuffleboardContainer_GetLayout(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        type_: frc_BuiltInLayouts,
    ) -> *mut frc_ShuffleboardLayout;
}
extern "C" {
    #[doc = " Gets the layout with the given type and title, creating it if it does not\n already exist at the time this method is called.\n\n @param title the title of the layout\n @param type  the type of the layout, eg \"List\" or \"Grid\"\n @return the layout"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer9GetLayoutESt17basic_string_viewIcSt11char_traitsIcEERKNS_10LayoutTypeE"]
    pub fn frc_ShuffleboardContainer_GetLayout1(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        type_: *const frc_LayoutType,
    ) -> *mut frc_ShuffleboardLayout;
}
extern "C" {
    #[doc = " Gets the layout with the given type and title, creating it if it does not\n already exist at the time this method is called. Note: this method should\n only be used to use a layout type that is not already built into\n Shuffleboard. To use a layout built into Shuffleboard, use\n GetLayout(std::string_view, const LayoutType&) and the layouts in\n BuiltInLayouts.\n\n @param title the title of the layout\n @param type  the type of the layout, eg \"List Layout\" or \"Grid Layout\"\n @return the layout\n @see GetLayout(std::string_view, const LayoutType&)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer9GetLayoutESt17basic_string_viewIcSt11char_traitsIcEES4_"]
    pub fn frc_ShuffleboardContainer_GetLayout2(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        type_: std_string_view,
    ) -> *mut frc_ShuffleboardLayout;
}
extern "C" {
    #[doc = " Gets the already-defined layout in this container with the given title.\n\n <pre>{@code\n Shuffleboard::GetTab(\"Example Tab\")->getLayout(\"My Layout\",\n &BuiltInLayouts.kList);\n\n // Later...\n Shuffleboard::GetTab(\"Example Tab\")->GetLayout(\"My Layout\");\n }</pre>\n\n @param title the title of the layout to get\n @return the layout with the given title\n @throws if no layout has yet been defined with the given title"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer9GetLayoutESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_ShuffleboardContainer_GetLayout3(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
    ) -> *mut frc_ShuffleboardLayout;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given sendable.\n\n @param title    the title of the widget\n @param sendable the sendable to display\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n container with the given title"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddESt17basic_string_viewIcSt11char_traitsIcEERN3wpi8SendableE"]
    pub fn frc_ShuffleboardContainer_Add(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        sendable: *mut wpi_Sendable,
    ) -> *mut frc_ComplexWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given sendable.\n\n @param sendable the sendable to display\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n container with the given title, or if the sendable's name has not been\n specified"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddERN3wpi8SendableE"]
    pub fn frc_ShuffleboardContainer_Add1(
        this: *mut frc_ShuffleboardContainer,
        sendable: *mut wpi_Sendable,
    ) -> *mut frc_ComplexWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given data.\n\n @param title the title of the widget\n @param defaultValue  the default value of the widget\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n         container with the given title\n @see AddPersistent(std::string_view, std::shared_ptr<nt::Value>)\n      Add(std::string_view title, std::shared_ptr<nt::Value> defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddESt17basic_string_viewIcSt11char_traitsIcEERKN2nt5ValueE"]
    pub fn frc_ShuffleboardContainer_Add2(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: *const nt_Value,
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given data.\n\n @param title the title of the widget\n @param defaultValue  the default value of the widget\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n         container with the given title\n @see AddPersistent(std::string_view, bool)\n      Add(std::string_view title, bool defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddESt17basic_string_viewIcSt11char_traitsIcEEb"]
    pub fn frc_ShuffleboardContainer_Add3(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: bool,
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given data.\n\n @param title the title of the widget\n @param defaultValue  the default value of the widget\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n         container with the given title\n @see AddPersistent(std::string_view, double)\n      Add(std::string_view title, double defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddESt17basic_string_viewIcSt11char_traitsIcEEd"]
    pub fn frc_ShuffleboardContainer_Add4(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: f64,
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given data.\n\n @param title the title of the widget\n @param defaultValue  the default value of the widget\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n         container with the given title\n @see AddPersistent(std::string_view, double)\n      Add(std::string_view title, double defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddESt17basic_string_viewIcSt11char_traitsIcEEf"]
    pub fn frc_ShuffleboardContainer_Add5(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: f32,
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given data.\n\n @param title the title of the widget\n @param defaultValue  the default value of the widget\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n         container with the given title\n @see AddPersistent(std::string_view, int)\n      Add(std::string_view title, int defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddESt17basic_string_viewIcSt11char_traitsIcEEi"]
    pub fn frc_ShuffleboardContainer_Add6(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: ::std::os::raw::c_int,
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given data.\n\n @param title the title of the widget\n @param defaultValue  the default value of the widget\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n         container with the given title\n @see AddPersistent(std::string_view, std::string_view)\n      Add(std::string_view title, std::string_view defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddESt17basic_string_viewIcSt11char_traitsIcEES4_"]
    pub fn frc_ShuffleboardContainer_Add7(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: std_string_view,
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given data.\n\n @param title the title of the widget\n @param defaultValue  the default value of the widget\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n         container with the given title\n @see AddPersistent(std::string_view, const char*)\n      Add(std::string_view title, const char* defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddESt17basic_string_viewIcSt11char_traitsIcEEPKc"]
    pub fn frc_ShuffleboardContainer_Add8(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: *const ::std::os::raw::c_char,
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given data.\n\n @param title the title of the widget\n @param defaultValue  the default value of the widget\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n         container with the given title\n @see AddPersistent(std::string_view, std::span<const bool>)\n      Add(std::string_view title, std::span<const bool> defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKbLj4294967295EE"]
    pub fn frc_ShuffleboardContainer_Add9(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given data.\n\n @param title the title of the widget\n @param defaultValue  the default value of the widget\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n         container with the given title\n @see AddPersistent(std::string_view, std::span<const double>)\n      Add(std::string_view title, std::span<const double> defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKdLj4294967295EE"]
    pub fn frc_ShuffleboardContainer_Add10(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given data.\n\n @param title the title of the widget\n @param defaultValue  the default value of the widget\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n         container with the given title\n @see AddPersistent(std::string_view, std::span<const double>)\n      Add(std::string_view title, std::span<const double> defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKfLj4294967295EE"]
    pub fn frc_ShuffleboardContainer_Add11(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given data.\n\n @param title the title of the widget\n @param defaultValue  the default value of the widget\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n         container with the given title\n @see AddPersistent(std::string_view, std::span<const double>)\n      Add(std::string_view title, std::span<const double> defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKxLj4294967295EE"]
    pub fn frc_ShuffleboardContainer_Add12(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display the given data.\n\n @param title the title of the widget\n @param defaultValue  the default value of the widget\n @return a widget to display the sendable data\n @throws IllegalArgumentException if a widget already exists in this\n         container with the given title\n @see AddPersistent(std::string_view, std::span<const std::string>)\n      Add(std::string_view title, std::span<const std::string> defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer3AddESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKNSt7__cxx1112basic_stringIcS3_SaIcEEELj4294967295EE"]
    pub fn frc_ShuffleboardContainer_Add13(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer9AddStringESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFNSt7__cxx1112basic_stringIcS3_SaIcEEEvEE"]
    pub fn frc_ShuffleboardContainer_AddString(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer9AddNumberESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFdvEE"]
    pub fn frc_ShuffleboardContainer_AddNumber(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer9AddDoubleESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFdvEE"]
    pub fn frc_ShuffleboardContainer_AddDouble(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer8AddFloatESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFfvEE"]
    pub fn frc_ShuffleboardContainer_AddFloat(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer10AddIntegerESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFxvEE"]
    pub fn frc_ShuffleboardContainer_AddInteger(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer10AddBooleanESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFbvEE"]
    pub fn frc_ShuffleboardContainer_AddBoolean(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer14AddStringArrayESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt6vectorINSt7__cxx1112basic_stringIcS3_SaIcEEESaISA_EEvEE"]
    pub fn frc_ShuffleboardContainer_AddStringArray(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer14AddNumberArrayESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt6vectorIdSaIdEEvEE"]
    pub fn frc_ShuffleboardContainer_AddNumberArray(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer14AddDoubleArrayESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt6vectorIdSaIdEEvEE"]
    pub fn frc_ShuffleboardContainer_AddDoubleArray(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer13AddFloatArrayESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt6vectorIfSaIfEEvEE"]
    pub fn frc_ShuffleboardContainer_AddFloatArray(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer15AddIntegerArrayESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt6vectorIxSaIxEEvEE"]
    pub fn frc_ShuffleboardContainer_AddIntegerArray(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer15AddBooleanArrayESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt6vectorIiSaIiEEvEE"]
    pub fn frc_ShuffleboardContainer_AddBooleanArray(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer6AddRawESt17basic_string_viewIcSt11char_traitsIcEESt8functionIFSt6vectorIhSaIhEEvEE"]
    pub fn frc_ShuffleboardContainer_AddRaw(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container. The widget will display the data provided\n by the value supplier. Changes made on the dashboard will not propagate to\n the widget object, and will be overridden by values from the value\n supplier.\n\n @param title the title of the widget\n @param typeString the NT type string\n @param supplier the supplier for values\n @return a widget to display data"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer6AddRawESt17basic_string_viewIcSt11char_traitsIcEES4_St8functionIFSt6vectorIhSaIhEEvEE"]
    pub fn frc_ShuffleboardContainer_AddRaw1(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        typeString: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display a simple piece of data.\n\n Unlike Add(std::string_view, std::shared_ptr<nt::Value>), the value in the\n widget will be saved on the robot and will be used when the robot program\n next starts rather than {@code defaultValue}.\n\n @param title the title of the widget\n @param defaultValue the default value of the widget\n @return a widget to display the sendable data\n @see Add(stdd::string_view, std::shared_ptr<nt::Value>)\n      Add(std::string_view title, std::shared_ptr<nt::Value> defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer13AddPersistentESt17basic_string_viewIcSt11char_traitsIcEERKN2nt5ValueE"]
    pub fn frc_ShuffleboardContainer_AddPersistent(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: *const nt_Value,
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display a simple piece of data.\n\n Unlike Add(std::string_view, bool), the value in the widget will be saved\n on the robot and will be used when the robot program next starts rather\n than {@code defaultValue}.\n\n @param title the title of the widget\n @param defaultValue the default value of the widget\n @return a widget to display the sendable data\n @see Add(std::string_view, bool)\n      Add(std::string_view title, bool defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer13AddPersistentESt17basic_string_viewIcSt11char_traitsIcEEb"]
    pub fn frc_ShuffleboardContainer_AddPersistent1(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: bool,
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display a simple piece of data.\n\n Unlike Add(std::string_view, double), the value in the widget will be saved\n on the robot and will be used when the robot program next starts rather\n than {@code defaultValue}.\n\n @param title the title of the widget\n @param defaultValue the default value of the widget\n @return a widget to display the sendable data\n @see Add(std::string_view, double)\n      Add(std::string_view title, double defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer13AddPersistentESt17basic_string_viewIcSt11char_traitsIcEEd"]
    pub fn frc_ShuffleboardContainer_AddPersistent2(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: f64,
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display a simple piece of data.\n\n Unlike Add(std::string_view, float), the value in the widget will be saved\n on the robot and will be used when the robot program next starts rather\n than {@code defaultValue}.\n\n @param title the title of the widget\n @param defaultValue the default value of the widget\n @return a widget to display the sendable data\n @see Add(std::string_view, float)\n      Add(std::string_view title, float defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer13AddPersistentESt17basic_string_viewIcSt11char_traitsIcEEf"]
    pub fn frc_ShuffleboardContainer_AddPersistent3(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: f32,
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display a simple piece of data.\n\n Unlike Add(std::string_view, int64_t), the value in the widget will be\n saved on the robot and will be used when the robot program next starts\n rather than {@code defaultValue}.\n\n @param title the title of the widget\n @param defaultValue the default value of the widget\n @return a widget to display the sendable data\n @see Add(std:string_view, int64_t)\n      Add(std::string_view title, int64_t defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer13AddPersistentESt17basic_string_viewIcSt11char_traitsIcEEi"]
    pub fn frc_ShuffleboardContainer_AddPersistent4(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: ::std::os::raw::c_int,
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display a simple piece of data.\n\n Unlike Add(std::string_view, std::string_view), the value in the widget\n will be saved on the robot and will be used when the robot program next\n starts rather than {@code defaultValue}.\n\n @param title the title of the widget\n @param defaultValue the default value of the widget\n @return a widget to display the sendable data\n @see Add(std::string_view, std::string_view)\n      Add(std::string_view title, std::string_view defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer13AddPersistentESt17basic_string_viewIcSt11char_traitsIcEES4_"]
    pub fn frc_ShuffleboardContainer_AddPersistent5(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: std_string_view,
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display a simple piece of data.\n\n Unlike Add(std::string_view, std::span<const bool>), the value in the\n widget will be saved on the robot and will be used when the robot program\n next starts rather than {@code defaultValue}.\n\n @param title the title of the widget\n @param defaultValue the default value of the widget\n @return a widget to display the sendable data\n @see Add(std::string_view, std::span<const bool>)\n      Add(std::string_view title, std::span<const bool> defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer13AddPersistentESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKbLj4294967295EE"]
    pub fn frc_ShuffleboardContainer_AddPersistent6(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display a simple piece of data.\n\n Unlike Add(std::string_view, std::span<const double>), the value in the\n widget will be saved on the robot and will be used when the robot program\n next starts rather than {@code defaultValue}.\n\n @param title the title of the widget\n @param defaultValue the default value of the widget\n @return a widget to display the sendable data\n @see Add(std::string_view, std::span<const double>)\n      Add(std::string_view title, std::span<const double> defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer13AddPersistentESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKdLj4294967295EE"]
    pub fn frc_ShuffleboardContainer_AddPersistent7(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display a simple piece of data.\n\n Unlike Add(std::string_view, std::span<const float>), the value in the\n widget will be saved on the robot and will be used when the robot program\n next starts rather than {@code defaultValue}.\n\n @param title the title of the widget\n @param defaultValue the default value of the widget\n @return a widget to display the sendable data\n @see Add(std::string_view, std::span<const float>)\n      Add(std::string_view title, std::span<const float> defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer13AddPersistentESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKfLj4294967295EE"]
    pub fn frc_ShuffleboardContainer_AddPersistent8(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display a simple piece of data.\n\n Unlike Add(std::string_view, std::span<const int64_t>), the value in the\n widget will be saved on the robot and will be used when the robot program\n next starts rather than {@code defaultValue}.\n\n @param title the title of the widget\n @param defaultValue the default value of the widget\n @return a widget to display the sendable data\n @see Add(std::string_view, std::span<const int64_t>)\n      Add(std::string_view title, std::span<const int64_t> defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer13AddPersistentESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKxLj4294967295EE"]
    pub fn frc_ShuffleboardContainer_AddPersistent9(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[doc = " Adds a widget to this container to display a simple piece of data.\n\n Unlike Add(std::string_view, std::span<const std::string>), the value in\n the widget will be saved on the robot and will be used when the robot\n program next starts rather than {@code defaultValue}.\n\n @param title the title of the widget\n @param defaultValue the default value of the widget\n @return a widget to display the sendable data\n @see Add(std::string_view, std::span<const std::string>)\n      Add(std::string_view title, std::span<const std::string> defaultValue)"]
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainer13AddPersistentESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKNSt7__cxx1112basic_stringIcS3_SaIcEEELj4294967295EE"]
    pub fn frc_ShuffleboardContainer_AddPersistent10(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc21ShuffleboardContainerC2ESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_ShuffleboardContainer_ShuffleboardContainer(
        this: *mut frc_ShuffleboardContainer,
        title: std_string_view,
    );
}
impl frc_ShuffleboardContainer {
    #[inline]
    pub unsafe fn GetComponents(&self) -> *const [u32; 3usize] {
        frc_ShuffleboardContainer_GetComponents(self)
    }
    #[inline]
    pub unsafe fn GetLayout(
        &mut self,
        title: std_string_view,
        type_: frc_BuiltInLayouts,
    ) -> *mut frc_ShuffleboardLayout {
        frc_ShuffleboardContainer_GetLayout(self, title, type_)
    }
    #[inline]
    pub unsafe fn GetLayout1(
        &mut self,
        title: std_string_view,
        type_: *const frc_LayoutType,
    ) -> *mut frc_ShuffleboardLayout {
        frc_ShuffleboardContainer_GetLayout1(self, title, type_)
    }
    #[inline]
    pub unsafe fn GetLayout2(
        &mut self,
        title: std_string_view,
        type_: std_string_view,
    ) -> *mut frc_ShuffleboardLayout {
        frc_ShuffleboardContainer_GetLayout2(self, title, type_)
    }
    #[inline]
    pub unsafe fn GetLayout3(&mut self, title: std_string_view) -> *mut frc_ShuffleboardLayout {
        frc_ShuffleboardContainer_GetLayout3(self, title)
    }
    #[inline]
    pub unsafe fn Add(
        &mut self,
        title: std_string_view,
        sendable: *mut wpi_Sendable,
    ) -> *mut frc_ComplexWidget {
        frc_ShuffleboardContainer_Add(self, title, sendable)
    }
    #[inline]
    pub unsafe fn Add1(&mut self, sendable: *mut wpi_Sendable) -> *mut frc_ComplexWidget {
        frc_ShuffleboardContainer_Add1(self, sendable)
    }
    #[inline]
    pub unsafe fn Add2(
        &mut self,
        title: std_string_view,
        defaultValue: *const nt_Value,
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_Add2(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn Add3(
        &mut self,
        title: std_string_view,
        defaultValue: bool,
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_Add3(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn Add4(
        &mut self,
        title: std_string_view,
        defaultValue: f64,
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_Add4(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn Add5(
        &mut self,
        title: std_string_view,
        defaultValue: f32,
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_Add5(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn Add6(
        &mut self,
        title: std_string_view,
        defaultValue: ::std::os::raw::c_int,
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_Add6(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn Add7(
        &mut self,
        title: std_string_view,
        defaultValue: std_string_view,
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_Add7(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn Add8(
        &mut self,
        title: std_string_view,
        defaultValue: *const ::std::os::raw::c_char,
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_Add8(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn Add9(
        &mut self,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_Add9(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn Add10(
        &mut self,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_Add10(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn Add11(
        &mut self,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_Add11(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn Add12(
        &mut self,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_Add12(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn Add13(
        &mut self,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_Add13(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn AddString(
        &mut self,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddString(self, title, supplier)
    }
    #[inline]
    pub unsafe fn AddNumber(
        &mut self,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddNumber(self, title, supplier)
    }
    #[inline]
    pub unsafe fn AddDouble(
        &mut self,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddDouble(self, title, supplier)
    }
    #[inline]
    pub unsafe fn AddFloat(
        &mut self,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddFloat(self, title, supplier)
    }
    #[inline]
    pub unsafe fn AddInteger(
        &mut self,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddInteger(self, title, supplier)
    }
    #[inline]
    pub unsafe fn AddBoolean(
        &mut self,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddBoolean(self, title, supplier)
    }
    #[inline]
    pub unsafe fn AddStringArray(
        &mut self,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddStringArray(self, title, supplier)
    }
    #[inline]
    pub unsafe fn AddNumberArray(
        &mut self,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddNumberArray(self, title, supplier)
    }
    #[inline]
    pub unsafe fn AddDoubleArray(
        &mut self,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddDoubleArray(self, title, supplier)
    }
    #[inline]
    pub unsafe fn AddFloatArray(
        &mut self,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddFloatArray(self, title, supplier)
    }
    #[inline]
    pub unsafe fn AddIntegerArray(
        &mut self,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddIntegerArray(self, title, supplier)
    }
    #[inline]
    pub unsafe fn AddBooleanArray(
        &mut self,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddBooleanArray(self, title, supplier)
    }
    #[inline]
    pub unsafe fn AddRaw(
        &mut self,
        title: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddRaw(self, title, supplier)
    }
    #[inline]
    pub unsafe fn AddRaw1(
        &mut self,
        title: std_string_view,
        typeString: std_string_view,
        supplier: u8,
    ) -> *mut frc_SuppliedValueWidget {
        frc_ShuffleboardContainer_AddRaw1(self, title, typeString, supplier)
    }
    #[inline]
    pub unsafe fn AddPersistent(
        &mut self,
        title: std_string_view,
        defaultValue: *const nt_Value,
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_AddPersistent(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn AddPersistent1(
        &mut self,
        title: std_string_view,
        defaultValue: bool,
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_AddPersistent1(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn AddPersistent2(
        &mut self,
        title: std_string_view,
        defaultValue: f64,
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_AddPersistent2(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn AddPersistent3(
        &mut self,
        title: std_string_view,
        defaultValue: f32,
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_AddPersistent3(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn AddPersistent4(
        &mut self,
        title: std_string_view,
        defaultValue: ::std::os::raw::c_int,
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_AddPersistent4(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn AddPersistent5(
        &mut self,
        title: std_string_view,
        defaultValue: std_string_view,
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_AddPersistent5(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn AddPersistent6(
        &mut self,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_AddPersistent6(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn AddPersistent7(
        &mut self,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_AddPersistent7(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn AddPersistent8(
        &mut self,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_AddPersistent8(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn AddPersistent9(
        &mut self,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_AddPersistent9(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn AddPersistent10(
        &mut self,
        title: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> *mut frc_SimpleWidget {
        frc_ShuffleboardContainer_AddPersistent10(self, title, defaultValue)
    }
    #[inline]
    pub unsafe fn new(title: std_string_view) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_ShuffleboardContainer_ShuffleboardContainer(__bindgen_tmp.as_mut_ptr(), title);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZTv0_n20_N3frc21ShuffleboardContainer16EnableIfActuatorEv"]
    pub fn frc_ShuffleboardContainer_EnableIfActuator(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZTv0_n24_N3frc21ShuffleboardContainer17DisableIfActuatorEv"]
    pub fn frc_ShuffleboardContainer_DisableIfActuator(this: *mut ::std::os::raw::c_void);
}
#[doc = " A Shuffleboard widget that handles a Sendable object such as a motor\n controller or sensor."]
#[repr(C)]
pub struct frc_ComplexWidget {
    pub _base: frc_ShuffleboardWidget,
    pub m_sendable: *mut wpi_Sendable,
    pub m_builder: u32,
}
#[test]
fn bindgen_test_layout_frc_ComplexWidget() {
    const UNINIT: ::std::mem::MaybeUninit<frc_ComplexWidget> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_ComplexWidget>(),
        112usize,
        concat!("Size of: ", stringify!(frc_ComplexWidget))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ComplexWidget>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_ComplexWidget))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_sendable) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ComplexWidget),
            "::",
            stringify!(m_sendable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_builder) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ComplexWidget),
            "::",
            stringify!(m_builder)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc13ComplexWidgetC1ERNS_21ShuffleboardContainerESt17basic_string_viewIcSt11char_traitsIcEERN3wpi8SendableE"]
    pub fn frc_ComplexWidget_ComplexWidget(
        this: *mut frc_ComplexWidget,
        parent: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        sendable: *mut wpi_Sendable,
    );
}
impl frc_ComplexWidget {
    #[inline]
    pub unsafe fn new(
        parent: *mut frc_ShuffleboardContainer,
        title: std_string_view,
        sendable: *mut wpi_Sendable,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_ComplexWidget_ComplexWidget(__bindgen_tmp.as_mut_ptr(), parent, title, sendable);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc13ComplexWidgetD1Ev"]
    pub fn frc_ComplexWidget_ComplexWidget_destructor(this: *mut frc_ComplexWidget);
}
extern "C" {
    #[link_name = "\u{1}_ZTv0_n20_N3frc13ComplexWidget16EnableIfActuatorEv"]
    pub fn frc_ComplexWidget_EnableIfActuator(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZTv0_n24_N3frc13ComplexWidget17DisableIfActuatorEv"]
    pub fn frc_ComplexWidget_DisableIfActuator(this: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[link_name = "\u{1}_ZTv0_n16_N3frc13ComplexWidget9BuildIntoESt10shared_ptrIN2nt12NetworkTableEES4_"]
    pub fn frc_ComplexWidget_BuildInto(
        this: *mut ::std::os::raw::c_void,
        parentTable: [u32; 2usize],
        metaTable: [u32; 2usize],
    );
}
#[doc = " A layout in a Shuffleboard tab. Layouts can contain widgets and other\n layouts."]
#[repr(C)]
pub struct frc_ShuffleboardLayout {
    pub _base: frc_ShuffleboardComponent,
    pub _base_1: frc_ShuffleboardContainer,
}
#[test]
fn bindgen_test_layout_frc_ShuffleboardLayout() {
    assert_eq!(
        ::std::mem::size_of::<frc_ShuffleboardLayout>(),
        952usize,
        concat!("Size of: ", stringify!(frc_ShuffleboardLayout))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ShuffleboardLayout>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_ShuffleboardLayout))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc18ShuffleboardLayoutC1ERNS_21ShuffleboardContainerESt17basic_string_viewIcSt11char_traitsIcEES6_"]
    pub fn frc_ShuffleboardLayout_ShuffleboardLayout(
        this: *mut frc_ShuffleboardLayout,
        parent: *mut frc_ShuffleboardContainer,
        name: std_string_view,
        type_: std_string_view,
    );
}
impl frc_ShuffleboardLayout {
    #[inline]
    pub unsafe fn new(
        parent: *mut frc_ShuffleboardContainer,
        name: std_string_view,
        type_: std_string_view,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_ShuffleboardLayout_ShuffleboardLayout(__bindgen_tmp.as_mut_ptr(), parent, name, type_);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZTv0_n16_N3frc18ShuffleboardLayout9BuildIntoESt10shared_ptrIN2nt12NetworkTableEES4_"]
    pub fn frc_ShuffleboardLayout_BuildInto(
        this: *mut ::std::os::raw::c_void,
        parentTable: [u32; 2usize],
        metaTable: [u32; 2usize],
    );
}
#[doc = " A Shuffleboard widget that handles a single data point such as a number or\n string."]
#[repr(C)]
pub struct frc_SimpleWidget {
    pub _base: frc_ShuffleboardWidget,
    pub m_entry: nt_GenericEntry,
    pub m_typeString: std_string,
}
#[test]
fn bindgen_test_layout_frc_SimpleWidget() {
    const UNINIT: ::std::mem::MaybeUninit<frc_SimpleWidget> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_SimpleWidget>(),
        144usize,
        concat!("Size of: ", stringify!(frc_SimpleWidget))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_SimpleWidget>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_SimpleWidget))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_entry) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SimpleWidget),
            "::",
            stringify!(m_entry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_typeString) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SimpleWidget),
            "::",
            stringify!(m_typeString)
        )
    );
}
extern "C" {
    #[doc = " Gets the NetworkTable entry that contains the data for this widget.\n The widget owns the entry; the returned pointer's lifetime is the same as\n that of the widget."]
    #[link_name = "\u{1}_ZN3frc12SimpleWidget8GetEntryEv"]
    pub fn frc_SimpleWidget_GetEntry(this: *mut frc_SimpleWidget) -> *mut nt_GenericEntry;
}
extern "C" {
    #[doc = " Gets the NetworkTable entry that contains the data for this widget.\n The widget owns the entry; the returned pointer's lifetime is the same as\n that of the widget.\n\n @param typeString NT type string"]
    #[link_name = "\u{1}_ZN3frc12SimpleWidget8GetEntryESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_SimpleWidget_GetEntry1(
        this: *mut frc_SimpleWidget,
        typeString: std_string_view,
    ) -> *mut nt_GenericEntry;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc12SimpleWidgetC1ERNS_21ShuffleboardContainerESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_SimpleWidget_SimpleWidget(
        this: *mut frc_SimpleWidget,
        parent: *mut frc_ShuffleboardContainer,
        title: std_string_view,
    );
}
impl frc_SimpleWidget {
    #[inline]
    pub unsafe fn GetEntry(&mut self) -> *mut nt_GenericEntry {
        frc_SimpleWidget_GetEntry(self)
    }
    #[inline]
    pub unsafe fn GetEntry1(&mut self, typeString: std_string_view) -> *mut nt_GenericEntry {
        frc_SimpleWidget_GetEntry1(self, typeString)
    }
    #[inline]
    pub unsafe fn new(parent: *mut frc_ShuffleboardContainer, title: std_string_view) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_SimpleWidget_SimpleWidget(__bindgen_tmp.as_mut_ptr(), parent, title);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZTv0_n16_N3frc12SimpleWidget9BuildIntoESt10shared_ptrIN2nt12NetworkTableEES4_"]
    pub fn frc_SimpleWidget_BuildInto(
        this: *mut ::std::os::raw::c_void,
        parentTable: [u32; 2usize],
        metaTable: [u32; 2usize],
    );
}
#[doc = " A wrapper to make video sources sendable and usable from Shuffleboard."]
#[repr(C)]
#[derive(Debug)]
pub struct frc_SendableCameraWrapper {
    pub _base: wpi_Sendable,
    pub m_uri: std_string,
    pub m_streams: nt_StringArrayPublisher,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_SendableCameraWrapper_private_init {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_frc_SendableCameraWrapper_private_init() {
    assert_eq!(
        ::std::mem::size_of::<frc_SendableCameraWrapper_private_init>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(frc_SendableCameraWrapper_private_init)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<frc_SendableCameraWrapper_private_init>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(frc_SendableCameraWrapper_private_init)
        )
    );
}
#[test]
fn bindgen_test_layout_frc_SendableCameraWrapper() {
    const UNINIT: ::std::mem::MaybeUninit<frc_SendableCameraWrapper> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_SendableCameraWrapper>(),
        36usize,
        concat!("Size of: ", stringify!(frc_SendableCameraWrapper))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_SendableCameraWrapper>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_SendableCameraWrapper))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_uri) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableCameraWrapper),
            "::",
            stringify!(m_uri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_streams) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SendableCameraWrapper),
            "::",
            stringify!(m_streams)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc21SendableCameraWrapper12InitSendableERN3wpi15SendableBuilderE"]
    pub fn frc_SendableCameraWrapper_InitSendable(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
#[doc = " Represents a tab in the Shuffleboard dashboard. Widgets can be added to the\n tab with Add(Sendable), Add(std::string_view, Object), and\n Add(String, Sendable). Widgets can also be added to layouts with\n GetLayout(std::string_view, std::string_view); layouts can be nested\n arbitrarily deep (note that too many levels may make deeper components\n unusable)."]
#[repr(C)]
pub struct frc_ShuffleboardTab {
    pub _base: frc_ShuffleboardContainer,
    pub m_root: *mut frc_ShuffleboardRoot,
}
#[test]
fn bindgen_test_layout_frc_ShuffleboardTab() {
    const UNINIT: ::std::mem::MaybeUninit<frc_ShuffleboardTab> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_ShuffleboardTab>(),
        880usize,
        concat!("Size of: ", stringify!(frc_ShuffleboardTab))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ShuffleboardTab>(),
        4usize,
        concat!("Alignment of ", stringify!(frc_ShuffleboardTab))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_root) as usize - ptr as usize },
        848usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ShuffleboardTab),
            "::",
            stringify!(m_root)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc15ShuffleboardTab7GetRootEv"]
    pub fn frc_ShuffleboardTab_GetRoot(this: *mut frc_ShuffleboardTab)
        -> *mut frc_ShuffleboardRoot;
}
extern "C" {
    #[link_name = "\u{1}_ZN3frc15ShuffleboardTabC1ERNS_16ShuffleboardRootESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_ShuffleboardTab_ShuffleboardTab(
        this: *mut frc_ShuffleboardTab,
        root: *mut frc_ShuffleboardRoot,
        title: std_string_view,
    );
}
impl frc_ShuffleboardTab {
    #[inline]
    pub unsafe fn GetRoot(&mut self) -> *mut frc_ShuffleboardRoot {
        frc_ShuffleboardTab_GetRoot(self)
    }
    #[inline]
    pub unsafe fn new(root: *mut frc_ShuffleboardRoot, title: std_string_view) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        frc_ShuffleboardTab_ShuffleboardTab(__bindgen_tmp.as_mut_ptr(), root, title);
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZTv0_n16_N3frc15ShuffleboardTab9BuildIntoESt10shared_ptrIN2nt12NetworkTableEES4_"]
    pub fn frc_ShuffleboardTab_BuildInto(
        this: *mut ::std::os::raw::c_void,
        parentTable: [u32; 2usize],
        metaTable: [u32; 2usize],
    );
}
#[doc = " The Shuffleboard class provides a mechanism with which data can be added and\n laid out in the Shuffleboard dashboard application from a robot program. Tabs\n and layouts can be specified, as well as choosing which widgets to display\n with and setting properties of these widgets; for example, programmers can\n specify a specific {@code boolean} value to be displayed with a toggle button\n instead of the default colored box, or set custom colors for that box.\n\n For example, displaying a boolean entry with a toggle button:\n <pre>{@code\n NetworkTableEntry myBoolean = Shuffleboard.getTab(\"Example Tab\")\n   .add(\"My Boolean\", false)\n   .withWidget(\"Toggle Button\")\n   .getEntry();\n }</pre>\n\n Changing the colors of the boolean box:\n <pre>{@code\n NetworkTableEntry myBoolean = Shuffleboard.getTab(\"Example Tab\")\n   .add(\"My Boolean\", false)\n   .withWidget(\"Boolean Box\")\n   .withProperties(Map.of(\"colorWhenTrue\", \"green\", \"colorWhenFalse\",\n \"maroon\")) .getEntry();\n }</pre>\n\n Specifying a parent layout. Note that the layout type must <i>always</i> be\n specified, even if the layout has already been generated by a previously\n defined entry.\n <pre>{@code\n NetworkTableEntry myBoolean = Shuffleboard.getTab(\"Example Tab\")\n   .getLayout(\"List\", \"Example List\")\n   .add(\"My Boolean\", false)\n   .withWidget(\"Toggle Button\")\n   .getEntry();\n }</pre>\n </p>\n\n Teams are encouraged to set up shuffleboard layouts at the start of the robot\n program."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct frc_Shuffleboard {
    pub _address: u8,
}
#[doc = " The name of the base NetworkTable into which all Shuffleboard data will be\n added."]
pub const frc_Shuffleboard_kBaseTableName: &[u8; 14usize] = b"/Shuffleboard\0";
#[test]
fn bindgen_test_layout_frc_Shuffleboard() {
    assert_eq!(
        ::std::mem::size_of::<frc_Shuffleboard>(),
        1usize,
        concat!("Size of: ", stringify!(frc_Shuffleboard))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_Shuffleboard>(),
        1usize,
        concat!("Alignment of ", stringify!(frc_Shuffleboard))
    );
}
extern "C" {
    #[doc = " Updates all the values in Shuffleboard. Iterative and timed robots are\n pre-configured to call this method in the main robot loop; teams using\n custom robot base classes, or subclass SampleRobot, should make sure to\n call this repeatedly to keep data on the dashboard up to date."]
    #[link_name = "\u{1}_ZN3frc12Shuffleboard6UpdateEv"]
    pub fn frc_Shuffleboard_Update();
}
extern "C" {
    #[doc = " Gets the Shuffleboard tab with the given title, creating it if it does not\n already exist.\n\n @param title the title of the tab\n @return the tab with the given title"]
    #[link_name = "\u{1}_ZN3frc12Shuffleboard6GetTabESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_Shuffleboard_GetTab(title: std_string_view) -> *mut frc_ShuffleboardTab;
}
extern "C" {
    #[doc = " Selects the tab in the dashboard with the given index in the range\n [0..n-1], where <i>n</i> is the number of tabs in the dashboard at the time\n this method is called.\n\n @param index the index of the tab to select"]
    #[link_name = "\u{1}_ZN3frc12Shuffleboard9SelectTabEi"]
    pub fn frc_Shuffleboard_SelectTab(index: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Selects the tab in the dashboard with the given title.\n\n @param title the title of the tab to select"]
    #[link_name = "\u{1}_ZN3frc12Shuffleboard9SelectTabESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_Shuffleboard_SelectTab1(title: std_string_view);
}
extern "C" {
    #[doc = " Enables user control of widgets containing actuators: motor controllers,\n relays, etc. This should only be used when the robot is in test mode.\n IterativeRobotBase and SampleRobot are both configured to call this method\n when entering test mode; most users should not need to use this method\n directly."]
    #[link_name = "\u{1}_ZN3frc12Shuffleboard21EnableActuatorWidgetsEv"]
    pub fn frc_Shuffleboard_EnableActuatorWidgets();
}
extern "C" {
    #[doc = " Disables user control of widgets containing actuators. For safety reasons,\n actuators should only be controlled while in test mode. IterativeRobotBase\n and SampleRobot are both configured to call this method when exiting in\n test mode; most users should not need to use this method directly."]
    #[link_name = "\u{1}_ZN3frc12Shuffleboard22DisableActuatorWidgetsEv"]
    pub fn frc_Shuffleboard_DisableActuatorWidgets();
}
extern "C" {
    #[doc = " Starts data recording on the dashboard. Has no effect if recording is\n already in progress."]
    #[link_name = "\u{1}_ZN3frc12Shuffleboard14StartRecordingEv"]
    pub fn frc_Shuffleboard_StartRecording();
}
extern "C" {
    #[doc = " Stops data recording on the dashboard. Has no effect if no recording is in\n progress."]
    #[link_name = "\u{1}_ZN3frc12Shuffleboard13StopRecordingEv"]
    pub fn frc_Shuffleboard_StopRecording();
}
extern "C" {
    #[doc = " Sets the file name format for new recording files to use. If recording is\n in progress when this method is called, it will continue to use the same\n file. New recordings will use the format.\n\n <p>To avoid recording files overwriting each other, make sure to use unique\n recording file names. File name formats accept templates for inserting the\n date and time when the recording started with the {@code ${date}} and\n {@code ${time}} templates, respectively. For example, the default format is\n {@code \"recording-${time}\"} and recording files created with it will have\n names like {@code \"recording-2018.01.15.sbr\"}. Users are\n <strong>strongly</strong> recommended to use the {@code ${time}} template\n to ensure unique file names.\n </p>\n\n @param format the format for the"]
    #[link_name = "\u{1}_ZN3frc12Shuffleboard26SetRecordingFileNameFormatESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn frc_Shuffleboard_SetRecordingFileNameFormat(format: std_string_view);
}
extern "C" {
    #[doc = " Clears the custom name format for recording files. New recordings will use\n the default format.\n\n @see SetRecordingFileNameFormat(std::string_view)"]
    #[link_name = "\u{1}_ZN3frc12Shuffleboard28ClearRecordingFileNameFormatEv"]
    pub fn frc_Shuffleboard_ClearRecordingFileNameFormat();
}
extern "C" {
    #[doc = " Notifies Shuffleboard of an event. Events can range from as trivial as a\n change in a command state to as critical as a total power loss or component\n failure. If Shuffleboard is recording, the event will also be recorded.\n\n <p>If {@code name} is {@code null} or empty, no event will be sent and an\n error will be printed to the driver station.\n\n @param name        the name of the event\n @param description a description of the event\n @param importance  the importance of the event"]
    #[link_name = "\u{1}_ZN3frc12Shuffleboard14AddEventMarkerESt17basic_string_viewIcSt11char_traitsIcEES4_NS_27ShuffleboardEventImportanceE"]
    pub fn frc_Shuffleboard_AddEventMarker(
        name: std_string_view,
        description: std_string_view,
        importance: frc_ShuffleboardEventImportance,
    );
}
extern "C" {
    #[doc = " Notifies Shuffleboard of an event. Events can range from as trivial as a\n change in a command state to as critical as a total power loss or component\n failure. If Shuffleboard is recording, the event will also be recorded.\n\n <p>If {@code name} is {@code null} or empty, no event will be sent and an\n error will be printed to the driver station.\n\n @param name        the name of the event\n @param importance  the importance of the event"]
    #[link_name = "\u{1}_ZN3frc12Shuffleboard14AddEventMarkerESt17basic_string_viewIcSt11char_traitsIcEENS_27ShuffleboardEventImportanceE"]
    pub fn frc_Shuffleboard_AddEventMarker1(
        name: std_string_view,
        importance: frc_ShuffleboardEventImportance,
    );
}
impl frc_Shuffleboard {
    #[inline]
    pub unsafe fn Update() {
        frc_Shuffleboard_Update()
    }
    #[inline]
    pub unsafe fn GetTab(title: std_string_view) -> *mut frc_ShuffleboardTab {
        frc_Shuffleboard_GetTab(title)
    }
    #[inline]
    pub unsafe fn SelectTab(index: ::std::os::raw::c_int) {
        frc_Shuffleboard_SelectTab(index)
    }
    #[inline]
    pub unsafe fn SelectTab1(title: std_string_view) {
        frc_Shuffleboard_SelectTab1(title)
    }
    #[inline]
    pub unsafe fn EnableActuatorWidgets() {
        frc_Shuffleboard_EnableActuatorWidgets()
    }
    #[inline]
    pub unsafe fn DisableActuatorWidgets() {
        frc_Shuffleboard_DisableActuatorWidgets()
    }
    #[inline]
    pub unsafe fn StartRecording() {
        frc_Shuffleboard_StartRecording()
    }
    #[inline]
    pub unsafe fn StopRecording() {
        frc_Shuffleboard_StopRecording()
    }
    #[inline]
    pub unsafe fn SetRecordingFileNameFormat(format: std_string_view) {
        frc_Shuffleboard_SetRecordingFileNameFormat(format)
    }
    #[inline]
    pub unsafe fn ClearRecordingFileNameFormat() {
        frc_Shuffleboard_ClearRecordingFileNameFormat()
    }
    #[inline]
    pub unsafe fn AddEventMarker(
        name: std_string_view,
        description: std_string_view,
        importance: frc_ShuffleboardEventImportance,
    ) {
        frc_Shuffleboard_AddEventMarker(name, description, importance)
    }
    #[inline]
    pub unsafe fn AddEventMarker1(
        name: std_string_view,
        importance: frc_ShuffleboardEventImportance,
    ) {
        frc_Shuffleboard_AddEventMarker1(name, importance)
    }
}
#[doc = " Represents the speed of a robot chassis. Although this struct contains\n similar members compared to a Twist2d, they do NOT represent the same thing.\n Whereas a Twist2d represents a change in pose w.r.t to the robot frame of\n reference, this ChassisSpeeds struct represents a velocity w.r.t to the robot\n frame of reference.\n\n A strictly non-holonomic drivetrain, such as a differential drive, should\n never have a dy component because it can never move sideways. Holonomic\n drivetrains such as swerve and mecanum will often have all three components."]
#[repr(C)]
pub struct frc_ChassisSpeeds {
    #[doc = " Represents forward velocity w.r.t the robot frame of reference. (Fwd is +)"]
    pub vx: units_velocity_meters_per_second_t,
    #[doc = " Represents strafe velocity w.r.t the robot frame of reference. (Left is +)"]
    pub vy: units_velocity_meters_per_second_t,
    #[doc = " Represents the angular velocity of the robot frame. (CCW is +)"]
    pub omega: units_angular_velocity_radians_per_second_t,
}
#[test]
fn bindgen_test_layout_frc_ChassisSpeeds() {
    const UNINIT: ::std::mem::MaybeUninit<frc_ChassisSpeeds> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_ChassisSpeeds>(),
        24usize,
        concat!("Size of: ", stringify!(frc_ChassisSpeeds))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ChassisSpeeds>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_ChassisSpeeds))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ChassisSpeeds),
            "::",
            stringify!(vx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ChassisSpeeds),
            "::",
            stringify!(vy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).omega) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_ChassisSpeeds),
            "::",
            stringify!(omega)
        )
    );
}
#[doc = " Represents the position of one swerve module."]
#[repr(C)]
pub struct frc_SwerveModulePosition {
    #[doc = " Distance the wheel of a module has traveled"]
    pub distance: units_length_meter_t,
    #[doc = " Angle of the module."]
    pub angle: frc_Rotation2d,
}
#[test]
fn bindgen_test_layout_frc_SwerveModulePosition() {
    const UNINIT: ::std::mem::MaybeUninit<frc_SwerveModulePosition> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_SwerveModulePosition>(),
        32usize,
        concat!("Size of: ", stringify!(frc_SwerveModulePosition))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_SwerveModulePosition>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_SwerveModulePosition))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).distance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SwerveModulePosition),
            "::",
            stringify!(distance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).angle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SwerveModulePosition),
            "::",
            stringify!(angle)
        )
    );
}
#[doc = " Represents the state of one swerve module."]
#[repr(C)]
pub struct frc_SwerveModuleState {
    #[doc = " Speed of the wheel of the module."]
    pub speed: units_velocity_meters_per_second_t,
    #[doc = " Angle of the module."]
    pub angle: frc_Rotation2d,
}
#[test]
fn bindgen_test_layout_frc_SwerveModuleState() {
    const UNINIT: ::std::mem::MaybeUninit<frc_SwerveModuleState> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<frc_SwerveModuleState>(),
        32usize,
        concat!("Size of: ", stringify!(frc_SwerveModuleState))
    );
    assert_eq!(
        ::std::mem::align_of::<frc_SwerveModuleState>(),
        8usize,
        concat!("Alignment of ", stringify!(frc_SwerveModuleState))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).speed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SwerveModuleState),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).angle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(frc_SwerveModuleState),
            "::",
            stringify!(angle)
        )
    );
}
extern "C" {
    #[doc = " Minimize the change in heading the desired swerve module state would\n require by potentially reversing the direction the wheel spins. If this is\n used with the PIDController class's continuous input functionality, the\n furthest a wheel will ever rotate is 90 degrees.\n\n @param desiredState The desired state.\n @param currentAngle The current module angle."]
    #[link_name = "\u{1}_ZN3frc17SwerveModuleState8OptimizeERKS0_RKNS_10Rotation2dE"]
    pub fn frc_SwerveModuleState_Optimize(
        desiredState: *const frc_SwerveModuleState,
        currentAngle: *const frc_Rotation2d,
    ) -> frc_SwerveModuleState;
}
impl frc_SwerveModuleState {
    #[inline]
    pub unsafe fn Optimize(
        desiredState: *const frc_SwerveModuleState,
        currentAngle: *const frc_Rotation2d,
    ) -> frc_SwerveModuleState {
        frc_SwerveModuleState_Optimize(desiredState, currentAngle)
    }
}
extern "C" {
    #[doc = " Performs inverse kinematics to return the module states from a desired\n chassis velocity. This method is often used to convert joystick values into\n module speeds and angles.\n\n This function also supports variable centers of rotation. During normal\n operations, the center of rotation is usually the same as the physical\n center of the robot; therefore, the argument is defaulted to that use case.\n However, if you wish to change the center of rotation for evasive\n maneuvers, vision alignment, or for any other use case, you can do so.\n\n In the case that the desired chassis speeds are zero (i.e. the robot will\n be stationary), the previously calculated module angle will be maintained.\n\n @param chassisSpeeds The desired chassis speed.\n @param centerOfRotation The center of rotation. For example, if you set the\n center of rotation at one corner of the robot and provide a chassis speed\n that only has a dtheta component, the robot will rotate around that corner.\n\n @return An array containing the module states. Use caution because these\n module states are not normalized. Sometimes, a user input may cause one of\n the module speeds to go above the attainable max velocity. Use the\n DesaturateWheelSpeeds(wpi::array<SwerveModuleState, NumModules>*,\n units::meters_per_second_t) function to rectify this issue. In addition,\n you can leverage the power of C++17 to directly assign the module states to\n variables:\n\n @code{.cpp}\n auto [fl, fr, bl, br] = kinematics.ToSwerveModuleStates(chassisSpeeds);\n @endcode"]
    #[link_name = "\u{1}ToSwerveModuleStates"]
    pub fn frc_SwerveDriveKinematics_ToSwerveModuleStates(
        this: *const u8,
        chassisSpeeds: *const frc_ChassisSpeeds,
        centerOfRotation: *const frc_Translation2d,
    ) -> u8;
}
extern "C" {
    #[doc = " Performs forward kinematics to return the resulting chassis state from the\n given module states. This method is often used for odometry -- determining\n the robot's position on the field using data from the real-world speed and\n angle of each module on the robot.\n\n @param moduleStates The state of the modules as an wpi::array of type\n SwerveModuleState, NumModules long as measured from respective encoders\n and gyros. The order of the swerve module states should be same as passed\n into the constructor of this class.\n\n @return The resulting chassis speed."]
    #[link_name = "\u{1}ToChassisSpeeds"]
    pub fn frc_SwerveDriveKinematics_ToChassisSpeeds(
        this: *const u8,
        moduleStates: u8,
    ) -> frc_ChassisSpeeds;
}
extern "C" {
    #[doc = " Performs forward kinematics to return the resulting Twist2d from the\n given module position deltas. This method is often used for odometry --\n determining the robot's position on the field using data from the\n real-world position delta and angle of each module on the robot.\n\n @param wheelDeltas The latest change in position of the modules (as a\n SwerveModulePosition type) as measured from respective encoders and gyros.\n The order of the swerve module states should be same as passed into the\n constructor of this class.\n\n @return The resulting Twist2d."]
    #[link_name = "\u{1}ToTwist2d"]
    pub fn frc_SwerveDriveKinematics_ToTwist2d(this: *const u8, wheelDeltas: u8) -> frc_Twist2d;
}
extern "C" {
    #[doc = " Renormalizes the wheel speeds if any individual speed is above the\n specified maximum.\n\n Sometimes, after inverse kinematics, the requested speed\n from one or more modules may be above the max attainable speed for the\n driving motor on that module. To fix this issue, one can reduce all the\n wheel speeds to make sure that all requested module speeds are at-or-below\n the absolute threshold, while maintaining the ratio of speeds between\n modules.\n\n @param moduleStates Reference to array of module states. The array will be\n mutated with the normalized speeds!\n @param attainableMaxSpeed The absolute max speed that a module can reach."]
    #[link_name = "\u{1}DesaturateWheelSpeeds"]
    pub fn frc_SwerveDriveKinematics_DesaturateWheelSpeeds(
        moduleStates: *mut u8,
        attainableMaxSpeed: units_velocity_meters_per_second_t,
    );
}
extern "C" {
    #[doc = " Renormalizes the wheel speeds if any individual speed is above the\n specified maximum, as well as getting rid of joystick saturation at edges\n of joystick.\n\n Sometimes, after inverse kinematics, the requested speed\n from one or more modules may be above the max attainable speed for the\n driving motor on that module. To fix this issue, one can reduce all the\n wheel speeds to make sure that all requested module speeds are at-or-below\n the absolute threshold, while maintaining the ratio of speeds between\n modules.\n\n @param moduleStates Reference to array of module states. The array will be\n mutated with the normalized speeds!\n @param currentChassisSpeed Current speed of the robot\n @param attainableMaxModuleSpeed The absolute max speed a module can reach\n @param attainableMaxRobotTranslationSpeed The absolute max speed the robot\n can reach while translating\n @param attainableMaxRobotRotationSpeed The absolute max speed the robot can\n reach while rotating"]
    #[link_name = "\u{1}DesaturateWheelSpeeds"]
    pub fn frc_SwerveDriveKinematics_DesaturateWheelSpeeds1(
        moduleStates: *mut u8,
        currentChassisSpeed: frc_ChassisSpeeds,
        attainableMaxModuleSpeed: units_velocity_meters_per_second_t,
        attainableMaxRobotTranslationSpeed: units_velocity_meters_per_second_t,
        attainableMaxRobotRotationSpeed: units_angular_velocity_radians_per_second_t,
    );
}
extern "C" {
    #[doc = " Resets the robot's position on the field.\n\n The gyroscope angle does not need to be reset here on the user's robot\n code. The library automatically takes care of offsetting the gyro angle.\n\n @param gyroAngle The angle reported by the gyroscope.\n @param modulePositions The wheel positions reported by each module.\n @param pose The position on the field that your robot is at."]
    #[link_name = "\u{1}ResetPosition"]
    pub fn frc_SwerveDriveOdometry_ResetPosition(
        this: *mut u8,
        gyroAngle: *const frc_Rotation2d,
        modulePositions: *mut u8,
        pose: *const frc_Pose2d,
    );
}
extern "C" {
    #[doc = " Updates the robot's position on the field using forward kinematics and\n integration of the pose over time. This also takes in an angle parameter\n which is used instead of the angular rate that is calculated from forward\n kinematics.\n\n @param gyroAngle The angle reported by the gyroscope.\n @param modulePositions The current position of all swerve modules. Please\n provide the positions in the same order in which you instantiated your\n SwerveDriveKinematics.\n\n @return The new pose of the robot."]
    #[link_name = "\u{1}Update"]
    pub fn frc_SwerveDriveOdometry_Update(
        this: *mut u8,
        gyroAngle: *const frc_Rotation2d,
        modulePositions: *mut u8,
    ) -> *const frc_Pose2d;
}
#[doc = " Interface for NetworkTable Sendable objects."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_NTSendable {
    pub _base: wpi_Sendable,
}
#[test]
fn bindgen_test_layout_nt_NTSendable() {
    assert_eq!(
        ::std::mem::size_of::<nt_NTSendable>(),
        4usize,
        concat!("Size of: ", stringify!(nt_NTSendable))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_NTSendable>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_NTSendable))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt10NTSendable12InitSendableERN3wpi15SendableBuilderE"]
    pub fn nt_NTSendable_InitSendable1(
        this: *mut ::std::os::raw::c_void,
        builder: *mut wpi_SendableBuilder,
    );
}
pub const nt_NetworkTableType_kUnassigned: nt_NetworkTableType = 0;
pub const nt_NetworkTableType_kBoolean: nt_NetworkTableType = 1;
pub const nt_NetworkTableType_kDouble: nt_NetworkTableType = 2;
pub const nt_NetworkTableType_kString: nt_NetworkTableType = 4;
pub const nt_NetworkTableType_kRaw: nt_NetworkTableType = 8;
pub const nt_NetworkTableType_kBooleanArray: nt_NetworkTableType = 16;
pub const nt_NetworkTableType_kDoubleArray: nt_NetworkTableType = 32;
pub const nt_NetworkTableType_kStringArray: nt_NetworkTableType = 64;
pub const nt_NetworkTableType_kInteger: nt_NetworkTableType = 256;
pub const nt_NetworkTableType_kFloat: nt_NetworkTableType = 512;
pub const nt_NetworkTableType_kIntegerArray: nt_NetworkTableType = 1024;
pub const nt_NetworkTableType_kFloatArray: nt_NetworkTableType = 2048;
#[doc = " NetworkTable entry type.\n @ingroup ntcore_cpp_api"]
pub type nt_NetworkTableType = ::std::os::raw::c_int;
#[doc = " A network table entry value.\n @ingroup ntcore_cpp_api"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nt_Value {
    pub m_val: NT_Value,
    pub m_storage: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_Value_private_init {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_nt_Value_private_init() {
    assert_eq!(
        ::std::mem::size_of::<nt_Value_private_init>(),
        1usize,
        concat!("Size of: ", stringify!(nt_Value_private_init))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_Value_private_init>(),
        1usize,
        concat!("Alignment of ", stringify!(nt_Value_private_init))
    );
}
#[test]
fn bindgen_test_layout_nt_Value() {
    const UNINIT: ::std::mem::MaybeUninit<nt_Value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_Value>(),
        40usize,
        concat!("Size of: ", stringify!(nt_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_Value),
            "::",
            stringify!(m_val)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_storage) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_Value),
            "::",
            stringify!(m_storage)
        )
    );
}
extern "C" {
    #[doc = " Creates a boolean array entry value.\n\n @param value the value\n @param time if nonzero, the creation time to use (instead of the current\n             time)\n @return The entry value"]
    #[link_name = "\u{1}_ZN2nt5Value16MakeBooleanArrayESt4spanIKbLj4294967295EEx"]
    pub fn nt_Value_MakeBooleanArray(value: [u32; 2usize], time: i64) -> nt_Value;
}
extern "C" {
    #[doc = " Creates a boolean array entry value.\n\n @param value the value\n @param time if nonzero, the creation time to use (instead of the current\n             time)\n @return The entry value"]
    #[link_name = "\u{1}_ZN2nt5Value16MakeBooleanArrayESt4spanIKiLj4294967295EEx"]
    pub fn nt_Value_MakeBooleanArray1(value: [u32; 2usize], time: i64) -> nt_Value;
}
extern "C" {
    #[doc = " Creates a boolean array entry value.\n\n @param value the value\n @param time if nonzero, the creation time to use (instead of the current\n             time)\n @return The entry value\n\n @note This function moves the values out of the vector."]
    #[link_name = "\u{1}_ZN2nt5Value16MakeBooleanArrayEOSt6vectorIiSaIiEEx"]
    pub fn nt_Value_MakeBooleanArray2(value: *mut [u32; 3usize], time: i64) -> nt_Value;
}
extern "C" {
    #[doc = " Creates an integer array entry value.\n\n @param value the value\n @param time if nonzero, the creation time to use (instead of the current\n             time)\n @return The entry value"]
    #[link_name = "\u{1}_ZN2nt5Value16MakeIntegerArrayESt4spanIKxLj4294967295EEx"]
    pub fn nt_Value_MakeIntegerArray(value: [u32; 2usize], time: i64) -> nt_Value;
}
extern "C" {
    #[doc = " Creates an integer array entry value.\n\n @param value the value\n @param time if nonzero, the creation time to use (instead of the current\n             time)\n @return The entry value\n\n @note This function moves the values out of the vector."]
    #[link_name = "\u{1}_ZN2nt5Value16MakeIntegerArrayEOSt6vectorIxSaIxEEx"]
    pub fn nt_Value_MakeIntegerArray1(value: *mut [u32; 3usize], time: i64) -> nt_Value;
}
extern "C" {
    #[doc = " Creates a float array entry value.\n\n @param value the value\n @param time if nonzero, the creation time to use (instead of the current\n             time)\n @return The entry value"]
    #[link_name = "\u{1}_ZN2nt5Value14MakeFloatArrayESt4spanIKfLj4294967295EEx"]
    pub fn nt_Value_MakeFloatArray(value: [u32; 2usize], time: i64) -> nt_Value;
}
extern "C" {
    #[doc = " Creates a float array entry value.\n\n @param value the value\n @param time if nonzero, the creation time to use (instead of the current\n             time)\n @return The entry value\n\n @note This function moves the values out of the vector."]
    #[link_name = "\u{1}_ZN2nt5Value14MakeFloatArrayEOSt6vectorIfSaIfEEx"]
    pub fn nt_Value_MakeFloatArray1(value: *mut [u32; 3usize], time: i64) -> nt_Value;
}
extern "C" {
    #[doc = " Creates a double array entry value.\n\n @param value the value\n @param time if nonzero, the creation time to use (instead of the current\n             time)\n @return The entry value"]
    #[link_name = "\u{1}_ZN2nt5Value15MakeDoubleArrayESt4spanIKdLj4294967295EEx"]
    pub fn nt_Value_MakeDoubleArray(value: [u32; 2usize], time: i64) -> nt_Value;
}
extern "C" {
    #[doc = " Creates a double array entry value.\n\n @param value the value\n @param time if nonzero, the creation time to use (instead of the current\n             time)\n @return The entry value\n\n @note This function moves the values out of the vector."]
    #[link_name = "\u{1}_ZN2nt5Value15MakeDoubleArrayEOSt6vectorIdSaIdEEx"]
    pub fn nt_Value_MakeDoubleArray1(value: *mut [u32; 3usize], time: i64) -> nt_Value;
}
extern "C" {
    #[doc = " Creates a string array entry value.\n\n @param value the value\n @param time if nonzero, the creation time to use (instead of the current\n             time)\n @return The entry value"]
    #[link_name = "\u{1}_ZN2nt5Value15MakeStringArrayESt4spanIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELj4294967295EEx"]
    pub fn nt_Value_MakeStringArray(value: [u32; 2usize], time: i64) -> nt_Value;
}
extern "C" {
    #[doc = " Creates a string array entry value.\n\n @param value the value\n @param time if nonzero, the creation time to use (instead of the current\n             time)\n @return The entry value\n\n @note This function moves the values out of the vector."]
    #[link_name = "\u{1}_ZN2nt5Value15MakeStringArrayEOSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS7_EEx"]
    pub fn nt_Value_MakeStringArray1(value: *mut [u32; 3usize], time: i64) -> nt_Value;
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt5ValueC1Ev"]
    pub fn nt_Value_Value(this: *mut nt_Value);
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt5ValueC1E7NT_TypexRKNS0_12private_initE"]
    pub fn nt_Value_Value1(
        this: *mut nt_Value,
        type_: NT_Type,
        time: i64,
        arg1: *const nt_Value_private_init,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt5ValueC1E7NT_TypexxRKNS0_12private_initE"]
    pub fn nt_Value_Value2(
        this: *mut nt_Value,
        type_: NT_Type,
        time: i64,
        serverTime: i64,
        arg1: *const nt_Value_private_init,
    );
}
impl nt_Value {
    #[inline]
    pub unsafe fn MakeBooleanArray(value: [u32; 2usize], time: i64) -> nt_Value {
        nt_Value_MakeBooleanArray(value, time)
    }
    #[inline]
    pub unsafe fn MakeBooleanArray1(value: [u32; 2usize], time: i64) -> nt_Value {
        nt_Value_MakeBooleanArray1(value, time)
    }
    #[inline]
    pub unsafe fn MakeBooleanArray2(value: *mut [u32; 3usize], time: i64) -> nt_Value {
        nt_Value_MakeBooleanArray2(value, time)
    }
    #[inline]
    pub unsafe fn MakeIntegerArray(value: [u32; 2usize], time: i64) -> nt_Value {
        nt_Value_MakeIntegerArray(value, time)
    }
    #[inline]
    pub unsafe fn MakeIntegerArray1(value: *mut [u32; 3usize], time: i64) -> nt_Value {
        nt_Value_MakeIntegerArray1(value, time)
    }
    #[inline]
    pub unsafe fn MakeFloatArray(value: [u32; 2usize], time: i64) -> nt_Value {
        nt_Value_MakeFloatArray(value, time)
    }
    #[inline]
    pub unsafe fn MakeFloatArray1(value: *mut [u32; 3usize], time: i64) -> nt_Value {
        nt_Value_MakeFloatArray1(value, time)
    }
    #[inline]
    pub unsafe fn MakeDoubleArray(value: [u32; 2usize], time: i64) -> nt_Value {
        nt_Value_MakeDoubleArray(value, time)
    }
    #[inline]
    pub unsafe fn MakeDoubleArray1(value: *mut [u32; 3usize], time: i64) -> nt_Value {
        nt_Value_MakeDoubleArray1(value, time)
    }
    #[inline]
    pub unsafe fn MakeStringArray(value: [u32; 2usize], time: i64) -> nt_Value {
        nt_Value_MakeStringArray(value, time)
    }
    #[inline]
    pub unsafe fn MakeStringArray1(value: *mut [u32; 3usize], time: i64) -> nt_Value {
        nt_Value_MakeStringArray1(value, time)
    }
    #[inline]
    pub unsafe fn new() -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nt_Value_Value(__bindgen_tmp.as_mut_ptr());
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(type_: NT_Type, time: i64, arg1: *const nt_Value_private_init) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nt_Value_Value1(__bindgen_tmp.as_mut_ptr(), type_, time, arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        type_: NT_Type,
        time: i64,
        serverTime: i64,
        arg1: *const nt_Value_private_init,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nt_Value_Value2(__bindgen_tmp.as_mut_ptr(), type_, time, serverTime, arg1);
        __bindgen_tmp.assume_init()
    }
}
#[doc = " A network table entry value.\n @ingroup ntcore_cpp_api"]
pub type nt_NetworkTableValue = nt_Value;
#[doc = " Timestamped Boolean.\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_TimestampedBoolean {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: bool,
}
#[test]
fn bindgen_test_layout_nt_TimestampedBoolean() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedBoolean> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedBoolean>(),
        24usize,
        concat!("Size of: ", stringify!(nt_TimestampedBoolean))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedBoolean>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedBoolean))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedBoolean),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedBoolean),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedBoolean),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param value value to publish\n @param time timestamp; 0 indicates current NT time should be used"]
    #[link_name = "\u{1}_ZN2nt10SetBooleanEjbx"]
    pub fn nt_SetBoolean(pubentry: NT_Handle, value: bool, time: i64) -> bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    #[link_name = "\u{1}_ZN2nt17SetDefaultBooleanEjb"]
    pub fn nt_SetDefaultBoolean(pubentry: NT_Handle, defaultValue: bool) -> bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    #[link_name = "\u{1}_ZN2nt10GetBooleanEjb"]
    pub fn nt_GetBoolean(subentry: NT_Handle, defaultValue: bool) -> bool;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return timestamped value"]
    #[link_name = "\u{1}_ZN2nt16GetAtomicBooleanEjb"]
    pub fn nt_GetAtomicBoolean(subentry: NT_Handle, defaultValue: bool) -> nt_TimestampedBoolean;
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of timestamped values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt16ReadQueueBooleanEj"]
    pub fn nt_ReadQueueBoolean(subentry: NT_Handle) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt22ReadQueueValuesBooleanEj"]
    pub fn nt_ReadQueueValuesBoolean(subentry: NT_Handle) -> [u32; 3usize];
}
#[doc = " Timestamped Integer.\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_TimestampedInteger {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: i64,
}
#[test]
fn bindgen_test_layout_nt_TimestampedInteger() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedInteger> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedInteger>(),
        24usize,
        concat!("Size of: ", stringify!(nt_TimestampedInteger))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedInteger>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedInteger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedInteger),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedInteger),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedInteger),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param value value to publish\n @param time timestamp; 0 indicates current NT time should be used"]
    #[link_name = "\u{1}_ZN2nt10SetIntegerEjxx"]
    pub fn nt_SetInteger(pubentry: NT_Handle, value: i64, time: i64) -> bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    #[link_name = "\u{1}_ZN2nt17SetDefaultIntegerEjx"]
    pub fn nt_SetDefaultInteger(pubentry: NT_Handle, defaultValue: i64) -> bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    #[link_name = "\u{1}_ZN2nt10GetIntegerEjx"]
    pub fn nt_GetInteger(subentry: NT_Handle, defaultValue: i64) -> i64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return timestamped value"]
    #[link_name = "\u{1}_ZN2nt16GetAtomicIntegerEjx"]
    pub fn nt_GetAtomicInteger(subentry: NT_Handle, defaultValue: i64) -> nt_TimestampedInteger;
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of timestamped values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt16ReadQueueIntegerEj"]
    pub fn nt_ReadQueueInteger(subentry: NT_Handle) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt22ReadQueueValuesIntegerEj"]
    pub fn nt_ReadQueueValuesInteger(subentry: NT_Handle) -> [u32; 3usize];
}
#[doc = " Timestamped Float.\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_TimestampedFloat {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_nt_TimestampedFloat() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedFloat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedFloat>(),
        24usize,
        concat!("Size of: ", stringify!(nt_TimestampedFloat))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedFloat>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedFloat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedFloat),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedFloat),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedFloat),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param value value to publish\n @param time timestamp; 0 indicates current NT time should be used"]
    #[link_name = "\u{1}_ZN2nt8SetFloatEjfx"]
    pub fn nt_SetFloat(pubentry: NT_Handle, value: f32, time: i64) -> bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    #[link_name = "\u{1}_ZN2nt15SetDefaultFloatEjf"]
    pub fn nt_SetDefaultFloat(pubentry: NT_Handle, defaultValue: f32) -> bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    #[link_name = "\u{1}_ZN2nt8GetFloatEjf"]
    pub fn nt_GetFloat(subentry: NT_Handle, defaultValue: f32) -> f32;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return timestamped value"]
    #[link_name = "\u{1}_ZN2nt14GetAtomicFloatEjf"]
    pub fn nt_GetAtomicFloat(subentry: NT_Handle, defaultValue: f32) -> nt_TimestampedFloat;
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of timestamped values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt14ReadQueueFloatEj"]
    pub fn nt_ReadQueueFloat(subentry: NT_Handle) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt20ReadQueueValuesFloatEj"]
    pub fn nt_ReadQueueValuesFloat(subentry: NT_Handle) -> [u32; 3usize];
}
#[doc = " Timestamped Double.\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_TimestampedDouble {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: f64,
}
#[test]
fn bindgen_test_layout_nt_TimestampedDouble() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedDouble> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedDouble>(),
        24usize,
        concat!("Size of: ", stringify!(nt_TimestampedDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedDouble))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedDouble),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedDouble),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedDouble),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param value value to publish\n @param time timestamp; 0 indicates current NT time should be used"]
    #[link_name = "\u{1}_ZN2nt9SetDoubleEjdx"]
    pub fn nt_SetDouble(pubentry: NT_Handle, value: f64, time: i64) -> bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    #[link_name = "\u{1}_ZN2nt16SetDefaultDoubleEjd"]
    pub fn nt_SetDefaultDouble(pubentry: NT_Handle, defaultValue: f64) -> bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    #[link_name = "\u{1}_ZN2nt9GetDoubleEjd"]
    pub fn nt_GetDouble(subentry: NT_Handle, defaultValue: f64) -> f64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return timestamped value"]
    #[link_name = "\u{1}_ZN2nt15GetAtomicDoubleEjd"]
    pub fn nt_GetAtomicDouble(subentry: NT_Handle, defaultValue: f64) -> nt_TimestampedDouble;
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of timestamped values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt15ReadQueueDoubleEj"]
    pub fn nt_ReadQueueDouble(subentry: NT_Handle) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt21ReadQueueValuesDoubleEj"]
    pub fn nt_ReadQueueValuesDouble(subentry: NT_Handle) -> [u32; 3usize];
}
#[doc = " Timestamped String.\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_TimestampedString {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: std_string,
}
#[test]
fn bindgen_test_layout_nt_TimestampedString() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedString>(),
        40usize,
        concat!("Size of: ", stringify!(nt_TimestampedString))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedString>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedString),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedString),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedString),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Timestamped String view (for SmallVector-taking functions).\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_TimestampedStringView {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: std_string_view,
}
#[test]
fn bindgen_test_layout_nt_TimestampedStringView() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedStringView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedStringView>(),
        24usize,
        concat!("Size of: ", stringify!(nt_TimestampedStringView))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedStringView>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedStringView))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedStringView),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedStringView),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedStringView),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param value value to publish\n @param time timestamp; 0 indicates current NT time should be used"]
    #[link_name = "\u{1}_ZN2nt9SetStringEjSt17basic_string_viewIcSt11char_traitsIcEEx"]
    pub fn nt_SetString(pubentry: NT_Handle, value: std_string_view, time: i64) -> bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    #[link_name = "\u{1}_ZN2nt16SetDefaultStringEjSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_SetDefaultString(pubentry: NT_Handle, defaultValue: std_string_view) -> bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    #[link_name = "\u{1}_ZN2nt9GetStringB5cxx11EjSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_GetString(subentry: NT_Handle, defaultValue: std_string_view) -> std_string;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return timestamped value"]
    #[link_name = "\u{1}_ZN2nt15GetAtomicStringEjSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_GetAtomicString(
        subentry: NT_Handle,
        defaultValue: std_string_view,
    ) -> nt_TimestampedString;
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of timestamped values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt15ReadQueueStringEj"]
    pub fn nt_ReadQueueString(subentry: NT_Handle) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt21ReadQueueValuesStringB5cxx11Ej"]
    pub fn nt_ReadQueueValuesString(subentry: NT_Handle) -> [u32; 3usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt9GetStringEjRN3wpi15SmallVectorImplIcEESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_GetString1(
        subentry: NT_Handle,
        buf: *mut wpi_SmallVectorImpl,
        defaultValue: std_string_view,
    ) -> std_string_view;
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt15GetAtomicStringEjRN3wpi15SmallVectorImplIcEESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_GetAtomicString1(
        subentry: NT_Handle,
        buf: *mut wpi_SmallVectorImpl,
        defaultValue: std_string_view,
    ) -> nt_TimestampedStringView;
}
#[doc = " Timestamped Raw.\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_TimestampedRaw {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_nt_TimestampedRaw() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedRaw> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedRaw>(),
        32usize,
        concat!("Size of: ", stringify!(nt_TimestampedRaw))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedRaw>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedRaw))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedRaw),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedRaw),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedRaw),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Timestamped Raw view (for SmallVector-taking functions).\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_TimestampedRawView {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_nt_TimestampedRawView() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedRawView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedRawView>(),
        24usize,
        concat!("Size of: ", stringify!(nt_TimestampedRawView))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedRawView>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedRawView))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedRawView),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedRawView),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedRawView),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param value value to publish\n @param time timestamp; 0 indicates current NT time should be used"]
    #[link_name = "\u{1}_ZN2nt6SetRawEjSt4spanIKhLj4294967295EEx"]
    pub fn nt_SetRaw(pubentry: NT_Handle, value: [u32; 2usize], time: i64) -> bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    #[link_name = "\u{1}_ZN2nt13SetDefaultRawEjSt4spanIKhLj4294967295EE"]
    pub fn nt_SetDefaultRaw(pubentry: NT_Handle, defaultValue: [u32; 2usize]) -> bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    #[link_name = "\u{1}_ZN2nt6GetRawEjSt4spanIKhLj4294967295EE"]
    pub fn nt_GetRaw(subentry: NT_Handle, defaultValue: [u32; 2usize]) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return timestamped value"]
    #[link_name = "\u{1}_ZN2nt12GetAtomicRawEjSt4spanIKhLj4294967295EE"]
    pub fn nt_GetAtomicRaw(subentry: NT_Handle, defaultValue: [u32; 2usize]) -> nt_TimestampedRaw;
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of timestamped values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt12ReadQueueRawEj"]
    pub fn nt_ReadQueueRaw(subentry: NT_Handle) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt18ReadQueueValuesRawEj"]
    pub fn nt_ReadQueueValuesRaw(subentry: NT_Handle) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt6GetRawEjRN3wpi15SmallVectorImplIhEESt4spanIKhLj4294967295EE"]
    pub fn nt_GetRaw1(
        subentry: NT_Handle,
        buf: *mut wpi_SmallVectorImpl,
        defaultValue: [u32; 2usize],
    ) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt12GetAtomicRawEjRN3wpi15SmallVectorImplIhEESt4spanIKhLj4294967295EE"]
    pub fn nt_GetAtomicRaw1(
        subentry: NT_Handle,
        buf: *mut wpi_SmallVectorImpl,
        defaultValue: [u32; 2usize],
    ) -> nt_TimestampedRawView;
}
#[doc = " Timestamped BooleanArray.\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_TimestampedBooleanArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_nt_TimestampedBooleanArray() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedBooleanArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedBooleanArray>(),
        32usize,
        concat!("Size of: ", stringify!(nt_TimestampedBooleanArray))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedBooleanArray>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedBooleanArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedBooleanArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedBooleanArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedBooleanArray),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Timestamped BooleanArray view (for SmallVector-taking functions).\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_TimestampedBooleanArrayView {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_nt_TimestampedBooleanArrayView() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedBooleanArrayView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedBooleanArrayView>(),
        24usize,
        concat!("Size of: ", stringify!(nt_TimestampedBooleanArrayView))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedBooleanArrayView>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedBooleanArrayView))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedBooleanArrayView),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedBooleanArrayView),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedBooleanArrayView),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param value value to publish\n @param time timestamp; 0 indicates current NT time should be used"]
    #[link_name = "\u{1}_ZN2nt15SetBooleanArrayEjSt4spanIKiLj4294967295EEx"]
    pub fn nt_SetBooleanArray(pubentry: NT_Handle, value: [u32; 2usize], time: i64) -> bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    #[link_name = "\u{1}_ZN2nt22SetDefaultBooleanArrayEjSt4spanIKiLj4294967295EE"]
    pub fn nt_SetDefaultBooleanArray(pubentry: NT_Handle, defaultValue: [u32; 2usize]) -> bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    #[link_name = "\u{1}_ZN2nt15GetBooleanArrayEjSt4spanIKiLj4294967295EE"]
    pub fn nt_GetBooleanArray(subentry: NT_Handle, defaultValue: [u32; 2usize]) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return timestamped value"]
    #[link_name = "\u{1}_ZN2nt21GetAtomicBooleanArrayEjSt4spanIKiLj4294967295EE"]
    pub fn nt_GetAtomicBooleanArray(
        subentry: NT_Handle,
        defaultValue: [u32; 2usize],
    ) -> nt_TimestampedBooleanArray;
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of timestamped values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt21ReadQueueBooleanArrayEj"]
    pub fn nt_ReadQueueBooleanArray(subentry: NT_Handle) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt27ReadQueueValuesBooleanArrayEj"]
    pub fn nt_ReadQueueValuesBooleanArray(subentry: NT_Handle) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt15GetBooleanArrayEjRN3wpi15SmallVectorImplIiEESt4spanIKiLj4294967295EE"]
    pub fn nt_GetBooleanArray1(
        subentry: NT_Handle,
        buf: *mut wpi_SmallVectorImpl,
        defaultValue: [u32; 2usize],
    ) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt21GetAtomicBooleanArrayEjRN3wpi15SmallVectorImplIiEESt4spanIKiLj4294967295EE"]
    pub fn nt_GetAtomicBooleanArray1(
        subentry: NT_Handle,
        buf: *mut wpi_SmallVectorImpl,
        defaultValue: [u32; 2usize],
    ) -> nt_TimestampedBooleanArrayView;
}
#[doc = " Timestamped IntegerArray.\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_TimestampedIntegerArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_nt_TimestampedIntegerArray() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedIntegerArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedIntegerArray>(),
        32usize,
        concat!("Size of: ", stringify!(nt_TimestampedIntegerArray))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedIntegerArray>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedIntegerArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedIntegerArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedIntegerArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedIntegerArray),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Timestamped IntegerArray view (for SmallVector-taking functions).\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_TimestampedIntegerArrayView {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_nt_TimestampedIntegerArrayView() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedIntegerArrayView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedIntegerArrayView>(),
        24usize,
        concat!("Size of: ", stringify!(nt_TimestampedIntegerArrayView))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedIntegerArrayView>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedIntegerArrayView))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedIntegerArrayView),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedIntegerArrayView),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedIntegerArrayView),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param value value to publish\n @param time timestamp; 0 indicates current NT time should be used"]
    #[link_name = "\u{1}_ZN2nt15SetIntegerArrayEjSt4spanIKxLj4294967295EEx"]
    pub fn nt_SetIntegerArray(pubentry: NT_Handle, value: [u32; 2usize], time: i64) -> bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    #[link_name = "\u{1}_ZN2nt22SetDefaultIntegerArrayEjSt4spanIKxLj4294967295EE"]
    pub fn nt_SetDefaultIntegerArray(pubentry: NT_Handle, defaultValue: [u32; 2usize]) -> bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    #[link_name = "\u{1}_ZN2nt15GetIntegerArrayEjSt4spanIKxLj4294967295EE"]
    pub fn nt_GetIntegerArray(subentry: NT_Handle, defaultValue: [u32; 2usize]) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return timestamped value"]
    #[link_name = "\u{1}_ZN2nt21GetAtomicIntegerArrayEjSt4spanIKxLj4294967295EE"]
    pub fn nt_GetAtomicIntegerArray(
        subentry: NT_Handle,
        defaultValue: [u32; 2usize],
    ) -> nt_TimestampedIntegerArray;
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of timestamped values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt21ReadQueueIntegerArrayEj"]
    pub fn nt_ReadQueueIntegerArray(subentry: NT_Handle) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt27ReadQueueValuesIntegerArrayEj"]
    pub fn nt_ReadQueueValuesIntegerArray(subentry: NT_Handle) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt15GetIntegerArrayEjRN3wpi15SmallVectorImplIxEESt4spanIKxLj4294967295EE"]
    pub fn nt_GetIntegerArray1(
        subentry: NT_Handle,
        buf: *mut wpi_SmallVectorImpl,
        defaultValue: [u32; 2usize],
    ) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt21GetAtomicIntegerArrayEjRN3wpi15SmallVectorImplIxEESt4spanIKxLj4294967295EE"]
    pub fn nt_GetAtomicIntegerArray1(
        subentry: NT_Handle,
        buf: *mut wpi_SmallVectorImpl,
        defaultValue: [u32; 2usize],
    ) -> nt_TimestampedIntegerArrayView;
}
#[doc = " Timestamped FloatArray.\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_TimestampedFloatArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_nt_TimestampedFloatArray() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedFloatArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedFloatArray>(),
        32usize,
        concat!("Size of: ", stringify!(nt_TimestampedFloatArray))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedFloatArray>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedFloatArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedFloatArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedFloatArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedFloatArray),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Timestamped FloatArray view (for SmallVector-taking functions).\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_TimestampedFloatArrayView {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_nt_TimestampedFloatArrayView() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedFloatArrayView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedFloatArrayView>(),
        24usize,
        concat!("Size of: ", stringify!(nt_TimestampedFloatArrayView))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedFloatArrayView>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedFloatArrayView))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedFloatArrayView),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedFloatArrayView),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedFloatArrayView),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param value value to publish\n @param time timestamp; 0 indicates current NT time should be used"]
    #[link_name = "\u{1}_ZN2nt13SetFloatArrayEjSt4spanIKfLj4294967295EEx"]
    pub fn nt_SetFloatArray(pubentry: NT_Handle, value: [u32; 2usize], time: i64) -> bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    #[link_name = "\u{1}_ZN2nt20SetDefaultFloatArrayEjSt4spanIKfLj4294967295EE"]
    pub fn nt_SetDefaultFloatArray(pubentry: NT_Handle, defaultValue: [u32; 2usize]) -> bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    #[link_name = "\u{1}_ZN2nt13GetFloatArrayEjSt4spanIKfLj4294967295EE"]
    pub fn nt_GetFloatArray(subentry: NT_Handle, defaultValue: [u32; 2usize]) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return timestamped value"]
    #[link_name = "\u{1}_ZN2nt19GetAtomicFloatArrayEjSt4spanIKfLj4294967295EE"]
    pub fn nt_GetAtomicFloatArray(
        subentry: NT_Handle,
        defaultValue: [u32; 2usize],
    ) -> nt_TimestampedFloatArray;
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of timestamped values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt19ReadQueueFloatArrayEj"]
    pub fn nt_ReadQueueFloatArray(subentry: NT_Handle) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt25ReadQueueValuesFloatArrayEj"]
    pub fn nt_ReadQueueValuesFloatArray(subentry: NT_Handle) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt13GetFloatArrayEjRN3wpi15SmallVectorImplIfEESt4spanIKfLj4294967295EE"]
    pub fn nt_GetFloatArray1(
        subentry: NT_Handle,
        buf: *mut wpi_SmallVectorImpl,
        defaultValue: [u32; 2usize],
    ) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt19GetAtomicFloatArrayEjRN3wpi15SmallVectorImplIfEESt4spanIKfLj4294967295EE"]
    pub fn nt_GetAtomicFloatArray1(
        subentry: NT_Handle,
        buf: *mut wpi_SmallVectorImpl,
        defaultValue: [u32; 2usize],
    ) -> nt_TimestampedFloatArrayView;
}
#[doc = " Timestamped DoubleArray.\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_TimestampedDoubleArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_nt_TimestampedDoubleArray() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedDoubleArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedDoubleArray>(),
        32usize,
        concat!("Size of: ", stringify!(nt_TimestampedDoubleArray))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedDoubleArray>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedDoubleArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedDoubleArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedDoubleArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedDoubleArray),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Timestamped DoubleArray view (for SmallVector-taking functions).\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_TimestampedDoubleArrayView {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_nt_TimestampedDoubleArrayView() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedDoubleArrayView> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedDoubleArrayView>(),
        24usize,
        concat!("Size of: ", stringify!(nt_TimestampedDoubleArrayView))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedDoubleArrayView>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedDoubleArrayView))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedDoubleArrayView),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedDoubleArrayView),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedDoubleArrayView),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param value value to publish\n @param time timestamp; 0 indicates current NT time should be used"]
    #[link_name = "\u{1}_ZN2nt14SetDoubleArrayEjSt4spanIKdLj4294967295EEx"]
    pub fn nt_SetDoubleArray(pubentry: NT_Handle, value: [u32; 2usize], time: i64) -> bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    #[link_name = "\u{1}_ZN2nt21SetDefaultDoubleArrayEjSt4spanIKdLj4294967295EE"]
    pub fn nt_SetDefaultDoubleArray(pubentry: NT_Handle, defaultValue: [u32; 2usize]) -> bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    #[link_name = "\u{1}_ZN2nt14GetDoubleArrayEjSt4spanIKdLj4294967295EE"]
    pub fn nt_GetDoubleArray(subentry: NT_Handle, defaultValue: [u32; 2usize]) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return timestamped value"]
    #[link_name = "\u{1}_ZN2nt20GetAtomicDoubleArrayEjSt4spanIKdLj4294967295EE"]
    pub fn nt_GetAtomicDoubleArray(
        subentry: NT_Handle,
        defaultValue: [u32; 2usize],
    ) -> nt_TimestampedDoubleArray;
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of timestamped values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt20ReadQueueDoubleArrayEj"]
    pub fn nt_ReadQueueDoubleArray(subentry: NT_Handle) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt26ReadQueueValuesDoubleArrayEj"]
    pub fn nt_ReadQueueValuesDoubleArray(subentry: NT_Handle) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt14GetDoubleArrayEjRN3wpi15SmallVectorImplIdEESt4spanIKdLj4294967295EE"]
    pub fn nt_GetDoubleArray1(
        subentry: NT_Handle,
        buf: *mut wpi_SmallVectorImpl,
        defaultValue: [u32; 2usize],
    ) -> [u32; 2usize];
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt20GetAtomicDoubleArrayEjRN3wpi15SmallVectorImplIdEESt4spanIKdLj4294967295EE"]
    pub fn nt_GetAtomicDoubleArray1(
        subentry: NT_Handle,
        buf: *mut wpi_SmallVectorImpl,
        defaultValue: [u32; 2usize],
    ) -> nt_TimestampedDoubleArrayView;
}
#[doc = " Timestamped StringArray.\n @ingroup ntcore_cpp_handle_api"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_TimestampedStringArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_nt_TimestampedStringArray() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimestampedStringArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimestampedStringArray>(),
        32usize,
        concat!("Size of: ", stringify!(nt_TimestampedStringArray))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimestampedStringArray>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimestampedStringArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedStringArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedStringArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimestampedStringArray),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param value value to publish\n @param time timestamp; 0 indicates current NT time should be used"]
    #[link_name = "\u{1}_ZN2nt14SetStringArrayEjSt4spanIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELj4294967295EEx"]
    pub fn nt_SetStringArray(pubentry: NT_Handle, value: [u32; 2usize], time: i64) -> bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    #[link_name = "\u{1}_ZN2nt21SetDefaultStringArrayEjSt4spanIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELj4294967295EE"]
    pub fn nt_SetDefaultStringArray(pubentry: NT_Handle, defaultValue: [u32; 2usize]) -> bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    #[link_name = "\u{1}_ZN2nt14GetStringArrayEjSt4spanIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELj4294967295EE"]
    pub fn nt_GetStringArray(subentry: NT_Handle, defaultValue: [u32; 2usize]) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return timestamped value"]
    #[link_name = "\u{1}_ZN2nt20GetAtomicStringArrayEjSt4spanIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELj4294967295EE"]
    pub fn nt_GetAtomicStringArray(
        subentry: NT_Handle,
        defaultValue: [u32; 2usize],
    ) -> nt_TimestampedStringArray;
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of timestamped values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt20ReadQueueStringArrayEj"]
    pub fn nt_ReadQueueStringArray(subentry: NT_Handle) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @return Array of values; empty array if no new changes have\n     been published since the previous call."]
    #[link_name = "\u{1}_ZN2nt26ReadQueueValuesStringArrayB5cxx11Ej"]
    pub fn nt_ReadQueueValuesStringArray(subentry: NT_Handle) -> u8;
}
#[doc = " Event notification flags.\n\n The flags are a bitmask and must be OR'ed together to indicate the\n combination of events desired to be received.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_EventFlags {
    pub _address: u8,
}
pub const nt_EventFlags_kNone: ::std::os::raw::c_uint = 0;
#[doc = " Initial listener addition.\n Set this flag to receive immediate notification of matches to the\n flag criteria."]
pub const nt_EventFlags_kImmediate: ::std::os::raw::c_uint = 1;
#[doc = " Client connected (on server, any client connected)."]
pub const nt_EventFlags_kConnected: ::std::os::raw::c_uint = 2;
#[doc = " Client disconnected (on server, any client disconnected)."]
pub const nt_EventFlags_kDisconnected: ::std::os::raw::c_uint = 4;
#[doc = " Any connection event (connect or disconnect)."]
pub const nt_EventFlags_kConnection: ::std::os::raw::c_uint = 6;
#[doc = " New topic published."]
pub const nt_EventFlags_kPublish: ::std::os::raw::c_uint = 8;
#[doc = " Topic unpublished."]
pub const nt_EventFlags_kUnpublish: ::std::os::raw::c_uint = 16;
#[doc = " Topic properties changed."]
pub const nt_EventFlags_kProperties: ::std::os::raw::c_uint = 32;
#[doc = " Any topic event (publish, unpublish, or properties changed)."]
pub const nt_EventFlags_kTopic: ::std::os::raw::c_uint = 56;
#[doc = " Topic value updated (via network)."]
pub const nt_EventFlags_kValueRemote: ::std::os::raw::c_uint = 64;
#[doc = " Topic value updated (local)."]
pub const nt_EventFlags_kValueLocal: ::std::os::raw::c_uint = 128;
#[doc = " Topic value updated (network or local)."]
pub const nt_EventFlags_kValueAll: ::std::os::raw::c_uint = 192;
#[doc = " Log message."]
pub const nt_EventFlags_kLogMessage: ::std::os::raw::c_uint = 256;
#[doc = " Time synchronized with server."]
pub const nt_EventFlags_kTimeSync: ::std::os::raw::c_uint = 512;
#[test]
fn bindgen_test_layout_nt_EventFlags() {
    assert_eq!(
        ::std::mem::size_of::<nt_EventFlags>(),
        1usize,
        concat!("Size of: ", stringify!(nt_EventFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_EventFlags>(),
        1usize,
        concat!("Alignment of ", stringify!(nt_EventFlags))
    );
}
#[doc = " NetworkTables Topic Information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_TopicInfo {
    #[doc = " Topic handle"]
    pub topic: NT_Topic,
    #[doc = " Topic name"]
    pub name: std_string,
    #[doc = " Topic type"]
    pub type_: NT_Type,
    #[doc = " Topic type string"]
    pub type_str: std_string,
    #[doc = " Topic properties JSON string"]
    pub properties: std_string,
}
#[test]
fn bindgen_test_layout_nt_TopicInfo() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TopicInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TopicInfo>(),
        80usize,
        concat!("Size of: ", stringify!(nt_TopicInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TopicInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_TopicInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TopicInfo),
            "::",
            stringify!(topic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TopicInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TopicInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_str) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TopicInfo),
            "::",
            stringify!(type_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TopicInfo),
            "::",
            stringify!(properties)
        )
    );
}
extern "C" {
    #[doc = " Get topic properties as a JSON object."]
    #[link_name = "\u{1}_ZNK2nt9TopicInfo13GetPropertiesEv"]
    pub fn nt_TopicInfo_GetProperties(this: *const nt_TopicInfo) -> wpi_json;
}
impl nt_TopicInfo {
    #[inline]
    pub unsafe fn GetProperties(&self) -> wpi_json {
        nt_TopicInfo_GetProperties(self)
    }
}
#[doc = " NetworkTables Connection Information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_ConnectionInfo {
    #[doc = " The remote identifier (as set on the remote node by\n NetworkTableInstance::StartClient4() or nt::StartClient4())."]
    pub remote_id: std_string,
    #[doc = " The IP address of the remote node."]
    pub remote_ip: std_string,
    #[doc = " The port number of the remote node."]
    pub remote_port: ::std::os::raw::c_uint,
    #[doc = " The last time any update was received from the remote node (same scale as\n returned by nt::Now())."]
    pub last_update: i64,
    #[doc = " The protocol version being used for this connection.  This in protocol\n layer format, so 0x0200 = 2.0, 0x0300 = 3.0)."]
    pub protocol_version: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nt_ConnectionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<nt_ConnectionInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_ConnectionInfo>(),
        72usize,
        concat!("Size of: ", stringify!(nt_ConnectionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_ConnectionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_ConnectionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_ConnectionInfo),
            "::",
            stringify!(remote_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_ip) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_ConnectionInfo),
            "::",
            stringify!(remote_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_port) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_ConnectionInfo),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_update) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_ConnectionInfo),
            "::",
            stringify!(last_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_version) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_ConnectionInfo),
            "::",
            stringify!(protocol_version)
        )
    );
}
#[doc = " NetworkTables Value Event Data"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nt_ValueEventData {
    #[doc = " Topic handle."]
    pub topic: NT_Topic,
    #[doc = " Subscriber/entry handle."]
    pub subentry: NT_Handle,
    #[doc = " The new value."]
    pub value: nt_Value,
}
#[test]
fn bindgen_test_layout_nt_ValueEventData() {
    const UNINIT: ::std::mem::MaybeUninit<nt_ValueEventData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_ValueEventData>(),
        48usize,
        concat!("Size of: ", stringify!(nt_ValueEventData))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_ValueEventData>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_ValueEventData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_ValueEventData),
            "::",
            stringify!(topic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subentry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_ValueEventData),
            "::",
            stringify!(subentry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_ValueEventData),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " NetworkTables log message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_LogMessage {
    #[doc = " Log level of the message.  See NT_LogLevel."]
    pub level: ::std::os::raw::c_uint,
    #[doc = " The filename of the source file that generated the message."]
    pub filename: std_string,
    #[doc = " The line number in the source file that generated the message."]
    pub line: ::std::os::raw::c_uint,
    #[doc = " The message."]
    pub message: std_string,
}
#[test]
fn bindgen_test_layout_nt_LogMessage() {
    const UNINIT: ::std::mem::MaybeUninit<nt_LogMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_LogMessage>(),
        56usize,
        concat!("Size of: ", stringify!(nt_LogMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_LogMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_LogMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_LogMessage),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_LogMessage),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_LogMessage),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_LogMessage),
            "::",
            stringify!(message)
        )
    );
}
#[doc = " NetworkTables time sync event data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_TimeSyncEventData {
    #[doc = " Offset between local time and server time, in microseconds. Add this value\n to local time to get the estimated equivalent server time."]
    pub serverTimeOffset: i64,
    #[doc = " Measured round trip time divided by 2, in microseconds."]
    pub rtt2: i64,
    #[doc = " If serverTimeOffset and RTT are valid. An event with this set to false is\n sent when the client disconnects."]
    pub valid: bool,
}
#[test]
fn bindgen_test_layout_nt_TimeSyncEventData() {
    const UNINIT: ::std::mem::MaybeUninit<nt_TimeSyncEventData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_TimeSyncEventData>(),
        24usize,
        concat!("Size of: ", stringify!(nt_TimeSyncEventData))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_TimeSyncEventData>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_TimeSyncEventData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTimeOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimeSyncEventData),
            "::",
            stringify!(serverTimeOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtt2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimeSyncEventData),
            "::",
            stringify!(rtt2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_TimeSyncEventData),
            "::",
            stringify!(valid)
        )
    );
}
#[doc = " NetworkTables event"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_Event {
    #[doc = " Listener that triggered this event."]
    pub listener: NT_Listener,
    #[doc = " Event flags (NT_EventFlags). Also indicates the data included with the\n event:\n - NT_EVENT_CONNECTED or NT_EVENT_DISCONNECTED: GetConnectionInfo()\n - NT_EVENT_PUBLISH, NT_EVENT_UNPUBLISH, or NT_EVENT_PROPERTIES:\n   GetTopicInfo()\n - NT_EVENT_VALUE, NT_EVENT_VALUE_LOCAL: GetValueData()\n - NT_EVENT_LOGMESSAGE: GetLogMessage()\n - NT_EVENT_TIMESYNC: GetTimeSyncEventData()"]
    pub flags: ::std::os::raw::c_uint,
    #[doc = " Event data; content depends on flags."]
    pub data: [u64; 11usize],
}
#[test]
fn bindgen_test_layout_nt_Event() {
    const UNINIT: ::std::mem::MaybeUninit<nt_Event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_Event>(),
        96usize,
        concat!("Size of: ", stringify!(nt_Event))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_Event>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_Event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listener) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_Event),
            "::",
            stringify!(listener)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_Event),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_Event),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " NetworkTables publish/subscribe options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_PubSubOptions {
    #[doc = " Structure size. Must be set to sizeof(PubSubOptions)."]
    pub structSize: ::std::os::raw::c_uint,
    #[doc = " Polling storage size for a subscription. Specifies the maximum number of\n updates NetworkTables should store between calls to the subscriber's\n ReadQueue() function. If zero, defaults to 1 if sendAll is false, 20 if\n sendAll is true."]
    pub pollStorage: ::std::os::raw::c_uint,
    #[doc = " How frequently changes will be sent over the network, in seconds.\n NetworkTables may send more frequently than this (e.g. use a combined\n minimum period for all values) or apply a restricted range to this value.\n The default is 100 ms."]
    pub periodic: f64,
    #[doc = " For subscriptions, if non-zero, value updates for ReadQueue() are not\n queued for this publisher."]
    pub excludePublisher: NT_Publisher,
    #[doc = " Send all value changes over the network."]
    pub sendAll: bool,
    #[doc = " For subscriptions, don't ask for value changes (only topic announcements)."]
    pub topicsOnly: bool,
    #[doc = " Preserve duplicate value changes (rather than ignoring them)."]
    pub keepDuplicates: bool,
    #[doc = " Perform prefix match on subscriber topic names. Is ignored/overridden by\n Subscribe() functions; only present in struct for the purposes of getting\n information about subscriptions."]
    pub prefixMatch: bool,
    #[doc = " For subscriptions, if remote value updates should not be queued for\n ReadQueue(). See also disableLocal."]
    pub disableRemote: bool,
    #[doc = " For subscriptions, if local value updates should not be queued for\n ReadQueue(). See also disableRemote."]
    pub disableLocal: bool,
    #[doc = " For entries, don't queue (for ReadQueue) value updates for the entry's\n internal publisher."]
    pub excludeSelf: bool,
}
#[doc = " Default value of periodic."]
pub const nt_PubSubOptions_kDefaultPeriodic: f64 = 0.1;
#[test]
fn bindgen_test_layout_nt_PubSubOptions() {
    const UNINIT: ::std::mem::MaybeUninit<nt_PubSubOptions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_PubSubOptions>(),
        32usize,
        concat!("Size of: ", stringify!(nt_PubSubOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_PubSubOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_PubSubOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_PubSubOptions),
            "::",
            stringify!(structSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pollStorage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_PubSubOptions),
            "::",
            stringify!(pollStorage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).periodic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_PubSubOptions),
            "::",
            stringify!(periodic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).excludePublisher) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_PubSubOptions),
            "::",
            stringify!(excludePublisher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sendAll) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_PubSubOptions),
            "::",
            stringify!(sendAll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicsOnly) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_PubSubOptions),
            "::",
            stringify!(topicsOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepDuplicates) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_PubSubOptions),
            "::",
            stringify!(keepDuplicates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixMatch) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_PubSubOptions),
            "::",
            stringify!(prefixMatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disableRemote) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_PubSubOptions),
            "::",
            stringify!(disableRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disableLocal) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_PubSubOptions),
            "::",
            stringify!(disableLocal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).excludeSelf) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_PubSubOptions),
            "::",
            stringify!(excludeSelf)
        )
    );
}
extern "C" {
    #[doc = " Get default instance.\n This is the instance used by non-handle-taking functions.\n\n @return Instance handle"]
    #[link_name = "\u{1}_ZN2nt18GetDefaultInstanceEv"]
    pub fn nt_GetDefaultInstance() -> NT_Inst;
}
extern "C" {
    #[doc = " Create an instance.\n\n @return Instance handle"]
    #[link_name = "\u{1}_ZN2nt14CreateInstanceEv"]
    pub fn nt_CreateInstance() -> NT_Inst;
}
extern "C" {
    #[doc = " Reset the internals of an instance. Every handle previously associated\n with this instance will no longer be valid, except for the instance\n handle."]
    #[link_name = "\u{1}_ZN2nt13ResetInstanceEj"]
    pub fn nt_ResetInstance(inst: NT_Inst);
}
extern "C" {
    #[doc = " Destroy an instance.\n The default instance cannot be destroyed.\n\n @param inst Instance handle"]
    #[link_name = "\u{1}_ZN2nt15DestroyInstanceEj"]
    pub fn nt_DestroyInstance(inst: NT_Inst);
}
extern "C" {
    #[doc = " Get instance handle from another handle.\n\n @param handle    entry/instance/etc. handle\n @return Instance handle"]
    #[link_name = "\u{1}_ZN2nt21GetInstanceFromHandleEj"]
    pub fn nt_GetInstanceFromHandle(handle: NT_Handle) -> NT_Inst;
}
extern "C" {
    #[doc = " Get Entry Handle.\n\n @param inst      instance handle\n @param name      entry name (UTF-8 string)\n @return entry handle"]
    #[link_name = "\u{1}_ZN2nt8GetEntryEjSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_GetEntry(inst: NT_Inst, name: std_string_view) -> NT_Entry;
}
extern "C" {
    #[doc = " Gets the name of the specified entry.\n Returns an empty string if the handle is invalid.\n\n @param entry   entry handle\n @return Entry name"]
    #[link_name = "\u{1}_ZN2nt12GetEntryNameB5cxx11Ej"]
    pub fn nt_GetEntryName(entry: NT_Entry) -> std_string;
}
extern "C" {
    #[doc = " Gets the type for the specified entry, or unassigned if non existent.\n\n @param entry   entry handle\n @return Entry type"]
    #[link_name = "\u{1}_ZN2nt12GetEntryTypeEj"]
    pub fn nt_GetEntryType(entry: NT_Entry) -> NT_Type;
}
extern "C" {
    #[doc = " Gets the last time the entry was changed.\n Returns 0 if the handle is invalid.\n\n @param subentry   subscriber or entry handle\n @return Entry last change time"]
    #[link_name = "\u{1}_ZN2nt18GetEntryLastChangeEj"]
    pub fn nt_GetEntryLastChange(subentry: NT_Handle) -> i64;
}
extern "C" {
    #[doc = " Get Entry Value.\n\n Returns copy of current entry value.\n Note that one of the type options is \"unassigned\".\n\n @param subentry     subscriber or entry handle\n @return entry value"]
    #[link_name = "\u{1}_ZN2nt13GetEntryValueEj"]
    pub fn nt_GetEntryValue(subentry: NT_Handle) -> nt_Value;
}
extern "C" {
    #[doc = " Set Default Entry Value\n\n Returns copy of current entry value if it exists.\n Otherwise, sets passed in value, and returns set value.\n Note that one of the type options is \"unassigned\".\n\n @param entry     entry handle\n @param value     value to be set if name does not exist\n @return False on error (value not set), True on success"]
    #[link_name = "\u{1}_ZN2nt20SetDefaultEntryValueEjRKNS_5ValueE"]
    pub fn nt_SetDefaultEntryValue(entry: NT_Entry, value: *const nt_Value) -> bool;
}
extern "C" {
    #[doc = " Set Entry Value.\n\n Sets new entry value.  If type of new value differs from the type of the\n currently stored entry, returns error and does not update value.\n\n @param entry     entry handle\n @param value     new entry value\n @return False on error (type mismatch), True on success"]
    #[link_name = "\u{1}_ZN2nt13SetEntryValueEjRKNS_5ValueE"]
    pub fn nt_SetEntryValue(entry: NT_Entry, value: *const nt_Value) -> bool;
}
extern "C" {
    #[doc = " Set Entry Flags.\n\n @param entry     entry handle\n @param flags     flags value (bitmask of NT_EntryFlags)"]
    #[link_name = "\u{1}_ZN2nt13SetEntryFlagsEjj"]
    pub fn nt_SetEntryFlags(entry: NT_Entry, flags: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Get Entry Flags.\n\n @param entry     entry handle\n @return Flags value (bitmask of NT_EntryFlags)"]
    #[link_name = "\u{1}_ZN2nt13GetEntryFlagsEj"]
    pub fn nt_GetEntryFlags(entry: NT_Entry) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Read Entry Queue.\n\n Returns new entry values since last call.\n\n @param subentry     subscriber or entry handle\n @return entry value array"]
    #[link_name = "\u{1}_ZN2nt14ReadQueueValueEj"]
    pub fn nt_ReadQueueValue(subentry: NT_Handle) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get Published Topics.\n\n Returns an array of topic handles.  The results are optionally filtered by\n string prefix and type to only return a subset of all topics.\n\n @param inst    instance handle\n @param prefix  name required prefix; only topics whose name\n                starts with this string are returned\n @param types   bitmask of NT_Type values; 0 is treated specially\n                as a \"don't care\"\n @return Array of topic handles."]
    #[link_name = "\u{1}_ZN2nt9GetTopicsEjSt17basic_string_viewIcSt11char_traitsIcEEj"]
    pub fn nt_GetTopics(
        inst: NT_Inst,
        prefix: std_string_view,
        types: ::std::os::raw::c_uint,
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get Published Topics.\n\n Returns an array of topic handles.  The results are optionally filtered by\n string prefix and type to only return a subset of all topics.\n\n @param inst    instance handle\n @param prefix  name required prefix; only topics whose name\n                starts with this string are returned\n @param types   array of type strings\n @return Array of topic handles."]
    #[link_name = "\u{1}_ZN2nt9GetTopicsEjSt17basic_string_viewIcSt11char_traitsIcEESt4spanIKS3_Lj4294967295EE"]
    pub fn nt_GetTopics1(
        inst: NT_Inst,
        prefix: std_string_view,
        types: [u32; 2usize],
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get Topic Information about multiple topics.\n\n Returns an array of topic information (handle, name, type, and properties).\n The results are optionally filtered by string prefix and type to only\n return a subset of all topics.\n\n @param inst    instance handle\n @param prefix  name required prefix; only topics whose name\n                starts with this string are returned\n @param types   bitmask of NT_Type values; 0 is treated specially\n                as a \"don't care\"\n @return Array of topic information."]
    #[link_name = "\u{1}_ZN2nt12GetTopicInfoEjSt17basic_string_viewIcSt11char_traitsIcEEj"]
    pub fn nt_GetTopicInfo(
        inst: NT_Inst,
        prefix: std_string_view,
        types: ::std::os::raw::c_uint,
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Get Topic Information about multiple topics.\n\n Returns an array of topic information (handle, name, type, and properties).\n The results are optionally filtered by string prefix and type to only\n return a subset of all topics.\n\n @param inst    instance handle\n @param prefix  name required prefix; only topics whose name\n                starts with this string are returned\n @param types   array of type strings\n @return Array of topic information."]
    #[link_name = "\u{1}_ZN2nt12GetTopicInfoEjSt17basic_string_viewIcSt11char_traitsIcEESt4spanIKS3_Lj4294967295EE"]
    pub fn nt_GetTopicInfo1(
        inst: NT_Inst,
        prefix: std_string_view,
        types: [u32; 2usize],
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Gets Topic Information.\n\n Returns information about a topic (name, type, and properties).\n\n @param topic   handle\n @return Topic information."]
    #[link_name = "\u{1}_ZN2nt12GetTopicInfoEj"]
    pub fn nt_GetTopicInfo2(topic: NT_Topic) -> nt_TopicInfo;
}
extern "C" {
    #[doc = " Gets Topic Handle.\n\n Returns topic handle.\n\n @param inst   instance handle\n @param name   topic name\n @return Topic handle."]
    #[link_name = "\u{1}_ZN2nt8GetTopicEjSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_GetTopic(inst: NT_Inst, name: std_string_view) -> NT_Topic;
}
extern "C" {
    #[doc = " Gets the name of the specified topic.\n Returns an empty string if the handle is invalid.\n\n @param topic   topic handle\n @return Topic name"]
    #[link_name = "\u{1}_ZN2nt12GetTopicNameB5cxx11Ej"]
    pub fn nt_GetTopicName(topic: NT_Topic) -> std_string;
}
extern "C" {
    #[doc = " Gets the type for the specified topic, or unassigned if non existent.\n\n @param topic   topic handle\n @return Topic type"]
    #[link_name = "\u{1}_ZN2nt12GetTopicTypeEj"]
    pub fn nt_GetTopicType(topic: NT_Topic) -> NT_Type;
}
extern "C" {
    #[doc = " Gets the type string for the specified topic, or empty string if non\n existent.  This may have more information than the numeric type (especially\n for raw values).\n\n @param topic   topic handle\n @return Topic type string"]
    #[link_name = "\u{1}_ZN2nt18GetTopicTypeStringB5cxx11Ej"]
    pub fn nt_GetTopicTypeString(topic: NT_Topic) -> std_string;
}
extern "C" {
    #[doc = " Sets the persistent property of a topic.  If true, the stored value is\n persistent through server restarts.\n\n @param topic topic handle\n @param value True for persistent, false for not persistent."]
    #[link_name = "\u{1}_ZN2nt18SetTopicPersistentEjb"]
    pub fn nt_SetTopicPersistent(topic: NT_Topic, value: bool);
}
extern "C" {
    #[doc = " Gets the persistent property of a topic.  If true, the server retains the\n topic even when there are no publishers.\n\n @param topic topic handle\n @return persistent property value"]
    #[link_name = "\u{1}_ZN2nt18GetTopicPersistentEj"]
    pub fn nt_GetTopicPersistent(topic: NT_Topic) -> bool;
}
extern "C" {
    #[doc = " Sets the retained property of a topic.\n\n @param topic topic handle\n @param value new retained property value"]
    #[link_name = "\u{1}_ZN2nt16SetTopicRetainedEjb"]
    pub fn nt_SetTopicRetained(topic: NT_Topic, value: bool);
}
extern "C" {
    #[doc = " Gets the retained property of a topic.\n\n @param topic topic handle\n @return retained property value"]
    #[link_name = "\u{1}_ZN2nt16GetTopicRetainedEj"]
    pub fn nt_GetTopicRetained(topic: NT_Topic) -> bool;
}
extern "C" {
    #[doc = " Determine if topic exists (e.g. has at least one publisher).\n\n @param handle Topic, entry, or subscriber handle.\n @return True if topic exists."]
    #[link_name = "\u{1}_ZN2nt14GetTopicExistsEj"]
    pub fn nt_GetTopicExists(handle: NT_Handle) -> bool;
}
extern "C" {
    #[doc = " Gets the current value of a property (as a JSON object).\n\n @param topic topic handle\n @param name property name\n @return JSON object; null object if the property does not exist."]
    #[link_name = "\u{1}_ZN2nt16GetTopicPropertyEjSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_GetTopicProperty(topic: NT_Topic, name: std_string_view) -> wpi_json;
}
extern "C" {
    #[doc = " Sets a property value.\n\n @param topic topic handle\n @param name property name\n @param value property value"]
    #[link_name = "\u{1}_ZN2nt16SetTopicPropertyEjSt17basic_string_viewIcSt11char_traitsIcEERKN3wpi4jsonE"]
    pub fn nt_SetTopicProperty(topic: NT_Topic, name: std_string_view, value: *const wpi_json);
}
extern "C" {
    #[doc = " Deletes a property.  Has no effect if the property does not exist.\n\n @param topic topic handle\n @param name property name"]
    #[link_name = "\u{1}_ZN2nt19DeleteTopicPropertyEjSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_DeleteTopicProperty(topic: NT_Topic, name: std_string_view);
}
extern "C" {
    #[doc = " Gets all topic properties as a JSON object.  Each key in the object\n is the property name, and the corresponding value is the property value.\n\n @param topic topic handle\n @return JSON object"]
    #[link_name = "\u{1}_ZN2nt18GetTopicPropertiesEj"]
    pub fn nt_GetTopicProperties(topic: NT_Topic) -> wpi_json;
}
extern "C" {
    #[doc = " Updates multiple topic properties.  Each key in the passed-in object is\n the name of the property to add/update, and the corresponding value is the\n property value to set for that property.  Null values result in deletion\n of the corresponding property.\n\n @param topic topic handle\n @param update JSON object with keys to add/update/delete\n @return False if update is not a JSON object"]
    #[link_name = "\u{1}_ZN2nt18SetTopicPropertiesEjRKN3wpi4jsonE"]
    pub fn nt_SetTopicProperties(topic: NT_Topic, update: *const wpi_json) -> bool;
}
extern "C" {
    #[doc = " Creates a new subscriber to value changes on a topic.\n\n @param topic topic handle\n @param type expected type\n @param typeStr expected type string\n @param options subscription options\n @return Subscriber handle"]
    #[link_name = "\u{1}_ZN2nt9SubscribeEj7NT_TypeSt17basic_string_viewIcSt11char_traitsIcEERKNS_13PubSubOptionsE"]
    pub fn nt_Subscribe(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: std_string_view,
        options: *const nt_PubSubOptions,
    ) -> NT_Subscriber;
}
extern "C" {
    #[doc = " Stops subscriber.\n\n @param sub subscriber handle"]
    #[link_name = "\u{1}_ZN2nt11UnsubscribeEj"]
    pub fn nt_Unsubscribe(sub: NT_Subscriber);
}
extern "C" {
    #[doc = " Creates a new publisher to a topic.\n\n @param topic topic handle\n @param type type\n @param typeStr type string\n @param options publish options\n @return Publisher handle"]
    #[link_name = "\u{1}_ZN2nt7PublishEj7NT_TypeSt17basic_string_viewIcSt11char_traitsIcEERKNS_13PubSubOptionsE"]
    pub fn nt_Publish(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: std_string_view,
        options: *const nt_PubSubOptions,
    ) -> NT_Publisher;
}
extern "C" {
    #[doc = " Creates a new publisher to a topic.\n\n @param topic topic handle\n @param type type\n @param typeStr type string\n @param properties initial properties\n @param options publish options\n @return Publisher handle"]
    #[link_name = "\u{1}_ZN2nt9PublishExEj7NT_TypeSt17basic_string_viewIcSt11char_traitsIcEERKN3wpi4jsonERKNS_13PubSubOptionsE"]
    pub fn nt_PublishEx(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: std_string_view,
        properties: *const wpi_json,
        options: *const nt_PubSubOptions,
    ) -> NT_Publisher;
}
extern "C" {
    #[doc = " Stops publisher.\n\n @param pubentry publisher/entry handle"]
    #[link_name = "\u{1}_ZN2nt9UnpublishEj"]
    pub fn nt_Unpublish(pubentry: NT_Handle);
}
extern "C" {
    #[doc = " @brief Creates a new entry (subscriber and weak publisher) to a topic.\n\n @param topic topic handle\n @param type type\n @param typeStr type string\n @param options publish options\n @return Entry handle"]
    #[link_name = "\u{1}_ZN2nt8GetEntryEj7NT_TypeSt17basic_string_viewIcSt11char_traitsIcEERKNS_13PubSubOptionsE"]
    pub fn nt_GetEntry1(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: std_string_view,
        options: *const nt_PubSubOptions,
    ) -> NT_Entry;
}
extern "C" {
    #[doc = " Stops entry subscriber/publisher.\n\n @param entry entry handle"]
    #[link_name = "\u{1}_ZN2nt12ReleaseEntryEj"]
    pub fn nt_ReleaseEntry(entry: NT_Entry);
}
extern "C" {
    #[doc = " Stops entry/subscriber/publisher.\n\n @param pubsubentry entry/subscriber/publisher handle"]
    #[link_name = "\u{1}_ZN2nt7ReleaseEj"]
    pub fn nt_Release(pubsubentry: NT_Handle);
}
extern "C" {
    #[doc = " Gets the topic handle from an entry/subscriber/publisher handle.\n\n @param pubsubentry entry/subscriber/publisher handle\n @return Topic handle"]
    #[link_name = "\u{1}_ZN2nt18GetTopicFromHandleEj"]
    pub fn nt_GetTopicFromHandle(pubsubentry: NT_Handle) -> NT_Topic;
}
extern "C" {
    #[doc = " Subscribes to multiple topics based on one or more topic name prefixes. Can\n be used in combination with a Value Listener or ReadQueueValue() to get value\n changes across all matching topics.\n\n @param inst instance handle\n @param prefixes topic name prefixes\n @param options subscriber options\n @return subscriber handle"]
    #[link_name = "\u{1}_ZN2nt17SubscribeMultipleEjSt4spanIKSt17basic_string_viewIcSt11char_traitsIcEELj4294967295EERKNS_13PubSubOptionsE"]
    pub fn nt_SubscribeMultiple(
        inst: NT_Inst,
        prefixes: [u32; 2usize],
        options: *const nt_PubSubOptions,
    ) -> NT_MultiSubscriber;
}
extern "C" {
    #[doc = " Unsubscribes a multi-subscriber.\n\n @param sub multi-subscriber handle"]
    #[link_name = "\u{1}_ZN2nt19UnsubscribeMultipleEj"]
    pub fn nt_UnsubscribeMultiple(sub: NT_MultiSubscriber);
}
#[doc = " @defgroup ntcore_listener_func Listener Functions\n @{"]
pub type nt_ListenerCallback = [u32; 4usize];
extern "C" {
    #[doc = " Creates a listener poller.\n\n A poller provides a single queue of poll events.  Events linked to this\n poller (using AddPolledListener()) will be stored in the queue and\n must be collected by calling ReadListenerQueue().\n The returned handle must be destroyed with DestroyListenerPoller().\n\n @param inst      instance handle\n @return poller handle"]
    #[link_name = "\u{1}_ZN2nt20CreateListenerPollerEj"]
    pub fn nt_CreateListenerPoller(inst: NT_Inst) -> NT_ListenerPoller;
}
extern "C" {
    #[doc = " Destroys a listener poller.  This will abort any blocked polling\n call and prevent additional events from being generated for this poller.\n\n @param poller    poller handle"]
    #[link_name = "\u{1}_ZN2nt21DestroyListenerPollerEj"]
    pub fn nt_DestroyListenerPoller(poller: NT_ListenerPoller);
}
extern "C" {
    #[doc = " Read notifications.\n\n @param poller    poller handle\n @return Array of events.  Returns empty array if no events since last call."]
    #[link_name = "\u{1}_ZN2nt17ReadListenerQueueEj"]
    pub fn nt_ReadListenerQueue(poller: NT_ListenerPoller) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Removes a listener.\n\n @param listener Listener handle to remove"]
    #[link_name = "\u{1}_ZN2nt14RemoveListenerEj"]
    pub fn nt_RemoveListener(listener: NT_Listener);
}
extern "C" {
    #[doc = " Wait for the listener queue to be empty. This is primarily useful\n for deterministic testing. This blocks until either the listener\n queue is empty (e.g. there are no more events that need to be passed along to\n callbacks or poll queues) or the timeout expires.\n\n @param handle  handle\n @param timeout timeout, in seconds. Set to 0 for non-blocking behavior, or a\n                negative value to block indefinitely\n @return False if timed out, otherwise true."]
    #[link_name = "\u{1}_ZN2nt20WaitForListenerQueueEjd"]
    pub fn nt_WaitForListenerQueue(handle: NT_Handle, timeout: f64) -> bool;
}
extern "C" {
    #[doc = " Create a listener for changes to topics with names that start with any of\n the given prefixes. This creates a corresponding internal subscriber with the\n lifetime of the listener.\n\n @param inst Instance handle\n @param prefixes Topic name string prefixes\n @param mask Bitmask of NT_EventFlags values (only topic and value events will\n             be generated)\n @param callback Listener function"]
    #[link_name = "\u{1}_ZN2nt11AddListenerEjSt4spanIKSt17basic_string_viewIcSt11char_traitsIcEELj4294967295EEjSt8functionIFvRKNS_5EventEEE"]
    pub fn nt_AddListener(
        inst: NT_Inst,
        prefixes: [u32; 2usize],
        mask: ::std::os::raw::c_uint,
        callback: nt_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Create a listener.\n\n Some combinations of handle and mask have no effect:\n - connection and log message events are only generated on instances\n - topic and value events are only generated on non-instances\n\n Adding value and topic events on a topic will create a corresponding internal\n subscriber with the lifetime of the listener.\n\n Adding a log message listener through this function will only result in\n events at NT_LOG_INFO or higher; for more customized settings, use\n AddLogger().\n\n @param handle Instance, topic, subscriber, multi-subscriber, or entry handle\n @param mask Bitmask of NT_EventFlags values\n @param callback Listener function"]
    #[link_name = "\u{1}_ZN2nt11AddListenerEjjSt8functionIFvRKNS_5EventEEE"]
    pub fn nt_AddListener1(
        handle: NT_Handle,
        mask: ::std::os::raw::c_uint,
        callback: nt_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Creates a polled listener. This creates a corresponding internal subscriber\n with the lifetime of the listener.\n The caller is responsible for calling ReadListenerQueue() to poll.\n\n @param poller poller handle\n @param prefixes array of UTF-8 string prefixes\n @param mask Bitmask of NT_EventFlags values (only topic and value events will\n             be generated)\n @return Listener handle"]
    #[link_name = "\u{1}_ZN2nt17AddPolledListenerEjSt4spanIKSt17basic_string_viewIcSt11char_traitsIcEELj4294967295EEj"]
    pub fn nt_AddPolledListener(
        poller: NT_ListenerPoller,
        prefixes: [u32; 2usize],
        mask: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Creates a polled listener.\n The caller is responsible for calling ReadListenerQueue() to poll.\n\n Some combinations of handle and mask have no effect:\n - connection and log message events are only generated on instances\n - topic and value events are only generated on non-instances\n\n Adding value and topic events on a topic will create a corresponding internal\n subscriber with the lifetime of the listener.\n\n Adding a log message listener through this function will only result in\n events at NT_LOG_INFO or higher; for more customized settings, use\n AddPolledLogger().\n\n @param poller poller handle\n @param handle instance, topic, subscriber, multi-subscriber, or entry handle\n @param mask NT_EventFlags bitmask\n @return Listener handle"]
    #[link_name = "\u{1}_ZN2nt17AddPolledListenerEjjj"]
    pub fn nt_AddPolledListener1(
        poller: NT_ListenerPoller,
        handle: NT_Handle,
        mask: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Get the current network mode.\n\n @param inst  instance handle\n @return Bitmask of NT_NetworkMode."]
    #[link_name = "\u{1}_ZN2nt14GetNetworkModeEj"]
    pub fn nt_GetNetworkMode(inst: NT_Inst) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Starts local-only operation.  Prevents calls to StartServer or StartClient\n from taking effect.  Has no effect if StartServer or StartClient\n has already been called."]
    #[link_name = "\u{1}_ZN2nt10StartLocalEj"]
    pub fn nt_StartLocal(inst: NT_Inst);
}
extern "C" {
    #[doc = " Stops local-only operation.  StartServer or StartClient can be called after\n this call to start a server or client."]
    #[link_name = "\u{1}_ZN2nt9StopLocalEj"]
    pub fn nt_StopLocal(inst: NT_Inst);
}
extern "C" {
    #[doc = " Starts a server using the specified filename, listening address, and port.\n\n @param inst              instance handle\n @param persist_filename  the name of the persist file to use (UTF-8 string,\n                          null terminated)\n @param listen_address    the address to listen on, or null to listen on any\n                          address. (UTF-8 string, null terminated)\n @param port3             port to communicate over (NT3)\n @param port4             port to communicate over (NT4)"]
    #[link_name = "\u{1}_ZN2nt11StartServerEjSt17basic_string_viewIcSt11char_traitsIcEEPKcjj"]
    pub fn nt_StartServer(
        inst: NT_Inst,
        persist_filename: std_string_view,
        listen_address: *const ::std::os::raw::c_char,
        port3: ::std::os::raw::c_uint,
        port4: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Stops the server if it is running.\n\n @param inst  instance handle"]
    #[link_name = "\u{1}_ZN2nt10StopServerEj"]
    pub fn nt_StopServer(inst: NT_Inst);
}
extern "C" {
    #[doc = " Starts a NT3 client.  Use SetServer or SetServerTeam to set the server name\n and port.\n\n @param inst      instance handle\n @param identity  network identity to advertise (cannot be empty string)"]
    #[link_name = "\u{1}_ZN2nt12StartClient3EjSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_StartClient3(inst: NT_Inst, identity: std_string_view);
}
extern "C" {
    #[doc = " Starts a NT4 client.  Use SetServer or SetServerTeam to set the server name\n and port.\n\n @param inst      instance handle\n @param identity  network identity to advertise (cannot be empty string)"]
    #[link_name = "\u{1}_ZN2nt12StartClient4EjSt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_StartClient4(inst: NT_Inst, identity: std_string_view);
}
extern "C" {
    #[doc = " Stops the client if it is running.\n\n @param inst  instance handle"]
    #[link_name = "\u{1}_ZN2nt10StopClientEj"]
    pub fn nt_StopClient(inst: NT_Inst);
}
extern "C" {
    #[doc = " Sets server address and port for client (without restarting client).\n\n @param inst        instance handle\n @param server_name server name (UTF-8 string, null terminated)\n @param port        port to communicate over"]
    #[link_name = "\u{1}_ZN2nt9SetServerEjPKcj"]
    pub fn nt_SetServer(
        inst: NT_Inst,
        server_name: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Sets server addresses for client (without restarting client).\n The client will attempt to connect to each server in round robin fashion.\n\n @param inst      instance handle\n @param servers   array of server name and port pairs"]
    #[link_name = "\u{1}_ZN2nt9SetServerEjSt4spanIKSt4pairISt17basic_string_viewIcSt11char_traitsIcEEjELj4294967295EE"]
    pub fn nt_SetServer1(inst: NT_Inst, servers: [u32; 2usize]);
}
extern "C" {
    #[doc = " Sets server addresses and port for client (without restarting client).\n Connects using commonly known robot addresses for the specified team.\n\n @param inst        instance handle\n @param team        team number\n @param port        port to communicate over"]
    #[link_name = "\u{1}_ZN2nt13SetServerTeamEjjj"]
    pub fn nt_SetServerTeam(
        inst: NT_Inst,
        team: ::std::os::raw::c_uint,
        port: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Starts requesting server address from Driver Station.\n This connects to the Driver Station running on localhost to obtain the\n server IP address.\n\n @param inst  instance handle\n @param port  server port to use in combination with IP from DS"]
    #[link_name = "\u{1}_ZN2nt13StartDSClientEjj"]
    pub fn nt_StartDSClient(inst: NT_Inst, port: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Stops requesting server address from Driver Station.\n\n @param inst  instance handle"]
    #[link_name = "\u{1}_ZN2nt12StopDSClientEj"]
    pub fn nt_StopDSClient(inst: NT_Inst);
}
extern "C" {
    #[doc = " Flush local updates.\n\n Forces an immediate flush of all local changes to the client/server.\n This does not flush to the network.\n\n Normally this is done on a regularly scheduled interval.\n\n @param inst      instance handle"]
    #[link_name = "\u{1}_ZN2nt10FlushLocalEj"]
    pub fn nt_FlushLocal(inst: NT_Inst);
}
extern "C" {
    #[doc = " Flush to network.\n\n Forces an immediate flush of all local entry changes to network.\n Normally this is done on a regularly scheduled interval (set\n by update rates on individual publishers).\n\n Note: flushes are rate limited to avoid excessive network traffic.  If\n the time between calls is too short, the flush will occur after the minimum\n time elapses (rather than immediately).\n\n @param inst      instance handle"]
    #[link_name = "\u{1}_ZN2nt5FlushEj"]
    pub fn nt_Flush(inst: NT_Inst);
}
extern "C" {
    #[doc = " Get information on the currently established network connections.\n If operating as a client, this will return either zero or one values.\n\n @param inst  instance handle\n @return      array of connection information"]
    #[link_name = "\u{1}_ZN2nt14GetConnectionsEj"]
    pub fn nt_GetConnections(inst: NT_Inst) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Return whether or not the instance is connected to another node.\n\n @param inst  instance handle\n @return True if connected."]
    #[link_name = "\u{1}_ZN2nt11IsConnectedEj"]
    pub fn nt_IsConnected(inst: NT_Inst) -> bool;
}
extern "C" {
    #[doc = " Get the time offset between server time and local time. Add this value to\n local time to get the estimated equivalent server time. In server mode, this\n always returns 0. In client mode, this returns the time offset only if the\n client and server are connected and have exchanged synchronization messages.\n Note the time offset may change over time as it is periodically updated; to\n receive updates as events, add a listener to the \"time sync\" event.\n\n @param inst instance handle\n @return Time offset in microseconds (optional)"]
    #[link_name = "\u{1}_ZN2nt19GetServerTimeOffsetEj"]
    pub fn nt_GetServerTimeOffset(inst: NT_Inst) -> [u64; 2usize];
}
extern "C" {
    #[doc = " Returns monotonic current time in 1 us increments.\n This is the same time base used for value and connection timestamps.\n This function by default simply wraps wpi::Now(), but if SetNow() is\n called, this function instead returns the value passed to SetNow();\n this can be used to reduce overhead.\n\n @return Timestamp"]
    #[link_name = "\u{1}_ZN2nt3NowEv"]
    pub fn nt_Now() -> i64;
}
extern "C" {
    #[doc = " Sets the current timestamp used for timestamping values that do not\n provide a timestamp (e.g. a value of 0 is passed).  For consistency,\n it also results in Now() returning the set value.  This should generally\n be used only if the overhead of calling wpi::Now() is a concern.\n If used, it should be called periodically with the value of wpi::Now().\n\n @param timestamp timestamp (1 us increments)"]
    #[link_name = "\u{1}_ZN2nt6SetNowEx"]
    pub fn nt_SetNow(timestamp: i64);
}
extern "C" {
    #[doc = " Turns a type string into a type enum value.\n\n @param typeString type string\n @return Type value"]
    #[link_name = "\u{1}_ZN2nt17GetTypeFromStringESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_GetTypeFromString(typeString: std_string_view) -> NT_Type;
}
extern "C" {
    #[doc = " Turns a type enum value into a type string.\n\n @param type type enum\n @return Type string"]
    #[link_name = "\u{1}_ZN2nt17GetStringFromTypeE7NT_Type"]
    pub fn nt_GetStringFromType(type_: NT_Type) -> std_string_view;
}
extern "C" {
    #[doc = " Starts logging entry changes to a DataLog.\n\n @param inst instance handle\n @param log data log object; lifetime must extend until StopEntryDataLog is\n            called or the instance is destroyed\n @param prefix only store entries with names that start with this prefix;\n               the prefix is not included in the data log entry name\n @param logPrefix prefix to add to data log entry names\n @return Data logger handle"]
    #[link_name = "\u{1}_ZN2nt17StartEntryDataLogEjRN3wpi3log7DataLogESt17basic_string_viewIcSt11char_traitsIcEES7_"]
    pub fn nt_StartEntryDataLog(
        inst: NT_Inst,
        log: *mut wpi_log_DataLog,
        prefix: std_string_view,
        logPrefix: std_string_view,
    ) -> NT_DataLogger;
}
extern "C" {
    #[doc = " Stops logging entry changes to a DataLog.\n\n @param logger data logger handle"]
    #[link_name = "\u{1}_ZN2nt16StopEntryDataLogEj"]
    pub fn nt_StopEntryDataLog(logger: NT_DataLogger);
}
extern "C" {
    #[doc = " Starts logging connection changes to a DataLog.\n\n @param inst instance handle\n @param log data log object; lifetime must extend until StopConnectionDataLog\n            is called or the instance is destroyed\n @param name data log entry name\n @return Data logger handle"]
    #[link_name = "\u{1}_ZN2nt22StartConnectionDataLogEjRN3wpi3log7DataLogESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_StartConnectionDataLog(
        inst: NT_Inst,
        log: *mut wpi_log_DataLog,
        name: std_string_view,
    ) -> NT_ConnectionDataLogger;
}
extern "C" {
    #[doc = " Stops logging connection changes to a DataLog.\n\n @param logger data logger handle"]
    #[link_name = "\u{1}_ZN2nt21StopConnectionDataLogEj"]
    pub fn nt_StopConnectionDataLog(logger: NT_ConnectionDataLogger);
}
extern "C" {
    #[doc = " Add logger callback function.  By default, log messages are sent to stderr;\n this function sends log messages to the provided callback function instead.\n The callback function will only be called for log messages with level\n greater than or equal to min_level and less than or equal to max_level;\n messages outside this range will be silently ignored.\n\n @param inst        instance handle\n @param min_level   minimum log level\n @param max_level   maximum log level\n @param func        listener callback function\n @return Listener handle"]
    #[link_name = "\u{1}_ZN2nt9AddLoggerEjjjSt8functionIFvRKNS_5EventEEE"]
    pub fn nt_AddLogger(
        inst: NT_Inst,
        min_level: ::std::os::raw::c_uint,
        max_level: ::std::os::raw::c_uint,
        func: nt_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Set the log level for a log poller.  Events will only be generated for\n log messages with level greater than or equal to min_level and less than or\n equal to max_level; messages outside this range will be silently ignored.\n\n @param poller        poller handle\n @param min_level     minimum log level\n @param max_level     maximum log level\n @return Logger handle"]
    #[link_name = "\u{1}_ZN2nt15AddPolledLoggerEjjj"]
    pub fn nt_AddPolledLogger(
        poller: NT_ListenerPoller,
        min_level: ::std::os::raw::c_uint,
        max_level: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
#[doc = " Subscriber options. Different from PubSubOptions in this reflects only\n options that are sent over the network."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_meta_SubscriberOptions {
    pub periodic: f64,
    pub topicsOnly: bool,
    pub sendAll: bool,
    pub prefixMatch: bool,
}
#[test]
fn bindgen_test_layout_nt_meta_SubscriberOptions() {
    const UNINIT: ::std::mem::MaybeUninit<nt_meta_SubscriberOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_meta_SubscriberOptions>(),
        16usize,
        concat!("Size of: ", stringify!(nt_meta_SubscriberOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_meta_SubscriberOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_meta_SubscriberOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).periodic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_SubscriberOptions),
            "::",
            stringify!(periodic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicsOnly) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_SubscriberOptions),
            "::",
            stringify!(topicsOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sendAll) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_SubscriberOptions),
            "::",
            stringify!(sendAll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixMatch) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_SubscriberOptions),
            "::",
            stringify!(prefixMatch)
        )
    );
}
#[doc = " Topic publisher (as published via `$pub$<topic>`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_meta_TopicPublisher {
    pub client: std_string,
    pub pubuid: u64,
}
#[test]
fn bindgen_test_layout_nt_meta_TopicPublisher() {
    const UNINIT: ::std::mem::MaybeUninit<nt_meta_TopicPublisher> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_meta_TopicPublisher>(),
        32usize,
        concat!("Size of: ", stringify!(nt_meta_TopicPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_meta_TopicPublisher>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_meta_TopicPublisher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_TopicPublisher),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pubuid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_TopicPublisher),
            "::",
            stringify!(pubuid)
        )
    );
}
#[doc = " Topic subscriber (as published via `$sub$<topic>`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_meta_TopicSubscriber {
    pub client: std_string,
    pub subuid: u64,
    pub options: nt_meta_SubscriberOptions,
}
#[test]
fn bindgen_test_layout_nt_meta_TopicSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_meta_TopicSubscriber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_meta_TopicSubscriber>(),
        48usize,
        concat!("Size of: ", stringify!(nt_meta_TopicSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_meta_TopicSubscriber>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_meta_TopicSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_TopicSubscriber),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subuid) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_TopicSubscriber),
            "::",
            stringify!(subuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_TopicSubscriber),
            "::",
            stringify!(options)
        )
    );
}
#[doc = " Client publisher (as published via `$clientpub$<client>` or `$serverpub`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_meta_ClientPublisher {
    pub uid: i64,
    pub topic: std_string,
}
#[test]
fn bindgen_test_layout_nt_meta_ClientPublisher() {
    const UNINIT: ::std::mem::MaybeUninit<nt_meta_ClientPublisher> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_meta_ClientPublisher>(),
        32usize,
        concat!("Size of: ", stringify!(nt_meta_ClientPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_meta_ClientPublisher>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_meta_ClientPublisher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_ClientPublisher),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_ClientPublisher),
            "::",
            stringify!(topic)
        )
    );
}
#[doc = " Client subscriber (as published via `$clientsub$<client>` or `$serversub`)."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_meta_ClientSubscriber {
    pub uid: i64,
    pub topics: [u32; 3usize],
    pub options: nt_meta_SubscriberOptions,
}
#[test]
fn bindgen_test_layout_nt_meta_ClientSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_meta_ClientSubscriber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_meta_ClientSubscriber>(),
        40usize,
        concat!("Size of: ", stringify!(nt_meta_ClientSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_meta_ClientSubscriber>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_meta_ClientSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_ClientSubscriber),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topics) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_ClientSubscriber),
            "::",
            stringify!(topics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_ClientSubscriber),
            "::",
            stringify!(options)
        )
    );
}
#[doc = " Client (as published via `$clients`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_meta_Client {
    pub id: std_string,
    pub conn: std_string,
    pub version: u16,
}
#[test]
fn bindgen_test_layout_nt_meta_Client() {
    const UNINIT: ::std::mem::MaybeUninit<nt_meta_Client> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_meta_Client>(),
        52usize,
        concat!("Size of: ", stringify!(nt_meta_Client))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_meta_Client>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_meta_Client))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_Client),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_Client),
            "::",
            stringify!(conn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_meta_Client),
            "::",
            stringify!(version)
        )
    );
}
extern "C" {
    #[doc = " Decodes `$pub$<topic>` meta-topic data.\n\n @param data data contents\n @return Vector of TopicPublishers, or empty optional on decoding error."]
    #[link_name = "\u{1}_ZN2nt4meta21DecodeTopicPublishersESt4spanIKhLj4294967295EE"]
    pub fn nt_meta_DecodeTopicPublishers(data: [u32; 2usize]) -> u8;
}
extern "C" {
    #[doc = " Decodes `$sub$<topic>` meta-topic data.\n\n @param data data contents\n @return Vector of TopicSubscribers, or empty optional on decoding error."]
    #[link_name = "\u{1}_ZN2nt4meta22DecodeTopicSubscribersESt4spanIKhLj4294967295EE"]
    pub fn nt_meta_DecodeTopicSubscribers(data: [u32; 2usize]) -> u8;
}
extern "C" {
    #[doc = " Decodes `$clientpub$<topic>` meta-topic data.\n\n @param data data contents\n @return Vector of ClientPublishers, or empty optional on decoding error."]
    #[link_name = "\u{1}_ZN2nt4meta22DecodeClientPublishersESt4spanIKhLj4294967295EE"]
    pub fn nt_meta_DecodeClientPublishers(data: [u32; 2usize]) -> u8;
}
extern "C" {
    #[doc = " Decodes `$clientsub$<topic>` meta-topic data.\n\n @param data data contents\n @return Vector of ClientSubscribers, or empty optional on decoding error."]
    #[link_name = "\u{1}_ZN2nt4meta23DecodeClientSubscribersESt4spanIKhLj4294967295EE"]
    pub fn nt_meta_DecodeClientSubscribers(data: [u32; 2usize]) -> u8;
}
extern "C" {
    #[doc = " Decodes `$clients` meta-topic data.\n\n @param data data contents\n @return Vector of Clients, or empty optional on decoding error."]
    #[link_name = "\u{1}_ZN2nt4meta13DecodeClientsESt4spanIKhLj4294967295EE"]
    pub fn nt_meta_DecodeClients(data: [u32; 2usize]) -> u8;
}
#[doc = " NetworkTables Entry\n\n @note For backwards compatibility, the NetworkTableEntry destructor does not\n       release the entry.\n\n @ingroup ntcore_cpp_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_NetworkTableEntry {
    pub m_handle: NT_Entry,
}
pub const nt_NetworkTableEntry_Flags_kPersistent: nt_NetworkTableEntry_Flags = 1;
#[doc = " Flag values (as returned by GetFlags()).\n @deprecated Use IsPersistent() instead."]
pub type nt_NetworkTableEntry_Flags = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_nt_NetworkTableEntry() {
    const UNINIT: ::std::mem::MaybeUninit<nt_NetworkTableEntry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_NetworkTableEntry>(),
        4usize,
        concat!("Size of: ", stringify!(nt_NetworkTableEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_NetworkTableEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_NetworkTableEntry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_NetworkTableEntry),
            "::",
            stringify!(m_handle)
        )
    );
}
extern "C" {
    #[doc = " Gets the instance for the entry.\n\n @return Instance"]
    #[link_name = "\u{1}_ZNK2nt17NetworkTableEntry11GetInstanceEv"]
    pub fn nt_NetworkTableEntry_GetInstance(
        this: *const nt_NetworkTableEntry,
    ) -> nt_NetworkTableInstance;
}
extern "C" {
    #[doc = " Gets the entry's topic.\n\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt17NetworkTableEntry8GetTopicEv"]
    pub fn nt_NetworkTableEntry_GetTopic(this: *const nt_NetworkTableEntry) -> nt_Topic;
}
impl nt_NetworkTableEntry {
    #[inline]
    pub unsafe fn GetInstance(&self) -> nt_NetworkTableInstance {
        nt_NetworkTableEntry_GetInstance(self)
    }
    #[inline]
    pub unsafe fn GetTopic(&self) -> nt_Topic {
        nt_NetworkTableEntry_GetTopic(self)
    }
}
#[doc = " A network table that knows its subtable path.\n @ingroup ntcore_cpp_api"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_NetworkTable {
    pub m_inst: NT_Inst,
    pub m_path: std_string,
    pub m_mutex: wpi_mutex,
    pub m_entries: wpi_StringMap<wpi_MallocAllocator>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_NetworkTable_private_init {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_nt_NetworkTable_private_init() {
    assert_eq!(
        ::std::mem::size_of::<nt_NetworkTable_private_init>(),
        1usize,
        concat!("Size of: ", stringify!(nt_NetworkTable_private_init))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_NetworkTable_private_init>(),
        1usize,
        concat!("Alignment of ", stringify!(nt_NetworkTable_private_init))
    );
}
#[doc = " Called when an event occurs on a topic in a {@link NetworkTable}.\n\n @param table the table the topic exists in\n @param key the key associated with the topic that changed\n @param event the event"]
pub type nt_NetworkTable_TableEventListener = u8;
#[doc = " Called when a new table is created within a NetworkTable.\n\n @param parent the parent of the table\n @param name the name of the new table\n @param table the new table"]
pub type nt_NetworkTable_SubTableListener = u8;
#[doc = " The path separator for sub-tables and keys"]
pub const nt_NetworkTable_PATH_SEPARATOR_CHAR: ::std::os::raw::c_char = 47;
#[test]
fn bindgen_test_layout_nt_NetworkTable() {
    const UNINIT: ::std::mem::MaybeUninit<nt_NetworkTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_NetworkTable>(),
        76usize,
        concat!("Size of: ", stringify!(nt_NetworkTable))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_NetworkTable>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_NetworkTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_inst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_NetworkTable),
            "::",
            stringify!(m_inst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_path) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_NetworkTable),
            "::",
            stringify!(m_path)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_mutex) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_NetworkTable),
            "::",
            stringify!(m_mutex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_entries) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_NetworkTable),
            "::",
            stringify!(m_entries)
        )
    );
}
extern "C" {
    #[doc = " Gets the \"base name\" of a key. For example, \"/foo/bar\" becomes \"bar\".\n If the key has a trailing slash, returns an empty string.\n\n @param key key\n @return base name"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable11BasenameKeyESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_BasenameKey(key: std_string_view) -> std_string_view;
}
extern "C" {
    #[doc = " Normalizes an network table key to contain no consecutive slashes and\n optionally start with a leading slash. For example:\n\n <pre><code>\n normalizeKey(\"/foo/bar\", true)  == \"/foo/bar\"\n normalizeKey(\"foo/bar\", true)   == \"/foo/bar\"\n normalizeKey(\"/foo/bar\", false) == \"foo/bar\"\n normalizeKey(\"foo//bar\", false) == \"foo/bar\"\n </code></pre>\n\n @param key              the key to normalize\n @param withLeadingSlash whether or not the normalized key should begin\n                         with a leading slash\n @return normalized key"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable12NormalizeKeyB5cxx11ESt17basic_string_viewIcSt11char_traitsIcEEb"]
    pub fn nt_NetworkTable_NormalizeKey(key: std_string_view, withLeadingSlash: bool)
        -> std_string;
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt12NetworkTable12NormalizeKeyESt17basic_string_viewIcSt11char_traitsIcEERN3wpi15SmallVectorImplIcEEb"]
    pub fn nt_NetworkTable_NormalizeKey1(
        key: std_string_view,
        buf: *mut wpi_SmallVectorImpl,
        withLeadingSlash: bool,
    ) -> std_string_view;
}
extern "C" {
    #[doc = " Gets a list of the names of all the super tables of a given key. For\n example, the key \"/foo/bar/baz\" has a hierarchy of \"/\", \"/foo\",\n \"/foo/bar\", and \"/foo/bar/baz\".\n\n @param key the key\n @return List of super tables"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable12GetHierarchyB5cxx11ESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetHierarchy(key: std_string_view) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Gets the instance for the table.\n\n @return Instance"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable11GetInstanceEv"]
    pub fn nt_NetworkTable_GetInstance(this: *const nt_NetworkTable) -> nt_NetworkTableInstance;
}
extern "C" {
    #[doc = " Gets the entry for a subkey.\n\n @param key the key name\n @return Network table entry."]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable8GetEntryESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetEntry(
        this: *const nt_NetworkTable,
        key: std_string_view,
    ) -> nt_NetworkTableEntry;
}
extern "C" {
    #[doc = " Get (generic) topic.\n\n @param name topic name\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable8GetTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetTopic(
        this: *const nt_NetworkTable,
        name: std_string_view,
    ) -> nt_Topic;
}
extern "C" {
    #[doc = " Get boolean topic.\n\n @param name topic name\n @return BooleanTopic"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable15GetBooleanTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetBooleanTopic(
        this: *const nt_NetworkTable,
        name: std_string_view,
    ) -> nt_BooleanTopic;
}
extern "C" {
    #[doc = " Get integer topic.\n\n @param name topic name\n @return IntegerTopic"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable15GetIntegerTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetIntegerTopic(
        this: *const nt_NetworkTable,
        name: std_string_view,
    ) -> nt_IntegerTopic;
}
extern "C" {
    #[doc = " Get float topic.\n\n @param name topic name\n @return FloatTopic"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable13GetFloatTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetFloatTopic(
        this: *const nt_NetworkTable,
        name: std_string_view,
    ) -> nt_FloatTopic;
}
extern "C" {
    #[doc = " Get double topic.\n\n @param name topic name\n @return DoubleTopic"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable14GetDoubleTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetDoubleTopic(
        this: *const nt_NetworkTable,
        name: std_string_view,
    ) -> nt_DoubleTopic;
}
extern "C" {
    #[doc = " Get String topic.\n\n @param name topic name\n @return StringTopic"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable14GetStringTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetStringTopic(
        this: *const nt_NetworkTable,
        name: std_string_view,
    ) -> nt_StringTopic;
}
extern "C" {
    #[doc = " Get raw topic.\n\n @param name topic name\n @return BooleanArrayTopic"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable11GetRawTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetRawTopic(
        this: *const nt_NetworkTable,
        name: std_string_view,
    ) -> nt_RawTopic;
}
extern "C" {
    #[doc = " Get boolean[] topic.\n\n @param name topic name\n @return BooleanArrayTopic"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable20GetBooleanArrayTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetBooleanArrayTopic(
        this: *const nt_NetworkTable,
        name: std_string_view,
    ) -> nt_BooleanArrayTopic;
}
extern "C" {
    #[doc = " Get integer[] topic.\n\n @param name topic name\n @return IntegerArrayTopic"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable20GetIntegerArrayTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetIntegerArrayTopic(
        this: *const nt_NetworkTable,
        name: std_string_view,
    ) -> nt_IntegerArrayTopic;
}
extern "C" {
    #[doc = " Get float[] topic.\n\n @param name topic name\n @return FloatArrayTopic"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable18GetFloatArrayTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetFloatArrayTopic(
        this: *const nt_NetworkTable,
        name: std_string_view,
    ) -> nt_FloatArrayTopic;
}
extern "C" {
    #[doc = " Get double[] topic.\n\n @param name topic name\n @return DoubleArrayTopic"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable19GetDoubleArrayTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetDoubleArrayTopic(
        this: *const nt_NetworkTable,
        name: std_string_view,
    ) -> nt_DoubleArrayTopic;
}
extern "C" {
    #[doc = " Get String[] topic.\n\n @param name topic name\n @return StringArrayTopic"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable19GetStringArrayTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetStringArrayTopic(
        this: *const nt_NetworkTable,
        name: std_string_view,
    ) -> nt_StringArrayTopic;
}
extern "C" {
    #[doc = " Returns the table at the specified key. If there is no table at the\n specified key, it will create a new table\n\n @param key the key name\n @return the networktable to be returned"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable11GetSubTableESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetSubTable(
        this: *const nt_NetworkTable,
        key: std_string_view,
    ) -> [u32; 2usize];
}
extern "C" {
    #[doc = " Determines whether the given key is in this table.\n\n @param key the key to search for\n @return true if the table as a value assigned to the given key"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable11ContainsKeyESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_ContainsKey(this: *const nt_NetworkTable, key: std_string_view) -> bool;
}
extern "C" {
    #[doc = " Determines whether there exists a non-empty subtable for this key\n in this table.\n\n @param key the key to search for\n @return true if there is a subtable with the key which contains at least\n one key/subtable of its own"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable16ContainsSubTableESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_ContainsSubTable(
        this: *const nt_NetworkTable,
        key: std_string_view,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets topic information for all keys in the table (not including\n sub-tables).\n\n @param types bitmask of types; 0 is treated as a \"don't care\".\n @return topic information for keys currently in the table"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable12GetTopicInfoEi"]
    pub fn nt_NetworkTable_GetTopicInfo(
        this: *const nt_NetworkTable,
        types: ::std::os::raw::c_int,
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Gets all topics in the table (not including sub-tables).\n\n @param types bitmask of types; 0 is treated as a \"don't care\".\n @return topic for keys currently in the table"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable9GetTopicsEi"]
    pub fn nt_NetworkTable_GetTopics(
        this: *const nt_NetworkTable,
        types: ::std::os::raw::c_int,
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Gets all keys in the table (not including sub-tables).\n\n @param types bitmask of types; 0 is treated as a \"don't care\".\n @return keys currently in the table"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable7GetKeysB5cxx11Ei"]
    pub fn nt_NetworkTable_GetKeys(
        this: *const nt_NetworkTable,
        types: ::std::os::raw::c_int,
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Gets the names of all subtables in the table.\n\n @return subtables currently in the table"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable12GetSubTablesB5cxx11Ev"]
    pub fn nt_NetworkTable_GetSubTables(this: *const nt_NetworkTable) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Makes a key's value persistent through program restarts.\n\n @param key the key to make persistent"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable13SetPersistentESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_SetPersistent(this: *mut nt_NetworkTable, key: std_string_view);
}
extern "C" {
    #[doc = " Stop making a key's value persistent through program restarts.\n The key cannot be null.\n\n @param key the key name"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable15ClearPersistentESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_ClearPersistent(this: *mut nt_NetworkTable, key: std_string_view);
}
extern "C" {
    #[doc = " Returns whether the value is persistent through program restarts.\n The key cannot be null.\n\n @param key the key name"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable12IsPersistentESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_IsPersistent(this: *const nt_NetworkTable, key: std_string_view)
        -> bool;
}
extern "C" {
    #[doc = " Put a number in the table\n\n @param key the key to be assigned to\n @param value the value that will be assigned\n @return False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable9PutNumberESt17basic_string_viewIcSt11char_traitsIcEEd"]
    pub fn nt_NetworkTable_PutNumber(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        value: f64,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key the key\n @param defaultValue the default value to set if key doesn't exist.\n @returns False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable16SetDefaultNumberESt17basic_string_viewIcSt11char_traitsIcEEd"]
    pub fn nt_NetworkTable_SetDefaultNumber(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        defaultValue: f64,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the number associated with the given name.\n\n @param key the key to look up\n @param defaultValue the value to be returned if no value is found\n @return the value associated with the given key or the given default value\n if there is no value associated with the key"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable9GetNumberESt17basic_string_viewIcSt11char_traitsIcEEd"]
    pub fn nt_NetworkTable_GetNumber(
        this: *const nt_NetworkTable,
        key: std_string_view,
        defaultValue: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " Put a string in the table\n\n @param key the key to be assigned to\n @param value the value that will be assigned\n @return False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable9PutStringESt17basic_string_viewIcSt11char_traitsIcEES4_"]
    pub fn nt_NetworkTable_PutString(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        value: std_string_view,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key the key\n @param defaultValue the default value to set if key doesn't exist.\n @returns False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable16SetDefaultStringESt17basic_string_viewIcSt11char_traitsIcEES4_"]
    pub fn nt_NetworkTable_SetDefaultString(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        defaultValue: std_string_view,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the string associated with the given name. If the key does not\n exist or is of different type, it will return the default value.\n\n @param key the key to look up\n @param defaultValue the value to be returned if no value is found\n @return the value associated with the given key or the given default value\n if there is no value associated with the key"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable9GetStringB5cxx11ESt17basic_string_viewIcSt11char_traitsIcEES4_"]
    pub fn nt_NetworkTable_GetString(
        this: *const nt_NetworkTable,
        key: std_string_view,
        defaultValue: std_string_view,
    ) -> std_string;
}
extern "C" {
    #[doc = " Put a boolean in the table\n\n @param key the key to be assigned to\n @param value the value that will be assigned\n @return False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable10PutBooleanESt17basic_string_viewIcSt11char_traitsIcEEb"]
    pub fn nt_NetworkTable_PutBoolean(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        value: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key the key\n @param defaultValue the default value to set if key doesn't exist.\n @returns False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable17SetDefaultBooleanESt17basic_string_viewIcSt11char_traitsIcEEb"]
    pub fn nt_NetworkTable_SetDefaultBoolean(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        defaultValue: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the boolean associated with the given name. If the key does not\n exist or is of different type, it will return the default value.\n\n @param key the key to look up\n @param defaultValue the value to be returned if no value is found\n @return the value associated with the given key or the given default value\n if there is no value associated with the key"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable10GetBooleanESt17basic_string_viewIcSt11char_traitsIcEEb"]
    pub fn nt_NetworkTable_GetBoolean(
        this: *const nt_NetworkTable,
        key: std_string_view,
        defaultValue: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " Put a boolean array in the table\n\n @param key the key to be assigned to\n @param value the value that will be assigned\n @return False if the table key already exists with a different type\n\n @note The array must be of int's rather than of bool's because\n       std::vector<bool> is special-cased in C++.  0 is false, any\n       non-zero value is true."]
    #[link_name = "\u{1}_ZN2nt12NetworkTable15PutBooleanArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKiLj4294967295EE"]
    pub fn nt_NetworkTable_PutBooleanArray(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        value: [u32; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key the key\n @param defaultValue the default value to set if key doesn't exist.\n @return False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable22SetDefaultBooleanArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKiLj4294967295EE"]
    pub fn nt_NetworkTable_SetDefaultBooleanArray(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the boolean array the key maps to. If the key does not exist or is\n of different type, it will return the default value.\n\n @param key the key to look up\n @param defaultValue the value to be returned if no value is found\n @return the value associated with the given key or the given default value\n if there is no value associated with the key\n\n @note This makes a copy of the array.  If the overhead of this is a\n       concern, use GetValue() instead.\n\n @note The returned array is std::vector<int> instead of std::vector<bool>\n       because std::vector<bool> is special-cased in C++.  0 is false, any\n       non-zero value is true."]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable15GetBooleanArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKiLj4294967295EE"]
    pub fn nt_NetworkTable_GetBooleanArray(
        this: *const nt_NetworkTable,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Put a number array in the table\n\n @param key the key to be assigned to\n @param value the value that will be assigned\n @return False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable14PutNumberArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKdLj4294967295EE"]
    pub fn nt_NetworkTable_PutNumberArray(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        value: [u32; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key the key\n @param defaultValue the default value to set if key doesn't exist.\n @returns False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable21SetDefaultNumberArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKdLj4294967295EE"]
    pub fn nt_NetworkTable_SetDefaultNumberArray(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the number array the key maps to. If the key does not exist or is\n of different type, it will return the default value.\n\n @param key the key to look up\n @param defaultValue the value to be returned if no value is found\n @return the value associated with the given key or the given default value\n if there is no value associated with the key\n\n @note This makes a copy of the array.  If the overhead of this is a\n       concern, use GetValue() instead."]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable14GetNumberArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKdLj4294967295EE"]
    pub fn nt_NetworkTable_GetNumberArray(
        this: *const nt_NetworkTable,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Put a string array in the table\n\n @param key the key to be assigned to\n @param value the value that will be assigned\n @return False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable14PutStringArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKNSt7__cxx1112basic_stringIcS3_SaIcEEELj4294967295EE"]
    pub fn nt_NetworkTable_PutStringArray(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        value: [u32; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key the key\n @param defaultValue the default value to set if key doesn't exist.\n @returns False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable21SetDefaultStringArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKNSt7__cxx1112basic_stringIcS3_SaIcEEELj4294967295EE"]
    pub fn nt_NetworkTable_SetDefaultStringArray(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the string array the key maps to. If the key does not exist or is\n of different type, it will return the default value.\n\n @param key the key to look up\n @param defaultValue the value to be returned if no value is found\n @return the value associated with the given key or the given default value\n if there is no value associated with the key\n\n @note This makes a copy of the array.  If the overhead of this is a\n       concern, use GetValue() instead."]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable14GetStringArrayESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKNSt7__cxx1112basic_stringIcS3_SaIcEEELj4294967295EE"]
    pub fn nt_NetworkTable_GetStringArray(
        this: *const nt_NetworkTable,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Put a raw value (byte array) in the table\n\n @param key the key to be assigned to\n @param value the value that will be assigned\n @return False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable6PutRawESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKhLj4294967295EE"]
    pub fn nt_NetworkTable_PutRaw(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        value: [u32; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key the key\n @param defaultValue the default value to set if key doesn't exist.\n @return False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable13SetDefaultRawESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKhLj4294967295EE"]
    pub fn nt_NetworkTable_SetDefaultRaw(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the raw value (byte array) the key maps to. If the key does not\n exist or is of different type, it will return the default value.\n\n @param key the key to look up\n @param defaultValue the value to be returned if no value is found\n @return the value associated with the given key or the given default value\n if there is no value associated with the key\n\n @note This makes a copy of the raw contents.  If the overhead of this is a\n       concern, use GetValue() instead."]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable6GetRawESt17basic_string_viewIcSt11char_traitsIcEESt4spanIKhLj4294967295EE"]
    pub fn nt_NetworkTable_GetRaw(
        this: *const nt_NetworkTable,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize];
}
extern "C" {
    #[doc = " Put a value in the table\n\n @param key the key to be assigned to\n @param value the value that will be assigned\n @return False if the table key already exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable8PutValueESt17basic_string_viewIcSt11char_traitsIcEERKNS_5ValueE"]
    pub fn nt_NetworkTable_PutValue(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        value: *const nt_Value,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the current value in the table, setting it if it does not exist.\n\n @param key the key\n @param defaultValue the default value to set if key doesn't exist.\n @return False if the table key exists with a different type"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable15SetDefaultValueESt17basic_string_viewIcSt11char_traitsIcEERKNS_5ValueE"]
    pub fn nt_NetworkTable_SetDefaultValue(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        defaultValue: *const nt_Value,
    ) -> bool;
}
extern "C" {
    #[doc = " Gets the value associated with a key as an object\n\n @param key the key of the value to look up\n @return the value associated with the given key, or nullptr if the key\n does not exist"]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable8GetValueESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTable_GetValue(this: *const nt_NetworkTable, key: std_string_view)
        -> nt_Value;
}
extern "C" {
    #[doc = " Gets the full path of this table.  Does not include the trailing \"/\".\n\n @return The path (e.g \"\", \"/foo\")."]
    #[link_name = "\u{1}_ZNK2nt12NetworkTable7GetPathEv"]
    pub fn nt_NetworkTable_GetPath(this: *const nt_NetworkTable) -> std_string_view;
}
extern "C" {
    #[doc = " Listen to topics only within this table.\n\n @param eventMask Bitmask of EventFlags values\n @param listener listener to add\n @return Listener handle"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable11AddListenerEiSt8functionIFvPS0_St17basic_string_viewIcSt11char_traitsIcEERKNS_5EventEEE"]
    pub fn nt_NetworkTable_AddListener(
        this: *mut nt_NetworkTable,
        eventMask: ::std::os::raw::c_int,
        listener: nt_NetworkTable_TableEventListener,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Listen to a single key.\n\n @param key the key name\n @param eventMask Bitmask of EventFlags values\n @param listener listener to add\n @return Listener handle"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable11AddListenerESt17basic_string_viewIcSt11char_traitsIcEEiSt8functionIFvPS0_S4_RKNS_5EventEEE"]
    pub fn nt_NetworkTable_AddListener1(
        this: *mut nt_NetworkTable,
        key: std_string_view,
        eventMask: ::std::os::raw::c_int,
        listener: nt_NetworkTable_TableEventListener,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Listen for sub-table creation. This calls the listener once for each newly\n created sub-table. It immediately calls the listener for any existing\n sub-tables.\n\n @param listener listener to add\n @return Listener handle"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable19AddSubTableListenerESt8functionIFvPS0_St17basic_string_viewIcSt11char_traitsIcEESt10shared_ptrIS0_EEE"]
    pub fn nt_NetworkTable_AddSubTableListener(
        this: *mut nt_NetworkTable,
        listener: nt_NetworkTable_SubTableListener,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Remove a listener.\n\n @param listener listener handle"]
    #[link_name = "\u{1}_ZN2nt12NetworkTable14RemoveListenerEj"]
    pub fn nt_NetworkTable_RemoveListener(this: *mut nt_NetworkTable, listener: NT_Listener);
}
extern "C" {
    #[doc = " Constructor.  Use NetworkTableInstance::GetTable() or GetSubTable()\n instead."]
    #[link_name = "\u{1}_ZN2nt12NetworkTableC1EjSt17basic_string_viewIcSt11char_traitsIcEERKNS0_12private_initE"]
    pub fn nt_NetworkTable_NetworkTable(
        this: *mut nt_NetworkTable,
        inst: NT_Inst,
        path: std_string_view,
        arg1: *const nt_NetworkTable_private_init,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN2nt12NetworkTableD1Ev"]
    pub fn nt_NetworkTable_NetworkTable_destructor(this: *mut nt_NetworkTable);
}
impl nt_NetworkTable {
    #[inline]
    pub unsafe fn BasenameKey(key: std_string_view) -> std_string_view {
        nt_NetworkTable_BasenameKey(key)
    }
    #[inline]
    pub unsafe fn NormalizeKey(key: std_string_view, withLeadingSlash: bool) -> std_string {
        nt_NetworkTable_NormalizeKey(key, withLeadingSlash)
    }
    #[inline]
    pub unsafe fn NormalizeKey1(
        key: std_string_view,
        buf: *mut wpi_SmallVectorImpl,
        withLeadingSlash: bool,
    ) -> std_string_view {
        nt_NetworkTable_NormalizeKey1(key, buf, withLeadingSlash)
    }
    #[inline]
    pub unsafe fn GetHierarchy(key: std_string_view) -> [u32; 3usize] {
        nt_NetworkTable_GetHierarchy(key)
    }
    #[inline]
    pub unsafe fn GetInstance(&self) -> nt_NetworkTableInstance {
        nt_NetworkTable_GetInstance(self)
    }
    #[inline]
    pub unsafe fn GetEntry(&self, key: std_string_view) -> nt_NetworkTableEntry {
        nt_NetworkTable_GetEntry(self, key)
    }
    #[inline]
    pub unsafe fn GetTopic(&self, name: std_string_view) -> nt_Topic {
        nt_NetworkTable_GetTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetBooleanTopic(&self, name: std_string_view) -> nt_BooleanTopic {
        nt_NetworkTable_GetBooleanTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetIntegerTopic(&self, name: std_string_view) -> nt_IntegerTopic {
        nt_NetworkTable_GetIntegerTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetFloatTopic(&self, name: std_string_view) -> nt_FloatTopic {
        nt_NetworkTable_GetFloatTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetDoubleTopic(&self, name: std_string_view) -> nt_DoubleTopic {
        nt_NetworkTable_GetDoubleTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetStringTopic(&self, name: std_string_view) -> nt_StringTopic {
        nt_NetworkTable_GetStringTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetRawTopic(&self, name: std_string_view) -> nt_RawTopic {
        nt_NetworkTable_GetRawTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetBooleanArrayTopic(&self, name: std_string_view) -> nt_BooleanArrayTopic {
        nt_NetworkTable_GetBooleanArrayTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetIntegerArrayTopic(&self, name: std_string_view) -> nt_IntegerArrayTopic {
        nt_NetworkTable_GetIntegerArrayTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetFloatArrayTopic(&self, name: std_string_view) -> nt_FloatArrayTopic {
        nt_NetworkTable_GetFloatArrayTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetDoubleArrayTopic(&self, name: std_string_view) -> nt_DoubleArrayTopic {
        nt_NetworkTable_GetDoubleArrayTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetStringArrayTopic(&self, name: std_string_view) -> nt_StringArrayTopic {
        nt_NetworkTable_GetStringArrayTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetSubTable(&self, key: std_string_view) -> [u32; 2usize] {
        nt_NetworkTable_GetSubTable(self, key)
    }
    #[inline]
    pub unsafe fn ContainsKey(&self, key: std_string_view) -> bool {
        nt_NetworkTable_ContainsKey(self, key)
    }
    #[inline]
    pub unsafe fn ContainsSubTable(&self, key: std_string_view) -> bool {
        nt_NetworkTable_ContainsSubTable(self, key)
    }
    #[inline]
    pub unsafe fn GetTopicInfo(&self, types: ::std::os::raw::c_int) -> [u32; 3usize] {
        nt_NetworkTable_GetTopicInfo(self, types)
    }
    #[inline]
    pub unsafe fn GetTopics(&self, types: ::std::os::raw::c_int) -> [u32; 3usize] {
        nt_NetworkTable_GetTopics(self, types)
    }
    #[inline]
    pub unsafe fn GetKeys(&self, types: ::std::os::raw::c_int) -> [u32; 3usize] {
        nt_NetworkTable_GetKeys(self, types)
    }
    #[inline]
    pub unsafe fn GetSubTables(&self) -> [u32; 3usize] {
        nt_NetworkTable_GetSubTables(self)
    }
    #[inline]
    pub unsafe fn SetPersistent(&mut self, key: std_string_view) {
        nt_NetworkTable_SetPersistent(self, key)
    }
    #[inline]
    pub unsafe fn ClearPersistent(&mut self, key: std_string_view) {
        nt_NetworkTable_ClearPersistent(self, key)
    }
    #[inline]
    pub unsafe fn IsPersistent(&self, key: std_string_view) -> bool {
        nt_NetworkTable_IsPersistent(self, key)
    }
    #[inline]
    pub unsafe fn PutNumber(&mut self, key: std_string_view, value: f64) -> bool {
        nt_NetworkTable_PutNumber(self, key, value)
    }
    #[inline]
    pub unsafe fn SetDefaultNumber(&mut self, key: std_string_view, defaultValue: f64) -> bool {
        nt_NetworkTable_SetDefaultNumber(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetNumber(&self, key: std_string_view, defaultValue: f64) -> f64 {
        nt_NetworkTable_GetNumber(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn PutString(&mut self, key: std_string_view, value: std_string_view) -> bool {
        nt_NetworkTable_PutString(self, key, value)
    }
    #[inline]
    pub unsafe fn SetDefaultString(
        &mut self,
        key: std_string_view,
        defaultValue: std_string_view,
    ) -> bool {
        nt_NetworkTable_SetDefaultString(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetString(
        &self,
        key: std_string_view,
        defaultValue: std_string_view,
    ) -> std_string {
        nt_NetworkTable_GetString(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn PutBoolean(&mut self, key: std_string_view, value: bool) -> bool {
        nt_NetworkTable_PutBoolean(self, key, value)
    }
    #[inline]
    pub unsafe fn SetDefaultBoolean(&mut self, key: std_string_view, defaultValue: bool) -> bool {
        nt_NetworkTable_SetDefaultBoolean(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetBoolean(&self, key: std_string_view, defaultValue: bool) -> bool {
        nt_NetworkTable_GetBoolean(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn PutBooleanArray(&mut self, key: std_string_view, value: [u32; 2usize]) -> bool {
        nt_NetworkTable_PutBooleanArray(self, key, value)
    }
    #[inline]
    pub unsafe fn SetDefaultBooleanArray(
        &mut self,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> bool {
        nt_NetworkTable_SetDefaultBooleanArray(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetBooleanArray(
        &self,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize] {
        nt_NetworkTable_GetBooleanArray(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn PutNumberArray(&mut self, key: std_string_view, value: [u32; 2usize]) -> bool {
        nt_NetworkTable_PutNumberArray(self, key, value)
    }
    #[inline]
    pub unsafe fn SetDefaultNumberArray(
        &mut self,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> bool {
        nt_NetworkTable_SetDefaultNumberArray(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetNumberArray(
        &self,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize] {
        nt_NetworkTable_GetNumberArray(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn PutStringArray(&mut self, key: std_string_view, value: [u32; 2usize]) -> bool {
        nt_NetworkTable_PutStringArray(self, key, value)
    }
    #[inline]
    pub unsafe fn SetDefaultStringArray(
        &mut self,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> bool {
        nt_NetworkTable_SetDefaultStringArray(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetStringArray(
        &self,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize] {
        nt_NetworkTable_GetStringArray(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn PutRaw(&mut self, key: std_string_view, value: [u32; 2usize]) -> bool {
        nt_NetworkTable_PutRaw(self, key, value)
    }
    #[inline]
    pub unsafe fn SetDefaultRaw(
        &mut self,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> bool {
        nt_NetworkTable_SetDefaultRaw(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetRaw(
        &self,
        key: std_string_view,
        defaultValue: [u32; 2usize],
    ) -> [u32; 3usize] {
        nt_NetworkTable_GetRaw(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn PutValue(&mut self, key: std_string_view, value: *const nt_Value) -> bool {
        nt_NetworkTable_PutValue(self, key, value)
    }
    #[inline]
    pub unsafe fn SetDefaultValue(
        &mut self,
        key: std_string_view,
        defaultValue: *const nt_Value,
    ) -> bool {
        nt_NetworkTable_SetDefaultValue(self, key, defaultValue)
    }
    #[inline]
    pub unsafe fn GetValue(&self, key: std_string_view) -> nt_Value {
        nt_NetworkTable_GetValue(self, key)
    }
    #[inline]
    pub unsafe fn GetPath(&self) -> std_string_view {
        nt_NetworkTable_GetPath(self)
    }
    #[inline]
    pub unsafe fn AddListener(
        &mut self,
        eventMask: ::std::os::raw::c_int,
        listener: nt_NetworkTable_TableEventListener,
    ) -> NT_Listener {
        nt_NetworkTable_AddListener(self, eventMask, listener)
    }
    #[inline]
    pub unsafe fn AddListener1(
        &mut self,
        key: std_string_view,
        eventMask: ::std::os::raw::c_int,
        listener: nt_NetworkTable_TableEventListener,
    ) -> NT_Listener {
        nt_NetworkTable_AddListener1(self, key, eventMask, listener)
    }
    #[inline]
    pub unsafe fn AddSubTableListener(
        &mut self,
        listener: nt_NetworkTable_SubTableListener,
    ) -> NT_Listener {
        nt_NetworkTable_AddSubTableListener(self, listener)
    }
    #[inline]
    pub unsafe fn RemoveListener(&mut self, listener: NT_Listener) {
        nt_NetworkTable_RemoveListener(self, listener)
    }
    #[inline]
    pub unsafe fn new(
        inst: NT_Inst,
        path: std_string_view,
        arg1: *const nt_NetworkTable_private_init,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        nt_NetworkTable_NetworkTable(__bindgen_tmp.as_mut_ptr(), inst, path, arg1);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn destruct(&mut self) {
        nt_NetworkTable_NetworkTable_destructor(self)
    }
}
#[doc = " NetworkTables Topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_Topic {
    pub m_handle: NT_Topic,
}
#[test]
fn bindgen_test_layout_nt_Topic() {
    const UNINIT: ::std::mem::MaybeUninit<nt_Topic> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_Topic>(),
        4usize,
        concat!("Size of: ", stringify!(nt_Topic))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_Topic>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_Topic))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_Topic),
            "::",
            stringify!(m_handle)
        )
    );
}
extern "C" {
    #[doc = " Gets the current value of a property (as a JSON object).\n\n @param name property name\n @return JSON object; null object if the property does not exist."]
    #[link_name = "\u{1}_ZNK2nt5Topic11GetPropertyESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_Topic_GetProperty(this: *const nt_Topic, name: std_string_view) -> wpi_json;
}
extern "C" {
    #[doc = " Sets a property value.\n\n @param name property name\n @param value property value"]
    #[link_name = "\u{1}_ZN2nt5Topic11SetPropertyESt17basic_string_viewIcSt11char_traitsIcEERKN3wpi4jsonE"]
    pub fn nt_Topic_SetProperty(this: *mut nt_Topic, name: std_string_view, value: *const wpi_json);
}
extern "C" {
    #[doc = " Gets all topic properties as a JSON object.  Each key in the object\n is the property name, and the corresponding value is the property value.\n\n @return JSON object"]
    #[link_name = "\u{1}_ZNK2nt5Topic13GetPropertiesEv"]
    pub fn nt_Topic_GetProperties(this: *const nt_Topic) -> wpi_json;
}
extern "C" {
    #[doc = " Create a new subscriber to the topic.\n\n <p>The subscriber is only active as long as the returned object\n is not destroyed.\n\n @param options subscribe options\n @return subscriber"]
    #[link_name = "\u{1}_ZN2nt5Topic16GenericSubscribeERKNS_13PubSubOptionsE"]
    pub fn nt_Topic_GenericSubscribe(
        this: *mut nt_Topic,
        options: *const nt_PubSubOptions,
    ) -> nt_GenericSubscriber;
}
extern "C" {
    #[doc = " Create a new subscriber to the topic.\n\n <p>The subscriber is only active as long as the returned object\n is not destroyed.\n\n @note Subscribers that do not match the published data type do not return\n     any values. To determine if the data type matches, use the appropriate\n     Topic functions.\n\n @param typeString type string\n @param options subscribe options\n @return subscriber"]
    #[link_name = "\u{1}_ZN2nt5Topic16GenericSubscribeESt17basic_string_viewIcSt11char_traitsIcEERKNS_13PubSubOptionsE"]
    pub fn nt_Topic_GenericSubscribe1(
        this: *mut nt_Topic,
        typeString: std_string_view,
        options: *const nt_PubSubOptions,
    ) -> nt_GenericSubscriber;
}
extern "C" {
    #[doc = " Create a new publisher to the topic.\n\n The publisher is only active as long as the returned object\n is not destroyed.\n\n @note It is not possible to publish two different data types to the same\n     topic. Conflicts between publishers are typically resolved by the\n     server on a first-come, first-served basis. Any published values that\n     do not match the topic's data type are dropped (ignored). To determine\n     if the data type matches, use the appropriate Topic functions.\n\n @param typeString type string\n @param options publish options\n @return publisher"]
    #[link_name = "\u{1}_ZN2nt5Topic14GenericPublishESt17basic_string_viewIcSt11char_traitsIcEERKNS_13PubSubOptionsE"]
    pub fn nt_Topic_GenericPublish(
        this: *mut nt_Topic,
        typeString: std_string_view,
        options: *const nt_PubSubOptions,
    ) -> nt_GenericPublisher;
}
extern "C" {
    #[doc = " Create a new publisher to the topic, with type string and initial\n properties.\n\n The publisher is only active as long as the returned object\n is not destroyed.\n\n @note It is not possible to publish two different data types to the same\n     topic. Conflicts between publishers are typically resolved by the\n     server on a first-come, first-served basis. Any published values that\n     do not match the topic's data type are dropped (ignored). To determine\n     if the data type matches, use the appropriate Topic functions.\n\n @param typeString type string\n @param properties JSON properties\n @param options publish options\n @return publisher"]
    #[link_name = "\u{1}_ZN2nt5Topic16GenericPublishExESt17basic_string_viewIcSt11char_traitsIcEERKN3wpi4jsonERKNS_13PubSubOptionsE"]
    pub fn nt_Topic_GenericPublishEx(
        this: *mut nt_Topic,
        typeString: std_string_view,
        properties: *const wpi_json,
        options: *const nt_PubSubOptions,
    ) -> nt_GenericPublisher;
}
extern "C" {
    #[doc = " Create a new generic entry for the topic.\n\n Entries act as a combination of a subscriber and a weak publisher. The\n subscriber is active as long as the entry is not destroyed. The publisher\n is created when the entry is first written to, and remains active until\n either Unpublish() is called or the entry is destroyed.\n\n @note It is not possible to use two different data types with the same\n     topic. Conflicts between publishers are typically resolved by the\n     server on a first-come, first-served basis. Any published values that\n     do not match the topic's data type are dropped (ignored), and the entry\n     will show no new values if the data type does not match. To determine\n     if the data type matches, use the appropriate Topic functions.\n\n @param options publish and/or subscribe options\n @return entry"]
    #[link_name = "\u{1}_ZN2nt5Topic15GetGenericEntryERKNS_13PubSubOptionsE"]
    pub fn nt_Topic_GetGenericEntry(
        this: *mut nt_Topic,
        options: *const nt_PubSubOptions,
    ) -> nt_GenericEntry;
}
extern "C" {
    #[doc = " Create a new generic entry for the topic.\n\n Entries act as a combination of a subscriber and a weak publisher. The\n subscriber is active as long as the entry is not destroyed. The publisher\n is created when the entry is first written to, and remains active until\n either Unpublish() is called or the entry is destroyed.\n\n @note It is not possible to use two different data types with the same\n     topic. Conflicts between publishers are typically resolved by the\n     server on a first-come, first-served basis. Any published values that\n     do not match the topic's data type are dropped (ignored), and the entry\n     will show no new values if the data type does not match. To determine\n     if the data type matches, use the appropriate Topic functions.\n\n @param typeString type string\n @param options publish and/or subscribe options\n @return entry"]
    #[link_name = "\u{1}_ZN2nt5Topic15GetGenericEntryESt17basic_string_viewIcSt11char_traitsIcEERKNS_13PubSubOptionsE"]
    pub fn nt_Topic_GetGenericEntry1(
        this: *mut nt_Topic,
        typeString: std_string_view,
        options: *const nt_PubSubOptions,
    ) -> nt_GenericEntry;
}
impl nt_Topic {
    #[inline]
    pub unsafe fn GetProperty(&self, name: std_string_view) -> wpi_json {
        nt_Topic_GetProperty(self, name)
    }
    #[inline]
    pub unsafe fn SetProperty(&mut self, name: std_string_view, value: *const wpi_json) {
        nt_Topic_SetProperty(self, name, value)
    }
    #[inline]
    pub unsafe fn GetProperties(&self) -> wpi_json {
        nt_Topic_GetProperties(self)
    }
    #[inline]
    pub unsafe fn GenericSubscribe(
        &mut self,
        options: *const nt_PubSubOptions,
    ) -> nt_GenericSubscriber {
        nt_Topic_GenericSubscribe(self, options)
    }
    #[inline]
    pub unsafe fn GenericSubscribe1(
        &mut self,
        typeString: std_string_view,
        options: *const nt_PubSubOptions,
    ) -> nt_GenericSubscriber {
        nt_Topic_GenericSubscribe1(self, typeString, options)
    }
    #[inline]
    pub unsafe fn GenericPublish(
        &mut self,
        typeString: std_string_view,
        options: *const nt_PubSubOptions,
    ) -> nt_GenericPublisher {
        nt_Topic_GenericPublish(self, typeString, options)
    }
    #[inline]
    pub unsafe fn GenericPublishEx(
        &mut self,
        typeString: std_string_view,
        properties: *const wpi_json,
        options: *const nt_PubSubOptions,
    ) -> nt_GenericPublisher {
        nt_Topic_GenericPublishEx(self, typeString, properties, options)
    }
    #[inline]
    pub unsafe fn GetGenericEntry(&mut self, options: *const nt_PubSubOptions) -> nt_GenericEntry {
        nt_Topic_GetGenericEntry(self, options)
    }
    #[inline]
    pub unsafe fn GetGenericEntry1(
        &mut self,
        typeString: std_string_view,
        options: *const nt_PubSubOptions,
    ) -> nt_GenericEntry {
        nt_Topic_GetGenericEntry1(self, typeString, options)
    }
}
#[repr(C)]
pub struct nt_Subscriber__bindgen_vtable {}
#[doc = " NetworkTables subscriber."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_Subscriber {
    pub vtable_: *const nt_Subscriber__bindgen_vtable,
    pub m_subHandle: NT_Subscriber,
}
#[test]
fn bindgen_test_layout_nt_Subscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_Subscriber> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_Subscriber>(),
        8usize,
        concat!("Size of: ", stringify!(nt_Subscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_Subscriber>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_Subscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_subHandle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_Subscriber),
            "::",
            stringify!(m_subHandle)
        )
    );
}
#[repr(C)]
pub struct nt_Publisher__bindgen_vtable {}
#[doc = " NetworkTables publisher."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_Publisher {
    pub vtable_: *const nt_Publisher__bindgen_vtable,
    pub m_pubHandle: NT_Publisher,
}
#[test]
fn bindgen_test_layout_nt_Publisher() {
    const UNINIT: ::std::mem::MaybeUninit<nt_Publisher> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_Publisher>(),
        8usize,
        concat!("Size of: ", stringify!(nt_Publisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_Publisher>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_Publisher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_pubHandle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_Publisher),
            "::",
            stringify!(m_pubHandle)
        )
    );
}
#[doc = " NetworkTables Instance.\n\n Instances are completely independent from each other.  Table operations on\n one instance will not be visible to other instances unless the instances are\n connected via the network.  The main limitation on instances is that you\n cannot have two servers on the same network port.  The main utility of\n instances is for unit testing, but they can also enable one program to\n connect to two different NetworkTables networks.\n\n The global \"default\" instance (as returned by GetDefault()) is\n always available, and is intended for the common case when there is only\n a single NetworkTables instance being used in the program.  The\n default instance cannot be destroyed.\n\n Additional instances can be created with the Create() function.\n Instances are not reference counted or RAII.  Instead, they must be\n explicitly destroyed (with Destroy()).\n\n @ingroup ntcore_cpp_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_NetworkTableInstance {
    pub m_handle: NT_Inst,
}
pub const nt_NetworkTableInstance_NetworkMode_kNetModeNone: nt_NetworkTableInstance_NetworkMode = 0;
pub const nt_NetworkTableInstance_NetworkMode_kNetModeServer: nt_NetworkTableInstance_NetworkMode =
    1;
pub const nt_NetworkTableInstance_NetworkMode_kNetModeClient3: nt_NetworkTableInstance_NetworkMode =
    2;
pub const nt_NetworkTableInstance_NetworkMode_kNetModeClient4: nt_NetworkTableInstance_NetworkMode =
    4;
pub const nt_NetworkTableInstance_NetworkMode_kNetModeLocal: nt_NetworkTableInstance_NetworkMode =
    16;
#[doc = " Client/server mode flag values (as returned by GetNetworkMode()).\n This is a bitmask."]
pub type nt_NetworkTableInstance_NetworkMode = ::std::os::raw::c_uint;
pub const nt_NetworkTableInstance_LogLevel_kLogCritical: nt_NetworkTableInstance_LogLevel = 50;
pub const nt_NetworkTableInstance_LogLevel_kLogError: nt_NetworkTableInstance_LogLevel = 40;
pub const nt_NetworkTableInstance_LogLevel_kLogWarning: nt_NetworkTableInstance_LogLevel = 30;
pub const nt_NetworkTableInstance_LogLevel_kLogInfo: nt_NetworkTableInstance_LogLevel = 20;
pub const nt_NetworkTableInstance_LogLevel_kLogDebug: nt_NetworkTableInstance_LogLevel = 10;
pub const nt_NetworkTableInstance_LogLevel_kLogDebug1: nt_NetworkTableInstance_LogLevel = 9;
pub const nt_NetworkTableInstance_LogLevel_kLogDebug2: nt_NetworkTableInstance_LogLevel = 8;
pub const nt_NetworkTableInstance_LogLevel_kLogDebug3: nt_NetworkTableInstance_LogLevel = 7;
pub const nt_NetworkTableInstance_LogLevel_kLogDebug4: nt_NetworkTableInstance_LogLevel = 6;
#[doc = " Logging levels (as used by SetLogger())."]
pub type nt_NetworkTableInstance_LogLevel = ::std::os::raw::c_uint;
#[doc = " The default port that network tables operates on for NT3."]
pub const nt_NetworkTableInstance_kDefaultPort3: ::std::os::raw::c_uint = 1735;
#[doc = " The default port that network tables operates on for NT4."]
pub const nt_NetworkTableInstance_kDefaultPort4: ::std::os::raw::c_uint = 5810;
#[test]
fn bindgen_test_layout_nt_NetworkTableInstance() {
    const UNINIT: ::std::mem::MaybeUninit<nt_NetworkTableInstance> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_NetworkTableInstance>(),
        4usize,
        concat!("Size of: ", stringify!(nt_NetworkTableInstance))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_NetworkTableInstance>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_NetworkTableInstance))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_NetworkTableInstance),
            "::",
            stringify!(m_handle)
        )
    );
}
extern "C" {
    #[doc = " Gets a \"generic\" (untyped) topic.\n\n @param name topic name\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt20NetworkTableInstance8GetTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTableInstance_GetTopic(
        this: *const nt_NetworkTableInstance,
        name: std_string_view,
    ) -> nt_Topic;
}
extern "C" {
    #[doc = " Gets a boolean topic.\n\n @param name topic name\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt20NetworkTableInstance15GetBooleanTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTableInstance_GetBooleanTopic(
        this: *const nt_NetworkTableInstance,
        name: std_string_view,
    ) -> nt_BooleanTopic;
}
extern "C" {
    #[doc = " Gets an integer topic.\n\n @param name topic name\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt20NetworkTableInstance15GetIntegerTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTableInstance_GetIntegerTopic(
        this: *const nt_NetworkTableInstance,
        name: std_string_view,
    ) -> nt_IntegerTopic;
}
extern "C" {
    #[doc = " Gets a float topic.\n\n @param name topic name\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt20NetworkTableInstance13GetFloatTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTableInstance_GetFloatTopic(
        this: *const nt_NetworkTableInstance,
        name: std_string_view,
    ) -> nt_FloatTopic;
}
extern "C" {
    #[doc = " Gets a double topic.\n\n @param name topic name\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt20NetworkTableInstance14GetDoubleTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTableInstance_GetDoubleTopic(
        this: *const nt_NetworkTableInstance,
        name: std_string_view,
    ) -> nt_DoubleTopic;
}
extern "C" {
    #[doc = " Gets a string topic.\n\n @param name topic name\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt20NetworkTableInstance14GetStringTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTableInstance_GetStringTopic(
        this: *const nt_NetworkTableInstance,
        name: std_string_view,
    ) -> nt_StringTopic;
}
extern "C" {
    #[doc = " Gets a raw topic.\n\n @param name topic name\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt20NetworkTableInstance11GetRawTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTableInstance_GetRawTopic(
        this: *const nt_NetworkTableInstance,
        name: std_string_view,
    ) -> nt_RawTopic;
}
extern "C" {
    #[doc = " Gets a boolean array topic.\n\n @param name topic name\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt20NetworkTableInstance20GetBooleanArrayTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTableInstance_GetBooleanArrayTopic(
        this: *const nt_NetworkTableInstance,
        name: std_string_view,
    ) -> nt_BooleanArrayTopic;
}
extern "C" {
    #[doc = " Gets an integer array topic.\n\n @param name topic name\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt20NetworkTableInstance20GetIntegerArrayTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTableInstance_GetIntegerArrayTopic(
        this: *const nt_NetworkTableInstance,
        name: std_string_view,
    ) -> nt_IntegerArrayTopic;
}
extern "C" {
    #[doc = " Gets a float array topic.\n\n @param name topic name\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt20NetworkTableInstance18GetFloatArrayTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTableInstance_GetFloatArrayTopic(
        this: *const nt_NetworkTableInstance,
        name: std_string_view,
    ) -> nt_FloatArrayTopic;
}
extern "C" {
    #[doc = " Gets a double array topic.\n\n @param name topic name\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt20NetworkTableInstance19GetDoubleArrayTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTableInstance_GetDoubleArrayTopic(
        this: *const nt_NetworkTableInstance,
        name: std_string_view,
    ) -> nt_DoubleArrayTopic;
}
extern "C" {
    #[doc = " Gets a string array topic.\n\n @param name topic name\n @return Topic"]
    #[link_name = "\u{1}_ZNK2nt20NetworkTableInstance19GetStringArrayTopicESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTableInstance_GetStringArrayTopic(
        this: *const nt_NetworkTableInstance,
        name: std_string_view,
    ) -> nt_StringArrayTopic;
}
extern "C" {
    #[doc = " Gets the table with the specified key.\n\n @param key the key name\n @return The network table"]
    #[link_name = "\u{1}_ZNK2nt20NetworkTableInstance8GetTableESt17basic_string_viewIcSt11char_traitsIcEE"]
    pub fn nt_NetworkTableInstance_GetTable(
        this: *const nt_NetworkTableInstance,
        key: std_string_view,
    ) -> [u32; 2usize];
}
extern "C" {
    #[doc = " Add a listener for changes on a particular topic. The callback\n function is called asynchronously on a separate thread, so it's important\n to use synchronization or atomics when accessing any shared state from the\n callback function.\n\n This creates a corresponding internal subscriber with the lifetime of the\n listener.\n\n @param topic Topic\n @param eventMask Bitmask of EventFlags values\n @param listener Listener function\n @return Listener handle"]
    #[link_name = "\u{1}_ZN2nt20NetworkTableInstance11AddListenerENS_5TopicEjSt8functionIFvRKNS_5EventEEE"]
    pub fn nt_NetworkTableInstance_AddListener(
        this: *mut nt_NetworkTableInstance,
        topic: nt_Topic,
        eventMask: ::std::os::raw::c_uint,
        listener: nt_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Add a listener for changes on a subscriber. The callback\n function is called asynchronously on a separate thread, so it's important\n to use synchronization or atomics when accessing any shared state from the\n callback function. This does NOT keep the subscriber active.\n\n @param subscriber Subscriber\n @param eventMask Bitmask of EventFlags values\n @param listener Listener function\n @return Listener handle"]
    #[link_name = "\u{1}_ZN2nt20NetworkTableInstance11AddListenerERNS_10SubscriberEjSt8functionIFvRKNS_5EventEEE"]
    pub fn nt_NetworkTableInstance_AddListener1(
        this: *mut nt_NetworkTableInstance,
        subscriber: *mut nt_Subscriber,
        eventMask: ::std::os::raw::c_uint,
        listener: nt_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Add a listener for changes on a subscriber. The callback\n function is called asynchronously on a separate thread, so it's important\n to use synchronization or atomics when accessing any shared state from the\n callback function. This does NOT keep the subscriber active.\n\n @param subscriber Subscriber\n @param eventMask Bitmask of EventFlags values\n @param listener Listener function\n @return Listener handle"]
    #[link_name = "\u{1}_ZN2nt20NetworkTableInstance11AddListenerERNS_15MultiSubscriberEiSt8functionIFvRKNS_5EventEEE"]
    pub fn nt_NetworkTableInstance_AddListener2(
        this: *mut nt_NetworkTableInstance,
        subscriber: *mut nt_MultiSubscriber,
        eventMask: ::std::os::raw::c_int,
        listener: nt_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Add a listener for changes on an entry. The callback function\n is called asynchronously on a separate thread, so it's important to use\n synchronization or atomics when accessing any shared state from the\n callback function.\n\n @param entry Entry\n @param eventMask Bitmask of EventFlags values\n @param listener Listener function\n @return Listener handle"]
    #[link_name = "\u{1}_ZN2nt20NetworkTableInstance11AddListenerERKNS_17NetworkTableEntryEiSt8functionIFvRKNS_5EventEEE"]
    pub fn nt_NetworkTableInstance_AddListener3(
        this: *mut nt_NetworkTableInstance,
        entry: *const nt_NetworkTableEntry,
        eventMask: ::std::os::raw::c_int,
        listener: nt_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Sets server addresses and port for client (without restarting client).\n The client will attempt to connect to each server in round robin fashion.\n\n @param servers   array of server names\n @param port      port to communicate over (0 = default)"]
    #[link_name = "\u{1}_ZN2nt20NetworkTableInstance9SetServerESt4spanIKSt17basic_string_viewIcSt11char_traitsIcEELj4294967295EEj"]
    pub fn nt_NetworkTableInstance_SetServer(
        this: *mut nt_NetworkTableInstance,
        servers: [u32; 2usize],
        port: ::std::os::raw::c_uint,
    );
}
impl nt_NetworkTableInstance {
    #[inline]
    pub unsafe fn GetTopic(&self, name: std_string_view) -> nt_Topic {
        nt_NetworkTableInstance_GetTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetBooleanTopic(&self, name: std_string_view) -> nt_BooleanTopic {
        nt_NetworkTableInstance_GetBooleanTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetIntegerTopic(&self, name: std_string_view) -> nt_IntegerTopic {
        nt_NetworkTableInstance_GetIntegerTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetFloatTopic(&self, name: std_string_view) -> nt_FloatTopic {
        nt_NetworkTableInstance_GetFloatTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetDoubleTopic(&self, name: std_string_view) -> nt_DoubleTopic {
        nt_NetworkTableInstance_GetDoubleTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetStringTopic(&self, name: std_string_view) -> nt_StringTopic {
        nt_NetworkTableInstance_GetStringTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetRawTopic(&self, name: std_string_view) -> nt_RawTopic {
        nt_NetworkTableInstance_GetRawTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetBooleanArrayTopic(&self, name: std_string_view) -> nt_BooleanArrayTopic {
        nt_NetworkTableInstance_GetBooleanArrayTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetIntegerArrayTopic(&self, name: std_string_view) -> nt_IntegerArrayTopic {
        nt_NetworkTableInstance_GetIntegerArrayTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetFloatArrayTopic(&self, name: std_string_view) -> nt_FloatArrayTopic {
        nt_NetworkTableInstance_GetFloatArrayTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetDoubleArrayTopic(&self, name: std_string_view) -> nt_DoubleArrayTopic {
        nt_NetworkTableInstance_GetDoubleArrayTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetStringArrayTopic(&self, name: std_string_view) -> nt_StringArrayTopic {
        nt_NetworkTableInstance_GetStringArrayTopic(self, name)
    }
    #[inline]
    pub unsafe fn GetTable(&self, key: std_string_view) -> [u32; 2usize] {
        nt_NetworkTableInstance_GetTable(self, key)
    }
    #[inline]
    pub unsafe fn AddListener(
        &mut self,
        topic: nt_Topic,
        eventMask: ::std::os::raw::c_uint,
        listener: nt_ListenerCallback,
    ) -> NT_Listener {
        nt_NetworkTableInstance_AddListener(self, topic, eventMask, listener)
    }
    #[inline]
    pub unsafe fn AddListener1(
        &mut self,
        subscriber: *mut nt_Subscriber,
        eventMask: ::std::os::raw::c_uint,
        listener: nt_ListenerCallback,
    ) -> NT_Listener {
        nt_NetworkTableInstance_AddListener1(self, subscriber, eventMask, listener)
    }
    #[inline]
    pub unsafe fn AddListener2(
        &mut self,
        subscriber: *mut nt_MultiSubscriber,
        eventMask: ::std::os::raw::c_int,
        listener: nt_ListenerCallback,
    ) -> NT_Listener {
        nt_NetworkTableInstance_AddListener2(self, subscriber, eventMask, listener)
    }
    #[inline]
    pub unsafe fn AddListener3(
        &mut self,
        entry: *const nt_NetworkTableEntry,
        eventMask: ::std::os::raw::c_int,
        listener: nt_ListenerCallback,
    ) -> NT_Listener {
        nt_NetworkTableInstance_AddListener3(self, entry, eventMask, listener)
    }
    #[inline]
    pub unsafe fn SetServer(&mut self, servers: [u32; 2usize], port: ::std::os::raw::c_uint) {
        nt_NetworkTableInstance_SetServer(self, servers, port)
    }
}
#[doc = " NetworkTables DoubleArray subscriber."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_DoubleArraySubscriber {
    pub _base: nt_Subscriber,
    pub m_defaultValue: nt_DoubleArraySubscriber_ValueType,
}
#[doc = " NetworkTables DoubleArray topic."]
pub type nt_DoubleArraySubscriber_TopicType = nt_DoubleArrayTopic;
pub type nt_DoubleArraySubscriber_ValueType = [u32; 3usize];
pub type nt_DoubleArraySubscriber_ParamType = [u32; 2usize];
#[doc = " Timestamped DoubleArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_DoubleArraySubscriber_TimestampedValueType = nt_TimestampedDoubleArray;
pub type nt_DoubleArraySubscriber_SmallRetType = [u32; 2usize];
pub type nt_DoubleArraySubscriber_SmallElemType = f64;
#[doc = " Timestamped DoubleArray view (for SmallVector-taking functions).\n @ingroup ntcore_cpp_handle_api"]
pub type nt_DoubleArraySubscriber_TimestampedValueViewType = nt_TimestampedDoubleArrayView;
#[test]
fn bindgen_test_layout_nt_DoubleArraySubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_DoubleArraySubscriber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_DoubleArraySubscriber>(),
        20usize,
        concat!("Size of: ", stringify!(nt_DoubleArraySubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_DoubleArraySubscriber>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_DoubleArraySubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_DoubleArraySubscriber),
            "::",
            stringify!(m_defaultValue)
        )
    );
}
#[doc = " NetworkTables DoubleArray publisher."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_DoubleArrayPublisher {
    pub _base: nt_Publisher,
}
#[doc = " NetworkTables DoubleArray topic."]
pub type nt_DoubleArrayPublisher_TopicType = nt_DoubleArrayTopic;
pub type nt_DoubleArrayPublisher_ValueType = [u32; 3usize];
pub type nt_DoubleArrayPublisher_ParamType = [u32; 2usize];
pub type nt_DoubleArrayPublisher_SmallRetType = [u32; 2usize];
pub type nt_DoubleArrayPublisher_SmallElemType = f64;
#[doc = " Timestamped DoubleArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_DoubleArrayPublisher_TimestampedValueType = nt_TimestampedDoubleArray;
#[test]
fn bindgen_test_layout_nt_DoubleArrayPublisher() {
    assert_eq!(
        ::std::mem::size_of::<nt_DoubleArrayPublisher>(),
        8usize,
        concat!("Size of: ", stringify!(nt_DoubleArrayPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_DoubleArrayPublisher>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_DoubleArrayPublisher))
    );
}
#[doc = " NetworkTables DoubleArray entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_DoubleArrayEntry {
    pub _base: nt_DoubleArraySubscriber,
    pub _base_1: nt_DoubleArrayPublisher,
}
#[doc = " NetworkTables DoubleArray subscriber."]
pub type nt_DoubleArrayEntry_SubscriberType = nt_DoubleArraySubscriber;
#[doc = " NetworkTables DoubleArray publisher."]
pub type nt_DoubleArrayEntry_PublisherType = nt_DoubleArrayPublisher;
#[doc = " NetworkTables DoubleArray topic."]
pub type nt_DoubleArrayEntry_TopicType = nt_DoubleArrayTopic;
pub type nt_DoubleArrayEntry_ValueType = [u32; 3usize];
pub type nt_DoubleArrayEntry_ParamType = [u32; 2usize];
pub type nt_DoubleArrayEntry_SmallRetType = [u32; 2usize];
pub type nt_DoubleArrayEntry_SmallElemType = f64;
#[doc = " Timestamped DoubleArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_DoubleArrayEntry_TimestampedValueType = nt_TimestampedDoubleArray;
#[test]
fn bindgen_test_layout_nt_DoubleArrayEntry() {
    assert_eq!(
        ::std::mem::size_of::<nt_DoubleArrayEntry>(),
        28usize,
        concat!("Size of: ", stringify!(nt_DoubleArrayEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_DoubleArrayEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_DoubleArrayEntry))
    );
}
#[doc = " NetworkTables DoubleArray topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_DoubleArrayTopic {
    pub _base: nt_Topic,
}
#[doc = " NetworkTables DoubleArray subscriber."]
pub type nt_DoubleArrayTopic_SubscriberType = nt_DoubleArraySubscriber;
#[doc = " NetworkTables DoubleArray publisher."]
pub type nt_DoubleArrayTopic_PublisherType = nt_DoubleArrayPublisher;
#[doc = " NetworkTables DoubleArray entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
pub type nt_DoubleArrayTopic_EntryType = nt_DoubleArrayEntry;
pub type nt_DoubleArrayTopic_ValueType = [u32; 3usize];
pub type nt_DoubleArrayTopic_ParamType = [u32; 2usize];
#[doc = " Timestamped DoubleArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_DoubleArrayTopic_TimestampedValueType = nt_TimestampedDoubleArray;
#[doc = " The default type string for this topic type."]
pub const nt_DoubleArrayTopic_kTypeString: &[u8; 9usize] = b"double[]\0";
#[test]
fn bindgen_test_layout_nt_DoubleArrayTopic() {
    assert_eq!(
        ::std::mem::size_of::<nt_DoubleArrayTopic>(),
        4usize,
        concat!("Size of: ", stringify!(nt_DoubleArrayTopic))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_DoubleArrayTopic>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_DoubleArrayTopic))
    );
}
#[doc = " NetworkTables String subscriber."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_StringSubscriber {
    pub _base: nt_Subscriber,
    pub m_defaultValue: nt_StringSubscriber_ValueType,
}
#[doc = " NetworkTables String topic."]
pub type nt_StringSubscriber_TopicType = nt_StringTopic;
pub type nt_StringSubscriber_ValueType = std_string;
pub type nt_StringSubscriber_ParamType = std_string_view;
#[doc = " Timestamped String.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_StringSubscriber_TimestampedValueType = nt_TimestampedString;
pub type nt_StringSubscriber_SmallRetType = std_string_view;
pub type nt_StringSubscriber_SmallElemType = ::std::os::raw::c_char;
#[doc = " Timestamped String view (for SmallVector-taking functions).\n @ingroup ntcore_cpp_handle_api"]
pub type nt_StringSubscriber_TimestampedValueViewType = nt_TimestampedStringView;
#[test]
fn bindgen_test_layout_nt_StringSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_StringSubscriber> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_StringSubscriber>(),
        32usize,
        concat!("Size of: ", stringify!(nt_StringSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_StringSubscriber>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_StringSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_StringSubscriber),
            "::",
            stringify!(m_defaultValue)
        )
    );
}
#[doc = " NetworkTables String publisher."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_StringPublisher {
    pub _base: nt_Publisher,
}
#[doc = " NetworkTables String topic."]
pub type nt_StringPublisher_TopicType = nt_StringTopic;
pub type nt_StringPublisher_ValueType = std_string;
pub type nt_StringPublisher_ParamType = std_string_view;
pub type nt_StringPublisher_SmallRetType = std_string_view;
pub type nt_StringPublisher_SmallElemType = ::std::os::raw::c_char;
#[doc = " Timestamped String.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_StringPublisher_TimestampedValueType = nt_TimestampedString;
#[test]
fn bindgen_test_layout_nt_StringPublisher() {
    assert_eq!(
        ::std::mem::size_of::<nt_StringPublisher>(),
        8usize,
        concat!("Size of: ", stringify!(nt_StringPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_StringPublisher>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_StringPublisher))
    );
}
#[doc = " NetworkTables String entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_StringEntry {
    pub _base: nt_StringSubscriber,
    pub _base_1: nt_StringPublisher,
}
#[doc = " NetworkTables String subscriber."]
pub type nt_StringEntry_SubscriberType = nt_StringSubscriber;
#[doc = " NetworkTables String publisher."]
pub type nt_StringEntry_PublisherType = nt_StringPublisher;
#[doc = " NetworkTables String topic."]
pub type nt_StringEntry_TopicType = nt_StringTopic;
pub type nt_StringEntry_ValueType = std_string;
pub type nt_StringEntry_ParamType = std_string_view;
pub type nt_StringEntry_SmallRetType = std_string_view;
pub type nt_StringEntry_SmallElemType = ::std::os::raw::c_char;
#[doc = " Timestamped String.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_StringEntry_TimestampedValueType = nt_TimestampedString;
#[test]
fn bindgen_test_layout_nt_StringEntry() {
    assert_eq!(
        ::std::mem::size_of::<nt_StringEntry>(),
        40usize,
        concat!("Size of: ", stringify!(nt_StringEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_StringEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_StringEntry))
    );
}
#[doc = " NetworkTables String topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_StringTopic {
    pub _base: nt_Topic,
}
#[doc = " NetworkTables String subscriber."]
pub type nt_StringTopic_SubscriberType = nt_StringSubscriber;
#[doc = " NetworkTables String publisher."]
pub type nt_StringTopic_PublisherType = nt_StringPublisher;
#[doc = " NetworkTables String entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
pub type nt_StringTopic_EntryType = nt_StringEntry;
pub type nt_StringTopic_ValueType = std_string;
pub type nt_StringTopic_ParamType = std_string_view;
#[doc = " Timestamped String.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_StringTopic_TimestampedValueType = nt_TimestampedString;
#[doc = " The default type string for this topic type."]
pub const nt_StringTopic_kTypeString: &[u8; 7usize] = b"string\0";
#[test]
fn bindgen_test_layout_nt_StringTopic() {
    assert_eq!(
        ::std::mem::size_of::<nt_StringTopic>(),
        4usize,
        concat!("Size of: ", stringify!(nt_StringTopic))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_StringTopic>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_StringTopic))
    );
}
#[doc = " NetworkTables Double subscriber."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_DoubleSubscriber {
    pub _base: nt_Subscriber,
    pub m_defaultValue: nt_DoubleSubscriber_ValueType,
}
#[doc = " NetworkTables Double topic."]
pub type nt_DoubleSubscriber_TopicType = nt_DoubleTopic;
pub type nt_DoubleSubscriber_ValueType = f64;
pub type nt_DoubleSubscriber_ParamType = f64;
#[doc = " Timestamped Double.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_DoubleSubscriber_TimestampedValueType = nt_TimestampedDouble;
#[test]
fn bindgen_test_layout_nt_DoubleSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_DoubleSubscriber> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_DoubleSubscriber>(),
        16usize,
        concat!("Size of: ", stringify!(nt_DoubleSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_DoubleSubscriber>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_DoubleSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_DoubleSubscriber),
            "::",
            stringify!(m_defaultValue)
        )
    );
}
#[doc = " NetworkTables Double publisher."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_DoublePublisher {
    pub _base: nt_Publisher,
}
#[doc = " NetworkTables Double topic."]
pub type nt_DoublePublisher_TopicType = nt_DoubleTopic;
pub type nt_DoublePublisher_ValueType = f64;
pub type nt_DoublePublisher_ParamType = f64;
#[doc = " Timestamped Double.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_DoublePublisher_TimestampedValueType = nt_TimestampedDouble;
#[test]
fn bindgen_test_layout_nt_DoublePublisher() {
    assert_eq!(
        ::std::mem::size_of::<nt_DoublePublisher>(),
        8usize,
        concat!("Size of: ", stringify!(nt_DoublePublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_DoublePublisher>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_DoublePublisher))
    );
}
#[doc = " NetworkTables Double entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_DoubleEntry {
    pub _base: nt_DoubleSubscriber,
    pub _base_1: nt_DoublePublisher,
}
#[doc = " NetworkTables Double subscriber."]
pub type nt_DoubleEntry_SubscriberType = nt_DoubleSubscriber;
#[doc = " NetworkTables Double publisher."]
pub type nt_DoubleEntry_PublisherType = nt_DoublePublisher;
#[doc = " NetworkTables Double topic."]
pub type nt_DoubleEntry_TopicType = nt_DoubleTopic;
pub type nt_DoubleEntry_ValueType = f64;
pub type nt_DoubleEntry_ParamType = f64;
#[doc = " Timestamped Double.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_DoubleEntry_TimestampedValueType = nt_TimestampedDouble;
#[test]
fn bindgen_test_layout_nt_DoubleEntry() {
    assert_eq!(
        ::std::mem::size_of::<nt_DoubleEntry>(),
        24usize,
        concat!("Size of: ", stringify!(nt_DoubleEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_DoubleEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_DoubleEntry))
    );
}
#[doc = " NetworkTables Double topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_DoubleTopic {
    pub _base: nt_Topic,
}
#[doc = " NetworkTables Double subscriber."]
pub type nt_DoubleTopic_SubscriberType = nt_DoubleSubscriber;
#[doc = " NetworkTables Double publisher."]
pub type nt_DoubleTopic_PublisherType = nt_DoublePublisher;
#[doc = " NetworkTables Double entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
pub type nt_DoubleTopic_EntryType = nt_DoubleEntry;
pub type nt_DoubleTopic_ValueType = f64;
pub type nt_DoubleTopic_ParamType = f64;
#[doc = " Timestamped Double.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_DoubleTopic_TimestampedValueType = nt_TimestampedDouble;
#[doc = " The default type string for this topic type."]
pub const nt_DoubleTopic_kTypeString: &[u8; 7usize] = b"double\0";
#[test]
fn bindgen_test_layout_nt_DoubleTopic() {
    assert_eq!(
        ::std::mem::size_of::<nt_DoubleTopic>(),
        4usize,
        concat!("Size of: ", stringify!(nt_DoubleTopic))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_DoubleTopic>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_DoubleTopic))
    );
}
#[doc = " NetworkTables Boolean subscriber."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_BooleanSubscriber {
    pub _base: nt_Subscriber,
    pub m_defaultValue: nt_BooleanSubscriber_ValueType,
}
#[doc = " NetworkTables Boolean topic."]
pub type nt_BooleanSubscriber_TopicType = nt_BooleanTopic;
pub type nt_BooleanSubscriber_ValueType = bool;
pub type nt_BooleanSubscriber_ParamType = bool;
#[doc = " Timestamped Boolean.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_BooleanSubscriber_TimestampedValueType = nt_TimestampedBoolean;
#[test]
fn bindgen_test_layout_nt_BooleanSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_BooleanSubscriber> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_BooleanSubscriber>(),
        12usize,
        concat!("Size of: ", stringify!(nt_BooleanSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_BooleanSubscriber>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_BooleanSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_BooleanSubscriber),
            "::",
            stringify!(m_defaultValue)
        )
    );
}
#[doc = " NetworkTables Boolean publisher."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_BooleanPublisher {
    pub _base: nt_Publisher,
}
#[doc = " NetworkTables Boolean topic."]
pub type nt_BooleanPublisher_TopicType = nt_BooleanTopic;
pub type nt_BooleanPublisher_ValueType = bool;
pub type nt_BooleanPublisher_ParamType = bool;
#[doc = " Timestamped Boolean.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_BooleanPublisher_TimestampedValueType = nt_TimestampedBoolean;
#[test]
fn bindgen_test_layout_nt_BooleanPublisher() {
    assert_eq!(
        ::std::mem::size_of::<nt_BooleanPublisher>(),
        8usize,
        concat!("Size of: ", stringify!(nt_BooleanPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_BooleanPublisher>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_BooleanPublisher))
    );
}
#[doc = " NetworkTables Boolean entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_BooleanEntry {
    pub _base: nt_BooleanSubscriber,
    pub _base_1: nt_BooleanPublisher,
}
#[doc = " NetworkTables Boolean subscriber."]
pub type nt_BooleanEntry_SubscriberType = nt_BooleanSubscriber;
#[doc = " NetworkTables Boolean publisher."]
pub type nt_BooleanEntry_PublisherType = nt_BooleanPublisher;
#[doc = " NetworkTables Boolean topic."]
pub type nt_BooleanEntry_TopicType = nt_BooleanTopic;
pub type nt_BooleanEntry_ValueType = bool;
pub type nt_BooleanEntry_ParamType = bool;
#[doc = " Timestamped Boolean.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_BooleanEntry_TimestampedValueType = nt_TimestampedBoolean;
#[test]
fn bindgen_test_layout_nt_BooleanEntry() {
    assert_eq!(
        ::std::mem::size_of::<nt_BooleanEntry>(),
        20usize,
        concat!("Size of: ", stringify!(nt_BooleanEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_BooleanEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_BooleanEntry))
    );
}
#[doc = " NetworkTables Boolean topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_BooleanTopic {
    pub _base: nt_Topic,
}
#[doc = " NetworkTables Boolean subscriber."]
pub type nt_BooleanTopic_SubscriberType = nt_BooleanSubscriber;
#[doc = " NetworkTables Boolean publisher."]
pub type nt_BooleanTopic_PublisherType = nt_BooleanPublisher;
#[doc = " NetworkTables Boolean entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
pub type nt_BooleanTopic_EntryType = nt_BooleanEntry;
pub type nt_BooleanTopic_ValueType = bool;
pub type nt_BooleanTopic_ParamType = bool;
#[doc = " Timestamped Boolean.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_BooleanTopic_TimestampedValueType = nt_TimestampedBoolean;
#[doc = " The default type string for this topic type."]
pub const nt_BooleanTopic_kTypeString: &[u8; 8usize] = b"boolean\0";
#[test]
fn bindgen_test_layout_nt_BooleanTopic() {
    assert_eq!(
        ::std::mem::size_of::<nt_BooleanTopic>(),
        4usize,
        concat!("Size of: ", stringify!(nt_BooleanTopic))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_BooleanTopic>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_BooleanTopic))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct nt_NTSendableBuilder {
    pub _base: wpi_SendableBuilder,
}
#[test]
fn bindgen_test_layout_nt_NTSendableBuilder() {
    assert_eq!(
        ::std::mem::size_of::<nt_NTSendableBuilder>(),
        4usize,
        concat!("Size of: ", stringify!(nt_NTSendableBuilder))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_NTSendableBuilder>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_NTSendableBuilder))
    );
}
extern "C" {
    #[doc = " Gets the kind of backend being used.\n\n @return Backend kind"]
    #[link_name = "\u{1}_ZNK2nt17NTSendableBuilder14GetBackendKindEv"]
    pub fn nt_NTSendableBuilder_GetBackendKind(
        this: *mut ::std::os::raw::c_void,
    ) -> wpi_SendableBuilder_BackendKind;
}
#[doc = " NetworkTables Integer subscriber."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_IntegerSubscriber {
    pub _base: nt_Subscriber,
    pub m_defaultValue: nt_IntegerSubscriber_ValueType,
}
#[doc = " NetworkTables Integer topic."]
pub type nt_IntegerSubscriber_TopicType = nt_IntegerTopic;
pub type nt_IntegerSubscriber_ValueType = i64;
pub type nt_IntegerSubscriber_ParamType = i64;
#[doc = " Timestamped Integer.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_IntegerSubscriber_TimestampedValueType = nt_TimestampedInteger;
#[test]
fn bindgen_test_layout_nt_IntegerSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_IntegerSubscriber> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_IntegerSubscriber>(),
        16usize,
        concat!("Size of: ", stringify!(nt_IntegerSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_IntegerSubscriber>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_IntegerSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_IntegerSubscriber),
            "::",
            stringify!(m_defaultValue)
        )
    );
}
#[doc = " NetworkTables Integer publisher."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_IntegerPublisher {
    pub _base: nt_Publisher,
}
#[doc = " NetworkTables Integer topic."]
pub type nt_IntegerPublisher_TopicType = nt_IntegerTopic;
pub type nt_IntegerPublisher_ValueType = i64;
pub type nt_IntegerPublisher_ParamType = i64;
#[doc = " Timestamped Integer.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_IntegerPublisher_TimestampedValueType = nt_TimestampedInteger;
#[test]
fn bindgen_test_layout_nt_IntegerPublisher() {
    assert_eq!(
        ::std::mem::size_of::<nt_IntegerPublisher>(),
        8usize,
        concat!("Size of: ", stringify!(nt_IntegerPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_IntegerPublisher>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_IntegerPublisher))
    );
}
#[doc = " NetworkTables Integer entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_IntegerEntry {
    pub _base: nt_IntegerSubscriber,
    pub _base_1: nt_IntegerPublisher,
}
#[doc = " NetworkTables Integer subscriber."]
pub type nt_IntegerEntry_SubscriberType = nt_IntegerSubscriber;
#[doc = " NetworkTables Integer publisher."]
pub type nt_IntegerEntry_PublisherType = nt_IntegerPublisher;
#[doc = " NetworkTables Integer topic."]
pub type nt_IntegerEntry_TopicType = nt_IntegerTopic;
pub type nt_IntegerEntry_ValueType = i64;
pub type nt_IntegerEntry_ParamType = i64;
#[doc = " Timestamped Integer.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_IntegerEntry_TimestampedValueType = nt_TimestampedInteger;
#[test]
fn bindgen_test_layout_nt_IntegerEntry() {
    assert_eq!(
        ::std::mem::size_of::<nt_IntegerEntry>(),
        24usize,
        concat!("Size of: ", stringify!(nt_IntegerEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_IntegerEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(nt_IntegerEntry))
    );
}
#[doc = " NetworkTables Integer topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_IntegerTopic {
    pub _base: nt_Topic,
}
#[doc = " NetworkTables Integer subscriber."]
pub type nt_IntegerTopic_SubscriberType = nt_IntegerSubscriber;
#[doc = " NetworkTables Integer publisher."]
pub type nt_IntegerTopic_PublisherType = nt_IntegerPublisher;
#[doc = " NetworkTables Integer entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
pub type nt_IntegerTopic_EntryType = nt_IntegerEntry;
pub type nt_IntegerTopic_ValueType = i64;
pub type nt_IntegerTopic_ParamType = i64;
#[doc = " Timestamped Integer.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_IntegerTopic_TimestampedValueType = nt_TimestampedInteger;
#[doc = " The default type string for this topic type."]
pub const nt_IntegerTopic_kTypeString: &[u8; 4usize] = b"int\0";
#[test]
fn bindgen_test_layout_nt_IntegerTopic() {
    assert_eq!(
        ::std::mem::size_of::<nt_IntegerTopic>(),
        4usize,
        concat!("Size of: ", stringify!(nt_IntegerTopic))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_IntegerTopic>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_IntegerTopic))
    );
}
#[doc = " NetworkTables generic subscriber."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_GenericSubscriber {
    pub _base: nt_Subscriber,
}
#[doc = " NetworkTables Topic."]
pub type nt_GenericSubscriber_TopicType = nt_Topic;
#[doc = " A network table entry value.\n @ingroup ntcore_cpp_api"]
pub type nt_GenericSubscriber_ValueType = nt_Value;
pub type nt_GenericSubscriber_ParamType = *const nt_Value;
#[doc = " A network table entry value.\n @ingroup ntcore_cpp_api"]
pub type nt_GenericSubscriber_TimestampedValueType = nt_Value;
#[test]
fn bindgen_test_layout_nt_GenericSubscriber() {
    assert_eq!(
        ::std::mem::size_of::<nt_GenericSubscriber>(),
        8usize,
        concat!("Size of: ", stringify!(nt_GenericSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_GenericSubscriber>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_GenericSubscriber))
    );
}
#[doc = " NetworkTables generic publisher."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_GenericPublisher {
    pub _base: nt_Publisher,
}
#[doc = " NetworkTables Topic."]
pub type nt_GenericPublisher_TopicType = nt_Topic;
#[doc = " A network table entry value.\n @ingroup ntcore_cpp_api"]
pub type nt_GenericPublisher_ValueType = nt_Value;
pub type nt_GenericPublisher_ParamType = *const nt_Value;
#[doc = " A network table entry value.\n @ingroup ntcore_cpp_api"]
pub type nt_GenericPublisher_TimestampedValueType = nt_Value;
#[test]
fn bindgen_test_layout_nt_GenericPublisher() {
    assert_eq!(
        ::std::mem::size_of::<nt_GenericPublisher>(),
        8usize,
        concat!("Size of: ", stringify!(nt_GenericPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_GenericPublisher>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_GenericPublisher))
    );
}
#[doc = " NetworkTables generic entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_GenericEntry {
    pub _base: nt_GenericSubscriber,
    pub _base_1: nt_GenericPublisher,
}
#[doc = " NetworkTables generic subscriber."]
pub type nt_GenericEntry_SubscriberType = nt_GenericSubscriber;
#[doc = " NetworkTables generic publisher."]
pub type nt_GenericEntry_PublisherType = nt_GenericPublisher;
#[doc = " NetworkTables Topic."]
pub type nt_GenericEntry_TopicType = nt_Topic;
#[doc = " A network table entry value.\n @ingroup ntcore_cpp_api"]
pub type nt_GenericEntry_ValueType = nt_Value;
pub type nt_GenericEntry_ParamType = *const nt_Value;
#[doc = " A network table entry value.\n @ingroup ntcore_cpp_api"]
pub type nt_GenericEntry_TimestampedValueType = nt_Value;
#[test]
fn bindgen_test_layout_nt_GenericEntry() {
    assert_eq!(
        ::std::mem::size_of::<nt_GenericEntry>(),
        16usize,
        concat!("Size of: ", stringify!(nt_GenericEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_GenericEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_GenericEntry))
    );
}
#[doc = " NetworkTables StringArray subscriber."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_StringArraySubscriber {
    pub _base: nt_Subscriber,
    pub m_defaultValue: nt_StringArraySubscriber_ValueType,
}
#[doc = " NetworkTables StringArray topic."]
pub type nt_StringArraySubscriber_TopicType = nt_StringArrayTopic;
pub type nt_StringArraySubscriber_ValueType = [u32; 3usize];
pub type nt_StringArraySubscriber_ParamType = [u32; 2usize];
#[doc = " Timestamped StringArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_StringArraySubscriber_TimestampedValueType = nt_TimestampedStringArray;
#[test]
fn bindgen_test_layout_nt_StringArraySubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_StringArraySubscriber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_StringArraySubscriber>(),
        20usize,
        concat!("Size of: ", stringify!(nt_StringArraySubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_StringArraySubscriber>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_StringArraySubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_StringArraySubscriber),
            "::",
            stringify!(m_defaultValue)
        )
    );
}
#[doc = " NetworkTables StringArray publisher."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_StringArrayPublisher {
    pub _base: nt_Publisher,
}
#[doc = " NetworkTables StringArray topic."]
pub type nt_StringArrayPublisher_TopicType = nt_StringArrayTopic;
pub type nt_StringArrayPublisher_ValueType = [u32; 3usize];
pub type nt_StringArrayPublisher_ParamType = [u32; 2usize];
#[doc = " Timestamped StringArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_StringArrayPublisher_TimestampedValueType = nt_TimestampedStringArray;
#[test]
fn bindgen_test_layout_nt_StringArrayPublisher() {
    assert_eq!(
        ::std::mem::size_of::<nt_StringArrayPublisher>(),
        8usize,
        concat!("Size of: ", stringify!(nt_StringArrayPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_StringArrayPublisher>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_StringArrayPublisher))
    );
}
#[doc = " NetworkTables StringArray entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_StringArrayEntry {
    pub _base: nt_StringArraySubscriber,
    pub _base_1: nt_StringArrayPublisher,
}
#[doc = " NetworkTables StringArray subscriber."]
pub type nt_StringArrayEntry_SubscriberType = nt_StringArraySubscriber;
#[doc = " NetworkTables StringArray publisher."]
pub type nt_StringArrayEntry_PublisherType = nt_StringArrayPublisher;
#[doc = " NetworkTables StringArray topic."]
pub type nt_StringArrayEntry_TopicType = nt_StringArrayTopic;
pub type nt_StringArrayEntry_ValueType = [u32; 3usize];
pub type nt_StringArrayEntry_ParamType = [u32; 2usize];
#[doc = " Timestamped StringArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_StringArrayEntry_TimestampedValueType = nt_TimestampedStringArray;
#[test]
fn bindgen_test_layout_nt_StringArrayEntry() {
    assert_eq!(
        ::std::mem::size_of::<nt_StringArrayEntry>(),
        28usize,
        concat!("Size of: ", stringify!(nt_StringArrayEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_StringArrayEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_StringArrayEntry))
    );
}
#[doc = " NetworkTables StringArray topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_StringArrayTopic {
    pub _base: nt_Topic,
}
#[doc = " NetworkTables StringArray subscriber."]
pub type nt_StringArrayTopic_SubscriberType = nt_StringArraySubscriber;
#[doc = " NetworkTables StringArray publisher."]
pub type nt_StringArrayTopic_PublisherType = nt_StringArrayPublisher;
#[doc = " NetworkTables StringArray entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
pub type nt_StringArrayTopic_EntryType = nt_StringArrayEntry;
pub type nt_StringArrayTopic_ValueType = [u32; 3usize];
pub type nt_StringArrayTopic_ParamType = [u32; 2usize];
#[doc = " Timestamped StringArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_StringArrayTopic_TimestampedValueType = nt_TimestampedStringArray;
#[doc = " The default type string for this topic type."]
pub const nt_StringArrayTopic_kTypeString: &[u8; 9usize] = b"string[]\0";
#[test]
fn bindgen_test_layout_nt_StringArrayTopic() {
    assert_eq!(
        ::std::mem::size_of::<nt_StringArrayTopic>(),
        4usize,
        concat!("Size of: ", stringify!(nt_StringArrayTopic))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_StringArrayTopic>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_StringArrayTopic))
    );
}
#[doc = " NetworkTables BooleanArray subscriber."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_BooleanArraySubscriber {
    pub _base: nt_Subscriber,
    pub m_defaultValue: nt_BooleanArraySubscriber_ValueType,
}
#[doc = " NetworkTables BooleanArray topic."]
pub type nt_BooleanArraySubscriber_TopicType = nt_BooleanArrayTopic;
pub type nt_BooleanArraySubscriber_ValueType = [u32; 3usize];
pub type nt_BooleanArraySubscriber_ParamType = [u32; 2usize];
#[doc = " Timestamped BooleanArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_BooleanArraySubscriber_TimestampedValueType = nt_TimestampedBooleanArray;
pub type nt_BooleanArraySubscriber_SmallRetType = [u32; 2usize];
pub type nt_BooleanArraySubscriber_SmallElemType = ::std::os::raw::c_int;
#[doc = " Timestamped BooleanArray view (for SmallVector-taking functions).\n @ingroup ntcore_cpp_handle_api"]
pub type nt_BooleanArraySubscriber_TimestampedValueViewType = nt_TimestampedBooleanArrayView;
#[test]
fn bindgen_test_layout_nt_BooleanArraySubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_BooleanArraySubscriber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_BooleanArraySubscriber>(),
        20usize,
        concat!("Size of: ", stringify!(nt_BooleanArraySubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_BooleanArraySubscriber>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_BooleanArraySubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_BooleanArraySubscriber),
            "::",
            stringify!(m_defaultValue)
        )
    );
}
#[doc = " NetworkTables BooleanArray publisher."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_BooleanArrayPublisher {
    pub _base: nt_Publisher,
}
#[doc = " NetworkTables BooleanArray topic."]
pub type nt_BooleanArrayPublisher_TopicType = nt_BooleanArrayTopic;
pub type nt_BooleanArrayPublisher_ValueType = [u32; 3usize];
pub type nt_BooleanArrayPublisher_ParamType = [u32; 2usize];
pub type nt_BooleanArrayPublisher_SmallRetType = [u32; 2usize];
pub type nt_BooleanArrayPublisher_SmallElemType = ::std::os::raw::c_int;
#[doc = " Timestamped BooleanArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_BooleanArrayPublisher_TimestampedValueType = nt_TimestampedBooleanArray;
#[test]
fn bindgen_test_layout_nt_BooleanArrayPublisher() {
    assert_eq!(
        ::std::mem::size_of::<nt_BooleanArrayPublisher>(),
        8usize,
        concat!("Size of: ", stringify!(nt_BooleanArrayPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_BooleanArrayPublisher>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_BooleanArrayPublisher))
    );
}
#[doc = " NetworkTables BooleanArray entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_BooleanArrayEntry {
    pub _base: nt_BooleanArraySubscriber,
    pub _base_1: nt_BooleanArrayPublisher,
}
#[doc = " NetworkTables BooleanArray subscriber."]
pub type nt_BooleanArrayEntry_SubscriberType = nt_BooleanArraySubscriber;
#[doc = " NetworkTables BooleanArray publisher."]
pub type nt_BooleanArrayEntry_PublisherType = nt_BooleanArrayPublisher;
#[doc = " NetworkTables BooleanArray topic."]
pub type nt_BooleanArrayEntry_TopicType = nt_BooleanArrayTopic;
pub type nt_BooleanArrayEntry_ValueType = [u32; 3usize];
pub type nt_BooleanArrayEntry_ParamType = [u32; 2usize];
pub type nt_BooleanArrayEntry_SmallRetType = [u32; 2usize];
pub type nt_BooleanArrayEntry_SmallElemType = ::std::os::raw::c_int;
#[doc = " Timestamped BooleanArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_BooleanArrayEntry_TimestampedValueType = nt_TimestampedBooleanArray;
#[test]
fn bindgen_test_layout_nt_BooleanArrayEntry() {
    assert_eq!(
        ::std::mem::size_of::<nt_BooleanArrayEntry>(),
        28usize,
        concat!("Size of: ", stringify!(nt_BooleanArrayEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_BooleanArrayEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_BooleanArrayEntry))
    );
}
#[doc = " NetworkTables BooleanArray topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_BooleanArrayTopic {
    pub _base: nt_Topic,
}
#[doc = " NetworkTables BooleanArray subscriber."]
pub type nt_BooleanArrayTopic_SubscriberType = nt_BooleanArraySubscriber;
#[doc = " NetworkTables BooleanArray publisher."]
pub type nt_BooleanArrayTopic_PublisherType = nt_BooleanArrayPublisher;
#[doc = " NetworkTables BooleanArray entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
pub type nt_BooleanArrayTopic_EntryType = nt_BooleanArrayEntry;
pub type nt_BooleanArrayTopic_ValueType = [u32; 3usize];
pub type nt_BooleanArrayTopic_ParamType = [u32; 2usize];
#[doc = " Timestamped BooleanArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_BooleanArrayTopic_TimestampedValueType = nt_TimestampedBooleanArray;
#[doc = " The default type string for this topic type."]
pub const nt_BooleanArrayTopic_kTypeString: &[u8; 10usize] = b"boolean[]\0";
#[test]
fn bindgen_test_layout_nt_BooleanArrayTopic() {
    assert_eq!(
        ::std::mem::size_of::<nt_BooleanArrayTopic>(),
        4usize,
        concat!("Size of: ", stringify!(nt_BooleanArrayTopic))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_BooleanArrayTopic>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_BooleanArrayTopic))
    );
}
#[doc = " NetworkTables IntegerArray subscriber."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_IntegerArraySubscriber {
    pub _base: nt_Subscriber,
    pub m_defaultValue: nt_IntegerArraySubscriber_ValueType,
}
#[doc = " NetworkTables IntegerArray topic."]
pub type nt_IntegerArraySubscriber_TopicType = nt_IntegerArrayTopic;
pub type nt_IntegerArraySubscriber_ValueType = [u32; 3usize];
pub type nt_IntegerArraySubscriber_ParamType = [u32; 2usize];
#[doc = " Timestamped IntegerArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_IntegerArraySubscriber_TimestampedValueType = nt_TimestampedIntegerArray;
pub type nt_IntegerArraySubscriber_SmallRetType = [u32; 2usize];
pub type nt_IntegerArraySubscriber_SmallElemType = i64;
#[doc = " Timestamped IntegerArray view (for SmallVector-taking functions).\n @ingroup ntcore_cpp_handle_api"]
pub type nt_IntegerArraySubscriber_TimestampedValueViewType = nt_TimestampedIntegerArrayView;
#[test]
fn bindgen_test_layout_nt_IntegerArraySubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_IntegerArraySubscriber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_IntegerArraySubscriber>(),
        20usize,
        concat!("Size of: ", stringify!(nt_IntegerArraySubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_IntegerArraySubscriber>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_IntegerArraySubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_IntegerArraySubscriber),
            "::",
            stringify!(m_defaultValue)
        )
    );
}
#[doc = " NetworkTables IntegerArray publisher."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_IntegerArrayPublisher {
    pub _base: nt_Publisher,
}
#[doc = " NetworkTables IntegerArray topic."]
pub type nt_IntegerArrayPublisher_TopicType = nt_IntegerArrayTopic;
pub type nt_IntegerArrayPublisher_ValueType = [u32; 3usize];
pub type nt_IntegerArrayPublisher_ParamType = [u32; 2usize];
pub type nt_IntegerArrayPublisher_SmallRetType = [u32; 2usize];
pub type nt_IntegerArrayPublisher_SmallElemType = i64;
#[doc = " Timestamped IntegerArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_IntegerArrayPublisher_TimestampedValueType = nt_TimestampedIntegerArray;
#[test]
fn bindgen_test_layout_nt_IntegerArrayPublisher() {
    assert_eq!(
        ::std::mem::size_of::<nt_IntegerArrayPublisher>(),
        8usize,
        concat!("Size of: ", stringify!(nt_IntegerArrayPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_IntegerArrayPublisher>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_IntegerArrayPublisher))
    );
}
#[doc = " NetworkTables IntegerArray entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_IntegerArrayEntry {
    pub _base: nt_IntegerArraySubscriber,
    pub _base_1: nt_IntegerArrayPublisher,
}
#[doc = " NetworkTables IntegerArray subscriber."]
pub type nt_IntegerArrayEntry_SubscriberType = nt_IntegerArraySubscriber;
#[doc = " NetworkTables IntegerArray publisher."]
pub type nt_IntegerArrayEntry_PublisherType = nt_IntegerArrayPublisher;
#[doc = " NetworkTables IntegerArray topic."]
pub type nt_IntegerArrayEntry_TopicType = nt_IntegerArrayTopic;
pub type nt_IntegerArrayEntry_ValueType = [u32; 3usize];
pub type nt_IntegerArrayEntry_ParamType = [u32; 2usize];
pub type nt_IntegerArrayEntry_SmallRetType = [u32; 2usize];
pub type nt_IntegerArrayEntry_SmallElemType = i64;
#[doc = " Timestamped IntegerArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_IntegerArrayEntry_TimestampedValueType = nt_TimestampedIntegerArray;
#[test]
fn bindgen_test_layout_nt_IntegerArrayEntry() {
    assert_eq!(
        ::std::mem::size_of::<nt_IntegerArrayEntry>(),
        28usize,
        concat!("Size of: ", stringify!(nt_IntegerArrayEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_IntegerArrayEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_IntegerArrayEntry))
    );
}
#[doc = " NetworkTables IntegerArray topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_IntegerArrayTopic {
    pub _base: nt_Topic,
}
#[doc = " NetworkTables IntegerArray subscriber."]
pub type nt_IntegerArrayTopic_SubscriberType = nt_IntegerArraySubscriber;
#[doc = " NetworkTables IntegerArray publisher."]
pub type nt_IntegerArrayTopic_PublisherType = nt_IntegerArrayPublisher;
#[doc = " NetworkTables IntegerArray entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
pub type nt_IntegerArrayTopic_EntryType = nt_IntegerArrayEntry;
pub type nt_IntegerArrayTopic_ValueType = [u32; 3usize];
pub type nt_IntegerArrayTopic_ParamType = [u32; 2usize];
#[doc = " Timestamped IntegerArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_IntegerArrayTopic_TimestampedValueType = nt_TimestampedIntegerArray;
#[doc = " The default type string for this topic type."]
pub const nt_IntegerArrayTopic_kTypeString: &[u8; 6usize] = b"int[]\0";
#[test]
fn bindgen_test_layout_nt_IntegerArrayTopic() {
    assert_eq!(
        ::std::mem::size_of::<nt_IntegerArrayTopic>(),
        4usize,
        concat!("Size of: ", stringify!(nt_IntegerArrayTopic))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_IntegerArrayTopic>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_IntegerArrayTopic))
    );
}
#[doc = " NetworkTables Raw subscriber."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_RawSubscriber {
    pub _base: nt_Subscriber,
    pub m_defaultValue: nt_RawSubscriber_ValueType,
}
#[doc = " NetworkTables Raw topic."]
pub type nt_RawSubscriber_TopicType = nt_RawTopic;
pub type nt_RawSubscriber_ValueType = [u32; 3usize];
pub type nt_RawSubscriber_ParamType = [u32; 2usize];
#[doc = " Timestamped Raw.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_RawSubscriber_TimestampedValueType = nt_TimestampedRaw;
pub type nt_RawSubscriber_SmallRetType = [u32; 2usize];
pub type nt_RawSubscriber_SmallElemType = u8;
#[doc = " Timestamped Raw view (for SmallVector-taking functions).\n @ingroup ntcore_cpp_handle_api"]
pub type nt_RawSubscriber_TimestampedValueViewType = nt_TimestampedRawView;
#[test]
fn bindgen_test_layout_nt_RawSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_RawSubscriber> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_RawSubscriber>(),
        20usize,
        concat!("Size of: ", stringify!(nt_RawSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_RawSubscriber>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_RawSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_RawSubscriber),
            "::",
            stringify!(m_defaultValue)
        )
    );
}
#[doc = " NetworkTables Raw publisher."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_RawPublisher {
    pub _base: nt_Publisher,
}
#[doc = " NetworkTables Raw topic."]
pub type nt_RawPublisher_TopicType = nt_RawTopic;
pub type nt_RawPublisher_ValueType = [u32; 3usize];
pub type nt_RawPublisher_ParamType = [u32; 2usize];
pub type nt_RawPublisher_SmallRetType = [u32; 2usize];
pub type nt_RawPublisher_SmallElemType = u8;
#[doc = " Timestamped Raw.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_RawPublisher_TimestampedValueType = nt_TimestampedRaw;
#[test]
fn bindgen_test_layout_nt_RawPublisher() {
    assert_eq!(
        ::std::mem::size_of::<nt_RawPublisher>(),
        8usize,
        concat!("Size of: ", stringify!(nt_RawPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_RawPublisher>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_RawPublisher))
    );
}
#[doc = " NetworkTables Raw entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_RawEntry {
    pub _base: nt_RawSubscriber,
    pub _base_1: nt_RawPublisher,
}
#[doc = " NetworkTables Raw subscriber."]
pub type nt_RawEntry_SubscriberType = nt_RawSubscriber;
#[doc = " NetworkTables Raw publisher."]
pub type nt_RawEntry_PublisherType = nt_RawPublisher;
#[doc = " NetworkTables Raw topic."]
pub type nt_RawEntry_TopicType = nt_RawTopic;
pub type nt_RawEntry_ValueType = [u32; 3usize];
pub type nt_RawEntry_ParamType = [u32; 2usize];
pub type nt_RawEntry_SmallRetType = [u32; 2usize];
pub type nt_RawEntry_SmallElemType = u8;
#[doc = " Timestamped Raw.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_RawEntry_TimestampedValueType = nt_TimestampedRaw;
#[test]
fn bindgen_test_layout_nt_RawEntry() {
    assert_eq!(
        ::std::mem::size_of::<nt_RawEntry>(),
        28usize,
        concat!("Size of: ", stringify!(nt_RawEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_RawEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_RawEntry))
    );
}
#[doc = " NetworkTables Raw topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_RawTopic {
    pub _base: nt_Topic,
}
#[doc = " NetworkTables Raw subscriber."]
pub type nt_RawTopic_SubscriberType = nt_RawSubscriber;
#[doc = " NetworkTables Raw publisher."]
pub type nt_RawTopic_PublisherType = nt_RawPublisher;
#[doc = " NetworkTables Raw entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
pub type nt_RawTopic_EntryType = nt_RawEntry;
pub type nt_RawTopic_ValueType = [u32; 3usize];
pub type nt_RawTopic_ParamType = [u32; 2usize];
#[doc = " Timestamped Raw.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_RawTopic_TimestampedValueType = nt_TimestampedRaw;
#[test]
fn bindgen_test_layout_nt_RawTopic() {
    assert_eq!(
        ::std::mem::size_of::<nt_RawTopic>(),
        4usize,
        concat!("Size of: ", stringify!(nt_RawTopic))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_RawTopic>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_RawTopic))
    );
}
#[doc = " Subscribe to multiple topics based on one or more topic name prefixes. Can be\n used in combination with ValueListenerPoller to listen for value changes\n across all matching topics."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_MultiSubscriber {
    pub m_handle: NT_MultiSubscriber,
}
#[test]
fn bindgen_test_layout_nt_MultiSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_MultiSubscriber> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_MultiSubscriber>(),
        4usize,
        concat!("Size of: ", stringify!(nt_MultiSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_MultiSubscriber>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_MultiSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_MultiSubscriber),
            "::",
            stringify!(m_handle)
        )
    );
}
#[doc = " NetworkTables FloatArray subscriber."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_FloatArraySubscriber {
    pub _base: nt_Subscriber,
    pub m_defaultValue: nt_FloatArraySubscriber_ValueType,
}
#[doc = " NetworkTables FloatArray topic."]
pub type nt_FloatArraySubscriber_TopicType = nt_FloatArrayTopic;
pub type nt_FloatArraySubscriber_ValueType = [u32; 3usize];
pub type nt_FloatArraySubscriber_ParamType = [u32; 2usize];
#[doc = " Timestamped FloatArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_FloatArraySubscriber_TimestampedValueType = nt_TimestampedFloatArray;
pub type nt_FloatArraySubscriber_SmallRetType = [u32; 2usize];
pub type nt_FloatArraySubscriber_SmallElemType = f32;
#[doc = " Timestamped FloatArray view (for SmallVector-taking functions).\n @ingroup ntcore_cpp_handle_api"]
pub type nt_FloatArraySubscriber_TimestampedValueViewType = nt_TimestampedFloatArrayView;
#[test]
fn bindgen_test_layout_nt_FloatArraySubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_FloatArraySubscriber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_FloatArraySubscriber>(),
        20usize,
        concat!("Size of: ", stringify!(nt_FloatArraySubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_FloatArraySubscriber>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_FloatArraySubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_FloatArraySubscriber),
            "::",
            stringify!(m_defaultValue)
        )
    );
}
#[doc = " NetworkTables FloatArray publisher."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_FloatArrayPublisher {
    pub _base: nt_Publisher,
}
#[doc = " NetworkTables FloatArray topic."]
pub type nt_FloatArrayPublisher_TopicType = nt_FloatArrayTopic;
pub type nt_FloatArrayPublisher_ValueType = [u32; 3usize];
pub type nt_FloatArrayPublisher_ParamType = [u32; 2usize];
pub type nt_FloatArrayPublisher_SmallRetType = [u32; 2usize];
pub type nt_FloatArrayPublisher_SmallElemType = f32;
#[doc = " Timestamped FloatArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_FloatArrayPublisher_TimestampedValueType = nt_TimestampedFloatArray;
#[test]
fn bindgen_test_layout_nt_FloatArrayPublisher() {
    assert_eq!(
        ::std::mem::size_of::<nt_FloatArrayPublisher>(),
        8usize,
        concat!("Size of: ", stringify!(nt_FloatArrayPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_FloatArrayPublisher>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_FloatArrayPublisher))
    );
}
#[doc = " NetworkTables FloatArray entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_FloatArrayEntry {
    pub _base: nt_FloatArraySubscriber,
    pub _base_1: nt_FloatArrayPublisher,
}
#[doc = " NetworkTables FloatArray subscriber."]
pub type nt_FloatArrayEntry_SubscriberType = nt_FloatArraySubscriber;
#[doc = " NetworkTables FloatArray publisher."]
pub type nt_FloatArrayEntry_PublisherType = nt_FloatArrayPublisher;
#[doc = " NetworkTables FloatArray topic."]
pub type nt_FloatArrayEntry_TopicType = nt_FloatArrayTopic;
pub type nt_FloatArrayEntry_ValueType = [u32; 3usize];
pub type nt_FloatArrayEntry_ParamType = [u32; 2usize];
pub type nt_FloatArrayEntry_SmallRetType = [u32; 2usize];
pub type nt_FloatArrayEntry_SmallElemType = f32;
#[doc = " Timestamped FloatArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_FloatArrayEntry_TimestampedValueType = nt_TimestampedFloatArray;
#[test]
fn bindgen_test_layout_nt_FloatArrayEntry() {
    assert_eq!(
        ::std::mem::size_of::<nt_FloatArrayEntry>(),
        28usize,
        concat!("Size of: ", stringify!(nt_FloatArrayEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_FloatArrayEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_FloatArrayEntry))
    );
}
#[doc = " NetworkTables FloatArray topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_FloatArrayTopic {
    pub _base: nt_Topic,
}
#[doc = " NetworkTables FloatArray subscriber."]
pub type nt_FloatArrayTopic_SubscriberType = nt_FloatArraySubscriber;
#[doc = " NetworkTables FloatArray publisher."]
pub type nt_FloatArrayTopic_PublisherType = nt_FloatArrayPublisher;
#[doc = " NetworkTables FloatArray entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
pub type nt_FloatArrayTopic_EntryType = nt_FloatArrayEntry;
pub type nt_FloatArrayTopic_ValueType = [u32; 3usize];
pub type nt_FloatArrayTopic_ParamType = [u32; 2usize];
#[doc = " Timestamped FloatArray.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_FloatArrayTopic_TimestampedValueType = nt_TimestampedFloatArray;
#[doc = " The default type string for this topic type."]
pub const nt_FloatArrayTopic_kTypeString: &[u8; 8usize] = b"float[]\0";
#[test]
fn bindgen_test_layout_nt_FloatArrayTopic() {
    assert_eq!(
        ::std::mem::size_of::<nt_FloatArrayTopic>(),
        4usize,
        concat!("Size of: ", stringify!(nt_FloatArrayTopic))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_FloatArrayTopic>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_FloatArrayTopic))
    );
}
#[doc = " NetworkTables Float subscriber."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_FloatSubscriber {
    pub _base: nt_Subscriber,
    pub m_defaultValue: nt_FloatSubscriber_ValueType,
}
#[doc = " NetworkTables Float topic."]
pub type nt_FloatSubscriber_TopicType = nt_FloatTopic;
pub type nt_FloatSubscriber_ValueType = f32;
pub type nt_FloatSubscriber_ParamType = f32;
#[doc = " Timestamped Float.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_FloatSubscriber_TimestampedValueType = nt_TimestampedFloat;
#[test]
fn bindgen_test_layout_nt_FloatSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<nt_FloatSubscriber> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_FloatSubscriber>(),
        12usize,
        concat!("Size of: ", stringify!(nt_FloatSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_FloatSubscriber>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_FloatSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_defaultValue) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_FloatSubscriber),
            "::",
            stringify!(m_defaultValue)
        )
    );
}
#[doc = " NetworkTables Float publisher."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_FloatPublisher {
    pub _base: nt_Publisher,
}
#[doc = " NetworkTables Float topic."]
pub type nt_FloatPublisher_TopicType = nt_FloatTopic;
pub type nt_FloatPublisher_ValueType = f32;
pub type nt_FloatPublisher_ParamType = f32;
#[doc = " Timestamped Float.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_FloatPublisher_TimestampedValueType = nt_TimestampedFloat;
#[test]
fn bindgen_test_layout_nt_FloatPublisher() {
    assert_eq!(
        ::std::mem::size_of::<nt_FloatPublisher>(),
        8usize,
        concat!("Size of: ", stringify!(nt_FloatPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_FloatPublisher>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_FloatPublisher))
    );
}
#[doc = " NetworkTables Float entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_FloatEntry {
    pub _base: nt_FloatSubscriber,
    pub _base_1: nt_FloatPublisher,
}
#[doc = " NetworkTables Float subscriber."]
pub type nt_FloatEntry_SubscriberType = nt_FloatSubscriber;
#[doc = " NetworkTables Float publisher."]
pub type nt_FloatEntry_PublisherType = nt_FloatPublisher;
#[doc = " NetworkTables Float topic."]
pub type nt_FloatEntry_TopicType = nt_FloatTopic;
pub type nt_FloatEntry_ValueType = f32;
pub type nt_FloatEntry_ParamType = f32;
#[doc = " Timestamped Float.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_FloatEntry_TimestampedValueType = nt_TimestampedFloat;
#[test]
fn bindgen_test_layout_nt_FloatEntry() {
    assert_eq!(
        ::std::mem::size_of::<nt_FloatEntry>(),
        20usize,
        concat!("Size of: ", stringify!(nt_FloatEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_FloatEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_FloatEntry))
    );
}
#[doc = " NetworkTables Float topic."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_FloatTopic {
    pub _base: nt_Topic,
}
#[doc = " NetworkTables Float subscriber."]
pub type nt_FloatTopic_SubscriberType = nt_FloatSubscriber;
#[doc = " NetworkTables Float publisher."]
pub type nt_FloatTopic_PublisherType = nt_FloatPublisher;
#[doc = " NetworkTables Float entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed."]
pub type nt_FloatTopic_EntryType = nt_FloatEntry;
pub type nt_FloatTopic_ValueType = f32;
pub type nt_FloatTopic_ParamType = f32;
#[doc = " Timestamped Float.\n @ingroup ntcore_cpp_handle_api"]
pub type nt_FloatTopic_TimestampedValueType = nt_TimestampedFloat;
#[doc = " The default type string for this topic type."]
pub const nt_FloatTopic_kTypeString: &[u8; 6usize] = b"float\0";
#[test]
fn bindgen_test_layout_nt_FloatTopic() {
    assert_eq!(
        ::std::mem::size_of::<nt_FloatTopic>(),
        4usize,
        concat!("Size of: ", stringify!(nt_FloatTopic))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_FloatTopic>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_FloatTopic))
    );
}
#[doc = " Event listener. This calls back to a callback function when an event\n matching the specified mask occurs. The callback function is called\n asynchronously on a separate thread, so it's important to use synchronization\n or atomics when accessing any shared state from the callback function."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_NetworkTableListener {
    pub m_handle: NT_Listener,
}
#[test]
fn bindgen_test_layout_nt_NetworkTableListener() {
    const UNINIT: ::std::mem::MaybeUninit<nt_NetworkTableListener> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_NetworkTableListener>(),
        4usize,
        concat!("Size of: ", stringify!(nt_NetworkTableListener))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_NetworkTableListener>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_NetworkTableListener))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_NetworkTableListener),
            "::",
            stringify!(m_handle)
        )
    );
}
#[doc = " Event polled listener. This queues events matching the specified mask. Code\n using the listener must periodically call ReadQueue() to read the\n events."]
#[repr(C)]
#[derive(Debug)]
pub struct nt_NetworkTableListenerPoller {
    pub m_handle: NT_ListenerPoller,
}
#[test]
fn bindgen_test_layout_nt_NetworkTableListenerPoller() {
    const UNINIT: ::std::mem::MaybeUninit<nt_NetworkTableListenerPoller> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<nt_NetworkTableListenerPoller>(),
        4usize,
        concat!("Size of: ", stringify!(nt_NetworkTableListenerPoller))
    );
    assert_eq!(
        ::std::mem::align_of::<nt_NetworkTableListenerPoller>(),
        4usize,
        concat!("Alignment of ", stringify!(nt_NetworkTableListenerPoller))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nt_NetworkTableListenerPoller),
            "::",
            stringify!(m_handle)
        )
    );
}
#[doc = " Timestamped unit.\n\n @tparam T unit type, e.g. units::meter_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_TimestampedUnit<T> {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: T,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[doc = " NetworkTables unit-typed subscriber.\n\n @tparam T unit type, e.g. units::meter_t"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_UnitSubscriber<T> {
    pub _base: nt_Subscriber,
    pub m_defaultValue: nt_UnitSubscriber_ValueType<T>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[doc = " NetworkTables unit-typed topic. Publishers publish the type name (e.g.\n \"meter\") as the \"unit\" property. Type conversions are not performed--for\n correct behavior the publisher and subscriber must use the same unit type,\n but this can be checked at runtime using IsMatchingUnit().\n\n @tparam T unit type, e.g. units::meter_t"]
pub type nt_UnitSubscriber_TopicType = nt_UnitTopic;
pub type nt_UnitSubscriber_ValueType<T> = T;
pub type nt_UnitSubscriber_ParamType<T> = T;
#[doc = " Timestamped unit.\n\n @tparam T unit type, e.g. units::meter_t"]
pub type nt_UnitSubscriber_TimestampedValueType<T> = nt_TimestampedUnit<T>;
#[doc = " NetworkTables unit-typed publisher.\n\n @tparam T unit type, e.g. units::meter_t"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_UnitPublisher {
    pub _base: nt_Publisher,
}
#[doc = " NetworkTables unit-typed topic. Publishers publish the type name (e.g.\n \"meter\") as the \"unit\" property. Type conversions are not performed--for\n correct behavior the publisher and subscriber must use the same unit type,\n but this can be checked at runtime using IsMatchingUnit().\n\n @tparam T unit type, e.g. units::meter_t"]
pub type nt_UnitPublisher_TopicType = nt_UnitTopic;
pub type nt_UnitPublisher_ValueType<T> = T;
pub type nt_UnitPublisher_ParamType<T> = T;
#[doc = " Timestamped unit.\n\n @tparam T unit type, e.g. units::meter_t"]
pub type nt_UnitPublisher_TimestampedValueType<T> = nt_TimestampedUnit<T>;
#[doc = " NetworkTables unit-typed entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed.\n\n @tparam T unit type, e.g. units::meter_t"]
#[repr(C)]
#[derive(Debug)]
pub struct nt_UnitEntry<T> {
    pub _base: nt_UnitSubscriber<T>,
    pub _base_1: nt_UnitPublisher,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
#[doc = " NetworkTables unit-typed subscriber.\n\n @tparam T unit type, e.g. units::meter_t"]
pub type nt_UnitEntry_SubscriberType<T> = nt_UnitSubscriber<T>;
#[doc = " NetworkTables unit-typed publisher.\n\n @tparam T unit type, e.g. units::meter_t"]
pub type nt_UnitEntry_PublisherType = nt_UnitPublisher;
#[doc = " NetworkTables unit-typed topic. Publishers publish the type name (e.g.\n \"meter\") as the \"unit\" property. Type conversions are not performed--for\n correct behavior the publisher and subscriber must use the same unit type,\n but this can be checked at runtime using IsMatchingUnit().\n\n @tparam T unit type, e.g. units::meter_t"]
pub type nt_UnitEntry_TopicType = nt_UnitTopic;
pub type nt_UnitEntry_ValueType<T> = T;
pub type nt_UnitEntry_ParamType<T> = T;
#[doc = " Timestamped unit.\n\n @tparam T unit type, e.g. units::meter_t"]
pub type nt_UnitEntry_TimestampedValueType<T> = nt_TimestampedUnit<T>;
#[doc = " NetworkTables unit-typed topic. Publishers publish the type name (e.g.\n \"meter\") as the \"unit\" property. Type conversions are not performed--for\n correct behavior the publisher and subscriber must use the same unit type,\n but this can be checked at runtime using IsMatchingUnit().\n\n @tparam T unit type, e.g. units::meter_t"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nt_UnitTopic {
    pub _base: nt_Topic,
}
#[doc = " NetworkTables unit-typed subscriber.\n\n @tparam T unit type, e.g. units::meter_t"]
pub type nt_UnitTopic_SubscriberType<T> = nt_UnitSubscriber<T>;
#[doc = " NetworkTables unit-typed publisher.\n\n @tparam T unit type, e.g. units::meter_t"]
pub type nt_UnitTopic_PublisherType = nt_UnitPublisher;
#[doc = " NetworkTables unit-typed entry.\n\n @note Unlike NetworkTableEntry, the entry goes away when this is destroyed.\n\n @tparam T unit type, e.g. units::meter_t"]
pub type nt_UnitTopic_EntryType<T> = nt_UnitEntry<T>;
pub type nt_UnitTopic_ValueType<T> = T;
pub type nt_UnitTopic_ParamType<T> = T;
#[doc = " Timestamped unit.\n\n @tparam T unit type, e.g. units::meter_t"]
pub type nt_UnitTopic_TimestampedValueType<T> = nt_TimestampedUnit<T>;
extern "C" {
    #[link_name = "\u{1}_Z16GetWPILibVersionv"]
    pub fn GetWPILibVersion() -> *const ::std::os::raw::c_char;
}
pub type Eigen_internal_conditional_type<Then> = Then;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_traits {
    pub _address: u8,
}
#[doc = " \\internal The reference selector for template expressions. The idea is that we don't\n need to use references for expressions since they are light weight proxy\n objects which should generate no copying overhead."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_ref_selector {
    pub _address: u8,
}
pub type Eigen_internal_ref_selector_type = u8;
pub type Eigen_internal_ref_selector_non_const_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_dense_xpr_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_default_packet_traits {
    pub _address: u8,
}
pub const Eigen_internal_default_packet_traits_HasHalfPacket:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasAdd:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasSub:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasShift:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasMul:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasNegate:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasAbs:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasArg:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasAbs2:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasAbsDiff:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasMin:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasMax:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasConj:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasSetLinear:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 1;
pub const Eigen_internal_default_packet_traits_HasBlend:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasCmp:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasDiv:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasSqrt:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasRsqrt:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasExp:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasExpm1:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasLog:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasLog1p:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasLog10:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasPow:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasSin:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasCos:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasTan:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasASin:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasACos:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasATan:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasSinh:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasCosh:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasTanh:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasLGamma:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasDiGamma:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasZeta:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasPolygamma:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasErf:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasErfc:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasNdtri:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasBessel:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasIGamma:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasIGammaDerA:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasGammaSampleDerAlpha:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasIGammac:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasBetaInc:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasRound:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasRint:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasFloor:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasCeil:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_default_packet_traits_HasSign:
    Eigen_internal_default_packet_traits__bindgen_ty_1 = 0;
pub type Eigen_internal_default_packet_traits__bindgen_ty_1 = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_Eigen_internal_default_packet_traits() {
    assert_eq!(
        ::std::mem::size_of::<Eigen_internal_default_packet_traits>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(Eigen_internal_default_packet_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Eigen_internal_default_packet_traits>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(Eigen_internal_default_packet_traits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_internal_packet_traits {
    pub _address: u8,
}
pub type Eigen_internal_packet_traits_type<T> = T;
pub type Eigen_internal_packet_traits_half<T> = T;
pub const Eigen_internal_packet_traits_Vectorizable: Eigen_internal_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_packet_traits_size: Eigen_internal_packet_traits__bindgen_ty_1 = 0;
pub const Eigen_internal_packet_traits_AlignedOnScalar: Eigen_internal_packet_traits__bindgen_ty_1 =
    0;
pub const Eigen_internal_packet_traits_HasHalfPacket: Eigen_internal_packet_traits__bindgen_ty_1 =
    0;
pub type Eigen_internal_packet_traits__bindgen_ty_1 = i32;
pub const Eigen_internal_packet_traits_HasAdd: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasSub: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasMul: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasNegate: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasAbs: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasAbs2: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasMin: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasMax: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasConj: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub const Eigen_internal_packet_traits_HasSetLinear: Eigen_internal_packet_traits__bindgen_ty_2 = 0;
pub type Eigen_internal_packet_traits__bindgen_ty_2 = i32;
#[doc = " \\class NumTraits\n \\ingroup Core_Module\n\n \\brief Holds information about the various numeric (i.e. scalar) types allowed by Eigen.\n\n \\tparam T the numeric type at hand\n\n This class stores enums, typedefs and static methods giving information about a numeric type.\n\n The provided data consists of:\n \\li A typedef \\c Real, giving the \"real part\" type of \\a T. If \\a T is already real,\n     then \\c Real is just a typedef to \\a T. If \\a T is \\c std::complex<U> then \\c Real\n     is a typedef to \\a U.\n \\li A typedef \\c NonInteger, giving the type that should be used for operations producing non-integral values,\n     such as quotients, square roots, etc. If \\a T is a floating-point type, then this typedef just gives\n     \\a T again. Note however that many Eigen functions such as internal::sqrt simply refuse to\n     take integers. Outside of a few cases, Eigen doesn't do automatic type promotion. Thus, this typedef is\n     only intended as a helper for code that needs to explicitly promote types.\n \\li A typedef \\c Literal giving the type to use for numeric literals such as \"2\" or \"0.5\". For instance, for \\c std::complex<U>, Literal is defined as \\c U.\n     Of course, this type must be fully compatible with \\a T. In doubt, just use \\a T here.\n \\li A typedef \\a Nested giving the type to use to nest a value inside of the expression tree. If you don't know what\n     this means, just use \\a T here.\n \\li An enum value \\a IsComplex. It is equal to 1 if \\a T is a \\c std::complex\n     type, and to 0 otherwise.\n \\li An enum value \\a IsInteger. It is equal to \\c 1 if \\a T is an integer type such as \\c int,\n     and to \\c 0 otherwise.\n \\li Enum values ReadCost, AddCost and MulCost representing a rough estimate of the number of CPU cycles needed\n     to by move / add / mul instructions respectively, assuming the data is already stored in CPU registers.\n     Stay vague here. No need to do architecture-specific stuff. If you don't know what this means, just use \\c Eigen::HugeCost.\n \\li An enum value \\a IsSigned. It is equal to \\c 1 if \\a T is a signed type and to 0 if \\a T is unsigned.\n \\li An enum value \\a RequireInitialization. It is equal to \\c 1 if the constructor of the numeric type \\a T must\n     be called, and to 0 if it is safe not to call it. Default is 0 if \\a T is an arithmetic type, and 1 otherwise.\n \\li An epsilon() function which, unlike <a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/epsilon\">std::numeric_limits::epsilon()</a>,\n     it returns a \\a Real instead of a \\a T.\n \\li A dummy_precision() function returning a weak epsilon value. It is mainly used as a default\n     value by the fuzzy comparison operators.\n \\li highest() and lowest() functions returning the highest and lowest possible values respectively.\n \\li digits() function returning the number of radix digits (non-sign digits for integers, mantissa for floating-point). This is\n     the analogue of <a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/digits\">std::numeric_limits<T>::digits</a>\n     which is used as the default implementation if specialized.\n \\li digits10() function returning the number of decimal digits that can be represented without change. This is\n     the analogue of <a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/digits10\">std::numeric_limits<T>::digits10</a>\n     which is used as the default implementation if specialized.\n \\li min_exponent() and max_exponent() functions returning the highest and lowest possible values, respectively,\n     such that the radix raised to the power exponent-1 is a normalized floating-point number.  These are equivalent to\n     <a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/min_exponent\">std::numeric_limits<T>::min_exponent</a>/\n     <a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/max_exponent\">std::numeric_limits<T>::max_exponent</a>.\n \\li infinity() function returning a representation of positive infinity, if available.\n \\li quiet_NaN function returning a non-signaling \"not-a-number\", if available."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_GenericNumTraits {
    pub _address: u8,
}
pub const Eigen_GenericNumTraits_IsInteger: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub const Eigen_GenericNumTraits_IsSigned: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub const Eigen_GenericNumTraits_IsComplex: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub const Eigen_GenericNumTraits_RequireInitialization: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub const Eigen_GenericNumTraits_ReadCost: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub const Eigen_GenericNumTraits_AddCost: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub const Eigen_GenericNumTraits_MulCost: Eigen_GenericNumTraits__bindgen_ty_1 = 0;
pub type Eigen_GenericNumTraits__bindgen_ty_1 = i32;
pub type Eigen_GenericNumTraits_Real<T> = T;
pub type Eigen_GenericNumTraits_NonInteger = u8;
pub type Eigen_GenericNumTraits_Nested<T> = T;
pub type Eigen_GenericNumTraits_Literal<T> = T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_NumTraits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PlainObjectBase {
    pub m_storage: u8,
}
pub const Eigen_PlainObjectBase_Options: Eigen_PlainObjectBase__bindgen_ty_1 = 0;
pub type Eigen_PlainObjectBase__bindgen_ty_1 = i32;
pub type Eigen_PlainObjectBase_Base = Eigen_internal_dense_xpr_base;
pub type Eigen_PlainObjectBase_StorageKind = Eigen_internal_traits;
pub type Eigen_PlainObjectBase_Scalar = Eigen_internal_traits;
pub type Eigen_PlainObjectBase_PacketScalar = Eigen_internal_packet_traits;
pub type Eigen_PlainObjectBase_RealScalar = Eigen_NumTraits;
pub type Eigen_PlainObjectBase_DenseType<Derived> = Derived;
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_MapType = u8;
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_ConstMapType = u8;
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_AlignedMapType = u8;
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_ConstAlignedMapType = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PlainObjectBase_StridedMapType {
    pub _address: u8,
}
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_StridedMapType_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PlainObjectBase_StridedConstMapType {
    pub _address: u8,
}
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_StridedConstMapType_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PlainObjectBase_StridedAlignedMapType {
    pub _address: u8,
}
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_StridedAlignedMapType_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Eigen_PlainObjectBase_StridedConstAlignedMapType {
    pub _address: u8,
}
#[doc = " \\class Map\n \\ingroup Core_Module\n\n \\brief A matrix or vector expression mapping an existing array of data.\n\n \\tparam PlainObjectType the equivalent matrix type of the mapped data\n \\tparam MapOptions specifies the pointer alignment in bytes. It can be: \\c #Aligned128, \\c #Aligned64, \\c #Aligned32, \\c #Aligned16, \\c #Aligned8 or \\c #Unaligned.\n                The default is \\c #Unaligned.\n \\tparam StrideType optionally specifies strides. By default, Map assumes the memory layout\n                   of an ordinary, contiguous array. This can be overridden by specifying strides.\n                   The type passed here must be a specialization of the Stride template, see examples below.\n\n This class represents a matrix or vector expression mapping an existing array of data.\n It can be used to let Eigen interface without any overhead with non-Eigen data structures,\n such as plain C arrays or structures from other libraries. By default, it assumes that the\n data is laid out contiguously in memory. You can however override this by explicitly specifying\n inner and outer strides.\n\n Here's an example of simply mapping a contiguous array as a \\ref TopicStorageOrders \"column-major\" matrix:\n \\include Map_simple.cpp\n Output: \\verbinclude Map_simple.out\n\n If you need to map non-contiguous arrays, you can do so by specifying strides:\n\n Here's an example of mapping an array as a vector, specifying an inner stride, that is, the pointer\n increment between two consecutive coefficients. Here, we're specifying the inner stride as a compile-time\n fixed value.\n \\include Map_inner_stride.cpp\n Output: \\verbinclude Map_inner_stride.out\n\n Here's an example of mapping an array while specifying an outer stride. Here, since we're mapping\n as a column-major matrix, 'outer stride' means the pointer increment between two consecutive columns.\n Here, we're specifying the outer stride as a runtime parameter. Note that here \\c OuterStride<> is\n a short version of \\c OuterStride<Dynamic> because the default template parameter of OuterStride\n is  \\c Dynamic\n \\include Map_outer_stride.cpp\n Output: \\verbinclude Map_outer_stride.out\n\n For more details and for an example of specifying both an inner and an outer stride, see class Stride.\n\n \\b Tip: to change the array of data mapped by a Map object, you can use the C++\n placement new syntax:\n\n Example: \\include Map_placement_new.cpp\n Output: \\verbinclude Map_placement_new.out\n\n This class is the return type of PlainObjectBase::Map() but can also be used directly.\n\n \\sa PlainObjectBase::Map(), \\ref TopicStorageOrders"]
pub type Eigen_PlainObjectBase_StridedConstAlignedMapType_type = u8;
pub const Eigen_PlainObjectBase_NeedsToAlign: Eigen_PlainObjectBase__bindgen_ty_2 = 0;
pub type Eigen_PlainObjectBase__bindgen_ty_2 = i32;
pub const Eigen_PlainObjectBase_IsPlainObjectBase: Eigen_PlainObjectBase__bindgen_ty_3 = 0;
pub type Eigen_PlainObjectBase__bindgen_ty_3 = i32;
#[doc = " \\brief Base class typedef.\n \\sa PlainObjectBase"]
pub type Eigen_Matrix_Base = Eigen_PlainObjectBase;
pub const Eigen_Matrix_Options: Eigen_Matrix__bindgen_ty_1 = 0;
pub type Eigen_Matrix__bindgen_ty_1 = i32;
pub type Eigen_Matrix_Scalar = Eigen_internal_traits;
pub type Eigen_Matrix_RealScalar = Eigen_NumTraits;
pub type Eigen_Matrix_CoeffReturnType = Eigen_Matrix_Base;
pub type Eigen_Matrix_Nested = Eigen_internal_ref_selector;
pub type Eigen_Matrix_StorageKind = Eigen_internal_traits;
pub type Eigen_Matrix_StorageIndex = Eigen_internal_traits;
pub const Eigen_Matrix_CompileTimeTraits_RowsAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_ColsAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_Flags: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_SizeAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_MaxSizeAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub const Eigen_Matrix_CompileTimeTraits_IsVectorAtCompileTime: Eigen_Matrix_CompileTimeTraits = 0;
pub type Eigen_Matrix_CompileTimeTraits = i32;
pub type Eigen_Matrix_PacketScalar = Eigen_Matrix_Base;
pub type Eigen_Matrix_PlainObject = Eigen_Matrix_Base;
#[doc = " \\ingroup matrixtypedefs\n \\brief \\cpp11"]
pub type Eigen_Vector = u8;
pub type Eigen_Map_Base = u8;
pub type Eigen_Map_Scalar = Eigen_internal_traits;
pub type Eigen_Map_RealScalar = Eigen_NumTraits;
pub type Eigen_Map_CoeffReturnType = Eigen_Map_Base;
pub type Eigen_Map_Nested = Eigen_internal_ref_selector;
pub type Eigen_Map_StorageKind = Eigen_internal_traits;
pub type Eigen_Map_StorageIndex = Eigen_internal_traits;
pub const Eigen_Map_CompileTimeTraits_RowsAtCompileTime: Eigen_Map_CompileTimeTraits = 0;
pub const Eigen_Map_CompileTimeTraits_ColsAtCompileTime: Eigen_Map_CompileTimeTraits = 0;
pub const Eigen_Map_CompileTimeTraits_Flags: Eigen_Map_CompileTimeTraits = 0;
pub const Eigen_Map_CompileTimeTraits_SizeAtCompileTime: Eigen_Map_CompileTimeTraits = 0;
pub const Eigen_Map_CompileTimeTraits_MaxSizeAtCompileTime: Eigen_Map_CompileTimeTraits = 0;
pub const Eigen_Map_CompileTimeTraits_IsVectorAtCompileTime: Eigen_Map_CompileTimeTraits = 0;
pub type Eigen_Map_CompileTimeTraits = i32;
pub type Eigen_Map_PacketScalar = Eigen_Map_Base;
pub type Eigen_Map_PointerType = Eigen_Map_Base;
pub type Eigen_Map_PointerArgType = Eigen_Map_PointerType;
#[doc = " Typedefs"]
pub type NT_Bool = ::std::os::raw::c_int;
pub type NT_Handle = ::std::os::raw::c_uint;
pub type NT_ConnectionDataLogger = NT_Handle;
pub type NT_DataLogger = NT_Handle;
pub type NT_Entry = NT_Handle;
pub type NT_Inst = NT_Handle;
pub type NT_Listener = NT_Handle;
pub type NT_ListenerPoller = NT_Handle;
pub type NT_MultiSubscriber = NT_Handle;
pub type NT_Topic = NT_Handle;
pub type NT_Subscriber = NT_Handle;
pub type NT_Publisher = NT_Handle;
pub const NT_Type_NT_UNASSIGNED: NT_Type = 0;
pub const NT_Type_NT_BOOLEAN: NT_Type = 1;
pub const NT_Type_NT_DOUBLE: NT_Type = 2;
pub const NT_Type_NT_STRING: NT_Type = 4;
pub const NT_Type_NT_RAW: NT_Type = 8;
pub const NT_Type_NT_BOOLEAN_ARRAY: NT_Type = 16;
pub const NT_Type_NT_DOUBLE_ARRAY: NT_Type = 32;
pub const NT_Type_NT_STRING_ARRAY: NT_Type = 64;
pub const NT_Type_NT_RPC: NT_Type = 128;
pub const NT_Type_NT_INTEGER: NT_Type = 256;
pub const NT_Type_NT_FLOAT: NT_Type = 512;
pub const NT_Type_NT_INTEGER_ARRAY: NT_Type = 1024;
pub const NT_Type_NT_FLOAT_ARRAY: NT_Type = 2048;
#[doc = " NetworkTables data types."]
pub type NT_Type = ::std::os::raw::c_uint;
pub const NT_EntryFlags_NT_PERSISTENT: NT_EntryFlags = 1;
pub const NT_EntryFlags_NT_RETAINED: NT_EntryFlags = 2;
#[doc = " NetworkTables entry flags."]
pub type NT_EntryFlags = ::std::os::raw::c_uint;
pub const NT_LogLevel_NT_LOG_CRITICAL: NT_LogLevel = 50;
pub const NT_LogLevel_NT_LOG_ERROR: NT_LogLevel = 40;
pub const NT_LogLevel_NT_LOG_WARNING: NT_LogLevel = 30;
pub const NT_LogLevel_NT_LOG_INFO: NT_LogLevel = 20;
pub const NT_LogLevel_NT_LOG_DEBUG: NT_LogLevel = 10;
pub const NT_LogLevel_NT_LOG_DEBUG1: NT_LogLevel = 9;
pub const NT_LogLevel_NT_LOG_DEBUG2: NT_LogLevel = 8;
pub const NT_LogLevel_NT_LOG_DEBUG3: NT_LogLevel = 7;
pub const NT_LogLevel_NT_LOG_DEBUG4: NT_LogLevel = 6;
#[doc = " NetworkTables logging levels."]
pub type NT_LogLevel = ::std::os::raw::c_uint;
pub const NT_NetworkMode_NT_NET_MODE_NONE: NT_NetworkMode = 0;
pub const NT_NetworkMode_NT_NET_MODE_SERVER: NT_NetworkMode = 1;
pub const NT_NetworkMode_NT_NET_MODE_CLIENT3: NT_NetworkMode = 2;
pub const NT_NetworkMode_NT_NET_MODE_CLIENT4: NT_NetworkMode = 4;
pub const NT_NetworkMode_NT_NET_MODE_STARTING: NT_NetworkMode = 8;
pub const NT_NetworkMode_NT_NET_MODE_LOCAL: NT_NetworkMode = 16;
#[doc = " Client/server modes"]
pub type NT_NetworkMode = ::std::os::raw::c_uint;
pub const NT_EventFlags_NT_EVENT_NONE: NT_EventFlags = 0;
#[doc = " Initial listener addition."]
pub const NT_EventFlags_NT_EVENT_IMMEDIATE: NT_EventFlags = 1;
#[doc = " Client connected (on server, any client connected)."]
pub const NT_EventFlags_NT_EVENT_CONNECTED: NT_EventFlags = 2;
#[doc = " Client disconnected (on server, any client disconnected)."]
pub const NT_EventFlags_NT_EVENT_DISCONNECTED: NT_EventFlags = 4;
#[doc = " Any connection event (connect or disconnect)."]
pub const NT_EventFlags_NT_EVENT_CONNECTION: NT_EventFlags = 6;
#[doc = " New topic published."]
pub const NT_EventFlags_NT_EVENT_PUBLISH: NT_EventFlags = 8;
#[doc = " Topic unpublished."]
pub const NT_EventFlags_NT_EVENT_UNPUBLISH: NT_EventFlags = 16;
#[doc = " Topic properties changed."]
pub const NT_EventFlags_NT_EVENT_PROPERTIES: NT_EventFlags = 32;
#[doc = " Any topic event (publish, unpublish, or properties changed)."]
pub const NT_EventFlags_NT_EVENT_TOPIC: NT_EventFlags = 56;
#[doc = " Topic value updated (via network)."]
pub const NT_EventFlags_NT_EVENT_VALUE_REMOTE: NT_EventFlags = 64;
#[doc = " Topic value updated (local)."]
pub const NT_EventFlags_NT_EVENT_VALUE_LOCAL: NT_EventFlags = 128;
#[doc = " Topic value updated (network or local)."]
pub const NT_EventFlags_NT_EVENT_VALUE_ALL: NT_EventFlags = 192;
#[doc = " Log message."]
pub const NT_EventFlags_NT_EVENT_LOGMESSAGE: NT_EventFlags = 256;
#[doc = " Time synchronized with server."]
pub const NT_EventFlags_NT_EVENT_TIMESYNC: NT_EventFlags = 512;
#[doc = " Event notification flags."]
pub type NT_EventFlags = ::std::os::raw::c_uint;
#[doc = " A NetworkTables string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_String {
    #[doc = " String contents (UTF-8).\n The string is NOT required to be zero-terminated.\n When returned by the library, this is zero-terminated and allocated with\n std::malloc()."]
    pub str_: *mut ::std::os::raw::c_char,
    #[doc = " Length of the string in bytes.  If the string happens to be zero\n terminated, this does not include the zero-termination."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_String() {
    const UNINIT: ::std::mem::MaybeUninit<NT_String> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_String>(),
        8usize,
        concat!("Size of: ", stringify!(NT_String))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_String>(),
        4usize,
        concat!("Alignment of ", stringify!(NT_String))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_String),
            "::",
            stringify!(str_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_String),
            "::",
            stringify!(len)
        )
    );
}
#[doc = " NetworkTables Entry Value.  Note this is a typed union."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NT_Value {
    pub type_: NT_Type,
    pub last_change: i64,
    pub server_time: i64,
    pub data: NT_Value__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NT_Value__bindgen_ty_1 {
    pub v_boolean: NT_Bool,
    pub v_int: i64,
    pub v_float: f32,
    pub v_double: f64,
    pub v_string: NT_String,
    pub v_raw: NT_Value__bindgen_ty_1__bindgen_ty_1,
    pub arr_boolean: NT_Value__bindgen_ty_1__bindgen_ty_2,
    pub arr_double: NT_Value__bindgen_ty_1__bindgen_ty_3,
    pub arr_float: NT_Value__bindgen_ty_1__bindgen_ty_4,
    pub arr_int: NT_Value__bindgen_ty_1__bindgen_ty_5,
    pub arr_string: NT_Value__bindgen_ty_1__bindgen_ty_6,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_1 {
    pub data: *mut u8,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_2 {
    pub arr: *mut NT_Bool,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_3 {
    pub arr: *mut f64,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_4 {
    pub arr: *mut f32,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_5 {
    pub arr: *mut i64,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_5>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Value__bindgen_ty_1__bindgen_ty_6 {
    pub arr: *mut NT_String,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1__bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1__bindgen_ty_6>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(arr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_NT_Value__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(NT_Value__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Value__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_string)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v_raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(v_raw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_boolean) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_boolean)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_double) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_double)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_float) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_float)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arr_string) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value__bindgen_ty_1),
            "::",
            stringify!(arr_string)
        )
    );
}
#[test]
fn bindgen_test_layout_NT_Value() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Value> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Value>(),
        32usize,
        concat!("Size of: ", stringify!(NT_Value))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Value>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Value))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_change) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value),
            "::",
            stringify!(last_change)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).server_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value),
            "::",
            stringify!(server_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Value),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " NetworkTables Topic Information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TopicInfo {
    #[doc = " Topic handle"]
    pub topic: NT_Topic,
    #[doc = " Topic name"]
    pub name: NT_String,
    #[doc = " Topic type"]
    pub type_: NT_Type,
    #[doc = " Topic type string"]
    pub type_str: NT_String,
    #[doc = " Topic properties JSON string"]
    pub properties: NT_String,
}
#[test]
fn bindgen_test_layout_NT_TopicInfo() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TopicInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TopicInfo>(),
        32usize,
        concat!("Size of: ", stringify!(NT_TopicInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TopicInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(NT_TopicInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(topic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_str) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(type_str)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).properties) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TopicInfo),
            "::",
            stringify!(properties)
        )
    );
}
#[doc = " NetworkTables Connection Information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_ConnectionInfo {
    #[doc = " The remote identifier (as set on the remote node by NT_StartClient4()."]
    pub remote_id: NT_String,
    #[doc = " The IP address of the remote node."]
    pub remote_ip: NT_String,
    #[doc = " The port number of the remote node."]
    pub remote_port: ::std::os::raw::c_uint,
    #[doc = " The last time any update was received from the remote node (same scale as\n returned by nt::Now())."]
    pub last_update: u64,
    #[doc = " The protocol version being used for this connection.  This in protocol\n layer format, so 0x0200 = 2.0, 0x0300 = 3.0)."]
    pub protocol_version: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_NT_ConnectionInfo() {
    const UNINIT: ::std::mem::MaybeUninit<NT_ConnectionInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_ConnectionInfo>(),
        40usize,
        concat!("Size of: ", stringify!(NT_ConnectionInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_ConnectionInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_ConnectionInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(remote_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_ip) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(remote_ip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remote_port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(remote_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_update) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(last_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).protocol_version) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ConnectionInfo),
            "::",
            stringify!(protocol_version)
        )
    );
}
#[doc = " NetworkTables value event data."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NT_ValueEventData {
    #[doc = " Topic handle."]
    pub topic: NT_Topic,
    #[doc = " Subscriber/entry handle."]
    pub subentry: NT_Handle,
    #[doc = " The new value."]
    pub value: NT_Value,
}
#[test]
fn bindgen_test_layout_NT_ValueEventData() {
    const UNINIT: ::std::mem::MaybeUninit<NT_ValueEventData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_ValueEventData>(),
        40usize,
        concat!("Size of: ", stringify!(NT_ValueEventData))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_ValueEventData>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_ValueEventData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ValueEventData),
            "::",
            stringify!(topic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subentry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ValueEventData),
            "::",
            stringify!(subentry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_ValueEventData),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " NetworkTables log message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_LogMessage {
    #[doc = " Log level of the message.  See NT_LogLevel."]
    pub level: ::std::os::raw::c_uint,
    #[doc = " The filename of the source file that generated the message."]
    pub filename: *mut ::std::os::raw::c_char,
    #[doc = " The line number in the source file that generated the message."]
    pub line: ::std::os::raw::c_uint,
    #[doc = " The message."]
    pub message: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_NT_LogMessage() {
    const UNINIT: ::std::mem::MaybeUninit<NT_LogMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_LogMessage>(),
        16usize,
        concat!("Size of: ", stringify!(NT_LogMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_LogMessage>(),
        4usize,
        concat!("Alignment of ", stringify!(NT_LogMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_LogMessage),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_LogMessage),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_LogMessage),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_LogMessage),
            "::",
            stringify!(message)
        )
    );
}
#[doc = " NetworkTables time sync event data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimeSyncEventData {
    #[doc = " Offset between local time and server time, in microseconds. Add this value\n to local time to get the estimated equivalent server time."]
    pub serverTimeOffset: i64,
    #[doc = " Measured round trip time divided by 2, in microseconds."]
    pub rtt2: i64,
    #[doc = " If serverTimeOffset and RTT are valid. An event with this set to false is\n sent when the client disconnects."]
    pub valid: NT_Bool,
}
#[test]
fn bindgen_test_layout_NT_TimeSyncEventData() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimeSyncEventData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimeSyncEventData>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimeSyncEventData))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimeSyncEventData>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimeSyncEventData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTimeOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimeSyncEventData),
            "::",
            stringify!(serverTimeOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rtt2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimeSyncEventData),
            "::",
            stringify!(rtt2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimeSyncEventData),
            "::",
            stringify!(valid)
        )
    );
}
#[doc = " NetworkTables event"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NT_Event {
    #[doc = " Listener that triggered this event."]
    pub listener: NT_Handle,
    #[doc = " Event flags (NT_EventFlags). Also indicates the data included with the\n event:\n - NT_EVENT_CONNECTED or NT_EVENT_DISCONNECTED: connInfo\n - NT_EVENT_PUBLISH, NT_EVENT_UNPUBLISH, or NT_EVENT_PROPERTIES: topicInfo\n - NT_EVENT_VALUE_REMOTE, NT_NOTIFY_VALUE_LOCAL: valueData\n - NT_EVENT_LOGMESSAGE: logMessage\n - NT_EVENT_TIMESYNC: timeSyncData"]
    pub flags: ::std::os::raw::c_uint,
    pub data: NT_Event__bindgen_ty_1,
}
#[doc = " Event data; content depends on flags."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union NT_Event__bindgen_ty_1 {
    pub connInfo: NT_ConnectionInfo,
    pub topicInfo: NT_TopicInfo,
    pub valueData: NT_ValueEventData,
    pub logMessage: NT_LogMessage,
    pub timeSyncData: NT_TimeSyncEventData,
}
#[test]
fn bindgen_test_layout_NT_Event__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Event__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Event__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(NT_Event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).connInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(connInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(topicInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).valueData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(valueData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logMessage) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(logMessage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timeSyncData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event__bindgen_ty_1),
            "::",
            stringify!(timeSyncData)
        )
    );
}
#[test]
fn bindgen_test_layout_NT_Event() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Event> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Event>(),
        48usize,
        concat!("Size of: ", stringify!(NT_Event))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Event>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Event))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).listener) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event),
            "::",
            stringify!(listener)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Event),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " NetworkTables publish/subscribe options."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_PubSubOptions {
    #[doc = " Structure size. Must be set to sizeof(NT_PubSubOptions)."]
    pub structSize: ::std::os::raw::c_uint,
    #[doc = " Polling storage size for a subscription. Specifies the maximum number of\n updates NetworkTables should store between calls to the subscriber's\n ReadQueue() function. If zero, defaults to 1 if sendAll is false, 20 if\n sendAll is true."]
    pub pollStorage: ::std::os::raw::c_uint,
    #[doc = " How frequently changes will be sent over the network, in seconds.\n NetworkTables may send more frequently than this (e.g. use a combined\n minimum period for all values) or apply a restricted range to this value.\n The default is 100 ms."]
    pub periodic: f64,
    #[doc = " For subscriptions, if non-zero, value updates for ReadQueue() are not\n queued for this publisher."]
    pub excludePublisher: NT_Publisher,
    #[doc = " Send all value changes over the network."]
    pub sendAll: NT_Bool,
    #[doc = " For subscriptions, don't ask for value changes (only topic announcements)."]
    pub topicsOnly: NT_Bool,
    #[doc = " Perform prefix match on subscriber topic names. Is ignored/overridden by\n Subscribe() functions; only present in struct for the purposes of getting\n information about subscriptions."]
    pub prefixMatch: NT_Bool,
    #[doc = " Preserve duplicate value changes (rather than ignoring them)."]
    pub keepDuplicates: NT_Bool,
    #[doc = " For subscriptions, if remote value updates should not be queued for\n ReadQueue(). See also disableLocal."]
    pub disableRemote: NT_Bool,
    #[doc = " For subscriptions, if local value updates should not be queued for\n ReadQueue(). See also disableRemote."]
    pub disableLocal: NT_Bool,
    #[doc = " For entries, don't queue (for ReadQueue) value updates for the entry's\n internal publisher."]
    pub excludeSelf: NT_Bool,
}
#[test]
fn bindgen_test_layout_NT_PubSubOptions() {
    const UNINIT: ::std::mem::MaybeUninit<NT_PubSubOptions> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_PubSubOptions>(),
        48usize,
        concat!("Size of: ", stringify!(NT_PubSubOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_PubSubOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_PubSubOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(structSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pollStorage) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(pollStorage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).periodic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(periodic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).excludePublisher) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(excludePublisher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sendAll) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(sendAll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicsOnly) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(topicsOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixMatch) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(prefixMatch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepDuplicates) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(keepDuplicates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disableRemote) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(disableRemote)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disableLocal) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(disableLocal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).excludeSelf) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_PubSubOptions),
            "::",
            stringify!(excludeSelf)
        )
    );
}
extern "C" {
    #[doc = " Get default instance.\n This is the instance used by non-handle-taking functions.\n\n @return Instance handle"]
    pub fn NT_GetDefaultInstance() -> NT_Inst;
}
extern "C" {
    #[doc = " Create an instance.\n\n @return Instance handle"]
    pub fn NT_CreateInstance() -> NT_Inst;
}
extern "C" {
    #[doc = " Destroy an instance.\n The default instance cannot be destroyed.\n\n @param inst Instance handle"]
    pub fn NT_DestroyInstance(inst: NT_Inst);
}
extern "C" {
    #[doc = " Get instance handle from another handle.\n\n @param handle    handle\n @return Instance handle"]
    pub fn NT_GetInstanceFromHandle(handle: NT_Handle) -> NT_Inst;
}
extern "C" {
    #[doc = " Get Entry Handle.\n\n @param inst      instance handle\n @param name      entry name (UTF-8 string)\n @param name_len  length of name in bytes\n @return entry handle"]
    pub fn NT_GetEntry(
        inst: NT_Inst,
        name: *const ::std::os::raw::c_char,
        name_len: usize,
    ) -> NT_Entry;
}
extern "C" {
    #[doc = " Gets the name of the specified entry.\n Returns an empty string if the handle is invalid.\n\n @param entry     entry handle\n @param name_len  length of the returned string (output parameter)\n @return Entry name"]
    pub fn NT_GetEntryName(entry: NT_Entry, name_len: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the type for the specified key, or unassigned if non existent.\n\n @param entry   entry handle\n @return Entry type"]
    pub fn NT_GetEntryType(entry: NT_Entry) -> NT_Type;
}
extern "C" {
    #[doc = " Gets the last time the entry was changed.\n Returns 0 if the handle is invalid.\n\n @param entry   entry handle\n @return Entry last change time"]
    pub fn NT_GetEntryLastChange(entry: NT_Entry) -> u64;
}
extern "C" {
    #[doc = " Get Entry Value.\n\n Returns copy of current entry value.\n Note that one of the type options is \"unassigned\".\n\n @param entry     entry handle\n @param value     storage for returned entry value\n\n It is the caller's responsibility to free value once it's no longer\n needed (the utility function NT_DisposeValue() is useful for this\n purpose)."]
    pub fn NT_GetEntryValue(entry: NT_Entry, value: *mut NT_Value);
}
extern "C" {
    #[doc = " Set Default Entry Value.\n\n Returns copy of current entry value if it exists.\n Otherwise, sets passed in value, and returns set value.\n Note that one of the type options is \"unassigned\".\n\n @param entry     entry handle\n @param default_value     value to be set if name does not exist\n @return 0 on error (value not set), 1 on success"]
    pub fn NT_SetDefaultEntryValue(entry: NT_Entry, default_value: *const NT_Value) -> NT_Bool;
}
extern "C" {
    #[doc = " Set Entry Value.\n\n Sets new entry value.  If type of new value differs from the type of the\n currently stored entry, returns error and does not update value.\n\n @param entry     entry handle\n @param value     new entry value\n @return 0 on error (type mismatch), 1 on success"]
    pub fn NT_SetEntryValue(entry: NT_Entry, value: *const NT_Value) -> NT_Bool;
}
extern "C" {
    #[doc = " Set Entry Flags.\n\n @param entry     entry handle\n @param flags     flags value (bitmask of NT_EntryFlags)"]
    pub fn NT_SetEntryFlags(entry: NT_Entry, flags: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Get Entry Flags.\n\n @param entry     entry handle\n @return Flags value (bitmask of NT_EntryFlags)"]
    pub fn NT_GetEntryFlags(entry: NT_Entry) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Read Entry Queue.\n\n Returns new entry values since last call. The returned array must be freed\n using NT_DisposeValueArray().\n\n @param subentry     subscriber or entry handle\n @param count        count of items in returned array (output)\n @return entry value array; returns NULL and count=0 if no new values"]
    pub fn NT_ReadQueueValue(subentry: NT_Handle, count: *mut usize) -> *mut NT_Value;
}
extern "C" {
    #[doc = " Get Published Topic Handles.\n\n Returns an array of topic handles.  The results are optionally\n filtered by string prefix and type to only return a subset of all\n topics.\n\n @param inst          instance handle\n @param prefix        name required prefix; only topics whose name\n                      starts with this string are returned\n @param prefix_len    length of prefix in bytes\n @param types         bitmask of NT_Type values; 0 is treated specially\n                      as a \"don't care\"\n @param count         output parameter; set to length of returned array\n @return Array of topic handles."]
    pub fn NT_GetTopics(
        inst: NT_Inst,
        prefix: *const ::std::os::raw::c_char,
        prefix_len: usize,
        types: ::std::os::raw::c_uint,
        count: *mut usize,
    ) -> *mut NT_Topic;
}
extern "C" {
    #[doc = " Get Published Topic Handles.\n\n Returns an array of topic handles.  The results are optionally\n filtered by string prefix and type to only return a subset of all\n topics.\n\n @param inst          instance handle\n @param prefix        name required prefix; only topics whose name\n                      starts with this string are returned\n @param prefix_len    length of prefix in bytes\n @param types         array of type strings\n @param types_len     number of elements in types array\n @param count         output parameter; set to length of returned array\n @return Array of topic handles."]
    pub fn NT_GetTopicsStr(
        inst: NT_Inst,
        prefix: *const ::std::os::raw::c_char,
        prefix_len: usize,
        types: *const *const ::std::os::raw::c_char,
        types_len: usize,
        count: *mut usize,
    ) -> *mut NT_Topic;
}
extern "C" {
    #[doc = " Get Topics.\n\n Returns an array of topic information (handle, name, type).  The results are\n optionally filtered by string prefix and type to only return a subset\n of all topics.\n\n @param inst          instance handle\n @param prefix        name required prefix; only topics whose name\n                      starts with this string are returned\n @param prefix_len    length of prefix in bytes\n @param types         bitmask of NT_Type values; 0 is treated specially\n                      as a \"don't care\"\n @param count         output parameter; set to length of returned array\n @return Array of topic information."]
    pub fn NT_GetTopicInfos(
        inst: NT_Inst,
        prefix: *const ::std::os::raw::c_char,
        prefix_len: usize,
        types: ::std::os::raw::c_uint,
        count: *mut usize,
    ) -> *mut NT_TopicInfo;
}
extern "C" {
    #[doc = " Get Topics.\n\n Returns an array of topic information (handle, name, type).  The results are\n optionally filtered by string prefix and type to only return a subset\n of all topics.\n\n @param inst          instance handle\n @param prefix        name required prefix; only topics whose name\n                      starts with this string are returned\n @param prefix_len    length of prefix in bytes\n @param types         array of type strings\n @param types_len     number of elements in types array\n @param count         output parameter; set to length of returned array\n @return Array of topic information."]
    pub fn NT_GetTopicInfosStr(
        inst: NT_Inst,
        prefix: *const ::std::os::raw::c_char,
        prefix_len: usize,
        types: *const *const ::std::os::raw::c_char,
        types_len: usize,
        count: *mut usize,
    ) -> *mut NT_TopicInfo;
}
extern "C" {
    #[doc = " Gets Topic Information.\n\n Returns information about a topic (name and type).\n\n @param topic         handle\n @param info          information (output)\n @return True if successful, false on error."]
    pub fn NT_GetTopicInfo(topic: NT_Topic, info: *mut NT_TopicInfo) -> NT_Bool;
}
extern "C" {
    #[doc = " Gets Topic Handle.\n\n Returns topic handle.\n\n @param inst      instance handle\n @param name      topic name\n @param name_len  length of topic name in bytes\n @return Topic handle."]
    pub fn NT_GetTopic(
        inst: NT_Inst,
        name: *const ::std::os::raw::c_char,
        name_len: usize,
    ) -> NT_Topic;
}
extern "C" {
    #[doc = " Gets the name of the specified topic.\n\n @param topic     topic handle\n @param name_len  length of topic name (output)\n @return Topic name; returns NULL and name_len=0 if the handle is invalid."]
    pub fn NT_GetTopicName(topic: NT_Topic, name_len: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Gets the type for the specified topic, or unassigned if non existent.\n\n @param topic   topic handle\n @return Topic type"]
    pub fn NT_GetTopicType(topic: NT_Topic) -> NT_Type;
}
extern "C" {
    #[doc = " Gets the type string for the specified topic.  This may have more information\n than the numeric type (especially for raw values).\n\n @param topic     topic handle\n @param type_len  length of type string (output)\n @return Topic type string; returns NULL if non-existent"]
    pub fn NT_GetTopicTypeString(
        topic: NT_Topic,
        type_len: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets the persistent property of a topic.  If true, the stored value is\n persistent through server restarts.\n\n @param topic topic handle\n @param value True for persistent, false for not persistent."]
    pub fn NT_SetTopicPersistent(topic: NT_Topic, value: NT_Bool);
}
extern "C" {
    #[doc = " Gets the persistent property of a topic.\n\n @param topic topic handle\n @return persistent property value"]
    pub fn NT_GetTopicPersistent(topic: NT_Topic) -> NT_Bool;
}
extern "C" {
    #[doc = " Sets the retained property of a topic.  If true, the server retains the\n topic even when there are no publishers.\n\n @param topic topic handle\n @param value new retained property value"]
    pub fn NT_SetTopicRetained(topic: NT_Topic, value: NT_Bool);
}
extern "C" {
    #[doc = " Gets the retained property of a topic.\n\n @param topic topic handle\n @return retained property value"]
    pub fn NT_GetTopicRetained(topic: NT_Topic) -> NT_Bool;
}
extern "C" {
    #[doc = " Determine if topic exists (e.g. has at least one publisher).\n\n @param handle Topic, entry, or subscriber handle.\n @return True if topic exists."]
    pub fn NT_GetTopicExists(handle: NT_Handle) -> NT_Bool;
}
extern "C" {
    #[doc = " Gets the current value of a property (as a JSON string).\n\n @param topic topic handle\n @param name property name\n @param len length of returned string (output)\n @return JSON string; empty string if the property does not exist."]
    pub fn NT_GetTopicProperty(
        topic: NT_Topic,
        name: *const ::std::os::raw::c_char,
        len: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Sets a property value.\n\n @param topic topic handle\n @param name property name\n @param value property value (JSON string)"]
    pub fn NT_SetTopicProperty(
        topic: NT_Topic,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Deletes a property.  Has no effect if the property does not exist.\n\n @param topic topic handle\n @param name property name"]
    pub fn NT_DeleteTopicProperty(topic: NT_Topic, name: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Gets all topic properties as a JSON string.  Each key in the object\n is the property name, and the corresponding value is the property value.\n\n @param topic topic handle\n @param len length of returned string (output)\n @return JSON string"]
    pub fn NT_GetTopicProperties(topic: NT_Topic, len: *mut usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Updates multiple topic properties.  Each key in the passed-in JSON object is\n the name of the property to add/update, and the corresponding value is the\n property value to set for that property.  Null values result in deletion\n of the corresponding property.\n\n @param topic topic handle\n @param properties JSON object string with keys to add/update/delete\n @return False if properties are not a valid JSON object"]
    pub fn NT_SetTopicProperties(
        topic: NT_Topic,
        properties: *const ::std::os::raw::c_char,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Creates a new subscriber to value changes on a topic.\n\n @param topic topic handle\n @param type expected type\n @param typeStr expected type string\n @param options subscription options\n @return Subscriber handle"]
    pub fn NT_Subscribe(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: *const ::std::os::raw::c_char,
        options: *const NT_PubSubOptions,
    ) -> NT_Subscriber;
}
extern "C" {
    #[doc = " Stops subscriber.\n\n @param sub subscriber handle"]
    pub fn NT_Unsubscribe(sub: NT_Subscriber);
}
extern "C" {
    #[doc = " Creates a new publisher to a topic.\n\n @param topic topic handle\n @param type type\n @param typeStr type string\n @param options publish options\n @return Publisher handle"]
    pub fn NT_Publish(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: *const ::std::os::raw::c_char,
        options: *const NT_PubSubOptions,
    ) -> NT_Publisher;
}
extern "C" {
    #[doc = " Creates a new publisher to a topic.\n\n @param topic topic handle\n @param type type\n @param typeStr type string\n @param properties initial properties (JSON object)\n @param options publish options\n @return Publisher handle"]
    pub fn NT_PublishEx(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: *const ::std::os::raw::c_char,
        properties: *const ::std::os::raw::c_char,
        options: *const NT_PubSubOptions,
    ) -> NT_Publisher;
}
extern "C" {
    #[doc = " Stops publisher.\n\n @param pubentry publisher/entry handle"]
    pub fn NT_Unpublish(pubentry: NT_Handle);
}
extern "C" {
    #[doc = " @brief Creates a new entry (subscriber and weak publisher) to a topic.\n\n @param topic topic handle\n @param type type\n @param typeStr type string\n @param options publish options\n @return Entry handle"]
    pub fn NT_GetEntryEx(
        topic: NT_Topic,
        type_: NT_Type,
        typeStr: *const ::std::os::raw::c_char,
        options: *const NT_PubSubOptions,
    ) -> NT_Entry;
}
extern "C" {
    #[doc = " Stops entry subscriber/publisher.\n\n @param entry entry handle"]
    pub fn NT_ReleaseEntry(entry: NT_Entry);
}
extern "C" {
    #[doc = " Stops entry/subscriber/publisher.\n\n @param pubsubentry entry/subscriber/publisher handle"]
    pub fn NT_Release(pubsubentry: NT_Handle);
}
extern "C" {
    #[doc = " Gets the topic handle from an entry/subscriber/publisher handle.\n\n @param pubsubentry entry/subscriber/publisher handle\n @return Topic handle"]
    pub fn NT_GetTopicFromHandle(pubsubentry: NT_Handle) -> NT_Topic;
}
extern "C" {
    #[doc = " Subscribes to multiple topics based on one or more topic name prefixes. Can\n be used in combination with a Value Listener or ReadQueueValue() to get value\n changes across all matching topics.\n\n @param inst instance handle\n @param prefixes topic name prefixes\n @param prefixes_len number of elements in prefixes array\n @param options subscriber options\n @return subscriber handle"]
    pub fn NT_SubscribeMultiple(
        inst: NT_Inst,
        prefixes: *const NT_String,
        prefixes_len: usize,
        options: *const NT_PubSubOptions,
    ) -> NT_MultiSubscriber;
}
extern "C" {
    #[doc = " Unsubscribes a multi-subscriber.\n\n @param sub multi-subscriber handle"]
    pub fn NT_UnsubscribeMultiple(sub: NT_MultiSubscriber);
}
#[doc = " Event listener callback function.\n\n @param data            data pointer provided to callback creation function\n @param event           event info"]
pub type NT_ListenerCallback = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const NT_Event),
>;
extern "C" {
    #[doc = " Creates a listener poller.\n\n A poller provides a single queue of poll events.  Events linked to this\n poller (using NT_AddPolledXListener()) will be stored in the queue and\n must be collected by calling NT_ReadListenerQueue().\n The returned handle must be destroyed with NT_DestroyListenerPoller().\n\n @param inst      instance handle\n @return poller handle"]
    pub fn NT_CreateListenerPoller(inst: NT_Inst) -> NT_ListenerPoller;
}
extern "C" {
    #[doc = " Destroys a listener poller.  This will abort any blocked polling\n call and prevent additional events from being generated for this poller.\n\n @param poller    poller handle"]
    pub fn NT_DestroyListenerPoller(poller: NT_ListenerPoller);
}
extern "C" {
    #[doc = " Read notifications.\n\n @param poller    poller handle\n @param len       length of returned array (output)\n @return Array of events.  Returns NULL and len=0 if no events since last\n         call."]
    pub fn NT_ReadListenerQueue(poller: NT_ListenerPoller, len: *mut usize) -> *mut NT_Event;
}
extern "C" {
    #[doc = " Removes a listener.\n\n @param listener Listener handle to remove"]
    pub fn NT_RemoveListener(listener: NT_Listener);
}
extern "C" {
    #[doc = " Wait for the listener queue to be empty. This is primarily useful\n for deterministic testing. This blocks until either the listener\n queue is empty (e.g. there are no more events that need to be passed along to\n callbacks or poll queues) or the timeout expires.\n\n @param handle  handle\n @param timeout timeout, in seconds. Set to 0 for non-blocking behavior, or a\n                negative value to block indefinitely\n @return False if timed out, otherwise true."]
    pub fn NT_WaitForListenerQueue(handle: NT_Handle, timeout: f64) -> NT_Bool;
}
extern "C" {
    #[doc = " Create a listener for changes to topics with names that start with\n the given prefix. This creates a corresponding internal subscriber with the\n lifetime of the listener.\n\n @param inst Instance handle\n @param prefix Topic name string prefix\n @param prefix_len Length of topic name string prefix\n @param mask Bitmask of NT_EventFlags values (only topic and value events will\n             be generated)\n @param data Data passed to callback function\n @param callback Listener function\n @return Listener handle"]
    pub fn NT_AddListenerSingle(
        inst: NT_Inst,
        prefix: *const ::std::os::raw::c_char,
        prefix_len: usize,
        mask: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        callback: NT_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Create a listener for changes to topics with names that start with any of\n the given prefixes. This creates a corresponding internal subscriber with the\n lifetime of the listener.\n\n @param inst Instance handle\n @param prefixes Topic name string prefixes\n @param prefixes_len Number of elements in prefixes array\n @param mask Bitmask of NT_EventFlags values (only topic and value events will\n             be generated)\n @param data Data passed to callback function\n @param callback Listener function\n @return Listener handle"]
    pub fn NT_AddListenerMultiple(
        inst: NT_Inst,
        prefixes: *const NT_String,
        prefixes_len: usize,
        mask: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        callback: NT_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Create a listener.\n\n Some combinations of handle and mask have no effect:\n - connection and log message events are only generated on instances\n - topic and value events are only generated on non-instances\n\n Adding value and topic events on a topic will create a corresponding internal\n subscriber with the lifetime of the listener.\n\n Adding a log message listener through this function will only result in\n events at NT_LOG_INFO or higher; for more customized settings, use\n NT_AddLogger().\n\n @param handle Handle\n @param mask Bitmask of NT_EventFlags values\n @param data Data passed to callback function\n @param callback Listener function\n @return Listener handle"]
    pub fn NT_AddListener(
        handle: NT_Handle,
        mask: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        callback: NT_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Creates a polled topic listener. This creates a corresponding internal\n subscriber with the lifetime of the listener.\n The caller is responsible for calling NT_ReadListenerQueue() to poll.\n\n @param poller            poller handle\n @param prefix            UTF-8 string prefix\n @param prefix_len        Length of UTF-8 string prefix\n @param mask              NT_EventFlags bitmask (only topic and value events\n will be generated)\n @return Listener handle"]
    pub fn NT_AddPolledListenerSingle(
        poller: NT_ListenerPoller,
        prefix: *const ::std::os::raw::c_char,
        prefix_len: usize,
        mask: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Creates a polled topic listener. This creates a corresponding internal\n subscriber with the lifetime of the listener.\n The caller is responsible for calling NT_ReadListenerQueue() to poll.\n\n @param poller            poller handle\n @param prefixes          array of UTF-8 string prefixes\n @param prefixes_len      Length of prefixes array\n @param mask              NT_EventFlags bitmask (only topic and value events\n will be generated)\n @return Listener handle"]
    pub fn NT_AddPolledListenerMultiple(
        poller: NT_ListenerPoller,
        prefixes: *const NT_String,
        prefixes_len: usize,
        mask: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Creates a polled listener.\n The caller is responsible for calling NT_ReadListenerQueue() to poll.\n\n Some combinations of handle and mask have no effect:\n - connection and log message events are only generated on instances\n - topic and value events are only generated on non-instances\n\n Adding value and topic events on a topic will create a corresponding internal\n subscriber with the lifetime of the listener.\n\n Adding a log message listener through this function will only result in\n events at NT_LOG_INFO or higher; for more customized settings, use\n NT_AddPolledLogger().\n\n @param poller            poller handle\n @param handle            handle\n @param mask              NT_NotifyKind bitmask\n @return Listener handle"]
    pub fn NT_AddPolledListener(
        poller: NT_ListenerPoller,
        handle: NT_Handle,
        mask: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Get the current network mode.\n\n @param inst  instance handle\n @return Bitmask of NT_NetworkMode."]
    pub fn NT_GetNetworkMode(inst: NT_Inst) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Starts local-only operation.  Prevents calls to NT_StartServer or\n NT_StartClient from taking effect.  Has no effect if NT_StartServer or\n NT_StartClient has already been called."]
    pub fn NT_StartLocal(inst: NT_Inst);
}
extern "C" {
    #[doc = " Stops local-only operation.  NT_StartServer or NT_StartClient can be called\n after this call to start a server or client."]
    pub fn NT_StopLocal(inst: NT_Inst);
}
extern "C" {
    #[doc = " Starts a server using the specified filename, listening address, and port.\n\n @param inst              instance handle\n @param persist_filename  the name of the persist file to use (UTF-8 string,\n                          null terminated)\n @param listen_address    the address to listen on, or null to listen on any\n                          address. (UTF-8 string, null terminated)\n @param port3             port to communicate over (NT3)\n @param port4             port to communicate over (NT4)"]
    pub fn NT_StartServer(
        inst: NT_Inst,
        persist_filename: *const ::std::os::raw::c_char,
        listen_address: *const ::std::os::raw::c_char,
        port3: ::std::os::raw::c_uint,
        port4: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Stops the server if it is running.\n\n @param inst  instance handle"]
    pub fn NT_StopServer(inst: NT_Inst);
}
extern "C" {
    #[doc = " Starts a NT3 client.  Use NT_SetServer or NT_SetServerTeam to set the server\n name and port.\n\n @param inst      instance handle\n @param identity  network identity to advertise (cannot be empty string)"]
    pub fn NT_StartClient3(inst: NT_Inst, identity: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Starts a NT4 client.  Use NT_SetServer or NT_SetServerTeam to set the server\n name and port.\n\n @param inst      instance handle\n @param identity  network identity to advertise (cannot be empty string)"]
    pub fn NT_StartClient4(inst: NT_Inst, identity: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Stops the client if it is running.\n\n @param inst  instance handle"]
    pub fn NT_StopClient(inst: NT_Inst);
}
extern "C" {
    #[doc = " Sets server address and port for client (without restarting client).\n\n @param inst        instance handle\n @param server_name server name (UTF-8 string, null terminated)\n @param port        port to communicate over"]
    pub fn NT_SetServer(
        inst: NT_Inst,
        server_name: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Sets server addresses for client (without restarting client).\n The client will attempt to connect to each server in round robin fashion.\n\n @param inst         instance handle\n @param count        length of the server_names and ports arrays\n @param server_names array of server names (each a UTF-8 string, null\n                     terminated)\n @param ports        array of ports to communicate over (one for each server)"]
    pub fn NT_SetServerMulti(
        inst: NT_Inst,
        count: usize,
        server_names: *mut *const ::std::os::raw::c_char,
        ports: *const ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Sets server addresses and port for client (without restarting client).\n Connects using commonly known robot addresses for the specified team.\n\n @param inst        instance handle\n @param team        team number\n @param port        port to communicate over"]
    pub fn NT_SetServerTeam(
        inst: NT_Inst,
        team: ::std::os::raw::c_uint,
        port: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " Starts requesting server address from Driver Station.\n This connects to the Driver Station running on localhost to obtain the\n server IP address.\n\n @param inst  instance handle\n @param port  server port to use in combination with IP from DS"]
    pub fn NT_StartDSClient(inst: NT_Inst, port: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Stops requesting server address from Driver Station.\n\n @param inst  instance handle"]
    pub fn NT_StopDSClient(inst: NT_Inst);
}
extern "C" {
    #[doc = " Flush local updates.\n\n Forces an immediate flush of all local changes to the client/server.\n This does not flush to the network.\n\n Normally this is done on a regularly scheduled interval.\n\n @param inst      instance handle"]
    pub fn NT_FlushLocal(inst: NT_Inst);
}
extern "C" {
    #[doc = " Flush to network.\n\n Forces an immediate flush of all local entry changes to network.\n Normally this is done on a regularly scheduled interval (set\n by update rates on individual publishers).\n\n Note: flushes are rate limited to avoid excessive network traffic.  If\n the time between calls is too short, the flush will occur after the minimum\n time elapses (rather than immediately).\n\n @param inst      instance handle"]
    pub fn NT_Flush(inst: NT_Inst);
}
extern "C" {
    #[doc = " Get information on the currently established network connections.\n If operating as a client, this will return either zero or one values.\n\n @param inst  instance handle\n @param count returns the number of elements in the array\n @return      array of connection information\n\n It is the caller's responsibility to free the array. The\n NT_DisposeConnectionInfoArray function is useful for this purpose."]
    pub fn NT_GetConnections(inst: NT_Inst, count: *mut usize) -> *mut NT_ConnectionInfo;
}
extern "C" {
    #[doc = " Return whether or not the instance is connected to another node.\n\n @param inst  instance handle\n @return True if connected."]
    pub fn NT_IsConnected(inst: NT_Inst) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the time offset between server time and local time. Add this value to\n local time to get the estimated equivalent server time. In server mode, this\n always returns a valid value of 0. In client mode, this returns the time\n offset only if the client and server are connected and have exchanged\n synchronization messages. Note the time offset may change over time as it is\n periodically updated; to receive updates as events, add a listener to the\n \"time sync\" event.\n\n @param inst instance handle\n @param valid set to true if the return value is valid, false otherwise\n              (output)\n @return Time offset in microseconds (if valid is set to true)"]
    pub fn NT_GetServerTimeOffset(inst: NT_Inst, valid: *mut NT_Bool) -> i64;
}
extern "C" {
    #[doc = " Frees value memory.\n\n @param value   value to free"]
    pub fn NT_DisposeValue(value: *mut NT_Value);
}
extern "C" {
    #[doc = " Initializes a NT_Value.\n Sets type to NT_UNASSIGNED and clears rest of struct.\n\n @param value value to initialize"]
    pub fn NT_InitValue(value: *mut NT_Value);
}
extern "C" {
    #[doc = " Frees string memory.\n\n @param str   string to free"]
    pub fn NT_DisposeString(str_: *mut NT_String);
}
extern "C" {
    #[doc = " Initializes a NT_String.\n Sets length to zero and pointer to null.\n\n @param str   string to initialize"]
    pub fn NT_InitString(str_: *mut NT_String);
}
extern "C" {
    #[doc = " Frees an array of NT_Values.\n\n @param arr   pointer to the value array to free\n @param count number of elements in the array\n\n Note that the individual NT_Values in the array should NOT be\n freed before calling this. This function will free all the values\n individually."]
    pub fn NT_DisposeValueArray(arr: *mut NT_Value, count: usize);
}
extern "C" {
    #[doc = " Disposes a connection info array.\n\n @param arr   pointer to the array to dispose\n @param count number of elements in the array"]
    pub fn NT_DisposeConnectionInfoArray(arr: *mut NT_ConnectionInfo, count: usize);
}
extern "C" {
    #[doc = " Disposes a topic info array.\n\n @param arr   pointer to the array to dispose\n @param count number of elements in the array"]
    pub fn NT_DisposeTopicInfoArray(arr: *mut NT_TopicInfo, count: usize);
}
extern "C" {
    #[doc = " Disposes a single topic info (as returned by NT_GetTopicInfo).\n\n @param info  pointer to the info to dispose"]
    pub fn NT_DisposeTopicInfo(info: *mut NT_TopicInfo);
}
extern "C" {
    #[doc = " Disposes an event array.\n\n @param arr   pointer to the array to dispose\n @param count number of elements in the array"]
    pub fn NT_DisposeEventArray(arr: *mut NT_Event, count: usize);
}
extern "C" {
    #[doc = " Disposes a single event.\n\n @param event  pointer to the event to dispose"]
    pub fn NT_DisposeEvent(event: *mut NT_Event);
}
extern "C" {
    #[doc = " Returns monotonic current time in 1 us increments.\n This is the same time base used for entry and connection timestamps.\n This function by default simply wraps WPI_Now(), but if NT_SetNow() is\n called, this function instead returns the value passed to NT_SetNow();\n this can be used to reduce overhead.\n\n @return Timestamp"]
    pub fn NT_Now() -> i64;
}
extern "C" {
    #[doc = " Sets the current timestamp used for timestamping values that do not\n provide a timestamp (e.g. a value of 0 is passed).  For consistency,\n it also results in NT_Now() returning the set value.  This should generally\n be used only if the overhead of calling WPI_Now() is a concern.\n If used, it should be called periodically with the value of WPI_Now().\n\n @param timestamp timestamp (1 us increments)"]
    pub fn NT_SetNow(timestamp: i64);
}
extern "C" {
    #[doc = " Add logger callback function.  By default, log messages are sent to stderr;\n this function sends log messages to the provided callback function instead.\n The callback function will only be called for log messages with level\n greater than or equal to min_level and less than or equal to max_level;\n messages outside this range will be silently ignored.\n\n @param inst        instance handle\n @param min_level   minimum log level\n @param max_level   maximum log level\n @param data        data pointer to pass to func\n @param func        listener callback function\n @return Listener handle"]
    pub fn NT_AddLogger(
        inst: NT_Inst,
        min_level: ::std::os::raw::c_uint,
        max_level: ::std::os::raw::c_uint,
        data: *mut ::std::os::raw::c_void,
        func: NT_ListenerCallback,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Set the log level for a listener poller.  Events will only be generated for\n log messages with level greater than or equal to min_level and less than or\n equal to max_level; messages outside this range will be silently ignored.\n\n @param poller        poller handle\n @param min_level     minimum log level\n @param max_level     maximum log level\n @return Listener handle"]
    pub fn NT_AddPolledLogger(
        poller: NT_ListenerPoller,
        min_level: ::std::os::raw::c_uint,
        max_level: ::std::os::raw::c_uint,
    ) -> NT_Listener;
}
extern "C" {
    #[doc = " Allocates an array of chars.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated char array\n\n After use, the array should be freed using the NT_FreeCharArray()\n function."]
    pub fn NT_AllocateCharArray(size: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Allocates an array of booleans.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated boolean array\n\n After use, the array should be freed using the NT_FreeBooleanArray()\n function."]
    pub fn NT_AllocateBooleanArray(size: usize) -> *mut NT_Bool;
}
extern "C" {
    #[doc = " Allocates an array of ints.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated double array\n\n After use, the array should be freed using the NT_FreeIntArray()\n function."]
    pub fn NT_AllocateIntegerArray(size: usize) -> *mut i64;
}
extern "C" {
    #[doc = " Allocates an array of floats.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated double array\n\n After use, the array should be freed using the NT_FreeFloatArray()\n function."]
    pub fn NT_AllocateFloatArray(size: usize) -> *mut f32;
}
extern "C" {
    #[doc = " Allocates an array of doubles.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated double array\n\n After use, the array should be freed using the NT_FreeDoubleArray()\n function."]
    pub fn NT_AllocateDoubleArray(size: usize) -> *mut f64;
}
extern "C" {
    #[doc = " Allocates an array of NT_Strings.\n Note that the size is the number of elements, and not the\n specific number of bytes to allocate. That is calculated internally.\n\n @param size  the number of elements the array will contain\n @return      the allocated NT_String array\n\n After use, the array should be freed using the NT_FreeStringArray()\n function."]
    pub fn NT_AllocateStringArray(size: usize) -> *mut NT_String;
}
extern "C" {
    #[doc = " Frees an array of chars.\n\n @param v_char pointer to the char array to free"]
    pub fn NT_FreeCharArray(v_char: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Frees an array of booleans.\n\n @param v_boolean pointer to the boolean array to free"]
    pub fn NT_FreeBooleanArray(v_boolean: *mut NT_Bool);
}
extern "C" {
    #[doc = " Frees an array of ints.\n\n @param v_int pointer to the int array to free"]
    pub fn NT_FreeIntegerArray(v_int: *mut i64);
}
extern "C" {
    #[doc = " Frees an array of floats.\n\n @param v_float pointer to the float array to free"]
    pub fn NT_FreeFloatArray(v_float: *mut f32);
}
extern "C" {
    #[doc = " Frees an array of doubles.\n\n @param v_double pointer to the double array to free"]
    pub fn NT_FreeDoubleArray(v_double: *mut f64);
}
extern "C" {
    #[doc = " Frees an array of NT_Strings.\n\n @param v_string  pointer to the string array to free\n @param arr_size  size of the string array to free\n\n Note that the individual NT_Strings in the array should NOT be\n freed before calling this. This function will free all the strings\n individually."]
    pub fn NT_FreeStringArray(v_string: *mut NT_String, arr_size: usize);
}
extern "C" {
    #[doc = " Returns the type of an NT_Value struct.\n Note that one of the type options is \"unassigned\".\n\n @param value  The NT_Value struct to get the type from.\n @return       The type of the value, or unassigned if null."]
    pub fn NT_GetValueType(value: *const NT_Value) -> NT_Type;
}
extern "C" {
    #[doc = " Returns the boolean from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the boolean from\n @param last_change returns time in ms since the last change in the value\n @param v_boolean   returns the boolean assigned to the name\n @return            1 if successful, or 0 if value is null or not a boolean"]
    pub fn NT_GetValueBoolean(
        value: *const NT_Value,
        last_change: *mut u64,
        v_boolean: *mut NT_Bool,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Returns the int from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the int from\n @param last_change returns time in ms since the last change in the value\n @param v_int       returns the int assigned to the name\n @return            1 if successful, or 0 if value is null or not an int"]
    pub fn NT_GetValueInteger(
        value: *const NT_Value,
        last_change: *mut u64,
        v_int: *mut i64,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Returns the float from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the float from\n @param last_change returns time in ms since the last change in the value\n @param v_float     returns the float assigned to the name\n @return            1 if successful, or 0 if value is null or not a float"]
    pub fn NT_GetValueFloat(
        value: *const NT_Value,
        last_change: *mut u64,
        v_float: *mut f32,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Returns the double from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the double from\n @param last_change returns time in ms since the last change in the value\n @param v_double    returns the double assigned to the name\n @return            1 if successful, or 0 if value is null or not a double"]
    pub fn NT_GetValueDouble(
        value: *const NT_Value,
        last_change: *mut u64,
        v_double: *mut f64,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Returns a copy of the string from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns 0.\n\n @param value       NT_Value struct to get the string from\n @param last_change returns time in ms since the last change in the value\n @param str_len     returns the length of the string\n @return            pointer to the string (UTF-8), or null if error\n\n It is the caller's responsibility to free the string once its no longer\n needed. The NT_FreeCharArray() function is useful for this purpose. The\n returned string is a copy of the string in the value, and must be freed\n separately."]
    pub fn NT_GetValueString(
        value: *const NT_Value,
        last_change: *mut u64,
        str_len: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns a copy of the raw value from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the string from\n @param last_change returns time in ms since the last change in the value\n @param raw_len     returns the length of the string\n @return            pointer to the raw value (UTF-8), or null if error\n\n It is the caller's responsibility to free the raw value once its no longer\n needed. The NT_FreeCharArray() function is useful for this purpose. The\n returned string is a copy of the string in the value, and must be freed\n separately."]
    pub fn NT_GetValueRaw(
        value: *const NT_Value,
        last_change: *mut u64,
        raw_len: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Returns a copy of the boolean array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the boolean array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the boolean array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeBooleanArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately."]
    pub fn NT_GetValueBooleanArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut NT_Bool;
}
extern "C" {
    #[doc = " Returns a copy of the int array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the int array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the int array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeIntArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately."]
    pub fn NT_GetValueIntegerArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut i64;
}
extern "C" {
    #[doc = " Returns a copy of the float array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the float array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the float array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeFloatArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately."]
    pub fn NT_GetValueFloatArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut f32;
}
extern "C" {
    #[doc = " Returns a copy of the double array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the double array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the double array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeDoubleArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately."]
    pub fn NT_GetValueDoubleArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut f64;
}
extern "C" {
    #[doc = " Returns a copy of the NT_String array from the NT_Value.\n If the NT_Value is null, or is assigned to a different type, returns null.\n\n @param value       NT_Value struct to get the NT_String array from\n @param last_change returns time in ms since the last change in the value\n @param arr_size    returns the number of elements in the array\n @return            pointer to the NT_String array, or null if error\n\n It is the caller's responsibility to free the array once its no longer\n needed. The NT_FreeStringArray() function is useful for this purpose.\n The returned array is a copy of the array in the value, and must be\n freed separately. Note that the individual NT_Strings should not be freed,\n but the entire array should be freed at once. The NT_FreeStringArray()\n function will free all the NT_Strings."]
    pub fn NT_GetValueStringArray(
        value: *const NT_Value,
        last_change: *mut u64,
        arr_size: *mut usize,
    ) -> *mut NT_String;
}
#[doc = " Subscriber options. Different from PubSubOptions in this reflects only\n options that are sent over the network."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_SubscriberOptions {
    pub periodic: f64,
    pub topicsOnly: NT_Bool,
    pub sendAll: NT_Bool,
    pub prefixMatch: NT_Bool,
}
#[test]
fn bindgen_test_layout_NT_Meta_SubscriberOptions() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_SubscriberOptions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_SubscriberOptions>(),
        24usize,
        concat!("Size of: ", stringify!(NT_Meta_SubscriberOptions))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_SubscriberOptions>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_SubscriberOptions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).periodic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_SubscriberOptions),
            "::",
            stringify!(periodic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicsOnly) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_SubscriberOptions),
            "::",
            stringify!(topicsOnly)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sendAll) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_SubscriberOptions),
            "::",
            stringify!(sendAll)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixMatch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_SubscriberOptions),
            "::",
            stringify!(prefixMatch)
        )
    );
}
#[doc = " Topic publisher (as published via `$pub$<topic>`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_TopicPublisher {
    pub client: NT_String,
    pub pubuid: u64,
}
#[test]
fn bindgen_test_layout_NT_Meta_TopicPublisher() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_TopicPublisher> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_TopicPublisher>(),
        16usize,
        concat!("Size of: ", stringify!(NT_Meta_TopicPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_TopicPublisher>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_TopicPublisher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicPublisher),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pubuid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicPublisher),
            "::",
            stringify!(pubuid)
        )
    );
}
#[doc = " Topic subscriber (as published via `$sub$<topic>`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_TopicSubscriber {
    pub client: NT_String,
    pub subuid: u64,
    pub options: NT_Meta_SubscriberOptions,
}
#[test]
fn bindgen_test_layout_NT_Meta_TopicSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_TopicSubscriber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_TopicSubscriber>(),
        40usize,
        concat!("Size of: ", stringify!(NT_Meta_TopicSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_TopicSubscriber>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_TopicSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).client) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicSubscriber),
            "::",
            stringify!(client)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subuid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicSubscriber),
            "::",
            stringify!(subuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_TopicSubscriber),
            "::",
            stringify!(options)
        )
    );
}
#[doc = " Client publisher (as published via `$clientpub$<client>` or `$serverpub`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_ClientPublisher {
    pub uid: i64,
    pub topic: NT_String,
}
#[test]
fn bindgen_test_layout_NT_Meta_ClientPublisher() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_ClientPublisher> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_ClientPublisher>(),
        16usize,
        concat!("Size of: ", stringify!(NT_Meta_ClientPublisher))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_ClientPublisher>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_ClientPublisher))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientPublisher),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientPublisher),
            "::",
            stringify!(topic)
        )
    );
}
#[doc = " Client subscriber (as published via `$clientsub$<client>` or `$serversub`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_ClientSubscriber {
    pub uid: i64,
    pub topicsCount: usize,
    pub topics: *mut NT_String,
    pub options: NT_Meta_SubscriberOptions,
}
#[test]
fn bindgen_test_layout_NT_Meta_ClientSubscriber() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_ClientSubscriber> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_ClientSubscriber>(),
        40usize,
        concat!("Size of: ", stringify!(NT_Meta_ClientSubscriber))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_ClientSubscriber>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_Meta_ClientSubscriber))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientSubscriber),
            "::",
            stringify!(uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topicsCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientSubscriber),
            "::",
            stringify!(topicsCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).topics) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientSubscriber),
            "::",
            stringify!(topics)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_ClientSubscriber),
            "::",
            stringify!(options)
        )
    );
}
#[doc = " Client (as published via `$clients`)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_Meta_Client {
    pub id: NT_String,
    pub conn: NT_String,
    pub version: u16,
}
#[test]
fn bindgen_test_layout_NT_Meta_Client() {
    const UNINIT: ::std::mem::MaybeUninit<NT_Meta_Client> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_Meta_Client>(),
        20usize,
        concat!("Size of: ", stringify!(NT_Meta_Client))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_Meta_Client>(),
        4usize,
        concat!("Alignment of ", stringify!(NT_Meta_Client))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_Client),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_Client),
            "::",
            stringify!(conn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_Meta_Client),
            "::",
            stringify!(version)
        )
    );
}
extern "C" {
    #[doc = " Decodes `$pub$<topic>` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of TopicPublishers, or NULL on decoding error."]
    pub fn NT_Meta_DecodeTopicPublishers(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_TopicPublisher;
}
extern "C" {
    #[doc = " Decodes `$sub$<topic>` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of TopicSubscribers, or NULL on decoding error."]
    pub fn NT_Meta_DecodeTopicSubscribers(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_TopicSubscriber;
}
extern "C" {
    #[doc = " Decodes `$clientpub$<topic>` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of ClientPublishers, or NULL on decoding error."]
    pub fn NT_Meta_DecodeClientPublishers(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_ClientPublisher;
}
extern "C" {
    #[doc = " Decodes `$clientsub$<topic>` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of ClientSubscribers, or NULL on decoding error."]
    pub fn NT_Meta_DecodeClientSubscribers(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_ClientSubscriber;
}
extern "C" {
    #[doc = " Decodes `$clients` meta-topic data.\n\n @param data data contents\n @param size size of data contents\n @param count number of elements in returned array (output)\n @return Array of Clients, or NULL on decoding error."]
    pub fn NT_Meta_DecodeClients(
        data: *const u8,
        size: usize,
        count: *mut usize,
    ) -> *mut NT_Meta_Client;
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_TopicPublisher.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeTopicPublishers(arr: *mut NT_Meta_TopicPublisher, count: usize);
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_TopicSubscriber.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeTopicSubscribers(arr: *mut NT_Meta_TopicSubscriber, count: usize);
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_ClientPublisher.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeClientPublishers(arr: *mut NT_Meta_ClientPublisher, count: usize);
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_ClientSubscriber.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeClientSubscribers(arr: *mut NT_Meta_ClientSubscriber, count: usize);
}
extern "C" {
    #[doc = " Frees an array of NT_Meta_Client.\n\n @param arr   pointer to the array to free\n @param count size of the array to free"]
    pub fn NT_Meta_FreeClients(arr: *mut NT_Meta_Client, count: usize);
}
#[doc = " Timestamped Boolean.\n @ingroup ntcore_c_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedBoolean {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: NT_Bool,
}
#[test]
fn bindgen_test_layout_NT_TimestampedBoolean() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedBoolean> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedBoolean>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedBoolean))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedBoolean>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedBoolean))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBoolean),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBoolean),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBoolean),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish"]
    pub fn NT_SetBoolean(pubentry: NT_Handle, time: i64, value: NT_Bool) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    pub fn NT_SetDefaultBoolean(pubentry: NT_Handle, defaultValue: NT_Bool) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    pub fn NT_GetBoolean(subentry: NT_Handle, defaultValue: NT_Bool) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicBoolean(
        subentry: NT_Handle,
        defaultValue: NT_Bool,
        value: *mut NT_TimestampedBoolean,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicBoolean).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedBoolean(value: *mut NT_TimestampedBoolean);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueBoolean(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedBoolean;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueBoolean).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueBoolean(arr: *mut NT_TimestampedBoolean, len: usize);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueValuesBoolean(subentry: NT_Handle, len: *mut usize) -> *mut NT_Bool;
}
#[doc = " Timestamped Integer.\n @ingroup ntcore_c_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedInteger {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: i64,
}
#[test]
fn bindgen_test_layout_NT_TimestampedInteger() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedInteger> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedInteger>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedInteger))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedInteger>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedInteger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedInteger),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedInteger),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedInteger),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish"]
    pub fn NT_SetInteger(pubentry: NT_Handle, time: i64, value: i64) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    pub fn NT_SetDefaultInteger(pubentry: NT_Handle, defaultValue: i64) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    pub fn NT_GetInteger(subentry: NT_Handle, defaultValue: i64) -> i64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicInteger(
        subentry: NT_Handle,
        defaultValue: i64,
        value: *mut NT_TimestampedInteger,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicInteger).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedInteger(value: *mut NT_TimestampedInteger);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueInteger(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedInteger;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueInteger).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueInteger(arr: *mut NT_TimestampedInteger, len: usize);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueValuesInteger(subentry: NT_Handle, len: *mut usize) -> *mut i64;
}
#[doc = " Timestamped Float.\n @ingroup ntcore_c_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedFloat {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: f32,
}
#[test]
fn bindgen_test_layout_NT_TimestampedFloat() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedFloat> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedFloat>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedFloat))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedFloat>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedFloat))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloat),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloat),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloat),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish"]
    pub fn NT_SetFloat(pubentry: NT_Handle, time: i64, value: f32) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    pub fn NT_SetDefaultFloat(pubentry: NT_Handle, defaultValue: f32) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    pub fn NT_GetFloat(subentry: NT_Handle, defaultValue: f32) -> f32;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicFloat(
        subentry: NT_Handle,
        defaultValue: f32,
        value: *mut NT_TimestampedFloat,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicFloat).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedFloat(value: *mut NT_TimestampedFloat);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueFloat(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedFloat;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueFloat).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueFloat(arr: *mut NT_TimestampedFloat, len: usize);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueValuesFloat(subentry: NT_Handle, len: *mut usize) -> *mut f32;
}
#[doc = " Timestamped Double.\n @ingroup ntcore_c_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedDouble {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: f64,
}
#[test]
fn bindgen_test_layout_NT_TimestampedDouble() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedDouble> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedDouble>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedDouble))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedDouble>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedDouble))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDouble),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDouble),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDouble),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish"]
    pub fn NT_SetDouble(pubentry: NT_Handle, time: i64, value: f64) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value"]
    pub fn NT_SetDefaultDouble(pubentry: NT_Handle, defaultValue: f64) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @return value"]
    pub fn NT_GetDouble(subentry: NT_Handle, defaultValue: f64) -> f64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicDouble(
        subentry: NT_Handle,
        defaultValue: f64,
        value: *mut NT_TimestampedDouble,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicDouble).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedDouble(value: *mut NT_TimestampedDouble);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueDouble(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedDouble;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueDouble).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueDouble(arr: *mut NT_TimestampedDouble, len: usize);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueValuesDouble(subentry: NT_Handle, len: *mut usize) -> *mut f64;
}
#[doc = " Timestamped String.\n @ingroup ntcore_c_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedString {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut ::std::os::raw::c_char,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedString() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedString> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedString>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedString))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedString>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedString))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedString),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedString),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedString),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedString),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetString(
        pubentry: NT_Handle,
        time: i64,
        value: *const ::std::os::raw::c_char,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultString(
        pubentry: NT_Handle,
        defaultValue: *const ::std::os::raw::c_char,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetString(
        subentry: NT_Handle,
        defaultValue: *const ::std::os::raw::c_char,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicString(
        subentry: NT_Handle,
        defaultValue: *const ::std::os::raw::c_char,
        defaultValueLen: usize,
        value: *mut NT_TimestampedString,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicString).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedString(value: *mut NT_TimestampedString);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueString(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedString;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueString).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueString(arr: *mut NT_TimestampedString, len: usize);
}
#[doc = " Timestamped Raw.\n @ingroup ntcore_c_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedRaw {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut u8,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedRaw() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedRaw> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedRaw>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedRaw))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedRaw>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedRaw))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedRaw),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedRaw),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedRaw),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedRaw),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetRaw(pubentry: NT_Handle, time: i64, value: *const u8, len: usize) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultRaw(
        pubentry: NT_Handle,
        defaultValue: *const u8,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetRaw(
        subentry: NT_Handle,
        defaultValue: *const u8,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicRaw(
        subentry: NT_Handle,
        defaultValue: *const u8,
        defaultValueLen: usize,
        value: *mut NT_TimestampedRaw,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicRaw).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedRaw(value: *mut NT_TimestampedRaw);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueRaw(subentry: NT_Handle, len: *mut usize) -> *mut NT_TimestampedRaw;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueRaw).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueRaw(arr: *mut NT_TimestampedRaw, len: usize);
}
#[doc = " Timestamped BooleanArray.\n @ingroup ntcore_c_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedBooleanArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut NT_Bool,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedBooleanArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedBooleanArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedBooleanArray>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedBooleanArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedBooleanArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedBooleanArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBooleanArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBooleanArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBooleanArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedBooleanArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetBooleanArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const NT_Bool,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultBooleanArray(
        pubentry: NT_Handle,
        defaultValue: *const NT_Bool,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetBooleanArray(
        subentry: NT_Handle,
        defaultValue: *const NT_Bool,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicBooleanArray(
        subentry: NT_Handle,
        defaultValue: *const NT_Bool,
        defaultValueLen: usize,
        value: *mut NT_TimestampedBooleanArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicBooleanArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedBooleanArray(value: *mut NT_TimestampedBooleanArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueBooleanArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedBooleanArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueBooleanArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueBooleanArray(arr: *mut NT_TimestampedBooleanArray, len: usize);
}
#[doc = " Timestamped IntegerArray.\n @ingroup ntcore_c_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedIntegerArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut i64,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedIntegerArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedIntegerArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedIntegerArray>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedIntegerArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedIntegerArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedIntegerArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedIntegerArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedIntegerArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedIntegerArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedIntegerArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetIntegerArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const i64,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultIntegerArray(
        pubentry: NT_Handle,
        defaultValue: *const i64,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetIntegerArray(
        subentry: NT_Handle,
        defaultValue: *const i64,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut i64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicIntegerArray(
        subentry: NT_Handle,
        defaultValue: *const i64,
        defaultValueLen: usize,
        value: *mut NT_TimestampedIntegerArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicIntegerArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedIntegerArray(value: *mut NT_TimestampedIntegerArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueIntegerArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedIntegerArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueIntegerArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueIntegerArray(arr: *mut NT_TimestampedIntegerArray, len: usize);
}
#[doc = " Timestamped FloatArray.\n @ingroup ntcore_c_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedFloatArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut f32,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedFloatArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedFloatArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedFloatArray>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedFloatArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedFloatArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedFloatArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloatArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloatArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloatArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedFloatArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetFloatArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const f32,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultFloatArray(
        pubentry: NT_Handle,
        defaultValue: *const f32,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetFloatArray(
        subentry: NT_Handle,
        defaultValue: *const f32,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut f32;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicFloatArray(
        subentry: NT_Handle,
        defaultValue: *const f32,
        defaultValueLen: usize,
        value: *mut NT_TimestampedFloatArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicFloatArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedFloatArray(value: *mut NT_TimestampedFloatArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueFloatArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedFloatArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueFloatArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueFloatArray(arr: *mut NT_TimestampedFloatArray, len: usize);
}
#[doc = " Timestamped DoubleArray.\n @ingroup ntcore_c_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedDoubleArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut f64,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedDoubleArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedDoubleArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedDoubleArray>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedDoubleArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedDoubleArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedDoubleArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDoubleArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDoubleArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDoubleArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedDoubleArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetDoubleArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const f64,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultDoubleArray(
        pubentry: NT_Handle,
        defaultValue: *const f64,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetDoubleArray(
        subentry: NT_Handle,
        defaultValue: *const f64,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut f64;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicDoubleArray(
        subentry: NT_Handle,
        defaultValue: *const f64,
        defaultValueLen: usize,
        value: *mut NT_TimestampedDoubleArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicDoubleArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedDoubleArray(value: *mut NT_TimestampedDoubleArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueDoubleArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedDoubleArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueDoubleArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueDoubleArray(arr: *mut NT_TimestampedDoubleArray, len: usize);
}
#[doc = " Timestamped StringArray.\n @ingroup ntcore_c_handle_api"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_TimestampedStringArray {
    #[doc = " Time in local time base."]
    pub time: i64,
    #[doc = " Time in server time base.  May be 0 or 1 for locally set values."]
    pub serverTime: i64,
    #[doc = " Value."]
    pub value: *mut NT_String,
    #[doc = " Value length."]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_NT_TimestampedStringArray() {
    const UNINIT: ::std::mem::MaybeUninit<NT_TimestampedStringArray> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NT_TimestampedStringArray>(),
        24usize,
        concat!("Size of: ", stringify!(NT_TimestampedStringArray))
    );
    assert_eq!(
        ::std::mem::align_of::<NT_TimestampedStringArray>(),
        8usize,
        concat!("Alignment of ", stringify!(NT_TimestampedStringArray))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedStringArray),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serverTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedStringArray),
            "::",
            stringify!(serverTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedStringArray),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(NT_TimestampedStringArray),
            "::",
            stringify!(len)
        )
    );
}
extern "C" {
    #[doc = " Publish a new value.\n\n @param pubentry publisher or entry handle\n @param time timestamp; 0 indicates current NT time should be used\n @param value value to publish\n @param len length of value\n"]
    pub fn NT_SetStringArray(
        pubentry: NT_Handle,
        time: i64,
        value: *const NT_String,
        len: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Publish a default value.\n On reconnect, a default value will never be used in preference to a\n published value.\n\n @param pubentry publisher or entry handle\n @param defaultValue default value\n @param defaultValueLen length of default value\n"]
    pub fn NT_SetDefaultStringArray(
        pubentry: NT_Handle,
        defaultValue: *const NT_String,
        defaultValueLen: usize,
    ) -> NT_Bool;
}
extern "C" {
    #[doc = " Get the last published value.\n If no value has been published, returns the passed defaultValue.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n @param len length of returned value (output)\n\n @return value"]
    pub fn NT_GetStringArray(
        subentry: NT_Handle,
        defaultValue: *const NT_String,
        defaultValueLen: usize,
        len: *mut usize,
    ) -> *mut NT_String;
}
extern "C" {
    #[doc = " Get the last published value along with its timestamp.\n If no value has been published, returns the passed defaultValue and a\n timestamp of 0.\n\n @param subentry subscriber or entry handle\n @param defaultValue default value to return if no value has been published\n @param defaultValueLen length of default value\n\n @param value timestamped value (output)"]
    pub fn NT_GetAtomicStringArray(
        subentry: NT_Handle,
        defaultValue: *const NT_String,
        defaultValueLen: usize,
        value: *mut NT_TimestampedStringArray,
    );
}
extern "C" {
    #[doc = " Disposes a timestamped value (as returned by NT_GetAtomicStringArray).\n\n @param value timestamped value"]
    pub fn NT_DisposeTimestampedStringArray(value: *mut NT_TimestampedStringArray);
}
extern "C" {
    #[doc = " Get an array of all value changes since the last call to ReadQueue.\n Also provides a timestamp for each value.\n\n @note The \"poll storage\" subscribe option can be used to set the queue\n     depth.\n\n @param subentry subscriber or entry handle\n @param len length of returned array (output)\n @return Array of timestamped values; NULL if no new changes have\n     been published since the previous call."]
    pub fn NT_ReadQueueStringArray(
        subentry: NT_Handle,
        len: *mut usize,
    ) -> *mut NT_TimestampedStringArray;
}
extern "C" {
    #[doc = " Frees a timestamped array of values (as returned by NT_ReadQueueStringArray).\n\n @param arr array\n @param len length of array"]
    pub fn NT_FreeQueueStringArray(arr: *mut NT_TimestampedStringArray, len: usize);
}
#[doc = " A source or sink property."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cs_VideoProperty {
    pub m_status: CS_Status,
    pub m_handle: CS_Property,
    pub m_kind: cs_VideoProperty_Kind,
}
pub const cs_VideoProperty_Kind_kNone: cs_VideoProperty_Kind = 0;
pub const cs_VideoProperty_Kind_kBoolean: cs_VideoProperty_Kind = 1;
pub const cs_VideoProperty_Kind_kInteger: cs_VideoProperty_Kind = 2;
pub const cs_VideoProperty_Kind_kString: cs_VideoProperty_Kind = 4;
pub const cs_VideoProperty_Kind_kEnum: cs_VideoProperty_Kind = 8;
pub type cs_VideoProperty_Kind = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_cs_VideoProperty() {
    const UNINIT: ::std::mem::MaybeUninit<cs_VideoProperty> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cs_VideoProperty>(),
        12usize,
        concat!("Size of: ", stringify!(cs_VideoProperty))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_VideoProperty>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_VideoProperty))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_VideoProperty),
            "::",
            stringify!(m_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_VideoProperty),
            "::",
            stringify!(m_handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_kind) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_VideoProperty),
            "::",
            stringify!(m_kind)
        )
    );
}
#[doc = " A source for video that provides a sequence of frames."]
#[repr(C)]
#[derive(Debug)]
pub struct cs_VideoSource {
    pub m_status: CS_Status,
    pub m_handle: CS_Source,
}
pub const cs_VideoSource_Kind_kUnknown: cs_VideoSource_Kind = 0;
pub const cs_VideoSource_Kind_kUsb: cs_VideoSource_Kind = 1;
pub const cs_VideoSource_Kind_kHttp: cs_VideoSource_Kind = 2;
pub const cs_VideoSource_Kind_kCv: cs_VideoSource_Kind = 4;
pub type cs_VideoSource_Kind = ::std::os::raw::c_uint;
#[doc = " Automatically connect or disconnect based on whether any sinks are\n connected to this source.  This is the default behavior."]
pub const cs_VideoSource_ConnectionStrategy_kConnectionAutoManage:
    cs_VideoSource_ConnectionStrategy = 0;
#[doc = " Try to keep the connection open regardless of whether any sinks are\n connected."]
pub const cs_VideoSource_ConnectionStrategy_kConnectionKeepOpen: cs_VideoSource_ConnectionStrategy =
    1;
#[doc = " Never open the connection.  If this is set when the connection is open,\n close the connection."]
pub const cs_VideoSource_ConnectionStrategy_kConnectionForceClose:
    cs_VideoSource_ConnectionStrategy = 2;
#[doc = " Connection strategy.  Used for SetConnectionStrategy()."]
pub type cs_VideoSource_ConnectionStrategy = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_cs_VideoSource() {
    const UNINIT: ::std::mem::MaybeUninit<cs_VideoSource> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cs_VideoSource>(),
        8usize,
        concat!("Size of: ", stringify!(cs_VideoSource))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_VideoSource>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_VideoSource))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_VideoSource),
            "::",
            stringify!(m_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_VideoSource),
            "::",
            stringify!(m_handle)
        )
    );
}
extern "C" {
    #[doc = " Enumerate all properties of this source."]
    #[link_name = "\u{1}_ZNK2cs11VideoSource19EnumeratePropertiesEv"]
    pub fn cs_VideoSource_EnumerateProperties(this: *const cs_VideoSource) -> u8;
}
extern "C" {
    #[doc = " Get a JSON configuration object.\n\n @return JSON configuration object"]
    #[link_name = "\u{1}_ZNK2cs11VideoSource19GetConfigJsonObjectEv"]
    pub fn cs_VideoSource_GetConfigJsonObject(this: *const cs_VideoSource) -> wpi_json;
}
extern "C" {
    #[doc = " Enumerate all sinks connected to this source.\n\n @return Vector of sinks."]
    #[link_name = "\u{1}_ZN2cs11VideoSource14EnumerateSinksEv"]
    pub fn cs_VideoSource_EnumerateSinks(this: *mut cs_VideoSource) -> u8;
}
extern "C" {
    #[doc = " Enumerate all existing sources.\n\n @return Vector of sources."]
    #[link_name = "\u{1}_ZN2cs11VideoSource16EnumerateSourcesEv"]
    pub fn cs_VideoSource_EnumerateSources() -> u8;
}
impl cs_VideoSource {
    #[inline]
    pub unsafe fn EnumerateProperties(&self) -> u8 {
        cs_VideoSource_EnumerateProperties(self)
    }
    #[inline]
    pub unsafe fn GetConfigJsonObject(&self) -> wpi_json {
        cs_VideoSource_GetConfigJsonObject(self)
    }
    #[inline]
    pub unsafe fn EnumerateSinks(&mut self) -> u8 {
        cs_VideoSource_EnumerateSinks(self)
    }
    #[inline]
    pub unsafe fn EnumerateSources() -> u8 {
        cs_VideoSource_EnumerateSources()
    }
}
#[doc = " A sink for video that accepts a sequence of frames."]
#[repr(C)]
#[derive(Debug)]
pub struct cs_VideoSink {
    pub m_status: CS_Status,
    pub m_handle: CS_Sink,
}
pub const cs_VideoSink_Kind_kUnknown: cs_VideoSink_Kind = 0;
pub const cs_VideoSink_Kind_kMjpeg: cs_VideoSink_Kind = 2;
pub const cs_VideoSink_Kind_kCv: cs_VideoSink_Kind = 4;
pub type cs_VideoSink_Kind = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_cs_VideoSink() {
    const UNINIT: ::std::mem::MaybeUninit<cs_VideoSink> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cs_VideoSink>(),
        8usize,
        concat!("Size of: ", stringify!(cs_VideoSink))
    );
    assert_eq!(
        ::std::mem::align_of::<cs_VideoSink>(),
        4usize,
        concat!("Alignment of ", stringify!(cs_VideoSink))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_VideoSink),
            "::",
            stringify!(m_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_handle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cs_VideoSink),
            "::",
            stringify!(m_handle)
        )
    );
}
extern "C" {
    #[doc = " Enumerate all properties of this sink."]
    #[link_name = "\u{1}_ZNK2cs9VideoSink19EnumeratePropertiesEv"]
    pub fn cs_VideoSink_EnumerateProperties(this: *const cs_VideoSink) -> u8;
}
extern "C" {
    #[doc = " Get a JSON configuration object.\n\n @return JSON configuration object"]
    #[link_name = "\u{1}_ZNK2cs9VideoSink19GetConfigJsonObjectEv"]
    pub fn cs_VideoSink_GetConfigJsonObject(this: *const cs_VideoSink) -> wpi_json;
}
extern "C" {
    #[doc = " Enumerate all existing sinks.\n\n @return Vector of sinks."]
    #[link_name = "\u{1}_ZN2cs9VideoSink14EnumerateSinksEv"]
    pub fn cs_VideoSink_EnumerateSinks() -> u8;
}
impl cs_VideoSink {
    #[inline]
    pub unsafe fn EnumerateProperties(&self) -> u8 {
        cs_VideoSink_EnumerateProperties(self)
    }
    #[inline]
    pub unsafe fn GetConfigJsonObject(&self) -> wpi_json {
        cs_VideoSink_GetConfigJsonObject(self)
    }
    #[inline]
    pub unsafe fn EnumerateSinks() -> u8 {
        cs_VideoSink_EnumerateSinks()
    }
}
pub type CS_Status = ::std::os::raw::c_int;
pub type CS_Handle = ::std::os::raw::c_int;
pub type CS_Property = CS_Handle;
pub type CS_Sink = CS_Handle;
pub type CS_Source = CS_Handle;
extern "C" {
    pub fn NT_GetStringForTesting(
        str_: *const ::std::os::raw::c_char,
        struct_size: *mut ::std::os::raw::c_int,
    ) -> *mut NT_String;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NT_EntryInfo {
    _unused: [u8; 0],
}
extern "C" {
    pub fn NT_GetEntryInfoForTesting(
        name: *const ::std::os::raw::c_char,
        type_: NT_Type,
        flags: ::std::os::raw::c_uint,
        last_change: u64,
        struct_size: *mut ::std::os::raw::c_int,
    ) -> *mut NT_EntryInfo;
}
extern "C" {
    pub fn NT_FreeEntryInfoForTesting(info: *mut NT_EntryInfo);
}
extern "C" {
    pub fn NT_GetConnectionInfoForTesting(
        remote_id: *const ::std::os::raw::c_char,
        remote_ip: *const ::std::os::raw::c_char,
        remote_port: ::std::os::raw::c_uint,
        last_update: u64,
        protocol_version: ::std::os::raw::c_uint,
        struct_size: *mut ::std::os::raw::c_int,
    ) -> *mut NT_ConnectionInfo;
}
extern "C" {
    pub fn NT_FreeConnectionInfoForTesting(info: *mut NT_ConnectionInfo);
}
extern "C" {
    pub fn NT_GetValueBooleanForTesting(
        last_change: u64,
        val: ::std::os::raw::c_int,
        struct_size: *mut ::std::os::raw::c_int,
    ) -> *mut NT_Value;
}
extern "C" {
    pub fn NT_GetValueDoubleForTesting(
        last_change: u64,
        val: f64,
        struct_size: *mut ::std::os::raw::c_int,
    ) -> *mut NT_Value;
}
extern "C" {
    pub fn NT_GetValueStringForTesting(
        last_change: u64,
        str_: *const ::std::os::raw::c_char,
        struct_size: *mut ::std::os::raw::c_int,
    ) -> *mut NT_Value;
}
extern "C" {
    pub fn NT_GetValueRawForTesting(
        last_change: u64,
        raw: *const ::std::os::raw::c_char,
        raw_len: ::std::os::raw::c_int,
        struct_size: *mut ::std::os::raw::c_int,
    ) -> *mut NT_Value;
}
extern "C" {
    pub fn NT_GetValueBooleanArrayForTesting(
        last_change: u64,
        arr: *const ::std::os::raw::c_int,
        array_len: usize,
        struct_size: *mut ::std::os::raw::c_int,
    ) -> *mut NT_Value;
}
extern "C" {
    pub fn NT_GetValueDoubleArrayForTesting(
        last_change: u64,
        arr: *const f64,
        array_len: usize,
        struct_size: *mut ::std::os::raw::c_int,
    ) -> *mut NT_Value;
}
extern "C" {
    pub fn NT_GetValueStringArrayForTesting(
        last_change: u64,
        arr: *const NT_String,
        array_len: usize,
        struct_size: *mut ::std::os::raw::c_int,
    ) -> *mut NT_Value;
}
#[test]
fn __bindgen_test_layout_units_base_unit_open0_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_base_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_base_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_base_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_base_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_base_unit_open0_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<units_base_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_base_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_base_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_base_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_base_unit_open0_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation_2(
) {
    assert_eq!(
        ::std::mem::size_of::<units_base_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_base_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_base_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_base_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_base_unit_open0_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation_3(
) {
    assert_eq!(
        ::std::mem::size_of::<units_base_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_base_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_base_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_base_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_base_unit_open0_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation_4(
) {
    assert_eq!(
        ::std::mem::size_of::<units_base_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_base_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_base_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_base_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_base_unit_open0_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation_5(
) {
    assert_eq!(
        ::std::mem::size_of::<units_base_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_base_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_base_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_base_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_base_unit_open0_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation_6(
) {
    assert_eq!(
        ::std::mem::size_of::<units_base_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_base_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_base_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_base_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_base_unit_open0_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation_7(
) {
    assert_eq!(
        ::std::mem::size_of::<units_base_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_base_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_base_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_base_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_base_unit_open0_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation_8(
) {
    assert_eq!(
        ::std::mem::size_of::<units_base_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_base_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_base_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_base_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_time_second_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_open0_units_time_seconds__bindgen_ty_id_168793_open1_std_ratio_open2_close2_units_base_unit_open2_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_close2_std_ratio_open2_close2_std_ratio_open2_close2_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(units_unit))
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_base_unit_open0_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation_9(
) {
    assert_eq!(
        ::std::mem::size_of::<units_base_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_base_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_base_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_base_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_time_nanosecond_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_open0_units_time_seconds__bindgen_ty_id_168885_open1_std_ratio_open2_close2_units_base_unit_open2_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_close2_std_ratio_open2_close2_std_ratio_open2_close2_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(units_unit))
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_base_unit_open0_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation_10(
) {
    assert_eq!(
        ::std::mem::size_of::<units_base_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_base_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_base_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_base_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_time_microsecond_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_open0_units_time_seconds__bindgen_ty_id_168977_open1_std_ratio_open2_close2_units_base_unit_open2_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_close2_std_ratio_open2_close2_std_ratio_open2_close2_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(units_unit))
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_base_unit_open0_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation_11(
) {
    assert_eq!(
        ::std::mem::size_of::<units_base_unit>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_base_unit)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_base_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_base_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_time_millisecond_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_ADXL345_I2C_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_ADXL345_SPI_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_ADXL362_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_angle_radian_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_open0_std_ratio_open1_close1_units_angle_radians_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(units_unit))
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_angle_degree_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_open0_std_ratio_open1_close1_units_angle_radians_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation_1(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(units_unit))
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_angle_turn_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_ADXRS450_Gyro_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_AnalogInput_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_AnalogAccelerometer_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_AnalogTriggerOutput_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_AnalogTrigger_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_Counter_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_AnalogEncoder_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_AnalogGyro_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_AnalogOutput_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_AnalogPotentiometer_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_BuiltInAccelerometer_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_current_ampere_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_length_meter_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_open0_std_ratio_open1_close1_units_length_meters_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(units_unit))
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_open0_std_ratio_open1_close1_units_length_feet_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(units_unit))
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_open0_units_mass_grams__bindgen_ty_id_179367_open1_std_ratio_open2_close2_units_base_unit_open2_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_std_ratio_open3_close3_close2_std_ratio_open2_close2_std_ratio_open2_close2_close1_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(units_unit))
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_mass_kilogram_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_open0_std_ratio_open1_close1_units_mass_kilograms_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(units_unit))
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_pressure_pounds_per_square_inch_double_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_voltage_volt_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_Compressor_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_DigitalGlitchFilter_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_DigitalInput_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_DigitalOutput_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_DutyCycle_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_Encoder_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_DoubleSolenoid_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_DutyCycleEncoder_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
pub type rep = ::std::os::raw::c_longlong;
#[test]
fn __bindgen_test_layout_wpi_AllocatorBase_open0_wpi_MallocAllocator_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_AllocatorBase>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_AllocatorBase)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_AllocatorBase>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_AllocatorBase)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_StringMap_open0_std_chrono_nanoseconds_wpi_MallocAllocator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_DenseMapInfo_open0_int_void_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_DenseMapInfo_open0_int_void_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<wpi_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_DenseMapInfo_open0_int_void_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<wpi_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_DenseMapInfo_open0_int_void_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<wpi_DenseMapInfo>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_DenseMapInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_DenseMapInfo>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_DenseMapInfo)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_PowerDistribution_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_PWM_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_Relay_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_Solenoid_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_priority_queue_open0_frc_TimedRobot_Callback_std_vector_open1_frc_TimedRobot_Callback_std_allocator_open2_frc_TimedRobot_Callback_close2_close1_std_greater_open1_frc_TimedRobot_Callback_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<[u32; 4usize]>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!([u32; 4usize])
        )
    );
    assert_eq!(
        ::std::mem::align_of::<[u32; 4usize]>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!([u32; 4usize])
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_velocity_meters_per_second_double_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_velocity_feet_per_second_double_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_Ultrasonic_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _bindgen_ty_79 {
    pub _address: u8,
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_angular_velocity_radians_per_second_double_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_impedance_ohm_double_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_open0_std_ratio_open1_close1_units_energy_joule_std_ratio_open1_close1_std_ratio_open1_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit>(),
        1usize,
        concat!("Size of template specialization: ", stringify!(units_unit))
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_torque_newton_meter_double_close0_instantiation()
{
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0__bindgen_ty_id_198273_open1_units_angular_velocity_radians_per_second__bindgen_ty_id_198268_open2_units_voltage_volt_units_base_unit_open3_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_close3_std_ratio_open3_close3_std_ratio_open3_close3_close2_std_ratio_open2_close2_std_ratio_open2_close2_close1_double_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0__bindgen_ty_id_198311_open1_units_torque_newton_meters__bindgen_ty_id_198306_open2_units_current_ampere_units_base_unit_open3_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_std_ratio_open4_close4_close3_std_ratio_open3_close3_std_ratio_open3_close3_close2_std_ratio_open2_close2_std_ratio_open2_close2_close1_double_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_units_unit_t_open0_units_moment_of_inertia_kilogram_square_meter_double_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<units_unit_t>(),
        8usize,
        concat!(
            "Size of template specialization: ",
            stringify!(units_unit_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<units_unit_t>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(units_unit_t)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SmallVectorImpl_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SmallVectorImpl>(),
        12usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SmallVectorImpl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SmallVectorImpl_open0_char_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SmallVectorImpl>(),
        12usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SmallVectorImpl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_StringMap_open0_NT_Entry_wpi_MallocAllocator_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SmallVectorImpl_open0_char_close0_instantiation_2() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SmallVectorImpl>(),
        12usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SmallVectorImpl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SmallVectorImpl_open0_frc_Pose2d_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SmallVectorImpl>(),
        12usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SmallVectorImpl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_Field2d_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SmallVectorImpl_open0_char_close0_instantiation_3() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SmallVectorImpl>(),
        12usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SmallVectorImpl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SmallVectorImpl_open0_char_close0_instantiation_4() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SmallVectorImpl>(),
        12usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SmallVectorImpl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SmallVectorImpl_open0_char_close0_instantiation_5() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SmallVectorImpl>(),
        12usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SmallVectorImpl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SmallVectorImpl_open0_char_close0_instantiation_6() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SmallVectorImpl>(),
        12usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SmallVectorImpl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_StringMap_open0_std_unique_ptr_open1_frc_MechanismObject2d_std_default_delete_open2_frc_MechanismObject2d_close2_close1_wpi_MallocAllocator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_Mechanism2d_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_StringMap_open0_std_unique_ptr_open1_frc_MechanismRoot2d_std_default_delete_open2_frc_MechanismRoot2d_close2_close1_wpi_MallocAllocator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SmallVectorImpl_open0_char_close0_instantiation_7() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SmallVectorImpl>(),
        12usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SmallVectorImpl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SmallVectorImpl_open0_std_string_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SmallVectorImpl>(),
        12usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SmallVectorImpl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SmallVectorImpl_open0_char_close0_instantiation_8() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SmallVectorImpl>(),
        12usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SmallVectorImpl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SmallVectorImpl_open0_std_string_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SmallVectorImpl>(),
        12usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SmallVectorImpl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SmallVectorImpl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_SendableChooserBase_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_StringMap_open0_nt_Value_wpi_MallocAllocator_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_StringMap_open0_nt_Value_wpi_MallocAllocator_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_StringMap_open0_ptr_ShuffleboardLayout_wpi_MallocAllocator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
}
#[test]
fn __bindgen_test_layout_frc_ShuffleboardWidget_open0_frc_ComplexWidget_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<frc_ShuffleboardWidget>(),
        104usize,
        concat!(
            "Size of template specialization: ",
            stringify!(frc_ShuffleboardWidget)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ShuffleboardWidget>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(frc_ShuffleboardWidget)
        )
    );
}
#[test]
fn __bindgen_test_layout_frc_ShuffleboardComponent_open0_frc_ShuffleboardLayout_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<frc_ShuffleboardComponent>(),
        104usize,
        concat!(
            "Size of template specialization: ",
            stringify!(frc_ShuffleboardComponent)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ShuffleboardComponent>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(frc_ShuffleboardComponent)
        )
    );
}
#[test]
fn __bindgen_test_layout_frc_ShuffleboardWidget_open0_frc_SimpleWidget_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<frc_ShuffleboardWidget>(),
        104usize,
        concat!(
            "Size of template specialization: ",
            stringify!(frc_ShuffleboardWidget)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<frc_ShuffleboardWidget>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(frc_ShuffleboardWidget)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_SendableHelper_open0_frc_SendableCameraWrapper_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_SendableHelper>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_SendableHelper)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_detail_json_ref_open0_wpi_json_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_detail_json_ref<wpi_json>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_detail_json_ref<wpi_json>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_detail_json_ref<wpi_json>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_detail_json_ref<wpi_json>)
        )
    );
}
#[doc = "@brief a class to store JSON values\n\n@requirement The class satisfies the following concept requirements:\n- Basic\n- [DefaultConstructible](http://en.cppreference.com/w/cpp/concept/DefaultConstructible):\nJSON values can be default constructed. The result will be a JSON null\nvalue.\n- [MoveConstructible](http://en.cppreference.com/w/cpp/concept/MoveConstructible):\nA JSON value can be constructed from an rvalue argument.\n- [CopyConstructible](http://en.cppreference.com/w/cpp/concept/CopyConstructible):\nA JSON value can be copy-constructed from an lvalue expression.\n- [MoveAssignable](http://en.cppreference.com/w/cpp/concept/MoveAssignable):\nA JSON value van be assigned from an rvalue argument.\n- [CopyAssignable](http://en.cppreference.com/w/cpp/concept/CopyAssignable):\nA JSON value can be copy-assigned from an lvalue expression.\n- [Destructible](http://en.cppreference.com/w/cpp/concept/Destructible):\nJSON values can be destructed.\n- Layout\n- [StandardLayoutType](http://en.cppreference.com/w/cpp/concept/StandardLayoutType):\nJSON values have\n[standard layout](http://en.cppreference.com/w/cpp/language/data_members#Standard_layout):\nAll non-static data members are private and standard layout types, the\nclass has no virtual functions or (virtual) base classes.\n- Library-wide\n- [EqualityComparable](http://en.cppreference.com/w/cpp/concept/EqualityComparable):\nJSON values can be compared with `==`, see @ref\noperator==(const_reference,const_reference).\n- [LessThanComparable](http://en.cppreference.com/w/cpp/concept/LessThanComparable):\nJSON values can be compared with `<`, see @ref\noperator<(const_reference,const_reference).\n- [Swappable](http://en.cppreference.com/w/cpp/concept/Swappable):\nAny JSON lvalue or rvalue of can be swapped with any lvalue or rvalue of\nother compatible types, using unqualified function call @ref swap().\n- [NullablePointer](http://en.cppreference.com/w/cpp/concept/NullablePointer):\nJSON values can be compared against `std::nullptr_t` objects which are used\nto model the `null` value.\n- Container\n- [Container](http://en.cppreference.com/w/cpp/concept/Container):\nJSON values can be used like STL containers and provide iterator access.\n- [ReversibleContainer](http://en.cppreference.com/w/cpp/concept/ReversibleContainer);\nJSON values can be used like STL containers and provide reverse iterator\naccess.\n\n@invariant The member variables @a m_value and @a m_type have the following\nrelationship:\n- If `m_type == value_t::object`, then `m_value.object != nullptr`.\n- If `m_type == value_t::array`, then `m_value.array != nullptr`.\n- If `m_type == value_t::string`, then `m_value.string != nullptr`.\nThe invariants are checked by member function assert_invariant().\n\n@internal\n@note ObjectType trick from http://stackoverflow.com/a/9860911\n@endinternal\n\n@see [RFC 7159: The JavaScript Object Notation (JSON) Data Interchange\nFormat](http://rfc7159.net/rfc7159)\n\n@since version 1.0.0\n\n@nosubgrouping"]
pub type value_type = wpi_json;
#[test]
fn __bindgen_test_layout_wpi_detail_iter_impl_open0_wpi_json_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_detail_iter_impl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_detail_iter_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_detail_iter_impl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_detail_iter_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_detail_iter_impl_open0_wpi_json_close0_instantiation_1() {
    assert_eq!(
        ::std::mem::size_of::<wpi_detail_iter_impl>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_detail_iter_impl)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_detail_iter_impl>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_detail_iter_impl)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_detail_json_reverse_iterator_open0_wpi_json_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<wpi_detail_json_reverse_iterator>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_detail_json_reverse_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_detail_json_reverse_iterator>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_detail_json_reverse_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_detail_json_reverse_iterator_open0_wpi_json_const_iterator_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<wpi_detail_json_reverse_iterator>(),
        16usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_detail_json_reverse_iterator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_detail_json_reverse_iterator>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_detail_json_reverse_iterator)
        )
    );
}
#[test]
fn __bindgen_test_layout_wpi_StringMap_open0_wpi_json_wpi_MallocAllocator_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        24usize,
        concat!(
            "Size of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<wpi_StringMap<wpi_MallocAllocator>>(),
        4usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(wpi_StringMap<wpi_MallocAllocator>)
        )
    );
}
